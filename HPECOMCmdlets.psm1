##############################################################################
# HPE Compute Ops Management PowerShell Library
##############################################################################
##############################################################################
## (C) Copyright 2013-2024 Hewlett Packard Enterprise Development LP
##############################################################################
<#

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

#>

# Set PowerShell library version
[Version]$ModuleVersion = '1.0.13'

# Set the module version as a global variable
$Global:HPECOMCmdletsModuleVersion = $ModuleVersion


#Region ---------------------------- OBJECT FORMATTING DEFINITIONS -------------------------------------------------------------------------------------------------------------------------------------------  

# Load *.Format.PS1XML format files
Get-ChildItem -path $PSScriptRoot -recurse -include *.Format.PS1XML | Foreach-Object {
    Update-FormatData -AppendPath $_.FullName
}

#EndRegion



#Region ---------------------------- ARGUMENT COMPLETER -------------------------------------------------------------------------------------------------------------------------------------------  

# Define the list of HTTP methods used in Invoke-HPEGLWebRequest
$httpMethods = 'GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS', 'PATCH', 'TRACE', 'CONNECT'

# Register an argument completer for Invoke-WebRequest and Invoke-RestMethod methods
Register-ArgumentCompleter -CommandName Invoke-HPEGLWebRequest, Invoke-HPECOMWebRequest -ParameterName Method -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)

    # Filter methods based on user input (if any)
    $httpMethods | Where-Object { $_.StartsWith($wordToComplete) } |
    ForEach-Object {
        # Create a new completion result for each method
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

# Define the list of HPE GreenLake languages used in Set-HPEGLUserAccountDetails and Set-HPEGLUserPreference

# Fetch the supported HPE GreenLake languages details
$languageUrl = 'https://auth.hpe.com/messages/supportedLanguagesList.json'

try {
    $response = Invoke-RestMethod -Uri $languageUrl -Method Get 
    
}
catch {
    Throw "The website auth.hpe.com is currently unreachable. Please ensure that you have an active internet connection and try again."
}

$global:HPESupportedLanguages = @{}

foreach ($langDetail in $response.supportedLanguagesListDetails) {
    $HPESupportedLanguages[$langDetail.label] = $langDetail.value
}


# Register an argument completer for the Language parameter using language labels (support quotes for language names containing spaces)
Register-ArgumentCompleter -CommandName Set-HPEGLUserAccountDetails, Set-HPEGLUserPreference -ParameterName Language -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)

    # Filter languages based on the input label and create completions
    $HPESupportedLanguages.Keys | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        # Check if the language name contains spaces
        if ($_ -match "\s") {
            # Wrap the language name in single quotes
            $completionText = "'$_'"
        }
        else {
            
            $completionText = $_
        }

        [System.Management.Automation.CompletionResult]::new($completionText, $completionText, 'ParameterValue', $_)
    }
}

#EndRegion



#Region ---------------------------- VARIABLES -------------------------------------------------------------------------------------------------------------------------------------------  

$HPEGLAPIbaseURL = 'https://global.api.greenlake.hpe.com'
$HPEGLAPIOrgbaseURL = 'https://aquila-org-api.common.cloud.hpe.com'

$HPEGLUIbaseURL = 'https://aquila-user-api.common.cloud.hpe.com'

$HPEOnepassbaseURL = 'https://onepass-enduserservice.it.hpe.com'

[string]$APIClientCredentialTemplateName = "PowerShell_Library_Temporary_Credential"

# $DefaultTimeout timeout variable for Wait-HPECOMJobComplete
# New-Variable -Name DefaultTimeout -Value (New-Timespan -Minutes 20) -Option Constant


#Region ---------------------------- HPE COM -------------------------------------------------------------------------------------------------------------------------------------------  

# [uri]$COMSidebarUrl = 'https://developer.greenlake.hpe.com/_auth/sidebar/__alternative-sidebar__-data-glcp-doc-portal-docs-greenlake-services-compute-ops-mgmt-sidebars.yaml'

#  Job-Templates 

[String]$COMJobTemplatesUri = '/compute-ops-mgmt/v1beta2/job-templates'

#  Activation-Keys

[String]$COMActivationKeysUri = '/compute-ops-mgmt/v1beta1/activation-keys'

#  Activation-Tokens-Keys

# [String]$COMActivationTokensUri = '/compute-ops-mgmt/v1beta1/activation-tokens'

#  Activities

[String]$COMActivitiesUri = '/compute-ops-mgmt/v1beta2/activities'

# Appliances

[String]$COMOneViewAppliancesUri = '/compute-ops-mgmt/v1beta1/oneview-appliances'

# Appliance Firmware Bundles

[String]$COMApplianceFirmwareBundlesUri = '/compute-ops-mgmt/v1beta1/appliance-firmware-bundles'


# External Services

[String]$COMExternalServicesUri = '/compute-ops-mgmt/v1beta1/external-services'

# Filters

[String]$COMFiltersUri = '/compute-ops-mgmt/v1beta1/filters'

# Firmware bundles

[String]$COMFirmwareBundlesUri = '/compute-ops-mgmt/v1beta2/firmware-bundles'

# Groups

[String]$COMGroupsUri = '/compute-ops-mgmt/v1beta3/groups'
# [String]$COMGroupsUri = '/compute-ops-mgmt/v1/groups'
# [String]$COMGroupsUri = '/compute-ops-mgmt/v1beta2/groups'

# Job templates

[String]$COMJobTemplatesUri = '/compute-ops-mgmt/v1beta2/job-templates'

# Jobs

[String]$COMGetJobUri = '/compute-ops-mgmt/v1/jobs'
[String]$COMJobsUri = '/compute-ops-mgmt/v1beta3/jobs'

# Metrics Configurations

[String]$COMMetricsConfigurationsUri = '/compute-ops-mgmt/v1beta1/metrics-configurations'

# Reports

[String]$COMReportsUri = '/compute-ops-mgmt/v1beta2/reports'

# Schedules

[String]$COMSchedulesUri = '/compute-ops-mgmt/v1beta2/schedules'

# Server locations

[String]$COMServerLocationsUri = '/compute-ops-mgmt/v1beta1/server-locations'

# Settings

[String]$COMSettingsUri = '/compute-ops-mgmt/v1beta1/settings'

# Servers

[String]$COMServersUri = '/compute-ops-mgmt/v1beta2/servers'
[String]$COMServersUIDoorwayUri = '/ui-doorway/compute/v2/servers'

# User preferences

[String]$COMUserPreferencesUri = '/compute-ops-mgmt/v1beta1/user-preferences'

# Webhooks

[String]$COMWebhooksUri = '/compute-ops-mgmt/v1beta1/webhooks'


#EndRegion

#Region ---------------------------- HPE GLP -------------------------------------------------------------------------------------------------------------------------------------------  

[uri]$ccsSettingsUrl = 'https://common.cloud.hpe.com/settings.json'
[uri]$AuthRedirecturi = 'https://auth.hpe.com/profile/login/callback'
[uri]$SchemaMetadataURI = 'https://onepass-enduserservice.it.hpe.com/v2-get-user-schema-metadata'

[String]$OpenidConfiguration = '/.well-known/openid-configuration'
[String]$SessionLoadAccountUri = $HPEGLUIbaseURL + '/authn/v1/session/load-account/'
[String]$LoadAccountUri = $HPEGLUIbaseURL + '/accounts/ui/v1/user/load-account/'
[String]$AuthnUri = '/api/v1/authn'
[String]$AuthnSessionUri = $HPEGLUIbaseURL + '/authn/v1/session'
[String]$AuthnEndSessionUri = $HPEGLUIbaseURL + '/authn/v1/session/end-session'

#SAML
[String]$AuthnSAMLSSOUri = $HPEGLUIbaseURL + '/authn/v1/saml/config'
[String]$AuthnSAMLSSOMetadataUri = $HPEGLUIbaseURL + '/authn/v1/saml/sp-metadata/'
[String]$SAMLAttributesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/saml?domain='
[String]$SAMLValidateDomainUri = $HPEGLUIbaseURL + '/authn/v1/saml/validate_domain?domain='
[String]$SAMLValidateMetadataUri = $HPEGLUIbaseURL + '/authn/v1/saml/metadata/manual/'
[String]$AuthnSAMLSSOConfigUri = $HPEGLUIbaseURL + '/authn/v1/saml/async/config'
[String]$AuthnSAMLSSOConfigTaskTrackerUri = $HPEGLUIbaseURL + '/authn/v1/async-task-tracker/'
[String]$AccountSAMLNotifyUsersUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/saml/notify/'

# Audit logs
[String]$AuditLogsUri = $HPEGLAPIbaseURL + '/audit-log/v1/logs'
# [String]$AuditLogsUri = $HPEGLUIbaseURL + '/auditlogs/ui/v1/search?app_slug=CCS'

# Accounts
[String]$NewWorkspaceUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/signup'
[String]$WorkspacesListUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/list-accounts'
[String]$CurrentWorkspaceUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/profile/contact'
# [String]$UserLoadAccountUri = $HPEGLUIbaseURL + '/accounts/ui/v1/user/load-account/'
# [String]$WorkspacesListUri = $HPEGLUIbaseURL + '/authn/v1/session'

#  Workspaces 
[String]$WorkspacesUri = $HPEGLAPIbaseURL + '/workspaces/v1/workspaces'
[String]$WorkspacesV2Uri = $HPEGLAPIOrgbaseURL + '/organizations/v2alpha1/workspaces'
[String]$WorkspaceMigrationUri = $HPEGLAPIOrgbaseURL + '/internal-identity/v2alpha1/workspaces/'


#  Users - Roles - Permissions

[String]$UsersUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/users'
[string]$UsersStatsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/stats'
[string]$UsersRolesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/customers/roles'
[string]$AuthzUsersRolesUri = $HPEGLUIbaseURL + "/authorization/ui/v2/customers/users/"
[String]$AuthzRolesUri = $HPEGLUIbaseURL + "/authorization/ui/v2/customers/"
[string]$AuthzUsersRolesAssignmentsUri = $HPEGLUIbaseURL + "/authorization/ui/v2/customers/"
[string]$InviteUserUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/invite-user'
[string]$ReInviteUserUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/resend-invite'
[string]$UserPreferencesUri = $HPEGLUIbaseURL + '/accounts/ui/v1/user/profile/preferences'

#  Devices 

[String]$DevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices'
# [String]$DevicesUri = $HPEGLAPIbaseURL + '/devices/v1beta1/devices'
[String]$DevicesAddUri = $HPEGLAPIbaseURL + '/devices/v1beta1/devices'
[String]$DevicesStatsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices/stats'
[String]$DevicesApplicationInstanceUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices/application-instance'
[String]$DevicesATagsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices/tags'
[String]$DevicesLocationUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/locations'

#  License - Subscription

[String]$SubscriptionsUri = $HPEGLAPIbaseURL + '/subscriptions/v1beta1/subscriptions'
[String]$LicenseDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/devices'
[String]$AddLicenseDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/customers/license'
# [String]$AddLicenseServicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/'
[String]$RemoveLicensesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/unclaim'
[String]$LicenseDevicesProductTypeDeviceUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license?product_type=DEVICE'
[String]$ServiceSubscriptionsListUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/service-subscriptions'
[String]$AutoLicenseDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/autolicense'
[String]$AutoRenewalDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/auto-renewal'

#  Services - Assignment 

# [String]$ApplicationsUri = '/ui-doorway/ui/v1/applications'
# [String]$ApplicationsCatalogPerRegionUri = '/app-catalog/ui/v1/per-region-applications'
# [String]$ApplicationsProvisioned = '/ui-doorway/ui/v1/applications/provisioned'
[String]$ApplicationsProvisionsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/applications/provisions'
[String]$RegionsUri = $HPEGLUIbaseURL + '/geo/ui/v1/regions'
[String]$ApplicationsScopeAssignmentsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/scope-assignments'
[String]$ApplicationsAPICredentialsUri = $HPEGLUIbaseURL + '/authn/v1/token-management/credentials'
[string]$ResourceRestrictionsPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/resource_restrictions"
[string]$ResourceRestrictionsPolicyUsersUri = $HPEGLUIbaseURL + "/authorization/ui/v2/resource_restriction/"
[string]$AuthZApplicationsUri = $HPEGLUIbaseURL + "/authorization/ui/v1/applications/"
[string]$ResourceRestrictionPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/resource_restriction/"
[string]$SetResourceRestrictionPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/customers/applications"
[string]$DeleteResourceRestrictionPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/resource_restriction/delete"
[string]$ApplicationInstancesUri = $HPEGLUIbaseURL + "/authorization/ui/v1/application_instances"
[string]$ApplicationProvisioningUri = $HPEGLUIbaseURL + "/app-provision/ui/v1/provisions"

[String]$ServiceManagersUri = $HPEGLAPIbaseURL + '/service-catalog/v1beta1/service-managers'

#EndRegion


#EndRegion



#Region ---------------------------- CLASS DEFINITIONS -------------------------------------------------------------------------------------------------------------------------------------------

# Custom exception class HtmlContentDetectedException to handle HTML content detection errors

function Test-TypeExists {
    param (
        [string]$TypeName
    )
    return [AppDomain]::CurrentDomain.GetAssemblies() |
    ForEach-Object { $_.GetType($TypeName, $false, $false) } |
    Where-Object { $_ -ne $null }
}


if (-not (Test-TypeExists -TypeName 'HtmlContentDetectedException')) {
    
    Add-Type @"
    using System;

    public class HtmlContentDetectedException : Exception
    {
        public HtmlContentDetectedException() : base("HTML content detected in response.") { }
        
        public HtmlContentDetectedException(string message) : base(message) { }

        public HtmlContentDetectedException(string message, Exception innerException) : base(message, innerException) { }

    }
"@
}



#EndRegion



#Region ---------------------------- PRIVATE FUNCTIONS -------------------------------------------------------------------------------------------------------------------------------------------  


function NewObject {

    [CmdletBinding ()]
    Param
    (

        [Object]$InputObject,
        [Switch]$AddComputeDevice,
        [Switch]$AddStorageDevice,
        [Switch]$AddNetworkDevice

    )

    Process {

        switch ($PSBoundParameters.Keys) {
           
            'AddComputeDevice' {

                Return [PSCustomObject]@{
                    SerialNumber = $null;
                    PartNumber   = $null;
                    Tags         = [System.Collections.Hashtable]::new()

                }

            }


            'AddStorageDevice' {

                Return [PSCustomObject]@{
                    SerialNumber    = $null;
                    SubscriptionKey = $null;

                }

            }


            'AddNetworkDevice' {

                Return [PSCustomObject]@{
                    SerialNumber       = $null;
                    MacAddress         = $null;
                    CloudActivationKey = $null;

                }

            }

        }

    }

}



function Test-EndpointTCPConnection {
    [CmdletBinding()] 
    param (

        [uri]$URL,
        [int]$Port = 443,
        [int]$Timeout = 5000, # 5000 milliseconds (5 seconds)
        [int]$RetryCount = 3   # Number of retry attempts
    )

    # Get progress bar actual settings 
    $OriginalProgressPreference = $Global:ProgressPreference
    # Disable progress bar
    $Global:ProgressPreference = 'SilentlyContinue'

    for ($i = 0; $i -lt $RetryCount; $i++) {

        try {
            # PowerShell 7 and later (using .NET Core)
            $tcpClient = New-Object System.Net.Sockets.TcpClient

            if ($tcpClient.ConnectAsync($URL, $Port).Wait($Timeout)) {
                "[{0}] '{1}' is reachable on port {2}." -f $MyInvocation.InvocationName.ToString().ToUpper(), $URL, $Port | Write-Verbose
                return
            }
            else {
                throw "Failed to connect to $URL on port $Port. Verify your firewall settings and ensure the connection is not being blocked."
            }
        
        } 
        catch {

            if ($i -eq $RetryCount - 1) {

                # Return to original progress bar global settings
                $Global:ProgressPreference = $OriginalProgressPreference
                "[{0}] {1} is currently unreachable after {2} attempts. Please ensure that you have an active internet connection and try again." -f $MyInvocation.InvocationName.ToString().ToUpper(), $url, $RetryCount | Write-Verbose

                throw "$($URL) is currently unreachable after $RetryCount attempts. Please ensure that you have an active internet connection and try again."
            } 
            else {

                "[{0}] Attempt {1} failed to reach {2}. Retrying..." -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $URL | Write-Verbose
                Start-Sleep -Seconds 2  # Wait for 2 seconds before retrying
            }
        } 
        finally {

            if ($tcpClient) {
                $tcpClient.Dispose()
            }

            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference

        }
    }
}


function Test-EndpointDNSResolution {
    [CmdletBinding()] 
    param (

        [uri]$URL,
        [int]$RetryCount = 3   # Number of retry attempts

    )

    # Get progress bar actual settings 
    $OriginalProgressPreference = $Global:ProgressPreference
    # Disable progress bar
    $Global:ProgressPreference = 'SilentlyContinue'

    for ($i = 0; $i -lt $RetryCount; $i++) {

        try {
            
            ([System.Net.Dns]::GetHostAddresses($URL)) | Out-Null
            
            "[{0}] '{1}' is DNS resolvable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $URL | Write-Verbose
            return
    
        } 
        catch {

            if ($i -eq $RetryCount - 1) {
                
                # Return to original progress bar global settings
                $Global:ProgressPreference = $OriginalProgressPreference
                "[{0}] {1} is not DNS resolvable after {2} attempts. Fix your network environment and try again." -f $MyInvocation.InvocationName.ToString().ToUpper(), $url, $RetryCount | Write-Verbose

                throw "$($URL) is not DNS resolvable after $RetryCount attempts. Fix your network environment and try again."
            } 
            else {
    
                "[{0}] Attempt {1} failed to resolve {2}. Retrying..." -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $URL | Write-Verbose
                Start-Sleep -Seconds 2  # Wait for 2 seconds before retrying
            }
        }
        finally {
    
            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
    
        }
    }
} 



function Invoke-RepackageObjectWithType {   
    Param   (   
        $RawObject,
        $ObjectName,
        [boolean]   $WhatIf = $false
    )
    process {
        if ( $RawObject ) {
            $OutputObject = @()
            if ( $WhatIf ) {
                Return 
            }
            foreach ( $RawElementObject in $RawObject ) {

                # "[{0}] Element: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject | out-string) | write-verbose

                $DataSetType = "HPEGreenLake.$ObjectName"
                $RawElementObject.PSTypeNames.Insert(0, $DataSetType)
                # "[{0}] Element PSTypeName set: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject.PSTypeNames[0] | out-string)| write-verbose
                # "[{0}] Element PSObject TypeNames set: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject.PSObject.TypeNames[0] | out-string)| write-verbose
                
                $RawElementObject.PSObject.TypeNames.Insert(0, $DataSetType)
                # "[{0}] Element PSObject TypeNames set: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject.PSObject.TypeNames[0] | out-string)| write-verbose

                $OutputObject += $RawElementObject
            }

            # "[{0}] Object typenames : `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($OutputObject.PSObject.TypeNames | Out-String) | write-verbose

            if ($OutputObject.PSObject.TypeNames -notcontains $DataSetType) {

                # "[{0}] Object typenames added using Add-Member as the object is read only" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-verbose

                foreach ($item in $OutputObject) {
                    [void]($item | Add-Member -MemberType NoteProperty -Name PSObject.TypeNames -Value @( $DataSetType) -Force)
                }
            }

            return $OutputObject
        }
        else {
 
            # "[{0}] Null value sent to create object type." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            
            return
        }
    }   
}


function Invoke-RestMethodWhatIf {   
    Param   (   
        $Uri,
        $Method,
        $Headers,
        $Websession,
        $ContentType,
        $Body,
        [ValidateSet ('Invoke-HPEGLWebRequest', 'Invoke-HPECOMWebRequest', 'Invoke-RestMethod', 'Invoke-WebRequest')]
        $Cmdlet
    )
    process {
        if ( -not $Body ) {
            $Body = 'No Body'
        }
        write-warning "You have selected the 'What-If' option; therefore, the call will not be made. Instead, you will see a preview of the REST API call."
        Write-host "The cmdlet executed for this call will be:" 
        write-host  "$Cmdlet" -foregroundcolor green
        Write-host "The URI for this call will be:" 
        write-host  "$Uri" -foregroundcolor green
        Write-host "The Method of this call will be:"
        write-host -foregroundcolor green $Method

        if ($headers) {
            Write-host "The Header for this call will be:"
            write-host -foregroundcolor green ($Headers | ConvertTo-JSON | Out-String)  
        }
        if ($websession) {
            Write-host "The Websession for this call will be:"
            write-host -foregroundcolor green ($websession.headers | ConvertTo-JSON | Out-String)  
        }
        if ( $ContentType ) {
            write-host "The Content-Type is set to:"
            write-host -foregroundcolor green $ContentType
        }  
        if ( $Body ) {
            write-host "The Body of this call will be:"
            write-host -foregroundcolor green ($Body | Out-String)
        }
    }
}



function Set-HPECOMJobTemplatesVariable {
    <#
    .SYNOPSIS
    Retrieve COM job templates URI.

    .DESCRIPTION
    The cmdlet retrieves and stores the URI for each COM job template in the $HPECOMjobtemplatesUris global variable.
    The Cmdlet is automatically executed the first time Invoke-HPECOMWebRequest is run.

    To get the URI of a job template, you can use:
    $HPECOMjobtemplatesUris | Where-Object name -eq PowerOn.New | ForEach-Object resourceuri

#>
    [CmdletBinding()]
    param (       
    )

    # $HPECOMjobtemplatesUrisList = [System.Collections.ArrayList]::new()


    $HPECOMjobtemplatesUrisList = @(
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/5a657c6f-777d-4c7e-874a-1650b95b37f2"
            Id          = "5a657c6f-777d-4c7e-874a-1650b95b37f2"
            name        = "AnalyzeFirmwareUpdate"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/87f47eff-7245-4788-bf58-5b6af361d1ba"
            Id          = "87f47eff-7245-4788-bf58-5b6af361d1ba"
            name        = "AnalyzeFirmwareUpdateOrchestrator"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/1c4ac4be-8eeb-49f2-a86a-fd8c9182616c"
            Id          = "1c4ac4be-8eeb-49f2-a86a-fd8c9182616c"
            name        = "ApplianceUpdate"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/2d0f40f7-2a07-4c74-92e1-d1afaf49e632"
            Id          = "2d0f40f7-2a07-4c74-92e1-d1afaf49e632"
            name        = "ApplySettingsTemplate"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/497a5418-cbc2-4870-a1e7-1fc30c885f2f"
            Id          = "497a5418-cbc2-4870-a1e7-1fc30c885f2f"
            name        = "CalculateiLOSettingsCompliance"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/aacfb3e0-6575-4d4f-a711-1ee1ae768407"
            Id          = "aacfb3e0-6575-4d4f-a711-1ee1ae768407"
            name        = "ColdBoot"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/aae145a1-79a2-4516-b191-c98039c96542"
            Id          = "aae145a1-79a2-4516-b191-c98039c96542"
            name        = "CreateOneviewComplianceReport"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/b0001d36-6490-48ac-93af-a87adfb997ed"
            Id          = "b0001d36-6490-48ac-93af-a87adfb997ed"
            name        = "DataRoundupReportOrchestrator"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/fd54a96c-cabc-42e3-aee3-374a2d009dba"
            Id          = "fd54a96c-cabc-42e3-aee3-374a2d009dba"
            name        = "FirmwareUpdate.New"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/d6595f1b-84e6-4587-ade5-656e2a5ea20d"
            Id          = "d6595f1b-84e6-4587-ade5-656e2a5ea20d"
            name        = "GetFullServerInventory"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/fc16aa48-c73c-4463-9112-e061383ebfa9"
            Id          = "fc16aa48-c73c-4463-9112-e061383ebfa9"
            name        = "GetOneViewSettings"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/a0124cb1-00f1-46b7-818f-a9eb5f60591f"
            Id          = "a0124cb1-00f1-46b7-818f-a9eb5f60591f"
            name        = "GetOneviewServerInventory"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/50fa7d05-5941-4e8e-90c3-5995f1d600a8"
            Id          = "50fa7d05-5941-4e8e-90c3-5995f1d600a8"
            name        = "GetPowerMeterData"
        },
        @{
            resourceUri = "/api/compute/v1/job-templates/2c7de503-77af-4340-b68d-7a26e5359b8e"
            Id          = "2c7de503-77af-4340-b68d-7a26e5359b8e"
            name        = "GetSSOUrl"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/6cd671db-ce6b-45ce-894e-7b5ae23e0399"
            Id          = "6cd671db-ce6b-45ce-894e-7b5ae23e0399"
            name        = "GetSettingsForTemplate"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/c708eb57-235d-4ea8-9e21-8ceea2438773"
            # resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/54095626-3911-4fea-9741-816e2531994e"
            Id          = "c708eb57-235d-4ea8-9e21-8ceea2438773"
            # Id = "54095626-3911-4fea-9741-816e2531994e"
            name        = "GroupApplyInternalStorageSettings"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/a229a162-b43f-45b0-b7bb-692df77b9746"
            Id          = "a229a162-b43f-45b0-b7bb-692df77b9746"
            name        = "GroupApplyOneviewSettings"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/1262f08e-79eb-4e9f-91d2-6984da9d31cd"
            Id          = "1262f08e-79eb-4e9f-91d2-6984da9d31cd"
            name        = "GroupApplyExternalStorageSettings"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/beff07ce-f36d-4699-9ac3-f872dcd63133"
            Id          = "beff07ce-f36d-4699-9ac3-f872dcd63133"
            name        = "GroupApplyServerSettings"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/db3620d4-19a4-4b54-9804-83f8f59d48a4"
            Id          = "db3620d4-19a4-4b54-9804-83f8f59d48a4"
            name        = "GroupCopyServerProfileTemplates"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/977139e0-f9d9-4940-9418-e0c321b5a458"
            Id          = "977139e0-f9d9-4940-9418-e0c321b5a458"
            name        = "GroupExternalStorageCompliance"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/23b8ba2a-6c46-4223-b028-919382c7dcac"
            Id          = "23b8ba2a-6c46-4223-b028-919382c7dcac"
            name        = "GroupFirmwareCompliance"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/91159b5e-9eeb-11ec-a9da-00155dc0a0c0"
            Id          = "91159b5e-9eeb-11ec-a9da-00155dc0a0c0"
            name        = "GroupFirmwareUpdate"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/08be2b1b-a9b3-4abb-82a2-8048f35dbccb"
            Id          = "08be2b1b-a9b3-4abb-82a2-8048f35dbccb"
            name        = "GroupGetIloSecurityParams"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/e2952628-2629-4088-93db-91742304ef0c"
            Id          = "e2952628-2629-4088-93db-91742304ef0c"
            name        = "GroupOSInstallation"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/2dfe138a-21b7-4797-8c6b-4d8e7e5f847c"
            Id          = "2dfe138a-21b7-4797-8c6b-4d8e7e5f847c"
            name        = "GroupServerInventoryReport"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/a55c8b26-3c57-4044-a4ee-1d0e3c108286"
            Id          = "a55c8b26-3c57-4044-a4ee-1d0e3c108286"
            name        = "GroupiLOSettingsCompliance"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/94caa4ef-9ff8-4805-9e97-18a09e673b66"
            Id          = "94caa4ef-9ff8-4805-9e97-18a09e673b66"
            name        = "IloOnlyFirmwareUpdate"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/abfda355-6e58-4c00-be0a-af35dbd70398"
            Id          = "abfda355-6e58-4c00-be0a-af35dbd70398"
            name        = "OrchestratorAddUpdateServerTemplates"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/d0c13b58-748c-461f-9a61-c0c5c71f1bb4"
            Id          = "d0c13b58-748c-461f-9a61-c0c5c71f1bb4"
            name        = "PowerOff.New"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/0cbb2377-1834-488d-840c-d5bf788c34fb"
            Id          = "0cbb2377-1834-488d-840c-d5bf788c34fb"
            name        = "PowerOn.New"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/30110551-cad6-4069-95b8-dbce9bbd8525"
            Id          = "30110551-cad6-4069-95b8-dbce9bbd8525"
            name        = "Restart.New"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/b21ca9e2-8a1b-11ee-b9d1-0242ac120002"
            Id          = "b21ca9e2-8a1b-11ee-b9d1-0242ac120002"
            name        = "ServerNetworkConnectivity"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/139cc26b-ac93-4da0-826c-220d15e3a422"
            Id          = "139cc26b-ac93-4da0-826c-220d15e3a422"
            name        = "ServerExternalStorageDetails"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/cf4f929b-d44a-4a90-93a9-820955458fd4"
            Id          = "cf4f929b-d44a-4a90-93a9-820955458fd4"
            name        = "SetIloSettings"
        },
        @{
            resourceUri = "/compute-ops-mgmt/v1beta2/job-templates/e1d69e76-38cc-4079-9192-a380baea2973"
            Id          = "e1d69e76-38cc-4079-9192-a380baea2973"
            name        = "iLOSecurity"
        }
    ) | Sort-Object -Property name


    $Global:HPECOMjobtemplatesUris = $HPECOMjobtemplatesUrisList

    "[{0}] Each COM job template has been stored in the `$HPECOMjobtemplatesUris global variable." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose


    # "[{0}] Region selected: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
    
    # if ($HPECOMAPICredentialRegions | Where-Object { $_ -eq $Region }) {

    #     $ConnectivityEndPoint = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).connectivity_endpoint
    #     $credentialname = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).name
    #     $comApiAccessToken = ($HPEGreenLakeSession.comApiAccessToken | Where-Object name -eq $credentialname).access_token

    #     $url = $ConnectivityEndPoint + $COMJobTemplatesUri
         
    #     $headers = @{} 
    #     $headers["Accept"] = "application/json"
    #     $headers["Content-Type"] = "application/json"
    #     $headers["Authorization"] = "Bearer $($comApiAccessToken)"

    #     "[{0}] About to run a GET request to '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
    #     "[{0}] Headers used: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | ConvertTo-Json) | Write-Verbose

    #     try {
    #         [array]$JobTemplates = (Invoke-RestMethod -Uri $url -Method 'GET' -Headers $Headers ).items
    #         "[{0}] Response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($JobTemplates | Out-String ) | Write-Verbose

    #     }   
    #     catch {    
    #         throw "COM job templates URI cannot be captured. Please ensure that you have administrastive right to the COM instance."

    #     }

    #     foreach ($JobTemplate in $JobTemplates) {

    #         $_Name = $JobTemplate.name 
    #         $_Value = $JobTemplate.resourceUri
    #         $_ID = $JobTemplate.id


    #         $object = @{
    #             name        = $_Name
    #             resourceUri = $_Value
    #             Id          = $_ID
    #         }
            
        
    #         [void]$HPECOMjobtemplatesUrisList.add($object)

    #     }

    #     $Global:HPECOMjobtemplatesUris = $HPECOMjobtemplatesUrisList

    #     "[{0}] Global variable set to: `$global:HPECOMjobtemplatesUris: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($HPECOMjobtemplatesUris | ConvertTo-Json) | Write-Verbose
    # }
    # else {
    #     "[{0}] Global variable `$global:HPECOMjobtemplatesUris cannot be set as no COM API client credential can be found for '{1}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $region | Write-Verbose
    # }

}


function Get-GMTTimeDifferenceInHours {
    # Function to get the current time difference between GMT and the local computer time zone

    [CmdletBinding()]
    Param(

        [switch]$InMinutes

    )

    # Get current date and time in UTC (GMT)
    $utcNow = [DateTime]::UtcNow

    # Define TimeZoneInfo objects for GMT and Local Time Zone
    $localTimeZone = [System.TimeZoneInfo]::Local                        # Local Computer Time Zone

    # Convert UTC to Local Time
    $localTime = [System.TimeZoneInfo]::ConvertTimeFromUtc($utcNow, $localTimeZone)

    # Calculate the time difference
    $timeDifferenceinHours = ($localTime - $utcNow).TotalHours
    $timeDifferenceinMinutes = ($localTime - $utcNow).TotalMinutes

    # Check if the current date/time falls within Daylight Saving Time
    $isDaylightSaving = $localTimeZone.IsDaylightSavingTime($localTime)

    # Display the detected local time zone, DST status, and the time difference
    "[{0}] Detected local time zone: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $localTimeZone.Id | Write-Verbose
    "[{0}] Is the current time in Daylight Saving Time? '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $isDaylightSaving | Write-Verbose
    "[{0}] Current time difference between GMT and local time: '{1}' hour(s)" -f $MyInvocation.InvocationName.ToString().ToUpper(), [Math]::Round($timeDifferenceinHours, 0) | Write-Verbose
    "[{0}] Current time difference between GMT and local time: '{1}' minutes(s)" -f $MyInvocation.InvocationName.ToString().ToUpper(), [Math]::Round($timeDifferenceinMinutes, 0) | Write-Verbose
       
    if ($InMinutes) {
        Return $timeDifferenceinMinutes
    }
    else {
        Return $timeDifferenceinHours
    }

}


function New-ErrorRecord {
    <#
        .Synopsis
        Creates an custom ErrorRecord that can be used to report a terminating or non-terminating error.

        .Description
        Creates an custom ErrorRecord that can be used to report a terminating or non-terminating error.

        .Parameter Exception
        The Exception that will be associated with the ErrorRecord. Uses RuntimeException by default.

        .Parameter ErrorID
        A scripter-defined identifier of the error. This identifier must be a non-localized string for a specific error type.

        .Parameter ErrorCategory
        An ErrorCategory enumeration that defines the category of the error.  The supported Category Members are (from: http://msdn.microsoft.com/en-us/library/system.management.automation.errorcategory(v=vs.85).aspx) :

            * AuthenticationError - An error that occurs when the user cannot be authenticated by the service. This could mean that the credentials are invalid or that the authentication system is not functioning properly.
            * CloseError - An error that occurs during closing.
            * ConnectionError - An error that occurs when a network connection that the operation depEnds on cannot be established or maintained.
            * DeadlockDetected - An error that occurs when a deadlock is detected.
            * DeviceError - An error that occurs when a device reports an error.
            * FromStdErr - An error that occurs when a non-Windows PowerShell command reports an error to its STDERR pipe.
            * InvalidArgument - An error that occurs when an argument that is not valid is specified.
            * InvalidData - An error that occurs when data that is not valid is specified.
            * InvalidOperation - An error that occurs when an operation that is not valid is requested.
            * InvalidResult - An error that occurs when a result that is not valid is returned.
            * InvalidType - An error that occurs when a .NET Framework type that is not valid is specified.
            * LimitsExceeded - An error that occurs when internal limits prevent the operation from being executed.
            * MetadataError - An error that occurs when metadata contains an error.
            * NotEnabled - An error that occurs when the operation attempts to use functionality that is currently disabled.
            * NotImplemented - An error that occurs when a referenced application programming interface (API) is not implemented.
            * NotInstalled - An error that occurs when an item is not installed.
            * NotSpecified - An unspecified error. Use only when not enough is known about the error to assign it to another error category. Avoid using this category if you have any information about the error, even if that information is incomplete.
            * ObjectNotFound - An error that occurs when an object cannot be found.
            * OpenError - An error that occurs during opening.
            * OperationStopped - An error that occurs when an operation has stopped. For example, the user interrupts the operation.
            * OperationTimeout - An error that occurs when an operation has exceeded its timeout limit.
            * ParserError - An error that occurs when a parser encounters an error.
            * PermissionDenied - An error that occurs when an operation is not permitted.
            * ProtocolError An error that occurs when the contract of a protocol is not being followed. This error should not happen with well-behaved components.
            * QuotaExceeded An error that occurs when controls on the use of traffic or resources prevent the operation from being executed.
            * ReadError An error that occurs during reading.
            * ResourceBusy An error that occurs when a resource is busy.
            * ResourceExists An error that occurs when a resource already exists.
            * ResourceUnavailable An error that occurs when a resource is unavailable.
            * SecurityError An error that occurs when a security violation occurs. This field is introduced in Windows PowerShell 2.0.
            * SyntaxError An error that occurs when a command is syntactically incorrect.
            * WriteError An error that occurs during writing.

        .Parameter TargetObject
        The object that was being Processed when the error took place.

        .Parameter Message
        Describes the Exception to the user.

        .Parameter InnerException
        The Exception instance that caused the Exception association with the ErrorRecord.

        .Parameter TargetType
        To customize the TargetType value, specify the appropriate Target object type.  Values can be "Array", "PSObject", "HashTable", etc.  Can be provided by ${ParameterName}.GetType().Name.

        .Example
        $errorMessage = "Timeout reached waiting for job to complete."
        $errorRecord = New-ErrorRecord TimeoutError OperationTimeout -Message $ErrorMessage
        $PSCmdlet.ThrowTerminatingError($ErrorRecord )

        .EXAMPLE
        $ErrorMessage = "Filter '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
        $ErrorRecord = New-ErrorRecord FilterNotFoundInCOM ObjectNotFound -TargetObject 'Filter' -Message $ErrorMessage -TargetType $Name.GetType().Name
        $PSCmdlet.ThrowTerminatingError($ErrorRecord )

    #>

    [CmdletBinding ()]
    Param
    (        
        
        [Parameter (Mandatory, Position = 0)]
        [Alias ('ID')]
        [System.String]$ErrorId,
        
        [Parameter (Mandatory, Position = 1)]
        [Alias ('Category')]
        [ValidateSet ('AuthenticationError', 'ConnectionError', 'NotSpecified', 'OpenError', 'CloseError', 'DeviceError',
            'DeadlockDetected', 'InvalidArgument', 'InvalidData', 'InvalidOperation',
            'InvalidResult', 'InvalidType', 'MetadataError', 'NotImplemented',
            'NotInstalled', 'ObjectNotFound', 'OperationStopped', 'OperationTimeout',
            'SyntaxError', 'ParserError', 'PermissionDenied', 'ResourceBusy',
            'ResourceExists', 'ResourceUnavailable', 'ReadError', 'WriteError',
            'FromStdErr', 'SecurityError')]
        [System.Management.Automation.ErrorCategory]$ErrorCategory,
            
        [Parameter (Position = 2)]
        [System.Object]$TargetObject,
            
        [System.String]$Exception = "System.Management.Automation.RuntimeException",
        
        # [Parameter (Mandatory)]
        [System.String]$Message,
        
        [System.Exception]$InnerException,
        
        [System.String]$TargetType = "String"

    )

    Process {

        # ...build and save the new Exception depending on present arguments, if it...
        $_exception = if ($Message -and $InnerException) {
            # ...includes a custom message and an inner exception
            New-Object $Exception $Message, $InnerException
        }
        elseif ($Message) {
            # ...includes a custom message only
            New-Object $Exception $Message
        }
        else {
            # ...is just the exception full name
            New-Object $Exception
        }

        # now build and output the new ErrorRecord
        "[{0}] Building ErrorRecord object" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

        $record = [Management.Automation.ErrorRecord]::new($_exception, $ErrorID, $ErrorCategory, $TargetObject)

        $record.CategoryInfo.TargetType = $TargetType

        Return $record
    }


}


Function Invoke-HPEGLAutoReconnect { 
    [CmdletBinding()]
    Param(
        # An access token is valid for 2 hours (120 minutes) - GLP Session idle timeout is 30 minutes by default 
        # Default: reconnect 10 minutes before GLP expiration
        # Timeout in minutes, 
        $Timeout = 100
    ) 

    # Access_token expiration date
    $AccessTokenExpirationDate = $HPEGreenLakeSession.oauth2TokenCreation.AddMinutes(120)
    
    # Number of minutes before expiration of the Access_token expiration date
    $BeforeExpirationinMinutes = [math]::Round(((New-TimeSpan -Start (Get-Date) -End ($AccessTokenExpirationDate)).TotalHours ) * 60)
    
    if ( $BeforeExpirationinMinutes -gt 0) { $Expiration = $BeforeExpirationinMinutes }
    else { $Expiration = 0 }
        

    if ($Expiration -eq 0) {

        "[{0}] Expiration={1} - Access Tokens refresh required but session gets expired! Connect-HPEGL must be executed!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Expiration | Write-Verbose

        Write-Warning "Access tokens refresh required, but the session has expired! Please reconnect using 'Connect-HPEGL'." 
        Break

    }
    elseif ( $Expiration -le $Timeout ) {

        "[{0}] Access Tokens refresh required ! $Expiration minute(s) before expiration - Tokens refresh in progress..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        try {
            Connect-HPEGLWorkspace -Force | out-null
            
        }
        catch {
            Write-Progress -Id 1 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed # progress bar from 'Connect-HPEGLWorkspace'
            $PSCmdlet.ThrowTerminatingError($_)
        }           
    }
    else {
        
        "[{0}] No Access Tokens refresh required ! $Expiration minute(s) before expiration - Allowable time to refresh/reconnect is {1} minutes." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Timeout | Write-Verbose

    }  
}


#EndRegion



#Region ---------------------------- PUBLIC FUNCTIONS -------------------------------------------------------------------------------------------------------------------------------------------  


  
#Region ------------------- GENERICs -------------------------------------------------------------------------------------------------------------------------------------------


function Invoke-HPEGLWebRequest {  
    <#
    .SYNOPSIS
    Cmdlet to run web requests to the HPE Greenlake APIs. 

    .DESCRIPTION
    The `Invoke-HPEGLWebRequest` cmdlet sends HTTPS requests to the HPE Greenlake APIs. It adds the required headers, session, parses the response and returns the response.

    .PARAMETER Uri
    The absolute uri that identifies the required HPE GreenLake resource (eg. '/ui-doorway/ui/v1/license/devices').

    .PARAMETER Body
    Body for the request. Required if the method is POST or PUT.

    .PARAMETER Method
    The request HTTP Method.
     - "GET" (default) to get a resource from the appliance (read)
     - "POST" to create a new resource
     - "PUT" to modify a resource (write)
     - "PATCH" to modify a resource (write), with specific attributes set to values, other attributes should be set to $null.
     - "DELETE" to delete a resource

    .PARAMETER WebSession
    Web session object containing information about the HPE GreenLake session, including cookies and credentials.
    Default uses $HPEGreenLakeSession.session global variable.

    .PARAMETER SkipSessionCheck
    Switch parameter to skip the session check. This parameter is only used by Get-HPEGLWorkspace and New-HPEGLWorkspace when Connect-HPEGLWorkspace has not been executed yet (i.e. when no workspace or workspace session exist yet).
    Skip parameter is only used by Get-HPEGLWorkspace when Connect-HPEGLWorkspace has not been executed yet (i.e. when no workspace session exists yet).

    .PARAMETER MaxRetries
    The maximum number of retries to attempt if the request fails. Default is 5.

    .PARAMETER InitialDelaySeconds
    The initial delay in seconds before the first retry attempt. Default is 1.

    .PARAMETER ContentType
    The content type of the request. Default is 'application/json'.

    .PARAMETER WhatIfBoolean
    Switch parameter to show the user what would happen if the cmdlet was to run without actually running it.

    .EXAMPLE
    Invoke-HPEGLWebRequest -Uri 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/license/devices' 

    Run a GET web request on 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/license/devices' using the web session object
    $HPEGreenLakeSession.session containing information about the HPE GreenLake session. 

    .EXAMPLE
    Invoke-HPEGLWebRequest 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/um/users' -WhatIfBoolean $True

    Run a GET web request on 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/um/users' with the WhatIfBoolean parameter to see 
    the potential effects of the command before committing to it.

    .EXAMPLE
    $Uri = 'https://aquila-user-api.common.cloud.hpe.com' + '/ui-doorway/ui/v1/um/users'

    $Payload = @"
    {
    "usernames": [
        "email1@gmail.com", 
        "email@yahoo.com"
    ]
    }
    "@

    Invoke-HPEGLWebRequest -Method Delete -Uri $Uri -Body $Payload

    Run a DELETE web request on 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/um/users' with the provided payload. 

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    The output of the cmdlet depends upon the format of the content that is retrieved.
    If the request returns JSON strings, Invoke-HPEGLWebRequest returns a PSObject that represents the strings.

    $Global:HPEGLInvokeReturnData global variable is set to the response of the web request.
        
         
    #>
    Param   (   

        [Parameter (Mandatory)]
        [String]$Uri,

        $Body, 

        [String]$Method = "GET",

        $WebSession = $HPEGreenLakeSession.session, 

        [String]$ContentType = 'application/json',
       
        [Switch]$SkipSessionCheck,
        
        [int]$MaxRetries = 5,
        [int]$InitialDelaySeconds = 1,

        $WhatIfBoolean = $false

    )
   
    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        #Region Check if HPEGreenLakeSession variable is available
        
        if ($null -eq $HPEGreenLakeSession) {
            
            Write-Error "Error - No HPE GreenLake session found! Connect-HPEGL must be executed first!"
            return
        }
        elseif ($null -eq $HPEGreenLakeSession.workspaceId) {
            
            # Throw error only if switch parameter to skip the session check is not used. 
            #  Skip parameter is only used by Get-HPEGLWorkspace when Connect-HPEGLWorkspace has not been executed yet (i.e. when no workspace session exists yet).
            if (-not $PSBoundParameters.ContainsKey('SkipSessionCheck')) {
                Write-Error "No workspace session found! Connect-HPEGLWorkspace must be executed first!"
                Return
            }
        }   
        #EndRegion


        #Region Check if a reconnection is required
        try {

            "[{0}] Running Invoke-HPEGLAutoReconnect to check if refresh token is required..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            Invoke-HPEGLAutoReconnect

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        #EndRegion

        
        #Region Construction for WhatIf
        Clear-Variable -Name InvokeReturnData -ErrorAction SilentlyContinue

        if ( $WhatIfBoolean ) {

            if ($uri -match $HPEGLUIbaseURL) {

                "[{0}] Detected URI: UI Doorway ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Body -WebSession $WebSession -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"

            }
            elseif ($uri -match $HPEOnepassbaseURL) {

                "[{0}] Detected URI: HPE Onepass ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                      
                if ($null -ne $Body) {

                    try {
                        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Body | Write-Verbose
                        $BodyObject = ConvertFrom-Json -InputObject $Body -ErrorAction Stop
                        "[{0}] Payload content after convertion: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $BodyObject | Write-Verbose
                        # Add sessionId to the object
                        $BodyObject | Add-Member -MemberType NoteProperty -Name 'sessionId' -Value $HPEGreenLakeSession.onepassSid
                        "[{0}] Payload content after adding sid: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $BodyObject | Write-Verbose

                    }
                    catch {
                        Write-Error "The provided JSON body is not valid."
                        return
                    }
                }
                else {
                    $BodyObject = @{ sessionId = $HPEGreenLakeSession.onepassSid }
                }


                # Convert the body hashtable to a JSON string
                $Payload = $BodyObject | ConvertTo-Json
                        
                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Payload -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"

            }
            elseif ($uri -match $HPEGLAPIbaseURL -and $uri -match "/internal-identity/v2alpha1") {

                "[{0}] Detected URI: global.api.greenlake.hpe.com with /internal-identity/v2alpha1 ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
                $headers = @{} 
                $headers["Accept"] = "application/json"
                $headers["Content-Type"] = $ContentType
                $headers["Authorization"] = "$($HPEGreenLakeSession.glpApiAccessTokenv1_2.access_token)"

                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Body -Headers $headers -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"
                
            }
            else {

                "[{0}] Detected URI: $uri ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
                $headers = @{} 
                $headers["Accept"] = "application/json"
                $headers["Content-Type"] = $ContentType
                $headers["Authorization"] = "Bearer $($HPEGreenLakeSession.glpApiAccessToken.access_token)"

                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Body -Headers $headers -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"
                
            }
        }        
        #EndRegion


        # Construction for Invoke-Webrequest
        else {

            $retries = 0

            $lastException = $null

            $attempt = 0
            $complete = $false

            while (-not $complete -and $attempt -lt $MaxRetries) {          

                #Region When using a UI Doorway URI
                if ($uri -match $HPEGLUIbaseURL) {

                    "[{0}] ------------------------------------ Detected URI: UI Doorway ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # Process pagination for GET 
                    if ($Method -eq "GET" -or $Method -eq "POST") {
                        # if ($Method -eq "GET" -or ($Method -eq "POST" -and -not $Body)) {

                        $AllCollection = [System.Collections.ArrayList]::new()

                        # Get 100 items pagination
                        $pagination = 100

                        # Detect if $uri contains a query parameter
                        $uriobj = [System.Uri]::new($uri)

                        # Parse the query parameters into a dictionary
                        $queryParameters = [System.Web.HttpUtility]::ParseQueryString($uriobj.Query)
                        
                        # URI modification to support pagination
                        if ($queryParameters["limit"]) {

                            $url = $uri
                        }
                        # If contains 'count_per_page' query parameter, set the pagination value to the value of count_per_page (condition for Get-HPEGLWorkspace)
                        elseif ($queryParameters["count_per_page"]) {

                            $url = $uri

                            # Capture the value of count_per_page
                            $countPerPageValue = $queryParameters["count_per_page"]
                            # Set the value of count_per_page to the pagination value
                            $pagination = $countPerPageValue

                        }
                        # If contains another query parameter
                        elseif ($uriobj.Query -ne "") {

                            $url = $uri + "&limit=$pagination&offset=0"

                        }
                        # If not contains any query parameter
                        else {
                            
                            $url = $uri + "?limit=$pagination&offset=0"
                        }

                        # "[{0}] URI that has been generated: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                        
                    }
                    else {

                        $url = $uri

                    }

                    
                    if ($HPEGreenLakeSession.session.headers) {

                        "[{0}] Request headers: `n'{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($HPEGreenLakeSession.session.headers | Out-String) | Write-Verbose
                    }

                      
                    if ($body) {

                        # If body is JSON
                        if ($body.Trim().StartsWith('{') -and $body.Trim().EndsWith('}')) {
                            $Payload = $Body 
                        }
                        else {
                            # Convert the body hashtable to a JSON string
                            $Payload = $Body | ConvertTo-Json -Depth 10
                    
                        }
                    }
                    
                    
                    try {

                        "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Url | Write-Verbose

                        if ($payload) {
                            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                        }
                        else {
                            "[{0}] No payload content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        }

                        $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Body $Body -WebSession $WebSession -ContentType $ContentType #-ErrorAction Stop

                        # Create a global variable to store the Invoke-WebRequest response
                        $Global:HPEGLInvokeReturnData = $InvokeReturnData
 
                        if ($InvokeReturnData -match "doctype html") {      
                            
                            "[{0}] HTML doctype response detected ! Throwing exception!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                            throw [HtmlContentDetectedException]::new("Error! HTML content detected! Throwing exception!")
                        }   
                        
                        "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                        "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   
                       
                        $complete = $true
                      
                    }
                    # Handle exceptions related to network operations
                    # catch [System.Net.WebException] {

                    #     $attempt++    
                        
                    #     # Store the last exception
                    #     $lastException = $_                        
    
                    #     # Service Unavailable error
                    #     if ($_.Exception.Response.StatusCode -eq 503) {
                    #         $retries++
                    #         # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                    #         $waitTime = 2
                    #         "[{0}] Received 503. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    #         Start-Sleep -Seconds $waitTime
                    #     }
                    #     else {
                        
                    #         "[{0}] Exception thrown!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                    #         # Get Exception type
                    #         $exception = $_.Exception

                    #         do {
                    #             "[{0}] Exception Type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $exception.GetType().Name | Write-Verbose
                    #             $exception = $exception.InnerException
                    #         } while ($exception)
    
                    #         # Get exception stream
                    #         $result = $_.Exception.Response.GetResponseStream()
                    #         $reader = New-Object System.IO.StreamReader($result)
                    #         $reader.BaseStream.Position = 0
                    #         $reader.DiscardBufferedData()
                    #         $responseBody = $reader.ReadToEnd() 
    
                    #         # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseBody | Write-Verbose
                    
    
                    #         if ($HPEGreenLakeSession.session.headers) {
                    #             "[{0}] Request headers: " -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                    #             foreach ($Param in $HPEGreenLakeSession.session.headers.Keys) { 
                        
                    #                 Write-Verbose "`t`t$Param : $($HPEGreenLakeSession.session.headers[$Param])" 
                         
                    #             }
                    #         }
    
                    #         $response = $responseBody | ConvertFrom-Json
                        
                    #         $ResponseCode = $response.code
                    #         $ResponseDetail = $response.detail
                    #         $ResponseStatus = $Response.Status
    
                    #         if ($ResponseCode) {
                    #             "[{0}] Request failed with the following Status: `n`tHTTPS Return Code = '{1}' `n`tHTTPS Return Code Description = '{2}' `n`tHTTPS Return Code Details = '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResponseStatus, $ResponseCode, $ResponseDetail | write-verbose
                    #         }  
                    
                    #         $StatusCode = [int]$_.Exception.Response.StatusCode
                    #         $ExceptionCode = $_.Exception.Response.StatusCode.value__
                    
                    #         if ($StatusCode -and -not $ResponseCode) {
                    #             "[{0}] HTTPS Return Code = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $StatusCode | Write-Verbose
                    #         }
                    #         elseif ($ExceptionCode -and -not $ResponseCode) {
                    #             "[{0}] HTTPS Return Code = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode | Write-Verbose
                    #         }
    
    
                    #         if ($ResponseStatus -and $ResponseCode -and $ResponseDetail) {
                    #             Throw "Error '{0}' - '{1}' : '{2}'" -f $ResponseCode, $ResponseStatus, $ResponseDetail
                    #         }
                    #         elseif ($ResponseStatus -and $ResponseCode -and -not $ResponseDetail) {
                    #             Throw "Error '{0}' - '{1}'" -f $ResponseCode, $ResponseStatus
                    #         }
                    #         elseif ($ResponseStatus -and -not $ResponseCode -and -not $ResponseDetail) {
                    #             Throw "Error '{0}'" -f $ResponseStatus
                    #         }
                    #         elseif ($responseBody -match "Unauthorized" ) {
                    #             Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                    #         }
                    #         elseif ($response.message ) {
                    #             Throw "Error - $($response.message)"
                    #         }
                    #         elseif ($response.detail ) {
    
                    #             if ($response.detail.msg) {
    
                    #                 $Detailmsg = ($response.detail | ForEach-Object { $_.msg + ": " + $_.type }) -join " AND "
    
                    #                 Throw "Error - $Detailmsg"
                    #             }
                    #             else {
    
                    #                 Throw "Error - $($response.detail)"
                    #             }
    
                    #         }
                    #         else {
    
                    #             Throw "Error - $($response | Out-String)"
     
                    #         }
                    #     }                   
                    # }
                    # Handle general runtime exceptions
                    # catch [System.Management.Automation.RuntimeException] {

                    #     "[{0}] System.Management.Automation.RuntimeException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose    
                    #     "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose
                    #     "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose

                    #     # Store the last exception
                    #     $lastException = $_                        

                    #     # 'Request Timeout' error
                    #     if ($_.Exception.Response.StatusCode -eq 408) {
                    #         $retries++
                    #         # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                    #         $waitTime = 2
                    #         "[{0}] Received 408. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    #         Start-Sleep -Seconds $waitTime
                    #     }
                    #     # When 'Forbidden' error are not expected (issue with GLP?)
                    #     elseif ($_.Exception.Response.StatusCode -eq 403) {
                    #         $retries++
                    #         # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                    #         $waitTime = 2
                    #         "[{0}] Received 403. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    #         Start-Sleep -Seconds $waitTime
                    #     }
                    #     # When 'Internal Server Error' error 
                    #     elseif ($_.Exception.Response.StatusCode -eq 500) {
                    #         $retries++
                    #         # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                    #         $waitTime = 2
                    #         "[{0}] Received 500. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    #         Start-Sleep -Seconds $waitTime
                    #     }
                    #     else {

                    #         # Convert JSON string to object
                    #         try {
                                
                    #             $response = $_ | ConvertFrom-Json
        
                    #             $_ExceptionMessageDetails = [System.Collections.ArrayList]::new()
                    #             $_ExceptionMessage = [System.Collections.ArrayList]::new()
                    
                    #             if ($response.detail) {
        
                    #                 foreach ($detail in $response.detail) {
        
                    #                     # Capture the 'msg' property
                    #                     $message = $detail.msg
                    #                     $type = $detail.type
        
                    #                     $Info = [System.Collections.HashTable]@{
                    #                         message = $message
                    #                         type    = $type
                    #                     }
        
                    #                     [void]$_ExceptionMessageDetails.Add($Info)
        
                    #                 }
        
                    #                 if ($_ExceptionMessageDetails) {
                                        
                    #                     "[{0}] Exception Message Details: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_ExceptionMessageDetails | out-String) | Write-Verbose
                    #                 }
        
                    #             }
        
                    #             if ($response.message) {
        
                    #                 [void]$_ExceptionMessage.add($response.message)
                    #             }

                    #             if ($response.errorDetails.length -ge 1 ) {

                    #                 foreach ($error in $response.errorDetails) {
                                    
                    #                     if ($error.metadata.error) {
                    #                         [void]$_ExceptionMessage.add($error.metadata.error)

                    #                     }
                    #                 }
                                    
                    #             }
                                
                    #         }
                    #         catch {}

                    #         $ExceptionCode = $_.Exception.Response.StatusCode.value__
                    #         $ExceptionText = $_.Exception.Response.StatusDescription + $_.Exception.Response.ReasonPhrase 


                    #         if ( $_ExceptionMessage) {
                    #             "[{0}] Request failed with the following Status:`r`n`tHTTPS Return Code = '{1}' `r`n`tHTTPS Return Code Description = '{2}' `r`n`tHTTPS Return Message = '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode, $ExceptionText, ($_ExceptionMessage -join " - ") | write-verbose
                    #         }
                    #         else {
                    #             "[{0}] Request failed with the following Status:`r`n`tHTTPS Return Code = '{1}' `r`n`tHTTPS Return Code Description = '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode, $ExceptionText | write-verbose
                    #         }
                        
                    #         if (-not $ExceptionCode ) {

                    #             $ExceptionCode = [int]$_.Exception.Response.StatusCode
                    #         }
        
        
                    #         if ( $ExceptionCode -eq 400 ) {
                    #             Throw "Error status Code: 400 (Bad Request)"
                            
                    #         } 
                
                    #         elseif ( $ExceptionCode -eq 401 ) {
                    #             Throw "Error status Code: 401 (Unauthorized) - Your session with HPE GreenLake doorway API has expired, please log in again using 'Connect-HPEGL'!"
                                
                    #         } 
                            
                    #         elseif ( $ExceptionCode -eq 403 ) {
                    #             Throw "Error status Code: 403 (Forbidden) - Your session with HPE GreenLake doorway API has expired or you do not have sufficient rights to perform this action!"
                                
                    #         } 
                            
                    #         elseif ( $ExceptionCode -eq 412 ) {
                    #             Throw "Error status Code: 412 (Precondition failed) - Please verify the content of the payload request!"
                                
                    #         } 
                            
                    #         elseif ( $ExceptionCode -eq 408 ) {
                    #             Throw "Error status Code: 408 (Request Timeout) - Please try again!"
                                
                    #         }
                            
                    #         else {
                    #             Throw "Error status Code: {0} ({1})" -f $ExceptionCode, $ExceptionText

                    #         }
                    #     }
                    # }  
                    catch [HtmlContentDetectedException] {

                        $attempt++

                        # Store the last exception
                        $lastException = $_ 

                        "[{0}] -------------------------------------------- HtmlContentDetectedException Catch triggered! ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        if ($_.Exception.Response) {
                            $statusCode = [int]$_.Exception.Response.StatusCode
                            "[{0}] Received HTTP status code: '{1}'." -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode | Write-Verbose
                        } else {
                            "[{0}] No HTTP status code received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            $statusCode = "N/A"
                        }
                        
                        
                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 
                        "[{0}] --------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                                             
                        
                        # When HTML is detected, it means the session has expired or been closed
                        Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                    }                   
                    catch {

                        $attempt++

                        # Store the last exception
                        $lastException = $_                      
                        
                        "[{0}] -------------------------------------------- Catch triggered! ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        if ($_.Exception.Response) {
                            $statusCode = [int]$_.Exception.Response.StatusCode
                            "[{0}] Received HTTP status code: '{1}'." -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode | Write-Verbose
                        } else {
                            "[{0}] No HTTP status code received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            $statusCode = "N/A"
                        }
                        
                        
                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 
                        "[{0}] --------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        
                        if ($statusCode -in 408, 500, 502, 503, 504) {
                            "[{0}] HTTP error {1} encountered. Retrying in 1 second... (Attempt {2} of {3})" -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode, $attempt, $MaxRetries | Write-Verbose  
                            Start-Sleep -Seconds 1
                        }
                        else {
                            
                            $ExceptionErrorMessage = $_.Exception.Message
                            
                            if ($ExceptionErrorMessage -eq "Unauthorized") {
                                Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                            }
                            
                            $complete = $true
                        }      
                    }

                }
                #EndRegion

                #Region When using an HPEOnepass URI
                elseif ($uri -match $HPEOnepassbaseURL) {

                    "[{0}] ------------------------------------ Detected URI: HPE Onepass ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    if ($null -ne $Body) {

                        try {
                            $BodyObject = ConvertFrom-Json -InputObject $Body -ErrorAction Stop
                            # "Payload content after convertion: `n{0}" -f $BodyObject | Write-Verbose
                            # Add sessionId to the object
                            $BodyObject | Add-Member -MemberType NoteProperty -Name 'sessionId' -Value $HPEGreenLakeSession.onepassSid                   
                            # "Payload content after adding HPEOnePass sessionId: `n{0}" -f $BodyObject | Write-Verbose

                        }
                        catch {
                            Write-Error "The provided JSON body is not valid."
                            return
                        }
                    }
                    else {
                        $BodyObject = @{ sessionId = $HPEGreenLakeSession.onepassSid }

                    }

                    "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Uri | Write-Verbose

                    # Convert the body hashtable to a JSON string
                    $Payload = $BodyObject | ConvertTo-Json
                    
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                    
                    Try {

                        $InvokeReturnData = Invoke-WebRequest -Uri $Uri -Method $Method -Body $Payload -ContentType $ContentType #-ErrorAction Stop

                        # Create a global variable to store the Invoke-WebRequest response
                        $Global:HPEGLInvokeReturnData = $InvokeReturnData

                        "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                        "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   

                        $complete = $true

                    }
                    catch {

                        $attempt++
                        
                        # Store the last exception
                        $lastException = $_

                        "[{0}] -------------------------------------------- Catch triggered! ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose
    
                        if ($_.Exception.Response) {
                            $statusCode = [int]$_.Exception.Response.StatusCode
                            "[{0}] Received HTTP status code: '{1}'." -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode | Write-Verbose
                        } else {
                            "[{0}] No HTTP status code received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            $statusCode = "N/A"
                        }
                        
                        
                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 
                        "[{0}] --------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        
                        if ($statusCode -in 408, 500, 502, 503, 504) {
                            "[{0}] HTTP error {1} encountered. Retrying in 1 second... (Attempt {2} of {3})" -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode, $attempt, $MaxRetries | Write-Verbose  
                            Start-Sleep -Seconds 1
                        }
                        else {

                            $complete = $true
                        }
                    }
                    
                }
                #EndRegion
                
                #Region When using an HPE GLP API URI
                elseif ($uri -match $HPEGLAPIbaseURL -or $uri -match $HPEGLAPIOrgbaseURL) {

                    # Process pagination for GET 
                    if ($Method -eq "GET") {

                        $AllCollection = [System.Collections.ArrayList]::new()

                        # Get 100 items pagination
                        $pagination = 50

                        # Detect if $uri contains a query parameter
                        $uriobj = [System.Uri]::new($uri)

                        # Parse the query parameters into a dictionary
                        $queryParameters = [System.Web.HttpUtility]::ParseQueryString($uriobj.Query)
                        
                        # URI modification to support pagination
                        if ($queryParameters["limit"]) {

                            $url = $uri
                        }
                        # If contains another query parameter
                        elseif ($uriobj.Query -ne "") {

                            $url = $uri + "&limit=$pagination&offset=0"

                        }
                        # If not contains any query parameter
                        else {
                            
                            $url = $uri + "?limit=$pagination&offset=0"
                        }

                        "[{0}] URI that has been generated: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                        
                    }
                    else {

                        $url = $uri

                    }
                    

                    if ($Null -eq $HPEGreenLakeSession.glpApiAccessToken) {
          
                        Throw "Error - No API Access Token found in `$HPEGreenLakeSession! Connect-HPEGL must be executed first!"
                   
                    }            

                    if ($uri -match "/v2alpha1/workspaces") {

                        "[{0}] ------------------------------------ Detected URI: GLP /v2alpha1/workspaces API using v1.2 tokens : {1} ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $uri | Write-Verbose     

                        $headers = @{} 
                        $headers["Accept"] = "application/json"
                        $headers["Content-Type"] = "application/json"
                        $headers["Authorization"] = "Bearer $($HPEGreenLakeSession.glpApiAccessTokenv1_2.access_token)"
                    }
                    else {

                        "[{0}] ------------------------------------ Detected URI: GLP API using v1 tokens : {1} ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $uri | Write-Verbose     

                        $headers = @{} 
                        $headers["Accept"] = "application/json"
                        $headers["Content-Type"] = "application/json"
                        $headers["Authorization"] = "Bearer $($HPEGreenLakeSession.glpApiAccessToken.access_token)"
                    }


                    "[{0}] Request headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | out-string) | Write-Verbose

                    if ($body) {
                        # If body is JSON
                        if ($body.Trim().StartsWith('{') -and $body.Trim().EndsWith('}')) {
                            $Payload = $Body 
                        }
                        else {
                            # Convert the body hashtable to a JSON string
                            $Payload = $Body | ConvertTo-Json -Depth 10
                        }
                    }


                    try {

                        "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Url | Write-Verbose      

                        if ($payload) {
                            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                        }
                        else {
                            "[{0}] No payload content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        }
              
                        $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Body $Body -ContentType $ContentType -Headers $headers #-ErrorAction Stop

                        # Create a global variable to store the Invoke-WebRequest response
                        $Global:HPEGLInvokeReturnData = $InvokeReturnData

                        "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                        "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   

                        $complete = $true
                    
                    }
                    # catch [System.Net.WebException] {

                    #     "[{0}] System.Net.WebException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    #     "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                    #     "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose     

                    #     # Store the last exception
                    #     $lastException = $_
                        
                    #     # Service Unavailable error
                    #     if ($_.Exception.Response.StatusCode -eq 503) {
                    #         $retries++
                    #         # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                    #         $waitTime = 2
                    #         Write-Host "Received 503. Retrying in $waitTime seconds..."
                    #         Start-Sleep -Seconds $waitTime
                    #     }
                    #     else {

                    #         if ($_.Exception.Response) {

                    #             $PSCmdlet.ThrowTerminatingError($_).Exception.Response
                                
                               
                    #         }
                    #         else {
                    #             Throw "No Response Received."
                    #         }
                    #     }
                    # }
                    catch {

                        $attempt++

                        # Store the last exception
                        $lastException = $_                      
                        
                        "[{0}] -------------------------------------------- Catch triggered! ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose
    
                        if ($_.Exception.Response) {
                            $statusCode = [int]$_.Exception.Response.StatusCode
                            "[{0}] Received HTTP status code: '{1}'." -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode | Write-Verbose
                        } 
                        else {
                            "[{0}] No HTTP status code received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            $statusCode = "N/A"
                        }
                        
                        
                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 
                        "[{0}] --------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                        

                        if ($statusCode -in 408, 500, 502, 503, 504) {
                            "[{0}] HTTP error {1} encountered. Retrying in 1 second... (Attempt {2} of {3})" -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode, $attempt, $MaxRetries | Write-Verbose  
                            Start-Sleep -Seconds 1
                        }
                        else {

                            $ExceptionErrorMessage = $_.Exception.Message
                        
                            if ($ExceptionErrorMessage -eq "Unauthorized") {
                                Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                            }

                            $complete = $true

                            # if ($_.ErrorDetails) {
    
                            #     "[{0}] Error Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose
        
                            #     $errorResponse = $_.ErrorDetails.Message | ConvertFrom-Json
        
                            #     # Write-Verbose  $errorResponse
        
                            #     $httpStatusCode = $errorResponse.httpStatusCode
                            #     $Message = $errorResponse.message
                               
                            #     if ($errorResponse -and $errorResponse.errorDetails -and $errorResponse.errorDetails.Count -gt 0 -and 
                            #         $errorResponse.errorDetails[0].issues -and $errorResponse.errorDetails[0].issues.Count -gt 0 -and 
                            #         $errorResponse.errorDetails[0].issues[0].description) {
                                
                            #         $Description = $errorResponse.errorDetails[0].issues[0].description
                            #         $Subject = $errorResponse.errorDetails[0].issues[0].subject
        
                            #     }                    
        
                            #     if ($errorResponse -and $errorResponse.errorDetails -and $errorResponse.errorDetails.Count -gt 0 -and 
                            #         $errorResponse.errorDetails[0].metadata -and $errorResponse.errorDetails[0].metadata.details) {
                                
                            #         $Description = $errorResponse.errorDetails[0].metadata.details
                            #     }                       
                                       
                            # }                       
    
                            # if ($httpStatusCode -eq 404) {
    
                            #     Write-Error $errorResponse
                            #     Throw "Resource not found (404) -  $message"
                                
                            # }
                            # elseif ($Message -eq "Unauthorized") {
    
                            #     "[{0}] Error response message: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $message | Write-Verbose
                            #     Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
    
    
                            # }
                            # elseif ($Message) {
    
                            #     "[{0}] Error response message: '{1}' - HTTP status code: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Message, $httpStatusCode | Write-Verbose
    
                            #     if ($Description -and $Subject) {
                                    
                            #         "[{0}] Error subject: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Subject | Write-Verbose
                            #         "[{0}] Error description: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Description | Write-Verbose
                            #         Throw "Error: '$message' - HTTP status code: '$httpStatusCode' - Subject: '$Subject' - Description: '$Description'"
    
                            #     }
                            #     elseif ($Description) {
    
                            #         "[{0}] Error description: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Description | Write-Verbose
                            #         Throw "Error: '$message' - HTTP status code: '$httpStatusCode' - Description: '$Description'"
    
                            #     }
                            #     else {
                            #         Throw "Error: '$message' - HTTP status code: '$httpStatusCode'"
                                    
                            #     }
    
    
                            # }
                            # else {
    
                            #     "[{0}] Error: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose
                            #     Throw $_

                            # }
                        }
                    }
                   
                }
                #EndRegion

                else {
                    Throw "Error - Invalid URI! The URI must be a valid HPE GreenLake API URI!"
                }
            
                 
    
                #Region Manage the response content
                if ($InvokeReturnData) {                 
            
                    # Convert from JSON if possible
                    try {

                        $InvokeReturnData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop

                        if ($InvokeReturnData -eq "OK") {

                            "[{0}] Response Detected with an 'OK' response!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            
                            return           
                        }   

                        # HPEOnepass URI expiration detection
                        if ($InvokeReturnData.message -match "expired") {
                            write-error "Session gets expired! You must run 'Connect-HPEGL' again!"
                        }


                        "[{0}] Response detected as JSON content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        # "[{0}] Response detected as JSON content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(),  ( $InvokeReturnData | out-string) | Write-Verbose

                        #Region UI Doorway API Pagination detection
                        if ($InvokeReturnData.pagination) {

                            if ($InvokeReturnData.pagination.total_count -gt 0) {
                   
                                "[{0}] Response detected with a pagination content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($InvokeReturnData.pagination | out-string) | Write-Verbose
                                
                                # Get all paginated pages (if any)
                                if (($Method -eq "GET" -or $Method -eq "POST") -and -not $queryParameters["limit"]) {
                                    #    if (($Method -eq "GET" -or ($Method -eq "POST" -and -not $Body)) -and -not $queryParameters["limit"]) {
        
                                    # "[{0}] Pagination found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                                       
                                    $AllCollection = $InvokeReturnData
    
                                    "[{0}] Total of items: '{1}' - Number of items per page: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.pagination.total_count, $InvokeReturnData.pagination.count_per_page | Write-Verbose
                                
                                    $Numberofpages = [System.Math]::Ceiling(($InvokeReturnData.pagination.total_count / $InvokeReturnData.pagination.count_per_page))
                                
                                    "[{0}] Number of pages found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofpages | Write-Verbose
                                
                                    if ($Numberofpages -gt 1) {
    
                                        for ($i = 1; $i -lt $Numberofpages; $i++) {
                                        
                                            $Offset += [int]$pagination

                                            "[{0}] Offset defined: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Offset | Write-Verbose
    
                                            # URI modification to support pagination with Get-HPEGLWorkspace
                                            if ($queryParameters["count_per_page"]) {
    
                                                $url = $uri + "&offset=$Offset"
                                            }
                                            elseif ($uriobj.Query -ne "") {
                                                
                                                $url = $uri + "&limit=$pagination&offset=$Offset"
                                                
                                            }
                                            else {
                                                
                                                $url = $uri + "?limit=$pagination&offset=$Offset"
                                            }
    
                                            "[{0}] Request URI for page '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $url | Write-Verbose
                                        
                                            try {
                                       
                                                $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Body $Body -WebSession $WebSession -ContentType $ContentType #-ErrorAction Stop

                                                # Create a global variable to store the Invoke-WebRequest response
                                                $Global:HPEGLInvokeReturnData = $InvokeReturnData
    
                                                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                                                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   
    
                                                $InvokeReturnMoreData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop 
                                                "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                                                # Initialize an empty hashtable
                                                $dictionary = @{}
                                                
                                                # Iterate through the properties of the returned object
                                                $InvokeReturnMoreData.PSObject.Properties | ForEach-Object {
                                                    $propertyName = $_.Name
                                                    $propertyValue = $_.Value
    
                                                    # Check if the property value is a list of objects (array or collection) and not a hashtable
                                                    if ($propertyValue -is [System.Collections.IEnumerable] -and $null -ne $propertyValue -and $propertyValue.GetType().Name -ne "String" -and -not ($propertyValue -is [hashtable])) {
                                                        $dictionary[$propertyName] = $propertyValue
                                                    }
                                                }
                                                
                                                "[{0}] Content of the list property that needs to be added: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($dictionary | Out-String) | Write-Verbose
    
                                                # "[{0}] `$dictionary: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($dictionary.GetEnumerator() | gm  | Out-String) | Write-Verbose
                                                
                                                # Iterate through the dictionary entries
                                                foreach ($entry in $dictionary.GetEnumerator()) {
                                                    $_Item = $entry.Key
                                                    $_Value = $entry.Value
                                                
                                                }
                                                
                                                # "[{0}] Adding item '{1}' with content: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Item, ($_Value | out-String)  | Write-Verbose
                                                
                                                if ($AllCollection.PSObject.Properties.Match('$_Item')) {
                                                    
                                                    "[{0}] Content of `$AllCollection matches with {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Item | Write-Verbose
                                                    
                                                    "[{0}] Adding page '{1}' to the result" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1) | Write-Verbose
                                                    $AllCollection.($_Item) += $_Value
                                                }
                                                    
                                            }
                                            catch {    
                                                $PSCmdlet.ThrowTerminatingError($_)
                                            
                                            }
                                        }
                                    }
    
                                    $InvokeReturnData = $AllCollection
                                }
    
                                if ($Null -ne $InvokeReturnData.content) {
    
                                    "[{0}] Response Detected with a Content property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                                    "[{0}] $InvokeReturnData content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($InvokeReturnData | out-String) | Write-Verbose
    
                                    $InvokeReturnData = $InvokeReturnData.content
                
                                }
    
                            }
                        }
                        #EndRegion

                        #Region GLP API Pagination detection
                        elseif ($InvokeReturnData.total) {

                            if ($InvokeReturnData.total -gt 0) {
                   
                                "[{0}] Response detected with a count/total content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                                
                                # Get all paginated pages (if any)
                                if ($Method -eq "GET" -and -not $queryParameters["limit"]) {
        
                                    $AllCollection = $InvokeReturnData
    
                                    "[{0}] Total of items: '{1}' - Number of items per page: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.total, $InvokeReturnData.count | Write-Verbose
                                
                                    $Numberofpages = [System.Math]::Ceiling(($InvokeReturnData.total / $InvokeReturnData.count))
                                
                                    "[{0}] Number of pages found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofpages | Write-Verbose
                                
                                    if ($Numberofpages -gt 1) {
    
                                        for ($i = 1; $i -lt $Numberofpages; $i++) {
                                        
                                            $Offset += [int]$pagination
    
                                            if ($uriobj.Query -ne "") {
                                                
                                                $url = $uri + "&limit=$pagination&offset=$Offset"
                                                
                                            }
                                            else {
                                                
                                                $url = $uri + "?limit=$pagination&offset=$Offset"
                                            }
    
                                            "[{0}] Request URI for page '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $url | Write-Verbose
                                        
                                            try {
                                       
                                                $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Body $Body -ContentType $ContentType -Headers $headers #-ErrorAction Stop

                                                # Create a global variable to store the Invoke-WebRequest response
                                                $Global:HPEGLInvokeReturnData = $InvokeReturnData
    
                                                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                                                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   
    
                                                $InvokeReturnMoreData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop 
                                                "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                                                # Initialize an empty hashtable
                                                $dictionary = @{}
                                                
                                                # Iterate through the properties of the returned object
                                                $InvokeReturnMoreData.PSObject.Properties | ForEach-Object {
                                                    $propertyName = $_.Name
                                                    $propertyValue = $_.Value
    
                                                    # Check if the property value is a list of objects (array or collection) and not a hashtable
                                                    if ($propertyValue -is [System.Collections.IEnumerable] -and $null -ne $propertyValue -and $propertyValue.GetType().Name -ne "String" -and -not ($propertyValue -is [hashtable])) {
                                                        $dictionary[$propertyName] = $propertyValue
                                                    }
                                                }
                                                
                                                "[{0}] Content of the list property that needs to be added: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($dictionary | Out-String) | Write-Verbose
    
                                                # Iterate through the dictionary entries
                                                foreach ($entry in $dictionary.GetEnumerator()) {
                                                    $_Item = $entry.Key
                                                    $_Value = $entry.Value
                                                
                                                }
                                                
                                                # "[{0}] Adding item '{1}' with content: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Item, ($_Value | out-String)  | Write-Verbose
                                                
                                                if ($AllCollection.PSObject.Properties.Match('$_Item')) {
                                                    
                                                    "[{0}] Content of `$AllCollection matches with {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Item | Write-Verbose
                                                    
                                                    "[{0}] Adding page '{1}' to the result" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1) | Write-Verbose
                                                    $AllCollection.($_Item) += $_Value
                                                }
                                                    
                                            }
                                            catch {    
                                                $PSCmdlet.ThrowTerminatingError($_)
                                            
                                            }
                                        }
                                    }
    
                                    $InvokeReturnData = $AllCollection
                                }
    
                                if ($Null -ne $InvokeReturnData.content) {
    
                                    "[{0}] Response Detected with a Content property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                                    "[{0}] $InvokeReturnData content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($InvokeReturnData | out-String) | Write-Verbose
    
                                    $InvokeReturnData = $InvokeReturnData.content
                
                                }
    
                            }
                        }
                        #Endregion

                        return $InvokeReturnData   

                    }

                    catch {

                        throw $InvokeReturnData
                    }                    
            
                }  
                #EndRegion

            }
           
            
            if ($lastException) {

                # If the request was not completed after retries          
                if (-not $complete) {
                    "[{0}] Retry loop was triggered and reached the maximum of retries - Retries={1} - MaxRetries={2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $attempt, $MaxRetries | Write-Verbose
                }  

                try {
                    $errorData = $lastException | ConvertFrom-Json
                }
                catch {                    
                }
                
                if ($errorData){

                    # Construct the custom exception message
                    $exceptionMessage = [System.Collections.ArrayList]::new()

                    # Checking icontent of errorDetails
                    foreach ($detail in $errorData.errorDetails) {

                        # if details exist
                        if ($detail.metadata.details) {
                            $detailsMessage = [System.Text.RegularExpressions.Regex]::Unescape($detail.metadata.details)
                            "[{0}] Message captured: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $detailsMessage  | Write-Verbose
                            [void]$exceptionMessage.add($detailsMessage)
                        }

                        # if error exist
                        if ($detail.metadata.error) {
                            $detailsMessage = [System.Text.RegularExpressions.Regex]::Unescape($detail.metadata.error)
                            "[{0}] Message captured: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $detailsMessage  | Write-Verbose
                            [void]$exceptionMessage.add($detailsMessage)
                        }

                        # if issues exist
                        if ($detail.issues.description) {
                            $detailsMessage = [System.Text.RegularExpressions.Regex]::Unescape($detail.issues.description)
                            "[{0}] Message captured: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $detailsMessage  | Write-Verbose
                            [void]$exceptionMessage.add($detailsMessage)
                        }
                    }       
                    
                    if ($exceptionMessage.count -gt 0) {
                        $exceptionMessage = $exceptionMessage -join " - "
                    }
                    

                    # Decode the Unicode escape sequences in the message as there is usually Unicode Escape Sequence (e.g. \u003c) in the message
                    if ($errorData.message) {
                        $Message = [System.Text.RegularExpressions.Regex]::Unescape($errorData.message)
                    }
                    else {
                        $Message =  [System.Text.RegularExpressions.Regex]::Unescape($errorData)
                    }

                                        
                    if($exceptionMessage -gt 0){

                        $msg = "{0} - {1}" -f  $Message, $exceptionMessage
                    }   
                    else {
                        
                        $msg = "{0}" -f $Message 

                    }                 
        
                    Throw $msg

                    
                }
                else {
                    Throw $lastException
                }
            }   
        }     
    }         
}


function Invoke-HPECOMWebRequest {  
    <#
     .SYNOPSIS
    Cmdlet to run web requests to the Compute Ops Management API. 

    .DESCRIPTION
    The `Invoke-HPECOMWebRequest` cmdlet sends HTTPS requests to the Compute Ops Management API. It adds the required headers, parses the response and returns the response.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Uri
    The uri that identifies the required Compute Ops Management resource (eg. /compute-ops/v1beta2/job-templates').

    .PARAMETER Body
    Body for the request. Required if the method is POST or PUT.

    .PARAMETER Method
    The request HTTP Method.

            * "GET" (default) to get a resource from the appliance (read)
            * "POST" to create a new resource
            * "PUT" to modify a resource (write)
            * "PATCH" to modify a resource (write), with specific attributes set to values, other attributes should be set to $null.
            * "DELETE" to delete a resource

    .PARAMETER WebSession
    Web session object containing information about the HPE GreenLake session, including cookies and credentials.
    Default uses $HPEGreenLakeSession.session global variable.

    .PARAMETER WhatIfBoolean
    Switch parameter to show the user what would happen if the cmdlet was to run without actually running it.

    .EXAMPLE
    Invoke-HPECOMWebRequest -Uri "/compute-ops/v1beta2/job-templates" -Region "us-west" -Method "GET"

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    The output of the cmdlet depends upon the format of the content that is retrieved.
    If the request returns JSON strings, Invoke-HPEGLWebRequest returns a PSObject that represents the strings.

    $HPECOMInvokeReturnData global variable is set to the response of the web request.
        
         
    #>
    Param   (   
        
        [Parameter (Mandatory)]
        [String]$Uri,

        $Body, 

        [String]$Method = "GET",

        [Parameter(Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$ContentType = 'application/json',

        $WhatIfBoolean = $false,

        [int]$MaxRetries = 5,
        [int]$InitialDelaySeconds = 1

    )
   
    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        #Region Check if HPEGreenLakeSession variable is available
        try {
            Get-Variable -Name HPEGreenLakeSession -Scope Global -ErrorAction Stop | Out-Null
        }
        catch {
            Throw "Error - No COM API credential found! Connect-HPEGL must be executed first!"
    
        }
        #EndRegion


        #Region Check if a reconnection is required
        try {
            Invoke-HPEGLAutoReconnect 
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        #EndRegion


        #Region Retrieve $HPECOMjobtemplatesUris if not available
        if (-not $HPECOMjobtemplatesUris) {
            "[{0}] About to retrieve the URIs of each job templates in '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $region | Write-Verbose
            Set-HPECOMJobTemplatesVariable 
        }
        #EndRegion
      

        #Region Check if COM API variable for the region is available + construct $url and pagination
        Clear-Variable -Name InvokeReturnData -ErrorAction SilentlyContinue

        "[{0}] Region selected: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
    
        $credentialname = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).name

        "[{0}] Credential found in `$HPEGreenLakeSession.apiCredentials: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $credentialname | Write-Verbose

        if ($Null -eq $credentialName) {

            Throw "Error! No COM API credential found for '$Region' in `$HPEGreenLakeSession.apiCredentials! 'Connect-HPEGL' must be executed first or make sure you have selected the correct region!"

        }
        else {

            $ConnectivityEndPoint = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).connectivity_endpoint
            
            if ($ConnectivityEndPoint ) {
                "[{0}] Connectivitiy EndPoint found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ConnectivityEndPoint | Write-Verbose
                
            }
            else {
                    
                Throw "Error - No COM API Access Token found in `$HPEGreenLakeSession! Connect-HPEGL must be executed !"
                    
            }
            
            $comApiAccessToken = ($HPEGreenLakeSession.comApiAccessToken | Where-Object name -eq $credentialname).access_token
    

            # Process pagination for GET 
            if ($Method -eq "GET") {

                $AllCollection = [System.Collections.ArrayList]::new()

                # Get 100 items pagination
                $pagination = 100

                # Detect if $uri contains a query parameter
                $url = $ConnectivityEndPoint + $uri
                $uriobj = [System.Uri]::new($url)

                # Parse the query parameters into a dictionary
                $queryParameters = [System.Web.HttpUtility]::ParseQueryString($uriobj.Query)
                
                # If contains a query limit parameter
                if ($queryParameters["limit"]) {

                    $Url = $ConnectivityEndPoint + $uri
                }
                # If contains another query parameter
                elseif ($uriobj.Query -ne "") {

                    $Url = $ConnectivityEndPoint + $uri + "&limit=$pagination&offset=0"

                }
                # If not contains any query parameter
                else {
                    
                    $Url = $ConnectivityEndPoint + $uri + "?limit=$pagination&offset=0"
                }
                
            }
            else {

                $url = $ConnectivityEndPoint + $uri

            }

            if ($comApiAccessToken ) {
                "[{0}] COM API Access token found" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
            }
            else {
                    
                Throw "Error - No COM API Access Token found in `$HPEGreenLakeSession! Connect-HPEGL must be executed !"
                    
            }


        }
        #EndRegion

       
        #Region Construction for WhatIf
        if ( $WhatIfBoolean ) {
               
            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Authorization"] = "Bearer $($comApiAccessToken)"

            Invoke-RestMethodWhatIf -Uri $Url -Method $Method -Body $Body -Headers $headers -ContentType $ContentType -Cmdlet "Invoke-HPECOMWebRequest"
                
        }
        #EndRegion
        

        #Region Construction for Invoke-Webrequest
        else {
            
            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Authorization"] = "Bearer $($comApiAccessToken)"

            "[{0}] Request headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | ConvertTo-Json) | Write-Verbose
           
            if ($body) {
                # If body is JSON
                if ($body.Trim().StartsWith('{') -and $body.Trim().EndsWith('}')) {
                    $Payload = $Body 
                }
                else {
                    # Convert the body hashtable to a JSON string
                    $Payload = $Body | ConvertTo-Json -Depth 10                
                }            
            }

            $lastException = $null

            $attempt = 0
            $complete = $false

            while (-not $complete -and $attempt -lt $MaxRetries) {          

                try {
              
                    "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Url | Write-Verbose      

                    if ($payload) {
                        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                    }
                    else {
                        "[{0}] No payload content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }

                    $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Headers $headers -Body $Body -ContentType $ContentType

                    # Create a global variable to store the Invoke-WebRequest response
                    $Global:HPECOMInvokeReturnData = $InvokeReturnData
                   
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose    
                    
                    $complete = $true
                    
                }
                catch {

                    $attempt++

                    # Store the last exception
                    $lastException = $_                      
                    
                    "[{0}] -------------------------------------------- Catch triggered! ------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                    "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                    if ($_.Exception.Response) {
                        $statusCode = [int]$_.Exception.Response.StatusCode
                        "[{0}] Received HTTP status code: '{1}'." -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode | Write-Verbose
                    } 
                    else {
                        "[{0}] No HTTP status code received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        $statusCode = "N/A"
                    }
                    
                    
                    "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 
                    "[{0}] --------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose                    
                    

                    if ($statusCode -in 408, 500, 502, 503, 504) {
                        "[{0}] HTTP error {1} encountered. Retrying in 1 second... (Attempt {2} of {3})" -f $MyInvocation.InvocationName.ToString().ToUpper(), $statusCode, $attempt, $MaxRetries | Write-Verbose  
                        Start-Sleep -Seconds 1
                    }
                    else {
                        
                        $ExceptionErrorMessage = $_.Exception.Message
                        
                        if ($ExceptionErrorMessage -eq "Unauthorized") {
                            Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                        }
                        
                        $complete = $true
                    }                       
                }
            
                #Region Manage the response content
                if ($InvokeReturnData) {
            
                    try {

                        $InvokeReturnData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop
                        "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose   
    
                        if ($InvokeReturnData -eq "OK") {
    
                            "[{0}] Response detected with an 'OK' response!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return           
                        }   
                        
                        # If the 'items' property exists with an empty array, return nothing 
                        if ($InvokeReturnData.count -eq 0 -and $InvokeReturnData.items -is [System.Collections.IEnumerable]) {
    
                            "[{0}] Response detected with an items property but most probably with an empty array" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            "[{0}] Leaving Invoke-HPECOMWebRequest and returning no content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return
                        
                        }
                        # If the 'items' property exists, return the content of items 
                        elseif ($InvokeReturnData.items ) {
    
                            "[{0}] Response detected with an items property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            # Get all paginated pages
                            if ($Method -eq "GET" -and -not $queryParameters["limit"] ) {
                                    
                                $AllCollection = $InvokeReturnData

                                "[{0}] Total of items: '{1}' - Number of items per page: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.total, $InvokeReturnData.items.count | Write-Verbose
                            
                                $Numberofpages = [System.Math]::Ceiling(($InvokeReturnData.total / $InvokeReturnData.items.count))
                            
                                "[{0}] Number of pages found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofpages | Write-Verbose
                            
                                if ($Numberofpages -gt 1) {

                                    for ($i = 1; $i -lt $Numberofpages; $i++) {
                                    
                                        $Offset += [int]$pagination
                            
                                        if ($uriobj.Query -ne "") {
                                            
                                            $Url = $ConnectivityEndPoint + $uri + "&limit=$pagination&offset=$Offset"
                                            
                                        }
                                        else {
                                            
                                            $Url = $ConnectivityEndPoint + $uri + "?limit=$pagination&offset=$Offset"
                                        }
                                    
                                        "[{0}] Request URI for page '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $Url | Write-Verbose
                                    
                                        try {
                                            $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Headers $headers -Body $Body -ContentType $ContentType

                                            # Create a global variable to store the Invoke-WebRequest response
                                            $Global:HPECOMInvokeReturnData = $InvokeReturnData

                                            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                                            "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   

                                            $InvokeReturnMoreData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop
                                            "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                                            "[{0}] Adding page '{1}' to the result" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1) | Write-Verbose
                                            $AllCollection.items += $InvokeReturnMoreData.items

                                        }
                                        catch {    
                                            $PSCmdlet.ThrowTerminatingError($_)
                                        
                                        }
                                    }
                                }

                                $InvokeReturnData = $AllCollection

                            }


                            "[{0}] Leaving Invoke-HPECOMWebRequest and returning the items content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return $InvokeReturnData.items
        
                        }
                        else {
    
                            "[{0}] Response detected with no items property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            "[{0}] Leaving Invoke-HPECOMWebRequest and returning the response content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return $InvokeReturnData   
                        }
                    }
                    catch {
                        "[{0}] Convert response from json exception due to case sensitive keys! Reformatting data..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        
                        # When using ConvertFrom-Json in PowerShell, case sensitivity can be an issue because PowerShell has case-insensitive hash table keys by default. 
                        # This means if your JSON object contains keys with different casing (e.g., Description and description), it will cause a conflict.
                        # To handle this issue, use the -AsHashTable switch to convert the JSON string into a hash table where key casing is preserved.
                        $_InvokeReturnData = ConvertFrom-Json $InvokeReturnData -AsHashtable

                        # "[{0}] Convertion to JSON as a hastable to fix same case sensitive properties... Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_InvokeReturnData | out-string) | Write-Verbose
                        
                        # Output the newly formatted data to [PSCustomObject] (removes Name / Value column names)

                        $customObject = [PSCustomObject]$_InvokeReturnData

                        "[{0}] Convertion to [customObject]: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($customObject | out-string) | Write-Verbose
                        
                        return [PSCustomObject]$customObject

                        
                    }                    
                }  
                #EndRegion

            }
         
            if ($lastException) {

                # If the request was not completed after retries          
                if (-not $complete) {
                    "[{0}] Retry loop was triggered and reached the maximum of retries - Retries={1} - MaxRetries={2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $attempt, $MaxRetries | Write-Verbose
                }  

                try {
                    $errorData = $lastException | ConvertFrom-Json
                }
                catch {                    
                }
                
                if ($errorData){

                    # Construct the custom exception message
                    $exceptionMessage = [System.Collections.ArrayList]::new()

                    # Checking icontent of errorDetails
                    foreach ($detail in $errorData.errorDetails) {

                        # if details exist
                        if ($detail.metadata.details) {
                            $detailsMessage = [System.Text.RegularExpressions.Regex]::Unescape($detail.metadata.details)
                            "[{0}] Message captured: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $detailsMessage  | Write-Verbose
                            [void]$exceptionMessage.add($detailsMessage)
                        }

                        # if error exist
                        if ($detail.metadata.error) {
                            $detailsMessage = [System.Text.RegularExpressions.Regex]::Unescape($detail.metadata.error)
                            "[{0}] Message captured: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $detailsMessage  | Write-Verbose
                            [void]$exceptionMessage.add($detailsMessage)
                        }

                        # if issues exist
                        if ($detail.issues.description) {
                            $detailsMessage = [System.Text.RegularExpressions.Regex]::Unescape($detail.issues.description)
                            "[{0}] Message captured: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $detailsMessage  | Write-Verbose
                            [void]$exceptionMessage.add($detailsMessage)
                        }
                    }       
                    
                    if ($exceptionMessage.count -gt 0) {
                        $exceptionMessage = $exceptionMessage -join " - "
                    }
                    

                    # Decode the Unicode escape sequences in the message as there is usually Unicode Escape Sequence (e.g. \u003c) in the message
                    if ($errorData.message) {
                        $Message = [System.Text.RegularExpressions.Regex]::Unescape($errorData.message)
                    }
                    else {
                        $Message =  [System.Text.RegularExpressions.Regex]::Unescape($errorData)
                    }

                                        
                    if($exceptionMessage -gt 0){

                        $msg = "{0} - {1}" -f  $Message, $exceptionMessage
                    }   
                    else {
                        
                        $msg = "{0}" -f $Message 

                    }                      
        
                    Throw $msg

                    
                }
                else {
                    Throw $lastException
                }
            }                        
        }
    }         
}


function Get-HPEGLJWTDetails {
    [cmdletbinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [string]$token
    )
  
    <#
  
  .SYNOPSIS
  Decode a JWT Access Token and convert to a PowerShell Object.
  JWT Access Token updated to include the JWT Signature (sig), JWT Token Expiry (expiryDateTime) and JWT Token time to expiry (timeToExpiry).
  
  .DESCRIPTION
  Decode a JWT Access Token and convert to a PowerShell Object.
  JWT Access Token updated to include the JWT Signature (sig), JWT Token Expiry (expiryDateTime) and JWT Token time to expiry (timeToExpiry).
  
  Thanks to Darren Robinson for this function!
  https://github.com/darrenjrobinson/JWTDetails
  https://blog.darrenjrobinson.com

  .PARAMETER token
  The JWT Access Token to decode and update with expiry time and time to expiry
  
  .INPUTS
  Token from Pipeline 
  
  .OUTPUTS
  PowerShell Object
  
  .EXAMPLE
  Get-HPEGLJWTDetails
  
  .EXAMPLE
  PS> Get-HPEGLJWTDetails($myAccessToken)
  or 
  PS> $myAccessToken | Get-JWTDetails
  tenant_id             : cd988f3c-710c-43eb-9e25-123456789
  internal              : False
  pod                   : uswest2
  org                   : myOrd
  identity_id           : 1c818084624f8babcdefgh9a4
  user_name             : adminDude
  strong_auth_supported : True
  user_id               : 100666
  scope                 : {read, write}
  exp                   : 1564474732
  jti                   : 1282411c-ffff-1111-a9d0-f9314a123c7a
  sig                   : SWPhCswizzleQWdM4K8A8HotX5fP/PT8kBWnaaAf2g6k=
  expiryDateTime        : 30/07/2019 6:18:52 PM
  timeToExpiry          : -00:57:37.4457299
  
  #>
  
    if (!$token.Contains(".") -or !$token.StartsWith("eyJ")) { Write-Error "Invalid token" -ErrorAction Stop }
  
    # Token
    foreach ($i in 0..1) {
        $data = $token.Split('.')[$i].Replace('-', '+').Replace('_', '/')
        switch ($data.Length % 4) {
            0 { break }
            2 { $data += '==' }
            3 { $data += '=' }
        }
    }
  
    $decodedToken = [System.Text.Encoding]::UTF8.GetString([convert]::FromBase64String($data)) | ConvertFrom-Json 
    "[{0}] JWT Token: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $decodedToken | Write-Verbose

  
    # Signature
    foreach ($i in 0..2) {
        $sig = $token.Split('.')[$i].Replace('-', '+').Replace('_', '/')
        switch ($sig.Length % 4) {
            0 { break }
            2 { $sig += '==' }
            3 { $sig += '=' }
        }
    }
    "[{0}] JWT Signature: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $sig | Write-Verbose

    $decodedToken | Add-Member -Type NoteProperty -Name "sig" -Value $sig
  
    # Convert Expiry time to PowerShell DateTime
    $orig = (Get-Date -Year 1970 -Month 1 -Day 1 -hour 0 -Minute 0 -Second 0 -Millisecond 0)
    $timeZone = Get-TimeZone
    $utcTime = $orig.AddSeconds($decodedToken.exp)
    $offset = $timeZone.GetUtcOffset($(Get-Date)).TotalMinutes #Daylight saving needs to be calculated
    $localTime = $utcTime.AddMinutes($offset)     # Return local time,
      
    $decodedToken | Add-Member -Type NoteProperty -Name "expiryDateTime" -Value $localTime
      
    # Time to Expiry
    $timeToExpiry = ($localTime - (get-date))
    $decodedToken | Add-Member -Type NoteProperty -Name "timeToExpiry" -Value $timeToExpiry
  
    return $decodedToken
}


Function Connect-HPEGL { 
    <#
    .SYNOPSIS
    Initiates a connection to the HPE GreenLake platform and to all available Compute Ops Management instances within the specified workspace.
    
    .DESCRIPTION
    This cmdlet initiates and manages your connection to the HPE GreenLake platform. Upon successful connection, it creates a persistent session for all subsequent module cmdlet requests through the ${Global:HPEGreenLakeSession}` connection tracker variable. 
    Additionally, the cmdlet generates temporary API client credentials for both HPE GreenLake and any Compute Ops Management service instances provisioned in the workspace.
    
    The global variable `$HPEGreenLakeSession` stores session information, API client credentials, API access tokens, and other relevant details for both HPE GreenLake and Compute Ops Management APIs.
    
    To use this cmdlet, you need an HPE Account. If you do not have an HPE Account, you can create one at https://common.cloud.hpe.com.
    
    Note: To learn how to create an HPE account, see https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&page=GUID-497192AA-FDC2-49C5-B572-0D2F58A23745.html
    
    Note: To interact with an HPE GreenLake workspace and a Compute Ops Management instance using this library, you must have at least the 'Observer' role for both 'HPE GreenLake Platform' and 'Compute Ops Management' service managers. 
          This role grants view-only privileges. For modification capabilities, you need either the 'Operator' (view and edit privileges) or the 'Administrator' (view, edit, and delete privileges) role. 
          Alternatively, you can create a custom role that meets your specific access requirements.
    
    Note: This library supports both single-factor authentication and multi-factor authentication (MFA) using Google Authenticator or Okta Verify. 
          To use MFA, ensure that the Okta Verify or Google Authenticator app is installed on your mobile device and properly linked to your account before initiating the connection process. 
          MFA with security keys or biometric authenticators is not supported. 
          - If your HPE GreenLake account is configured to use only security keys or biometric authenticators for MFA, you must enable either Google Authenticator or Okta Verify in your account settings to use this library.
          - For accounts with Google Authenticator enabled, you will be prompted to enter the verification code. 
          - For accounts with Okta Verify enabled, you will need to approve the push notification on your phone.
          - If both Google Authenticator and Okta Verify are enabled, the library defaults to using Okta Verify push notifications.
    
    Note: This library supports SAML Single Sign-On (SSO) but exclusively with Okta. 
          To use SSO, ensure that the Okta Verify app is installed on your mobile device and properly linked to your account before initiating the connection process. 
          Users leveraging SAML SSO through other identity providers cannot authenticate directly using their corporate credentials with the `Connect-HPEGL` cmdlet. 
          As a workaround, invite a user with an email address that is not associated with any SAML SSO domains configured in the workspace. 
          This can be done via the HPE GreenLake GUI under `User Management` by selecting `Invite Users`. Assign the HPE GreenLake Account Administrator role to the invited user. 
          Once the invitation is accepted, the user can set a password and use these credentials to log in with `Connect-HPEGL`.
    
    Note: You do not need an existing HPE GreenLake workspace to connect. You can create a new workspace after your first connection using the 'New-HPEGLWorkspace' cmdlet.
    
    .PARAMETER Credential 
    Set of security credentials such as a username and password to establish a connection to HPE GreenLake.
    
    .PARAMETER SSOEmail
    Specifies the email address used for Single Sign-On (SSO) authentication. 
    
    .PARAMETER Workspace 
    Specifies the name of a workspace available in HPE GreenLake that you want to connect to.
    
    - You can omit this parameter if no workspaces have been created in HPE GreenLake yet.
    - If you have only one workspace in HPE GreenLake, you can omit this parameter, and the cmdlet will automatically connect to the available workspace.
    - If you have multiple workspaces and are unsure of the workspace name you want to connect to, you can omit this parameter. After connecting to HPE GreenLake, use the 'Get-HPEGLWorkspace' cmdlet to list and identify the available workspaces.
    
    .INPUTS
    None. You cannot pipe objects to this cmdlet.
    
    .OUTPUTS
    HPEGreenLakeSession
    
    When a valid connection is established with the HPE GreenLake platform, several properties are added to the 
    `${Global:HPEGreenLakeSession}` connection tracker variable. The object returned will contain the following public properties:
            
         ====================================================================================================================
         | Name                      | Type               | Value                                                           |
         --------------------------------------------------------------------------------------------------------------------
         | session                   | WebrequestSession  | Web request session object                                      | 
         --------------------------------------------------------------------------------------------------------------------
         | oauth2AccessToken         | String             | OAuth2 access token                                             | 
         --------------------------------------------------------------------------------------------------------------------
         | oauth2IdToken             | String             | OAuth2 ID Token                                                 |
         --------------------------------------------------------------------------------------------------------------------
         | oauth2RefreshToken        | String             | OAuth2 refresh token                                            |
         --------------------------------------------------------------------------------------------------------------------
         | userName                  | String             | Username used for authentication                                |
         --------------------------------------------------------------------------------------------------------------------
         | name                      | String             | Name of the user used for authentication                        |
         --------------------------------------------------------------------------------------------------------------------
         | workspaceId               | String             | Workspace ID                                                    |
         --------------------------------------------------------------------------------------------------------------------
         | workspace                 | String             | Workspace name                                                  |
         --------------------------------------------------------------------------------------------------------------------
         | workspacesCount           | Integer            | Number of available workspaces                                  |
         --------------------------------------------------------------------------------------------------------------------
         | oauth2TokenCreation       | Datetime           | OAuth2 token creation time                                      |
         --------------------------------------------------------------------------------------------------------------------
         | oauth2TokenCreationEpoch  | String             | Unix timestamp of OAuth2 token creation                         |    
         --------------------------------------------------------------------------------------------------------------------
         | userSessionIdleTimeout    | String             | User session idle timeout in minutes                            |    
         --------------------------------------------------------------------------------------------------------------------
         | apiCredentials            | ArrayList          | List of API client credentials created during the session       |
         --------------------------------------------------------------------------------------------------------------------
         | glpApiAccessToken         | String             | GreenLake API access token                                      |    
         --------------------------------------------------------------------------------------------------------------------
         | comApiAccessToken         | ArrayList          | List of COM API access tokens                                   |    
         --------------------------------------------------------------------------------------------------------------------
         | ccsSid                    | String             | CCS API session ID                                              |    
         --------------------------------------------------------------------------------------------------------------------
         | onepassSid                | String             | HPE Onepass API session ID                                      |    
         ====================================================================================================================
    
    API client credentials are stored in `${Global:HPEGreenLakeSession.apiCredentials}` and contains the following properties:
         
         ====================================================================================================================
         | Name                       | Type               | Value                                                           |
         --------------------------------------------------------------------------------------------------------------------
         | name                       | String             | Name of the API Client credential                               | 
         --------------------------------------------------------------------------------------------------------------------
         | workspace_name             | String             | Name of the workspace                                           | 
         --------------------------------------------------------------------------------------------------------------------
         | workspace_id               | String             | ID of the workspace                                             |
         --------------------------------------------------------------------------------------------------------------------
         | application_name           | String             | Name of the service                                             |
         --------------------------------------------------------------------------------------------------------------------
         | region                     | String             | Name of the region where the service is provisioned             |
         --------------------------------------------------------------------------------------------------------------------
         | application_instance_id    | String             | ID of the service instaance                                     |
         --------------------------------------------------------------------------------------------------------------------
         | secure_client_secret       | SecureString       | Encrypted client secret of the API client credential            |
         --------------------------------------------------------------------------------------------------------------------
         | client_id                  | String             | Client ID of the API client credential                          |
         --------------------------------------------------------------------------------------------------------------------
         | connectivity_endpoint      | String             | Connectivity endpoint of the API                                |
         ====================================================================================================================
    
    API access tokens are stored in the following global variables:
     - ${Global:HPEGreenLakeSession.comApiAccessToken} 
     - ${Global:HPEGreenLakeSession.glpApiAccessToken}
    
     The tokens contain the following properties:
         
         ====================================================================================================================
         | Name                       | Type               | Value                                                           |
         --------------------------------------------------------------------------------------------------------------------
         | name                       | String             | Name of the API Client credential                               | 
         --------------------------------------------------------------------------------------------------------------------
         | access_token               | String             | Access token of the API client credential                       |
         --------------------------------------------------------------------------------------------------------------------
         | expires_in                 | String             | Time in seconds until the token expires                         |
         --------------------------------------------------------------------------------------------------------------------
         | creation_time              | Datetime           | Date and time of when the token was created                     |
         ====================================================================================================================
    .EXAMPLE
    Connect-HPEGL  
    
    Connect to HPE GreenLake when you have not yet created any workspace. The user will be prompted for their username and password.
    
    In this example, no parameters are passed to the `Connect-HPEGL` cmdlet, which will prompt the user for their HPE GreenLake username and password. 
    This is useful when connecting to HPE GreenLake for the first time or when no workspace exists yet.
    
    If there is only one workspace available, the cmdlet will automatically connect to that workspace. 
    
    If multiple workspaces exist, the user can use the `Get-HPEGLWorkspace` cmdlet once connected to retrieve the workspace names and then specify the desired workspace to connect to using 'Connect-HPEGLWorkspace -Name <WorkspaceName>'.
    
    .EXAMPLE
    $Username = "Sean@gmail.com"
    $Secpasswd = read-host "Please enter your HPE GreenLake password" -AsSecureString
    $Credentials = New-Object System.Management.Automation.PSCredential ($Username, $Secpasswd)
    Connect-HPEGL -Credential $Credentials 
    
    Connect the user Sean@gmail.com to HPE GreenLake using a PSCredential object. 
    
    In this example, the username and password are collected first, and then a PSCredential object is created. The credential object is subsequently passed to the `Connect-HPEGL` cmdlet to establish the connection.
    
    .EXAMPLE
    Connect-HPEGL -Credential $Credentials -Workspace "My_workspace_name" 
    
    Connect the user Sean@gmail.com to an existing workspace named "My_workspace_name" in HPE GreenLake using a PSCredential object. 
    Temporary HPE GreenLake and COM API client credentials are generated in the newly connected 'My_workspace_name' workspace.
    '$HPEGreenLakesession' is updated with the new API credentials and workspace details.
    
    Here, the previously created PSCredential object is used again, but this time with an additional `-Workspace` parameter to specify which workspace in HPE GreenLake to connect to.
    
    .EXAMPLE
    $GLP_Username = "lio@domain.com"
    $GLP_EncryptedPassword = "...01000000d08c9ddf0115d1118c7a00c04fc297eb01000000ea1f94d2f2dc2b40af7a0adaeeae84b1f349432b32a730af3b80567e2378c570b3a111d627d70ac9eb6f281..."
    $GLP_SecurePassword = ConvertTo-SecureString $GLP_EncryptedPassword
    $credentials = New-Object System.Management.Automation.PSCredential ($GLP_Username, $GLP_SecurePassword)
    
    Connect-HPEGL -Credential $credentials -Workspace "HPE Workspace" 
    
    Connect the user lio@domain.com to an existing workspace named "HPE Workspace" using an encrypted password.
    
    In this example, the secure password string is first converted to a SecureString, and then a PSCredential object is created using an encrypted password and username. This credential object is then used to connect to a specific workspace named "HPE Workspace".
    
    Using an encrypted password like $GLP_EncryptedPassword in a script enhances security by preventing unauthorized access to plaintext credentials, and follows best practices for secure coding. It also reduces the risk of human error and accidental exposure during code sharing or review processes.
    
    To generate an encrypted password, you can use:
    ConvertTo-SecureString -String "<Your_HPE_GreenLake_Password>" -AsPlainText -Force |  ConvertFrom-SecureString 
    
    .EXAMPLE
    Connect-HPEGL -Credential $credentials
    
    # Get the list of available workspaces
    Get-HPEGLWorkspace 
    
    # Connect to a specific workspace from the list of workspaces
    Connect-HPEGLWorkspace -Name "<WorkspaceName>"
    
    This example demonstrates how to connect to the HPE GreenLake platform using provided credentials, retrieve the list of available workspaces, and then connect to a specific workspace when the workspace name is unknown.
    
    .EXAMPLE
    Connect-HPEGL -SSOEmail "firstname.lastname@hpe.com" -Workspace "My_workspace_name" 
    
    This example demonstrates how to connect to HPE GreenLake using Single Sign-On (SSO) with an email address.
    The user will be prompted to approve the push notification on their phone for authentication.
    If the workspace name is specified, the cmdlet will connect to the specified workspace.
    If no workspace name is provided, the cmdlet will connect to the default workspace associated with the user's account.
    
    .LINK
    If you do not have an HPE Account, you can create one at https://common.cloud.hpe.com.
    
    To learn how to create an HPE account, see https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&page=GUID-497192AA-FDC2-49C5-B572-0D2F58A23745.html
    
    #>
    [CmdletBinding(DefaultParameterSetName = 'Credential')]
    param (
        [Parameter(Mandatory, ParameterSetName = 'Credential')]
        [Alias('PSCredential')]
        [PSCredential]$Credential,
    
        [Parameter(Mandatory = $true, ParameterSetName = 'SSO')]
        [string]$SSOEmail,
    
        [Parameter(Mandatory = $False)]        
        [ValidateNotNullOrEmpty()]
        [String]$Workspace
            
    )
    
    Begin {
            
        $Caller = (Get-PSCallStack)[1].Command
      
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        # Display the currently loaded version of the HPECOMCmdlets module
        "[{0}] Currently loaded HPECOMCmdlets module version: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPECOMCmdletsModuleVersion | Write-Verbose
    
        # Get the PowerShell version
        $PSversion = $PSVersionTable.PSVersion.ToString().Split('.')[0]
    
        if ($PSVersionTable.PSVersion.Major -lt 7) {
            # If the PowerShell version is 5, display an error message and exit
            if ($PSVersion -eq 5) {
                Write-Error "This module requires PowerShell version 7 or higher. PowerShell version 5 is no longer supported. Please upgrade your PowerShell version to continue using this module."
                Break
            }
            else {
                # If the PowerShell version is less than 7, display an error message and exit
                Write-Error "This module requires PowerShell version 7 or higher. Please upgrade your PowerShell version to continue using this module."
                Break
            }
        }

        # Changing default TLS to 1.2 from 1.0
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                       
        # Cleaning up any HPECOMCmdlets variables in the session
    
        # Remove $HPEGreenLakeSession global variable
        if ($HPEGreenLakeSession) {
    
            "[{0}] Global variable `$HPEGreenLakeSession detected in session" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Remove-Variable HPEGreenLakeSession -Scope Global
            "[{0}] Global variable `$HPEGreenLakeSession removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        }
            
        # Clear all HPEGL global variables
        if (Get-Variable -Scope global | Where-Object name -match HPEGL) {
    
            Get-Variable -Scope global | Where-Object name -match HPEGL | Remove-Variable -Force -Scope Global
            "[{0}] All global variable starting with HPEGL have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        }
            
        # Clear all HPECOM global variables
        if (Get-Variable -Scope global | Where-Object name -match HPECOM) {
    
            Get-Variable -Scope global | Where-Object name -match HPECOM | Remove-Variable -Force -Scope Global
            "[{0}] All global variable starting with HPECOM have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        }
            
        "[{0}] About to test DNS resolution and TCP connection with all HPE GreenLake endpoints" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        # 1 - Test DNS resolution
    
        $CCServer = $ccsSettingsUrl.Authority
        
        Test-EndpointDNSResolution $CCServer
    
        # 2 - Test TCP connection: common.cloud.hpe.com
    
        Test-EndpointTCPConnection $CCServer
            
        # 3 - Retrieve HPE GreenLake Common Cloud Services Settings and set global variables
            
        $response = Invoke-RestMethod $ccsSettingsUrl -Method 'GET' 
        "[{0}] Response content of GET '{1}' request: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSettingsUrl, $response | Write-Verbose
            
        [uri]$Global:HPEGLauthorityURL = $response.authorityURL
        "[{0}] HPEGLauthorityURL variable set: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLauthorityURL | Write-Verbose
            
        New-Variable -Name HPEGLoktaURL -Scope Global -Value $response.oktaURL -Option ReadOnly -ErrorAction SilentlyContinue -Force
        "[{0}] HPEGLoktaURL variable set: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLoktaURL | Write-Verbose
    
        New-Variable -Name HPEGLclient_id -Scope Global -Value $response.client_id -Option ReadOnly -ErrorAction SilentlyContinue -Force
        "[{0}] HPEGLclient_id variable set: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLclient_id | Write-Verbose
            
        # 4 - Test TCP connection: sso.common.cloud.hpe.com
    
        $SsoServer = $HPEGLauthorityURL.Authority 
    
        Test-EndpointTCPConnection $SsoServer      
    
        # 5 - Test TCP connection: auth.hpe.com
    
        $AuthServer = ([uri]$HPEGLoktaURL).Authority
    
        Test-EndpointTCPConnection $AuthServer
        
        # 6 - Test TCP connection: aquila-user-api.common.cloud.hpe.com
    
        $AquilaServer = ([uri]$HPEGLUIbaseURL).Authority
            
        Test-EndpointTCPConnection $AquilaServer
    
        # 7 - Test TCP connection: onepass-enduserservice.it.hpe.com
    
        $OnepassServer = ([uri]$SchemaMetadataURI).Authority
            
        Test-EndpointTCPConnection $OnepassServer
    
        # 8 - Decrypt credential password
    
        if ($psCmdlet.ParameterSetName -eq 'Credential') {
            $Username = $Credential.UserName
            $decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password))
        }
        else {
            $Username = $SSOEmail 
        }
                
        # 9 - Get Compute GMT time difference in hours
    
        $GMTTimeDifferenceInHour = Get-GMTTimeDifferenceInHours
        $Global:HPEGLGMTTimeDifferenceInHour = $GMTTimeDifferenceInHour 
    
        "[{0}] Global varibale `$HPEGLGMTTimeDifferenceInHour set to store compute time difference in hours with the GMT timezone" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            
            
    }
    
    Process { 
    
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
    
        # Define the total number of operations/steps
        $totalSteps = 8
    
        # Initialize a counter for completed steps
        $completedSteps = 0
    
        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id
            )
    
            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Connecting to HPE GreenLake, please wait..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -Id $Id
        }
    
           
        #-----------------------------------------------------------Authentication to HPE GreenLake Common Cloud Services-----------------------------------------------------------------------------
    
        #Region [STEP 1] Get HPE GreenLake Common Cloud Services Authorization endpoint: GET https://sso.common.cloud.hpe.com/.well-known/openid-configuration
    
        $url = $HPEGLauthorityURL.OriginalString + $OpenidConfiguration
    
        "`n[{0}] ------------------------------------- STEP 1 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 1 / 8" -Id 0
    
        "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
    
        try {
            $response = Invoke-RestMethod $url -Method 'GET' 
    
            $authEndpoint = $response.authorization_endpoint 
            $Global:HPEGLtokenEndpoint = $response.token_endpoint
            "[{0}] HPE GreenLake Common Cloud Services Authorization endpoint: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $authEndpoint | Write-Verbose
    
        }
        catch {
            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
            $PSCmdlet.ThrowTerminatingError($PSitem)
    
        }
    
        $completedSteps++
        #EndRegion
    
        #Region [STEP 2] Generate PKCE code verifier and code challenge
            
        "`n[{0}] ------------------------------------- STEP 2 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 8" -Id 0
        "[{0}] Generating PKCE code verifier and code challenge" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
        $pkceTemplate = [pscustomobject][ordered]@{  
            code_verifier  = $null  
            code_challenge = $null   
        }  
    
        $codeVerifier = -join (((48..57) * 4) + ((65..90) * 4) + ((97..122) * 4) | Get-Random -Count 128 | ForEach-Object { [char]$_ })
    
        $hashAlgo = [System.Security.Cryptography.HashAlgorithm]::Create('sha256')
        $hash = $hashAlgo.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($codeVerifier))
        $b64Hash = [System.Convert]::ToBase64String($hash)
        $code_challenge = $b64Hash.Substring(0, 43)
          
        $code_challenge = $code_challenge.Replace("/", "_")
        $code_challenge = $code_challenge.Replace("+", "-")
        $code_challenge = $code_challenge.Replace("=", "")
    
        $pkceChallenges = $pkceTemplate.PsObject.Copy()
        $pkceChallenges.code_challenge = $code_challenge
        $pkceChallenges.code_verifier = $codeVerifier 
    
        $codeChallenge = $pkceChallenges.code_challenge
        $codeVerifier = $pkceChallenges.code_verifier
    
        "[{0}] Code verifier: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $codeVerifier | Write-Verbose
        "[{0}] Code challenge: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $codeChallenge | write-Verbose
       
    
    
        $completedSteps++
    
        #EndRegion
    
        #Region [STEP 3] Get statetoken using code challenge to https://sso.common.cloud.hpe.com/as/authorization.oauth2?client_id=aquila-user-auth&redirect_uri=https://common.cloud.hpe.com/authentication/callback&response_type=code&scope=openid%20profile%20email&code_challenge=XXXXXXXXXXXX&code_challenge_method=S256  
        "`n[{0}] ------------------------------------- STEP 3 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 3 / 8" -Id 0
            
        $headers = @{} 
        $headers["Content-Type"] = "application/json"
    
        $ccsRedirecturi = 'https://common.cloud.hpe.com/authentication/callback'

        # $url = "{0}?client_id={1}&redirect_uri={2}&response_type=code&scope=openid%20profile%20email&code_challenge={3}&code_challenge_method=S256" -f $authEndpoint, $HPEGLclient_id, $encodedRedirectUri, $codeChallenge
            
        $queryParams = @{
            client_id             = $HPEGLclient_id
            redirect_uri          = $ccsRedirecturi
            # redirect_uri          = $encodedRedirectUri
            response_type         = "code"
            scope                 = "openid profile email"
            code_challenge        = $codeChallenge
            code_challenge_method = "S256"
        }
            
        # Build the query string
        $queryString = ($queryParams.GetEnumerator() | ForEach-Object { "$($_.Key)=$($_.Value)" }) -join "&"
    
        # Combine the base URL with the query string
        $url = "$($authEndpoint)?$($queryString)"
    
        "[{0}] About to execute GET request to: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $authEndpoint | Write-Verbose
        "[{0}] Using the query parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($queryParams | Out-String) | Write-Verbose
           
    
        do {  
        
            try {
                $response = Invoke-webrequest $url -Method 'GET' -Headers $headers -SessionVariable 'Session' 
               
            }
            catch {
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
      
            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $response.StatusDescription | Write-verbose
            # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
    
            # Capturing state token
            $stateToken = ($response.tostring() -split "[`r`n]" | select-string -Pattern '(?:"stateToken":")(.*?)(?:")').Matches | ForEach-Object { $_.groups[1].Value }
            # Start-Sleep -Milliseconds 500
    
            if ($stateToken.Contains("\")) {
    
                "[{0}] State token [not compatible](contains '\'): '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $stateToken | Write-Verbose
            }
            else {
    
                "[{0}] State token [compatible]: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $stateToken | Write-Verbose
    
            }
    
        } until ( -not $stateToken.Contains("\") )
    
        $cookies = $Session.Cookies.GetCookies($url)
        if ($cookies.Count -eq 0) {
            "[{0}] No cookies found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        }
        else {
            "[{0}] Cookies found in the response headers for '{1}':" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
            foreach ($cookie in $cookies) { 
                "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
            }
        }
         
    
        $completedSteps++
    
        #EndRegion
    
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        #Region [STEP 4] Collecting user webfinger information: GET https://auth.hpe.com/.well-known/webfinger?resource=acct:email@domain.com
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
    
        # This endpoint is used to check if the user is using SAML2 for the authentication, typically used by hpe.com email accounts.
        # The SAML2 type is important for determining the authentication method to use in the next step.
               
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        "[{0}] [STEP 4] Collecting user webfinger information" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
    
    
        "[{0}] Collecting webfinger information for the user: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $userName | Write-Verbose
    
        $url = $HPEGLoktaURL + "/.well-known/webfinger?resource=acct:" + $userName + "&requestContext=" + $stateToken
            
        "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
    
        try {
            $responseWebFinger = Invoke-RestMethod -Uri $url -Method 'GET' -ErrorAction Stop -WebSession $session
            "[{0}] User information retrieved successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] Raw response for `$responseWebFinger: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseWebFinger | Out-String) | Write-verbose
        }
        catch {
            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to retrieve user information" -Completed
            $PSCmdlet.ThrowTerminatingError($_)
        }       
    
        $cookies = $Session.Cookies.GetCookies($url)
        if ($cookies.Count -eq 0) {
            "[{0}] No cookies found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        }
        else {
            "[{0}] Cookies found in the response headers for '{1}':" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
            foreach ($cookie in $cookies) { 
                "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
            }
        }
    
        $Idp = $responseWebFinger.links[0].rel
        "[{0}] Extracted IdP for the user '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $userName, $Idp | Write-Verbose
            
        $OktaIDPType = $responseWebFinger.links[0].properties.'okta:idp:type'   
        "[{0}] Extracted protocol used by the IdP for authentication: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $OktaIDPType | Write-Verbose 
            
        $href = $responseWebFinger.links[0].href
        "[{0}] Extracted SSO endpoint for the IdP associated with the user: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
    
        #EndRegion
    
        if ($PSBoundParameters.ContainsKey('SSOEmail')){
            
            "[{0}] SSO authentication detected. Checking SSO authentication type..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            # If the user is using SSO authentication, we need to check if the user is using Okta-managed SAML2 authentication or HPE-managed OIDC authentication.
            ######################################################## OKTA IdP ############################################################################################################################
            if ($Idp -eq "okta:idp" -and $OktaIDPType -eq "SAML2") {
        
                "[{0}] Identity Provider detected: Okta-managed using SAML2." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] Proceeding with SAML2 authentication with Okta." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.1] Redirect to stateToken URL: GET https://auth.hpe.com/sso/idps/xxxxxx?stateToken=xxxxxxxx&login_hint=email%40domain.com#
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.1] Redirect to stateToken URL" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
                "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                    
                try {
                    $responseStep41 = Invoke-webrequest $href -Method 'GET' -ErrorAction Stop -WebSession $session
                    "[{0}] SAML2 IDP response received successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    # "[{0}] Raw response for `$responseStep41: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseStep41.content | Out-String) | Write-verbose
                }
                catch {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to retrieve SAML2 IDP information" -Completed
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
                $cookies = $Session.Cookies.GetCookies($href)
                if ($cookies.Count -eq 0) {
                    "[{0}] No cookies found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
                else {
                    "[{0}] Cookies found in the response headers for '{1}':" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                    foreach ($cookie in $cookies) { 
                        "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
                    }
                }
        
        
                # Get action, method, relayState, LoginHint and SAMLRequest values from the html response
                $encodedaction = ($responseStep41.content | Select-String -Pattern '(?<=action=")(.*?)(?=")' -AllMatches).Matches | ForEach-Object { $_.groups[1].Value }
                $action = [System.Web.HttpUtility]::HtmlDecode($encodedaction)
                "[{0}] Extracted Action: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $action | Write-Verbose
                    
                $method = ($responseStep41.content | Select-String -Pattern '(?<=method=")(.*?)(?=")' -AllMatches).Matches | ForEach-Object { $_.groups[1].Value }
                "[{0}] Extracted Method: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $method | Write-Verbose
                    
                $LoginHint = ($responseStep41.content | Select-String -Pattern '(?<=name="LoginHint" type="hidden" value=")(.*?)(?=")' -AllMatches).Matches | ForEach-Object { $_.groups[1].Value }
                $LoginHint = [System.Web.HttpUtility]::HtmlDecode($LoginHint)
                "[{0}] Extracted LoginHint: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $LoginHint | Write-Verbose
                    
                $encodedRelayState = ($responseStep41.content | Select-String -Pattern '(?<=name="RelayState" type="hidden" value=")(.*?)(?=")' -AllMatches).Matches | ForEach-Object { $_.groups[1].Value }
                $RelayState = [System.Web.HttpUtility]::HtmlDecode($encodedRelayState)
                "[{0}] Extracted RelayState: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RelayState | Write-Verbose
                $decodeRelayState = [System.Web.HttpUtility]::UrlDecode($RelayState)
                "[{0}] Decoded RelayState: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $decodeRelayState | Write-Verbose
        
        
                # Extract the SAMLRequest value from the HTML response
                $encodedSAMLRequest = ($responseStep41.Content -join "`n" | Select-String -Pattern 'name="SAMLRequest" type="hidden" value="([^"]+)"' -AllMatches).Matches | ForEach-Object { $_.Groups[1].Value }
                # "[{0}] Extracted Encoded SAMLRequest: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $encodedSAMLRequest | Write-Verbose
        
                $SAMLRequest = [System.Web.HttpUtility]::HtmlDecode($encodedSAMLRequest)
                "[{0}] Extracted Decoded SAMLRequest: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SAMLRequest | Write-Verbose
        
                # Decode base64
                try {
                    $byteArray = [System.Convert]::FromBase64String($SAMLRequest)
        
                    # Check if deflated (zlib)
                    if ($byteArray.Length -gt 1 -and $byteArray[0] -eq 0x78 -and $byteArray[1] -eq 0x9C) {
                        # Decompress using zlib
                        $memoryStream = New-Object System.IO.MemoryStream(, $byteArray)
                        $deflateStream = New-Object System.IO.Compression.DeflateStream($memoryStream, [System.IO.Compression.CompressionMode]::Decompress)
                        $decompressedStream = New-Object System.IO.MemoryStream
                        $deflateStream.CopyTo($decompressedStream)
                        $decompressedBytes = $decompressedStream.ToArray()
                        $xmlString = [System.Text.Encoding]::UTF8.GetString($decompressedBytes)
                    }
                    else {
                        # Not deflated, just convert to string
                        $xmlString = [System.Text.Encoding]::UTF8.GetString($byteArray)
                    }
        
                    # "[{0}] Decoded SAMLRequest:: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $xmlString | Write-Verbose
        
                    # Parse XML with namespace handling
                    try {
                        $xml = [xml]$xmlString
        
                        # Set up namespace manager
                        $nsManager = New-Object System.Xml.XmlNamespaceManager($xml.NameTable)
                        $nsManager.AddNamespace("saml2p", "urn:oasis:names:tc:SAML:2.0:protocol")
                        $nsManager.AddNamespace("saml2", "urn:oasis:names:tc:SAML:2.0:assertion")
                        $nsManager.AddNamespace("ds", "http://www.w3.org/2000/09/xmldsig#")
        
                        # Select the AuthnRequest node
                        $authnRequest = $xml.SelectSingleNode("//saml2p:AuthnRequest", $nsManager)
                        if ($authnRequest) {
                            $destination = $authnRequest.GetAttribute("Destination")
                            $acsUrl = $authnRequest.GetAttribute("AssertionConsumerServiceURL")
                            $issuerNode = $xml.SelectSingleNode("//saml2:Issuer", $nsManager)
                            $issuer = if ($issuerNode) { $issuerNode.InnerText } else { $null }
        
                            '[{0}] XML Decoded SAMLRequest Destination: {1}' -f $MyInvocation.InvocationName.ToString().ToUpper(), $destination | Write-Verbose
                            '[{0}] XML Decoded SAMLRequest AssertionConsumerServiceURL: {1}' -f $MyInvocation.InvocationName.ToString().ToUpper(), $acsUrl | Write-Verbose
                            '[{0}] XML Decoded SAMLRequest Issuer: {1}' -f $MyInvocation.InvocationName.ToString().ToUpper(), $issuer | Write-Verbose
        
                            # IdP Detection Logic
                            $idpType = "unknown"
                            if ($destination -match "okta\.com" -or $destination -match "mylogin\.hpe\.com" -or $issuer -match "okta\.com") {
                                $idpType = "okta"
                            }
                            elseif ($destination -match "microsoftonline\.com" -or $destination -match "windows\.net") {
                                $idpType = "azure"
                            }
                            elseif ($destination -match "google\.com") {
                                $idpType = "google"
                            }
                            elseif ($destination -match "pingidentity\.com" -or $destination -match "sso\..*?\.com") {
                                $idpType = "pingfederate"
                            }
        
                            "[{0}] Detected IdP: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $idpType | Write-Verbose
        
                        }
                        else {
                            Write-Host "Error: Could not find saml2p:AuthnRequest node."
                        }
        
                    }
                    catch {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to retrieve user information" -Completed
                        Throw "Error parsing XML: $_`nRaw XML String for debugging:`n$xmlString"
                    }
        
                }
                catch {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to retrieve user information" -Completed
                    Throw "Error decoding base64: $_`nRaw SAMLRequest: $SAMLRequest"
                }
        
                #EndRegion    
        
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.2] SAML Authentication Request Submission: POST request to: 'https://mylogin.hpe.com/app/hpe_211366workforceuserauthentication_1/exk95g22w0a0gbCGg697/sso/saml2?RelayState=...&SAMLRequest=...&LoginHint=...'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.2] SAML Authentication Request Submission" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
                "[{0}] About to execute {1} request to: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $method, $action | Write-Verbose
        
        
                # Define the payload
                $payload = @{
                    'SAMLRequest' = $SAMLRequest
                    'LoginHint'   = $LoginHint
                    'RelayState'  = $decodeRelayState
                } 
                    
                $payload = ($payload.GetEnumerator() | ForEach-Object { "$($_.Key)=$([System.Web.HttpUtility]::UrlEncode($_.Value))" }) -join "&"
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose
        
        
                # Define the headers
                $headers = @{
                    "Content-Type" = "application/x-www-form-urlencoded"
                }
        
                # Decode SAMLRequest for ID extraction
                $decodedSAMLRequest = $null
                if ($SAMLRequest -match '^[A-Za-z0-9+/=]+$') {
                    try {
                        $decodedSAMLRequest = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($SAMLRequest))
                        "[{0}] Decoded SAMLRequest: `n'{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $decodedSAMLRequest | Write-Verbose
                    }
                    catch {
                        "[{0}] ERROR: Failed to decode SAMLRequest: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.Message | Write-Verbose
                    }
                }
                else {
                    "[{0}] WARNING: SAMLRequest is not base64-encoded: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SAMLRequest | Write-Verbose
                    $decodedSAMLRequest = $SAMLRequest  # Assume it's already decoded
                }
        
                try {
                    $responseStep42 = Invoke-WebRequest -Uri $action -Method $method -ErrorAction Stop -Headers $headers -Body $payload -WebSession $Session 
                    "[{0}] SAML2 IDP response received successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        
                    # Extract AuthnRequest ID from decoded SAMLRequest
                    $authnRequestId = ($decodedSAMLRequest | Select-String -Pattern 'ID="([^"]+)"' | ForEach-Object { $_.Matches.Groups[1].Value })
                    if ($authnRequestId) {
                        "[{0}] Step 6 AuthnRequest ID: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $authnRequestId | Write-Verbose
                    }
                    else {
                        "[{0}] WARNING: No AuthnRequest ID found in SAMLRequest!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
                    
                    "[{0}] Step 6 Cookies:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    foreach ($cookie in $Session.Cookies.GetCookies($action)) {
                        "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.Name, $cookie.Value | Write-Verbose
                    }
                        
                    # "[{0}] Step 6 Response Content: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep42.Content | Write-Verbose
        
                }
                catch {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "SAML2 IDP response failed to process." -Completed
                    "[{0}] SAML2 IDP response failed to process: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.Message | Write-Verbose
                    "[{0}] Exception details: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_.Exception | Out-String) | Write-Verbose
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                    
                
                # Extract stateToken from HTML and decode
                $stateToken = ($responseStep42.Content | Select-String -Pattern '"stateToken":"(.*?)"' | ForEach-Object { $_.Matches.Groups[1].Value })
                $stateToken = $stateToken -replace '\\x2D', '-'
                "[{0}] Decoded stateToken: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $stateToken | Write-Verbose
        
        
                # Extract oktaData using regex
                $oktaDataMatch = [regex]::Match($responseStep42, 'var oktaData = ({[\s\S]*?});')
        
                "[{0}] SAML2 okta DataMatch: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oktaDataMatch | Write-Verbose
        
                if ($oktaDataMatch.Success) {
                    $oktaDataString = $oktaDataMatch.Groups[1].Value
        
                    try {
                        # Clean up the matched oktaData string using .NET Regex to decode \xNN sequences
                        $oktaDataString = [System.Text.RegularExpressions.Regex]::Replace(
                            $oktaDataString,
                            '\\x([0-9A-Fa-f]{2})',
                            { param($match) [char][Convert]::ToInt32($match.Groups[1].Value, 16) }
                        )
        
                        # Remove invalid JavaScript function definitions
                        $oktaDataString = $oktaDataString -replace '"consent":{"cancel":function\s*\(\)\s*{[^}]*}}', '"consent":{"cancel":""}'
        
                        # Parse JSON into a PowerShell object
                        $oktaData = $oktaDataString | ConvertFrom-Json
        
                        "[{0}] Extracted oktaData: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oktaData | Write-Verbose
                                                                
                        $baseUrl = [System.Web.HttpUtility]::HtmlDecode($oktaData.signIn.baseUrl)
                        "[{0}] Extracted baseUrl: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $baseUrl | Write-Verbose
        
                    }
                    catch {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to extract oktaData" -Completed
                        "[{0}] Failed to extract oktaData from the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        $PSCmdlet.ThrowTerminatingError($_)
                    }
                }
                else {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to extract oktaData" -Completed
                    "[{0}] No oktaData found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
                $cookies = $Session.Cookies.GetCookies($action)
                if ($cookies.Count -eq 0) {
                    "[{0}] No cookies found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
                else {
                    "[{0}] Cookies found in the response headers for '{1}':" -f $MyInvocation.InvocationName.ToString().ToUpper(), $action | Write-Verbose
                    foreach ($cookie in $cookies) { 
                        "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
                    }
                }

                #EndRegion
                    
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.3] Authentication State Introspection: POST request to 'https://mylogin.hpe.com/idp/idx/introspect'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.3] Authentication State Introspection" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
                # baseUrl, stateToken is coming from previous request
                # baseUrl = https://auth.hpe.com
        
                $url = $baseUrl + "/idp/idx/introspect"
                $method = "POST"
                    
                "[{0}] About to execute {1} request to: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $method, $url | Write-Verbose
        
        
                # Define the payload
                $payload = @{
                    stateToken = $stateToken
                } | ConvertTo-Json -Depth 10
        
                # Define the headers
                $headers = @{
                    "Content-Type" = "application/json"
                }
                            
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | out-string) | Write-Verbose
        
                try {
                    $responseStep43 = Invoke-RestMethod -Uri $url -Method $Method -ErrorAction Stop -Headers $headers -Body $payload -WebSession $Session
                        
                    "[{0}] SAML2 IDP response received successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    # "[{0}] Raw response for `$responseStep43: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseStep43 | ConvertTo-Json -d 10) | Write-verbose
                    "[{0}] Response: remediation = `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseStep43.remediation.value[0].name) | Write-verbose
                }
                catch {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    "[{0}] SAML2 IDP response failed to validate the authentication state. Please verify the state token and try again." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
                $cookies = $Session.Cookies.GetCookies($url)
                if ($cookies.Count -eq 0) {
                    "[{0}] No cookies found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
                else {
                    "[{0}] Cookies found in the response headers for '{1}':" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                    foreach ($cookie in $cookies) { 
                        "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
                    }
                }
        
                
                $RemediationValues = $responseStep43.remediation.value 
                "[{0}] Remediation values: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RemediationValues | ConvertTo-Json -Depth 10) | Write-Verbose

                # Capturing challengeHref, authenticatorId, methodType, and stateHandle from $responseStep43
                $stateHandle = $responseStep43.stateHandle
                "[{0}] Extracted stateHandle: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $stateHandle | Write-Verbose
    
                $challengeHref = $responseStep43.remediation.value | Where-Object { $_.name -eq 'select-authenticator-authenticate' } | Select-Object -ExpandProperty href
                "[{0}] Extracted challengeHref: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $challengeHref | Write-Verbose

                $OktaVerify = ($responseStep43.remediation.value | Where-Object { $_.name -eq 'select-authenticator-authenticate' }).value | Where-Object { $_.name -eq 'authenticator' } | Select-Object -ExpandProperty options | Where-Object { $_.label -eq 'Okta Verify' }
                            
                if (-not $OktaVerify) {
                    "[{0}] ERROR: Okta Verify authenticator not found" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    throw "Okta Verify authenticator not found in response"
                }
                "[{0}] Found Okta Verify authenticator" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Get authenticatorId for Okta Verify 
                $authenticatorId = ($OktaVerify.value.form.value | Where-Object { $_.name -eq "id" }).value
                if (-not $authenticatorId) {
                    "[{0}] ERROR: authenticatorId not found for Okta Verify" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    throw "authenticatorId not found"
                }
                "[{0}] Extracted authenticatorId: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $authenticatorId | Write-Verbose

                # Get available methodType options
                $methodOptions = ($OktaVerify.value.form.value | Where-Object { $_.name -eq "methodType" }).options
                if (-not $methodOptions) {
                    "[{0}] ERROR: No methodType options found for Okta Verify" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    throw "No methodType options found for Okta Verify"
                }
                "[{0}] Available methodTypes: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($methodOptions.value -join ", ") | Write-Verbose

                # Select method: prefer push, fallback to totp
                $methodType = $null
                $pushOption = $methodOptions | Where-Object { $_.value -eq "push" }
                $totpOption = $methodOptions | Where-Object { $_.value -eq "totp" }

                if ($pushOption) {
                    $methodType = "push"
                    "[{0}] Selected methodType: push" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
                elseif ($totpOption) {
                    $methodType = "totp"
                    "[{0}] Push not available, selected methodType: totp" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
                else {
                    "[{0}] ERROR: Neither push nor totp available for Okta Verify" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    throw "Neither push nor totp available for Okta Verify"
                }
        
                #EndRegion
        
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.4] Send Okta Verify Authenticator Request: POST request to 'https://mylogin.hpe.com/idp/idx/challenge'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------

                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.4] Send Okta Verify Authenticator Request" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
    
                $method = "POST"
                    
                "[{0}] About to execute {1} request to: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $method, $challengeHref | Write-Verbose
        
                # Define the payload
                $payload = @{
                    stateHandle   = $stateHandle
                    authenticator = @{
                        id         = $authenticatorId
                        methodType = $methodType
                    }
                } | ConvertTo-Json -Depth 10
        
                # Define the headers
                $headers = @{
                    "Content-Type" = "application/json"
                }
                            
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | out-string) | Write-Verbose
        
                try {
                    $responseStep44 = Invoke-RestMethod -Uri $challengeHref -Method $Method -ErrorAction Stop -Headers $headers -Body $payload -WebSession $Session                
                    "[{0}] Okta Verify push notification sent successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    "[{0}] Raw response for `$responseStep44: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseStep44 | ConvertTo-Json -d 50) | Write-verbose
                }
                catch {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    "[{0}] Failed to send Okta Verify push notification. Please verify your email and try again." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
                $cookies = $Session.Cookies.GetCookies($challengeHref)
                if ($cookies.Count -eq 0) {
                    "[{0}] No cookies found in the response." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
                else {
                    "[{0}] Cookies found in the response headers for '{1}':" -f $MyInvocation.InvocationName.ToString().ToUpper(), $challengeHref | Write-Verbose
                    foreach ($cookie in $cookies) { 
                        "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
                    }
                }
        
                # Capturing stateHandle, pollHref (for push), verifyHref (for totp), and correctAnswer (for push number challenge)
                $stateHandle = $responseStep44.stateHandle
                "[{0}] Extracted stateHandle: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $stateHandle | Write-Verbose

                if ($methodType -eq "push") {
                    $pollHref = $responseStep44.remediation.value | Where-Object { $_.name -eq 'challenge-poll' } | Select-Object -ExpandProperty href
                    if (-not $pollHref) {
                        "[{0}] ERROR: No pollHref found for push authentication" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "No pollHref found in response for push authentication"
                    }
                    "[{0}] Extracted pollHref: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $pollHref | Write-Verbose

                    $correctAnswer = $responseStep44.currentAuthenticator.value.contextualData.correctAnswer
                    if ($correctAnswer) {
                        "[{0}] Extracted correctAnswer: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $correctAnswer | Write-Verbose
                    }
                    else {
                        "[{0}] No correctAnswer found (number challenge not required)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
                }
                elseif ($methodType -eq "totp") {
                    # Try to get verifyHref from remediation (e.g., challenge-authenticator)
                    $verifyHref = $responseStep44.remediation.value | Where-Object { $_.name -eq 'challenge-authenticator' } | Select-Object -ExpandProperty href
                    if (-not $verifyHref) {
                        # Fallback to challengeHref
                        $verifyHref = $challengeHref
                        "[{0}] No verifyHref found in response, falling back to challengeHref: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $verifyHref | Write-Verbose
                    }
                    else {
                        "[{0}] Extracted verifyHref: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $verifyHref | Write-Verbose
                    }
                }
                
                
                #EndRegion                
                
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.5] Verify Okta Verify Status: Handle Push or TOTP
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------

                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.5] Verify Okta Verify Status" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose

                # $methodType ("push" or "totp") comes from Step 4.3
                # $pollHref (push) or $verifyHref (totp) comes from Step 4.4
                # $challengeHref (from Step 4.3) is fallback for TOTP

                if ($methodType -eq "push") {
                    # Handle Push Notification
                    Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Check your phone for an Okta Verify push notification from HPE GreenLake" -Id 0

                    Start-Sleep -Seconds 2
                    $completedSteps++
                    if ($correctAnswer) {
                        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Respond '$correctAnswer' to the Okta Verify notification." -Id 0
                    }
                    else {
                        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Approve the Okta Verify push notification." -Id 0
                    }

                    if (-not $pollHref) {
                        "[{0}] ERROR: No poll URL provided for push authentication" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "No poll URL provided for push authentication. Check Step 4.4 response."
                    }

                    $timeout = [datetime]::Now.AddMinutes(2)
                    
                    "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $pollHref | Write-Verbose

                    $payload = @{
                        stateHandle = $stateHandle
                    } | ConvertTo-Json
                    
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose

                    do {
                        try {
                            $responseStep45 = Invoke-RestMethod -Uri $pollHref -Method POST -Body $payload -ContentType 'application/json' -ErrorAction Stop -WebSession $session
                            "[{0}] Okta Verify push notification poll response received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        }
                        catch {
                            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                            "[{0}] Failed to poll Okta Verify push status: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.Message | Write-Verbose
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        if ([datetime]::Now -ge $timeout) {
                            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                            throw "Connection error due to timeout! Okta Verify push verification did not succeed within 2 minutes."
                        }

                        Start-Sleep -Milliseconds 500

                    } until ( $responseStep45.success.name -eq "success-redirect" -or ($responseStep45.messages -and $responseStep45.messages.value -and $responseStep45.messages.value[0] -and $responseStep45.messages.value[0].class -eq "ERROR") )

                    if ($responseStep45.success.name -eq "success-redirect") {
                        "[{0}] Verification via Okta Verify push notification completed successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        $redirectUrl = $responseStep45.success.href
                        "[{0}] Redirect URL: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirectUrl | Write-Verbose
                    }
                    elseif ($responseStep45.messages.value[0].class -eq "ERROR") {
                        "[{0}] Verification via Okta Verify push notification failed." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        "[{0}] Error message: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep45.messages.value[0].message | Write-Verbose
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "Connection error! Unable to verify the status of the Okta Verify push notification. The notification was either rejected or an incorrect verification number was selected."
                    }
                }
                elseif ($methodType -eq "totp") {
                    # Handle TOTP
                    Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Open Okta Verify and enter the 6-digit code" -Id 0
                    Start-Sleep -Seconds 2
                    $completedSteps++
                    Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Waiting for Okta Verify code input" -Id 0

                    # Use $verifyHref from Step 4.4, fallback to $challengeHref
                    $verifyHref = if ($verifyHref) { $verifyHref } else { $challengeHref }
                    if (-not $verifyHref) {
                        "[{0}] ERROR: No verify URL available for TOTP (neither verifyHref nor challengeHref provided)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "No verify URL available for TOTP authentication. Check Step 4.4 and 4.3 responses."
                    }

                    "[{0}] Prompting user for Okta Verify TOTP code" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    $baseurlofVerifyHref = ($verifyHref -split '/')[2]
                    Write-Host "Please open Okta Verify and enter the 6-digit code of '$baseurlofVerifyHref' for '$UserName'"
                    $totpCode = Read-Host "Enter Okta Verify code"
                    
                    if ($totpCode -notmatch '^\d{6}$') {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        "[{0}] ERROR: Invalid TOTP code. Must be a 6-digit number." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        throw "Invalid TOTP code. Must be a 6-digit number."
                    }

                    $payload = @{
                        stateHandle = $stateHandle
                        credentials = @{
                            totp = $totpCode
                        }
                    } | ConvertTo-Json
                    
                    "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $verifyHref | Write-Verbose
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose

                    try {
                        $responseStep45 = Invoke-RestMethod -Uri $verifyHref -Method POST -Body $payload -ContentType 'application/json' -ErrorAction Stop -WebSession $session
                        "[{0}] Okta Verify TOTP verification response received." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
                    catch {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        "[{0}] Failed to verify Okta Verify TOTP code: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.Message | Write-Verbose
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($responseStep45.success.name -eq "success-redirect") {
                        "[{0}] Verification via Okta Verify TOTP completed successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        $redirectUrl = $responseStep45.success.href
                        "[{0}] Redirect URL: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirectUrl | Write-Verbose
                    }
                    elseif ($responseStep45.messages -and $responseStep45.messages.value -and $responseStep45.messages.value[0].class -eq "ERROR") {
                        "[{0}] Verification via Okta Verify TOTP failed." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        "[{0}] Error message: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep45.messages.value[0].message | Write-Verbose
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "Connection error! Unable to verify the Okta Verify TOTP code. The code was incorrect or expired."
                    }
                }

                "[{0}] Raw response for `$responseStep45: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseStep45 | ConvertTo-Json -Depth 50) | Write-Verbose

                # Capture user details
                "[{0}] Retrieving user details for the current session" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                $Name = ($responseStep45).user.value.profile.firstName + " " +  ($responseStep45).user.value.profile.lastName
                "[{0}] User name to save to the current session object: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose      


                $completedSteps++

                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Verification via Okta Verify ($methodType) completed successfully." -Id 0

                #EndRegion
                        
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.6] Acquire SAML response: GET request to 'https://mylogin.hpe.com/login/token/redirect?stateToken=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.6] Acquire SAML response" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
        
                # Step 4.6: Capture SAMLResponse
                "[{0}] Step 4.6 - About to GET SAMLResponse from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirectUrl | Write-Verbose
        
                try {
                    $responseStep46 = Invoke-WebRequest -Uri $redirectUrl -Method 'GET' -ErrorAction Stop -WebSession $session 
                    "[{0}] SAML response acquired successfully." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    "[{0}] Step 4.6 Cookies:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    foreach ($cookie in $session.Cookies.GetCookies($redirectUrl)) {
                        "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.Name, $cookie.Value | Write-Verbose
                    }
        
                    # Log raw HTML for debugging
                    "[{0}] Step 4.6 - Raw HTML Response: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep46.Content | Write-Verbose
        
                    # Extract actionUrl
                    $encodedString = ($responseStep46.Content | Select-String -Pattern 'action="(.*?)"' | ForEach-Object { $_.Matches.Groups[1].Value } | Select-Object -First 1)
                    if (-not $encodedString) {
                        "[{0}] ERROR: No action URL found in response!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        throw "Action URL not found"
                    }
                    $actionUrl = [System.Web.HttpUtility]::HtmlDecode($encodedString)
                    "[{0}] Decoded actionUrl: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $actionUrl | Write-Verbose
        
                    # Extract RelayState
                    $encodedRelayState = ($responseStep46.Content -join "`n" | Select-String -Pattern 'name="RelayState" type="hidden" value="([^"]+)"' -AllMatches).Matches | ForEach-Object { $_.Groups[1].Value } | Select-Object -First 1
                    if (-not $encodedRelayState) {
                        "[{0}] ERROR: No RelayState found in response!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        throw "RelayState not found"
                    }
                    $RelayState = [System.Web.HttpUtility]::HtmlDecode($encodedRelayState)
                    $encodedRelayState = [System.Web.HttpUtility]::UrlEncode($RelayState)
                    "[{0}] Extracted RelayState: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RelayState | Write-Verbose
                    "[{0}] Encoded RelayState: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $encodedRelayState | Write-Verbose
                    
                    # Extract the SAMLResponse value from the HTML response
                    $encodedSAMLResponse = ($responseStep46.Content -join "`n" | Select-String -Pattern 'name="SAMLResponse" type="hidden" value="([^"]+)"' -AllMatches).Matches | ForEach-Object { $_.Groups[1].Value }
                    # "[{0}] Extracted Encoded SAMLResponse: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $encodedSAMLResponse | Write-Verbose
        
                    $SAMLResponse = [System.Web.HttpUtility]::HtmlDecode($encodedSAMLResponse)
                    "[{0}] Extracted Decoded SAMLResponse: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SAMLResponse | Write-Verbose
                    
                }
                catch {
                    "[{0}] Failed to acquire SAML response: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.Message | Write-Verbose
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed to acquire SAML response" -Completed
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
                #EndRegion
        
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.7] Submit SAML Response to obtain authorization code at step 13: POST request to 'https://auth.hpe.com/sso/saml2/0oaxkzvt641W1SCSY357'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.7] Acquire SAML response" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
                "[{0}] Step 4.7 - About to POST SAMLResponse to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $actionUrl | Write-Verbose
        
                $payload = @{
                    "SAMLResponse" = $SAMLResponse
                    "RelayState"   = $encodedRelayState
                }
        
        
                "[{0}] Step 4.7 - Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | out-String ) | Write-Verbose
        
                "[{0}] Step 4.7 - Cookies before request:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                foreach ($cookie in $session.Cookies.GetCookies($actionUrl)) {
                    "[{0}] - {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.Name, $cookie.Value | Write-Verbose
                }
        
                try {
                    $responseStep47 = Invoke-WebRequest -Uri $actionUrl -Method POST -ErrorAction Stop -Headers $headers -Form $payload -WebSession $session -MaximumRedirection 0 -ErrorVariable redirected
                    "[{0}] Step 4.7 - SAML2 IDP response received successfully. Status: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep47.StatusCode | Write-Verbose
        
                    if ($responseStep47.StatusCode -ne 302) {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        Throw "Check your HPE GreenLake username and password!"
                    }
                    else {
                        "[{0}] Redirection detected. Proceeding with the next step..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
        
                }
                catch {}
        
                if ($redirected.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                    $redirecturl1 = $redirected.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri

                    # Retrieve the SID from 'Set-Cookie' header values
                    $cookies = $redirected.ErrorRecord.Exception.Response.Headers
                    
                    # "[{0}] Cookies from response headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookies | Write-Verbose
                    
                    foreach ($cookie in $cookies) {
                                                
                        if ($cookie.value -match "sid=" ) {
                            
                            $onepassSid = ($cookie.value -split ';')[0].Split('=')[1]
                                
                        }                    
                    }
                }
        
                "[{0}] First redirection URL captured: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl1 | Write-Verbose
                "[{0}] HPE Onepass SID capture from response headers Set-Cookies: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $onepassSid | Write-Verbose
        
                
                #EndRegion
                                
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.8] Follow first redirection: GET request to 'https://sso.common.cloud.hpe.com/sp/xxxxxxxxx/cb.openid?code=xxxxxxxxxxxxx&state=xxxxxx'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.8] Follow first redirection" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
        
                "[{0}] Step 4.8 - Follow redirection: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl1 | Write-Verbose
        
                try {  
            
                    $responseStep48 = Invoke-WebRequest $redirecturl1 -Method Get -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected2 -WebSession $Session 
            
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep48.StatusCode, $responseStep48.StatusDescription | Write-verbose
                    "[{0}] Raw response fpr `$responseStep48: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep48 | Write-verbose           
            
                    if ($responseStep48.StatusCode -ne 302) {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        Throw "Check your HPE GreenLake username and password!"
                    }
                    else {
                        "[{0}] Redirection detected. Proceeding with the next step..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
                }
                # Not using catch as entering the catch block when encountering a 302 (false error as we have a redirection)
                catch {
                    #     Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    #     $PSCmdlet.ThrowTerminatingError($_)
                }
            
                if ($redirected2.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                    $redirecturl2 = $redirected2.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri
                }
            
                "[{0}] Second redirection URL captured: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl2 | Write-Verbose
            
        
                #EndRegion
                    
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
                #Region [STEP 4.9] Follow second redirection and obtain authorization code: GET request to 'https://sso.common.cloud.hpe.com/as/XHYtfQfeRn/resume/as/authorization.ping'
                # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                "[{0}] [STEP 4.9] Follow second redirection" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
        
                "[{0}] Step 4.9 - Follow redirection: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl2 | Write-Verbose
        
                try {  
            
                    $responseStep49 = Invoke-WebRequest $redirecturl2 -Method Get -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected3 -WebSession $Session 
            
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep49.StatusCode, $responseStep49.StatusDescription | Write-verbose
                    "[{0}] Raw response fpr `$responseStep49: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseStep49.Content | Write-verbose           
            
                    if ($responseStep49.StatusCode -ne 302) {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        Throw "Check your HPE GreenLake username and password!"
                    }
                    else {
                        "[{0}] Redirection detected. Proceeding with the next step..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
                }
                # Not using catch as entering the catch block when encountering a 302 (false error as we have a redirection)
                catch {
                    #     Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    #     $PSCmdlet.ThrowTerminatingError($_)
                }

                if ($redirected3.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                    $redirecturl3 = $redirected3.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri
                }
            
                "[{0}] Third redirection URL captured: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl3 | Write-Verbose
            
        
                # Authorization code is found in $redirecturl3
                # $redirecturl3 =  https://common.cloud.hpe.com/authentication/callback?code=xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        
                $code = ($redirecturl3 | select-string -Pattern '(?<=code=)(.*)').Matches | ForEach-Object Value 
                    
                "[{0}] Authorization Code: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $code | Write-Verbose
        
                #EndRegion    
                
            } 
            ######################################################## REJECTING ANY IDP THAT ARE NOT OKTA #################################################################################################
            elseif ($IdP -eq "microsoft:idp" -or $IdP -eq "azure:idp") {
                "[{0}] Identity Provider detected: Azure Active Directory using {1}." -f $MyInvocation.InvocationName.ToString().ToUpper(), $OktaIDPType | Write-Verbose
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Unsupported IdP type" -Completed
                Throw "Azure Active Directory Identity Provider is unsupported at this time, please use an email account that is associated with an Okta account or an email that does not belong to any SAML SSO domains configured in your workspace."
            }
            elseif ($IdP -eq "google:idp") {
                "[{0}] Identity Provider detected: Google using {1}." -f $MyInvocation.InvocationName.ToString().ToUpper(), $OktaIDPType | Write-Verbose
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Unsupported IdP type" -Completed
                Throw "Google Identity Provider is unsupported at this time, please use an email account that is associated with an Okta account or an email that does not belong to any SAML SSO domains configured in your workspace."
            }
            elseif ($IdP -eq "ping:idp" -or $IdP -eq "pingfederate:idp") {
                "[{0}] Identity Provider detected: PingFederate using {1}." -f $MyInvocation.InvocationName.ToString().ToUpper(), $OktaIDPType | Write-Verbose
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Unsupported IdP type" -Completed
                Throw "PingFederate Identity Provider is unsupported at this time, please use an email account that is associated with an Okta account or an email that does not belong to any SAML SSO domains configured in your workspace."
            }
            else {
                "[{0}] No recognized Identity Provider detected." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Unsupported IdP type" -Completed
                Throw "No recognized Identity Provider detected. Please use a supported Identity Provider."
            }
        }
        else {

            "[{0}] No recognized SAML2 Identity Provider detected (unknown protocol: {1}). Proceeding with single-factor authentication." -f $MyInvocation.InvocationName.ToString().ToUpper(), $OktaIDPType | Write-Verbose
            
            # --------------------------------------------------------------------------------------------------------------------------------------------------------------
            #Region [STEP 4.1] Authenticate and consent: POST to https://auth.hpe.com/api/v1/authn
            # --------------------------------------------------------------------------------------------------------------------------------------------------------------

            "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
            "[{0}] [STEP 4.1] Authenticate and consent" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
    
            
            $payload = @{}
            $payload["options"] = @{multiOptionalFactorEnroll = $True; warnBeforePasswordExpired = $True }
            $payload["password"] = $decryptPassword
            $payload["stateToken"] = $stateToken
            $payload["username"] = $UserName
        
            # Convert to JSON
            $payload = $payload | ConvertTo-Json -Depth 10
        
            # Fix the escaped backslash in stateToken
            # $payload = $payload -replace '"stateToken": "([^"]*?)(\\\\+)([^"]*?)"', '"stateToken": "$1\$3"'
        
            $url = $HPEGLoktaURL + $AuthnUri 

            
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 4 / 8" -Id 0
            "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose
        
        
            try {
                $responseccsauthclient = Invoke-webrequest $url -Method 'POST' -Body $payload -ContentType 'application/json' -ErrorAction stop -SessionVariable auth_session
                    
                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient.StatusCode, $responseccsauthclient.StatusDescription | Write-verbose
                "[{0}] Raw response for `$responseccsauthclient: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient | Write-verbose          
                
            }
            catch {
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                throw "Connection error! Invalid HPE GreenLake username or password!"            
            }
        
            $_status = ($responseccsauthclient.Content | Convertfrom-Json).Status
        
            "[{0}] Session setup status: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_status | Write-Verbose
        
            if ($_status -eq "MFA_ENROLL") {
        
                "[{0}] MFA enrollment has been detected. User must log in to the HPE GreenLake GUI and complete the MFA setup using one of the available methods before proceeding with this library: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_status | Write-Verbose
        
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                throw "Connection error! Multi-factor authentication (MFA) enrollment is required. Please log in to the HPE GreenLake GUI and complete the MFA setup using one of the available methods before proceeding with this library."
            }
            elseif ($_status -eq "MFA_REQUIRED") {
        
                $mfaStateToken = $($responseccsauthclient.Content | Convertfrom-Json).stateToken
        
                $Factors = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.factors
        
                # Authentication factor that uses Okta Verify push notifications
                $pushFactor = $Factors | Where-Object { $_.factorType -eq "push" }
                # Authentication factor that uses Time-Based One-Time Passwords (TOTP) 
                $TOTPFactor = $Factors | Where-Object { $_.factorType -eq "token:software:totp" }
                # Authentication factor that uses passkey (Yubikey, biometric device, etc.) - NOT SUPPORTED (requires external tools or libraries)
                $PassKeyFactor = $Factors | Where-Object { $_.factorType -eq "webauthn" }
                
        
                # Sign in with Okta Verify push (if available)
                if ($pushFactor) {
                    "[{0}] MFA factorType PUSH has been detected." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        
                    # Capture href redirection
                    $href = $pushFactor._links.verify.href 
                        
                    "[{0}] MFA verify href redirection: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                        
                    $mfaId = $pushFactor.id
                    $mfaProvider = $pushFactor.provider
        
                    if ($mfaProvider -eq "OKTA") {
                        $mfaProvider = "Okta"
                    }                
        
                    "[{0}] MFA ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaId | Write-Verbose
                    "[{0}] MFA Provider: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaProvider | Write-Verbose
                    "[{0}] MFA State Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaStateToken | Write-Verbose
        
                    # Authenticate MFA push using POST https://auth.hpe.com/api/v1/authn/factors/<ID>/verify
        
                    $payload = @{}
                    $payload["stateToken"] = $mfaStateToken
                    $payload = $payload | ConvertTo-Json
        
                    "[{0}] ------------------------------------- STEP MFA VERIFY -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                    Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Check your $mfaProvider-enabled device push notification from HPE GreenLake..." -Id 0
        
                    $timeout = [datetime]::Now.AddMinutes(2)
        
                    "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose
        
                    do {
            
                        Try {
                            $responseccsauthclient = Invoke-webrequest $href -Method 'POST' -Body $payload -ContentType 'application/json' -ErrorAction stop -SessionVariable auth_session
                            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                            "[{0}] Raw response for `$responseccsauthclient: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient | Write-verbose
                            "[{0}] Response content type: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($responseccsauthclient.Headers["Content-Type"][0]) | Write-verbose
                        }
                        catch {
                            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                            throw "Connection error! Invalid '$mfaProvider' MFA push verification!"
                        }
                                                
                        if ([datetime]::Now -ge $timeout) {
                            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                            throw "Connection error due to timeout error! MFA push verification did not succeed within 2 minutes."
                        }
                            
                        if (($responseccsauthclient.Headers["Content-Type"][0]) -like "text/html*") {
                            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                            throw "Connection error! Invalid '$mfaProvider' MFA push verification!"
                        }
        
                        Start-Sleep -Seconds 1
                            
                    } until ( ($responseccsauthclient.Content | Convertfrom-Json).status -eq "SUCCESS" -or ($responseccsauthclient.Content | Convertfrom-Json).factorResult -eq "REJECTED" )
        
                    if (($responseccsauthclient.Content | Convertfrom-Json).status -eq "SUCCESS") {
                        "[{0}] MFA push verification was successful." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "MFA push verification was successful." -Id 0
        
                    }
                    elseif (($responseccsauthclient.Content | Convertfrom-Json).factorResult -eq "REJECTED") {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "Connection error! MFA push verification was rejected."
                    }
                }           
                # Sign in with OTP using Okta Verify token or Google Authentication token
                elseif ($TOTPFactor) {
                        
                    "[{0}] MFA factorType TOKEN has been detected." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                    # Capture href redirection
                    $href = $TOTPFactor._links.verify.href 
                        
                    "[{0}] MFA verify href redirection: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
                    $mfaId = $TOTPFactor.id
                    $mfaProvider = $TOTPFactor.provider
                    $Domain = $TOTPFactor._links.verify.href.Split("/")[2]
        
                    if ($mfaProvider -eq "OKTA") {
                        $mfaProvider = "Okta Verify"
                    }
                    elseif ($mfaProvider -eq "GOOGLE") {
                        $mfaProvider = "Google Authenticator"
                    }
                        
                    "[{0}] MFA ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaId | Write-Verbose
                    "[{0}] MFA Provider: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaProvider | Write-Verbose
                    "[{0}] MFA State Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaStateToken | Write-Verbose
        
        
                    $_Account = $Domain + ": " + $UserName
                    # Authenticate MFA token using POST https://auth.hpe.com/api/v1/authn/factors/<ID>/verify
        
                    $payload = @{}
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    $PassCode = Read-Host -Prompt "Enter your '$mfaProvider' MFA token for the user account '$_Account'"
                        
                    Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 4 / 8" -Id 0
        
                    $payload["passCode"] = $PassCode
                    $payload["stateToken"] = $mfaStateToken
                    $payload = $payload | ConvertTo-Json
        
                    "[{0}] ------------------------------------- STEP MFA VERIFY -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                    "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose
        
                    Try {
                        $responseccsauthclient = Invoke-webrequest $href -Method 'POST' -Body $payload -ContentType 'application/json' -ErrorAction stop -SessionVariable auth_session
                        "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                        "[{0}] Raw response for `$responseccsauthclient: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient | Write-verbose
                    }
                    catch {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        throw "Connection error! Invalid '$mfaProvider' MFA token!"
        
                    }
        
                    if (($responseccsauthclient.Content | Convertfrom-Json).status -eq "SUCCESS") {
                        "[{0}] MFA token verification was successful." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "MFA token verification was successful." -Id 0
        
                    }
        
                }
        
                # Sign in with passkey (Yubikey, biometric device, etc.) - NOT SUPPORTED (requires external tools or libraries)
                elseif ($PassKeyFactor) {
        
                    "[{0}] MFA factorType WEBAUTHN has been detected." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        
                    # Capture href redirection
                    $href = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.factors[0]._links.verify.href 
                        
                    "[{0}] MFA verify href redirection: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        
                    $mfaId = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.factors[0].id
                    $mfaProvider = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.factors[0].provider
                    $mfaStateToken = ($responseccsauthclient.Content | Convertfrom-Json).stateToken
                    $mfaAuthenticatorName = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.factors[0].profile.authenticatorName
        
                    "[{0}] MFA ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaId | Write-Verbose
                    "[{0}] MFA Provider: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaProvider | Write-Verbose
                    "[{0}] MFA State Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaStateToken | Write-Verbose
        
                    "[{0}] MFA Authenticator Name: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $mfaAuthenticatorName | Write-Verbose
        
                    # The library does not support WebAuthn authentication. The user must log in to the HPE GreenLake GUI and complete the WebAuthn setup using one of the available methods before proceeding with this library.
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    $ErrorMessage = "Multifactor Authentication using a security key or biometric authenticator is not supported by this library. Please log in to your HPE GreenLake account and enable a supported MFA method."
                    throw $ErrorMessage
        
                }
            }
            elseif ($_status -ne "SUCCESS") {
        
                "[{0}] Connection error! Invalid HPE GreenLake username or password!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                throw "Connection error! Invalid HPE GreenLake username or password! Status: $_status"
            }
        
            # Capture user details
            "[{0}] Retrieving user details for the current session" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            $Name = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.user.profile.firstName + " " +  ($responseccsauthclient.Content | Convertfrom-Json)._embedded.user.profile.lastName
            "[{0}] User name to save to the current session object: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose      

            # Capture authentication issuer data        
            $Global:Oath2IssuerId = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.authentication.issuer.id
            "[{0}] Oath2 Issuer Id: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Oath2IssuerId | write-Verbose
            $Global:Oath2IssuerUri = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.authentication.issuer.uri
            "[{0}] Oath2 Issuer Uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Oath2IssuerUri | write-Verbose
            
            # Capture href redirection        
            $href = ($responseccsauthclient.Content | Convertfrom-Json)._links.next.href
            # href is usually like: "https://auth.hpe.com/login/token/redirect?stateToken=00kJygvJiy92zrYIXhROhpXMiF2NsC6zAT3SjF5XhF"
        
            $completedSteps++
        
            #EndRegion
    
            # --------------------------------------------------------------------------------------------------------------------------------------------------------------
            #Region [STEP 4.2] Acquire authorization code and HPE Onepass SID (session ID): HEAD to https://auth.hpe.com/login/token/redirect?stateToken=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
            # --------------------------------------------------------------------------------------------------------------------------------------------------------------

            "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
            "[{0}] [STEP 4.2] Acquire authorization code and HPE Onepass SID (session ID)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
    
        
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 5 / 8" -Id 0
        
        
            "[{0}] About to execute HEAD request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
            
            # Execute the HEAD request
                    
            "[{0}] Acquiring location in response1 headers..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
            try { $response1 = Invoke-WebRequest $href -Method Head -MaximumRedirection 0 -ErrorAction Ignore -ErrorVariable redirected1 }
            catch {}
            
            # Capture first redirection and HPE Onepass SID from response1 headers Set-Cookies
        
            "[{0}] ------------------------------------- First redirection -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            # $redirecturl1 = https://sso.common.cloud.hpe.com/sp/xxxxxxxxxxxxxxxxxxx/cb.openid?code=xxxxxxxxxxxxxxxxxxxxxxxxx
        
            "[{0}] Received status code response: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirected1.ErrorRecord.Exception.Response.StatusCode.value__, $redirected1.ErrorRecord.Exception.Response.StatusDescription | Write-verbose
    
            if ($redirected1.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                    
                # Retrieve the 'Location' header value
                $redirecturl1 = $redirected1.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri
                    
                # Retrieve the SID from 'Set-Cookie' header values
                $cookies = $redirected1.ErrorRecord.Exception.Response.Headers
                    
                # "[{0}] Cookies from response headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookies | Write-Verbose
    
                foreach ($cookie in $cookies) {
                                            
                    if ($cookie.value -match "sid=" ) {
                            
                        $onepassSid = ($cookie.value -split ';')[0].Split('=')[1]
                            
                    }                    
                }
                    
            }
                
            "[{0}] First redirection URL captured: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl1 | Write-Verbose
            "[{0}] HPE Onepass SID capture from response headers Set-Cookies: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $onepassSid | Write-Verbose
                
        
            "[{0}] ------------------------------------- Second redirection -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] About to execute Get request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl1 | Write-Verbose
        
            try {  
                "[{0}] Acquiring authorization code in response2..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                $response2 = Invoke-WebRequest $redirecturl1 -Method Get -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected2 -WebSession $Session 
        
                # "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response2.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                # "[{0}] Raw response fpr `$response2: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response2 | Write-verbose           
        
                if ($response2.StatusCode -ne 302) {
                    Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    Throw "Check your HPE GreenLake username and password!"
                }
                else {
                    "[{0}] Redirection detected. Proceeding with the next step..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                }
            }
            # Not using catch as entering the catch block when encountering a 302 (false error as we have a redirection)
            catch {
                #     Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                #     $PSCmdlet.ThrowTerminatingError($_)
            }
        
            if ($redirected2.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                $redirecturl2 = $redirected2.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri
            }
        
            "[{0}] Second redirection URL captured: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl2 | Write-Verbose
        
        
            # $redirecturl2 = "https://sso.common.cloud.hpe.com/as/xxxxxxxx/resume/as/authorization.ping"
        
            "[{0}] ------------------------------------- Third redirection -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl2 | Write-Verbose
        
            $tries = 0
            $maxTries = 10
            $redirecturl3 = $False
        
            do {
                    
                # Increment the counter
                $tries++
        
                try {
                    "[{0}] Acquiring authorization code response3..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                    $response3 = Invoke-WebRequest $redirecturl2 -Method Get -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected3 -WebSession $Session
        
                    # "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response3.StatusCode, $response3.StatusDescription | Write-Verbose
        
                    if ($response3.StatusCode -ne 302) {
                        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                        Throw "Check your HPE GreenLake username and password!"
                    }
                    else {
                        "[{0}] Redirection detected. Proceeding with the next step..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }
                }
                catch {
                    # Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                    # throw "Error during redirection handling: $($_.Exception.Message)"
                }
        
                if ($redirected3.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                    $redirecturl3 = $redirected3.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri
                }
        
                Start-Sleep -Seconds 1
                
            } until ($redirecturl3 -or $tries -ge $maxTries)
        
            if (-not  $redirecturl3) {
                Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
                Throw "Connection error due to timeout error!"
            }
            else {
                "[{0}] Third redirection URL captured: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl3 | Write-Verbose
        
            }
        
                
            # Authorization code is found in $redirecturl3
            # $redirecturl3 =  https://common.cloud.hpe.com/authentication/callback?code=xxxxxxxxxxxxxxxxxxxxxxxx
        
            $code = ($redirecturl3 | select-string -Pattern '(?<=code=)(.*)').Matches | ForEach-Object Value 
                
            "[{0}] Authorization Code: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $code | Write-Verbose
        
            $completedSteps++       
        
            #EndRegion
        }
        ##############################################################################################################################################################################################
       
            
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        #Region [STEP 5] Generate Access Token using authorization code + code verifier: POST request to 'https://sso.common.cloud.hpe.com/as/token.oauth2'
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------

        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        "[{0}] [STEP 5] Generate Access Token using authorization code + code verifier" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose


        "[{0}] Step 5 - Generate Access Token using authorization code + code verifier: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl2 | Write-Verbose
            
        "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
                        
            
        $tokenParams = @{
            grant_type    = 'authorization_code'
            code          = $code
            redirect_uri  = $ccsRedirecturi
            client_id     = $HPEGLclient_id
            code_verifier = $codeVerifier
        }
            
        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($tokenParams | convertto-json) | Write-Verbose

        try {

            "[{0}] Posting authorization code + code verifier..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
            $response4 = Invoke-WebRequest -Method Post -Uri $HPEGLtokenEndpoint -Body $tokenParams -ContentType 'application/x-www-form-urlencoded' 
            
            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response4.StatusCode, $response4.StatusDescription | Write-verbose
            "[{0}] Raw response for `$response4: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response4 | Write-verbose
            
        }
        catch {
            
            "[{0}] Create CCS session payload content: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($tokenParams | Out-String) | Write-Verbose
    
            if ($_.ErrorDetails.Message) {
                Write-Warning $_.ErrorDetails
            }
    
            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
            $PSCmdlet.ThrowTerminatingError($_).Exception.Message
        
        }
    
    
        # Get HPE GreenLake Common Cloud Services Access token, ID token and Refresh token
        $Oauth2AccessToken = ($response4.content | ConvertFrom-Json).access_token
        "[{0}] OAuth2 Access Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oauth2AccessToken | Write-Verbose
            
        $Oauth2IdToken = ($response4.content | ConvertFrom-Json).id_token
        "[{0}] OAuth2 ID Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oauth2IdToken | Write-Verbose
            
        $Oauth2RefreshToken = ($response4.content | ConvertFrom-Json).refresh_token
        "[{0}] OAuth2 Refresh Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oauth2RefreshToken | Write-Verbose
    
        $completedSteps++

        #EndRegion      
    
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        #Region [STEP 6] Set HPEGreenLakeSession global variable  
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
   
        
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        "[{0}] [STEP 6] Set HPEGreenLakeSession global variable" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose

        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 7 / 8" -Id 0 
        "About to Set HPEGreenLakeSession global variable" | Write-Verbose
        
        $Global:HPEGreenLakeSession = [System.Collections.ArrayList]::new()
            
        $SessionInformation = [PSCustomObject]@{
            session                  = $Null
            oauth2AccessToken        = $Oauth2AccessToken
            oauth2IdToken            = $Oauth2IdToken
            oauth2RefreshToken       = $Oauth2RefreshToken
            username                 = $UserName
            name                     = $Name
            workspaceId              = $Null
            workspace                = $Null
            workspacesCount          = $Null
            oauth2TokenCreation      = [datetime]$(Get-Date)
            oauth2TokenCreationEpoch = $((New-TimeSpan -Start (Get-Date "01/01/1970") -End (Get-Date)).TotalSeconds) 
            userSessionIdleTimeout   = $Null
            apiCredentials           = [System.Collections.ArrayList]::new()
            glpApiAccessToken        = [System.Collections.ArrayList]::new()
            glpApiAccessTokenv1_2    = [System.Collections.ArrayList]::new()
            comApiAccessToken        = [System.Collections.ArrayList]::new()
            ccsSid                   = $Null
            onepassSid               = $onepassSid
        }
            
        [void]$global:HPEGreenLakeSession.add($SessionInformation)
            
        $Global:HPEGreenLakeSession = Invoke-RepackageObjectWithType -RawObject $HPEGreenLakeSession -ObjectName 'Connection'
        # $global:HPEGreenLakeSession.apiCredentials = [System.Collections.ArrayList]::new()
            
        "`$HPEGreenLakeSession global variable set!" | Write-Verbose
    
        $completedSteps++        
                    
        #EndRegion
    
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
        #Region [STEP 7] Create session with workspace (acquire CCS SID) to https://aquila-user-api.common.cloud.hpe.com/authn/v1/session
        # --------------------------------------------------------------------------------------------------------------------------------------------------------------
    
            
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose
        "[{0}] [STEP 7] Create session with workspace (acquire CCS SID)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        "[{0}] ------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose

        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 8 / 8"  -Id 0    
            
        try {
                
            if ($Workspace) {
                "[{0}] Create session with workspace '{1}' using Connect-HPEGLWorkspace" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Workspace | Write-Verbose
                $CCSSession = Connect-HPEGLWorkspace -Name $Workspace 
            }
            else {
    
                "[{0}] Create session without workspace using Connect-HPEGLWorkspace" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                $CCSSession = Connect-HPEGLWorkspace 
            }
    
                                       
        }
        catch {
            Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed
            Write-Progress -Id 1 -Activity "Connecting to HPE GreenLake" -Status "Failed" -Completed # progress bar from 'Connect-HPEGLWorkspace' 
            $PSCmdlet.ThrowTerminatingError($_)
        }
                    
    
        $completedSteps++
    
        #EndRegion
            
        "[{0}] Connection to HPE GreenLake successful!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        # Clear the progress bar upon completion
        Write-Progress -Id 0 -Activity "Connecting to HPE GreenLake" -Status "Completed" -Completed
    
        return $HPEGreenLakeSession 
    
    }
        
}



Function Disconnect-HPEGL { 
    <#
.SYNOPSIS
Log off from the HPE GreenLake platform.

.DESCRIPTION
This cmdlet terminates the current HPE GreenLake session by logging out the user and purging all variables and temporary API credentials established through 'Connect-HPEGL'.

.EXAMPLE
Disconnect-HPEGL

Terminates the current HPE GreenLake session. 

.INPUTS
None. You cannot pipe objects to this cmdlet.

.OUTPUTS
System.String
    Returns "<email address> session disconnected!"

#>

    [CmdletBinding()]
    Param() 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
        # Define the total number of operations/steps
        $totalSteps = 3

        # Initialize a counter for completed steps
        $completedSteps = 0

        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id
            )

            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Disconnecting from HPE GreenLake, please wait..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -Id $Id
        }

      
        if (-not $HPEGreenLakeSession) {
            Write-Warning "Operation not required: No HPE GreenLake session found."
    
        }
        else {

            # Access_token expiration date
            $AccessTokenExpirationDate = $HPEGreenLakeSession.oauth2TokenCreation.AddMinutes(120)

            # Number of minutes before expiration of the Access_token expiration date
            $BeforeExpirationinMinutes = [math]::Round(((New-TimeSpan -Start (Get-Date) -End ($AccessTokenExpirationDate)).TotalHours ) * 60)
        
            if ( $BeforeExpirationinMinutes -gt 0) { 

                $Expiration = $BeforeExpirationinMinutes 

                "[{0}] Session expiration in '{1}' minutes" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Expiration | Write-Verbose


                #Region 1 - Remove library API client credentials   
            
                "[{0}] ------------------------------------- STEP 1 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 1 / 3 - Removing all library API Client credentials..." -Id 3
                "[{0}] About to remove all temporary API Client credentials using the template '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $APIClientCredentialTemplateName | Write-Verbose
                
                if ($HPEGreenLakeSession.apiCredentials) {

                    try {

                        $APIcredentials = Get-HPEGLAPICredential | Where-Object name -match $APIClientCredentialTemplateName 
                
                        if ($APIcredentials) {
            
                            $APIcredentials | Remove-HPEGLAPICredential -Force | Out-Null
            
                        }
                        else {
                            "[{0}] No library API Client credential found using the template '{1}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $APIClientCredentialTemplateName | Write-Verbose
                        }

                    }
                    catch {
                        Write-Progress -Id 3 -Activity "Disconnecting from HPE GreenLake" -Status "Failed" -Completed 
                        Write-Warning "The session has already been disconnected due to expiration!"
                        return
                        # $PSCmdlet.ThrowTerminatingError($_)
                    }    
                
                }

                $completedSteps++

                #endregion


                #Region 2 - Remove HPE GreenLake workspace session   
                "[{0}] ------------------------------------- STEP 2 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 3 - Removing HPE GreenLake workspace session..." -Id 3

                "[{0}] About to remove HPE GreenLake workspace session" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
                $url = $AuthnEndSessionUri
                
                "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
        
                try {

                    $InvokeReturnData = Invoke-WebRequest -Method GET -Uri $url -WebSession $HPEGreenLakeSession.session -ContentType 'application/json' 
                
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose
                
                    "[{0}] Workspace '{1}' session removed successfully!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

                }
                catch {

                    $Response = $_.Exception.Response | convertto-json -depth 10 

                    $ExceptionCode = $_.Exception.Response.StatusCode.value__
                    $ExceptionText = $_.Exception.Response.StatusDescription + $_.Exception.Response.ReasonPhrase 
                
                    "[{0}] Request payload: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Payload | Out-String) | Write-Verbose

                    "[{0}] Request failed with the following Status:`r`n`tHTTPS Return Code = '{1}' `r`n`tHTTPS Return Code Description = '{2}' `n" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode, $ExceptionText | write-verbose

                    # "[{0}] Raw response  = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-verbose


                    Write-Progress -Id 3 -Activity "Disconnecting from HPE GreenLake" -Status "Failed" -Completed
                    $PSCmdlet.ThrowTerminatingError($_)
            
                }

                $completedSteps++

                #endregion


                #Region 3 - Revoke CCS OAuth2 token
                "[{0}] ------------------------------------- STEP 3 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 3 - Revoking OAuth2 tokens..." -Id 3

                "[{0}] About to revoke CCS OAuth2 token" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                $url = $HPEGLauthorityURL.OriginalString + $OpenidConfiguration
                "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
            
                
                try {
                    $response = Invoke-RestMethod $url -Method 'GET' 
            
                }
                catch {                
                    Write-Progress -Id 3 -Activity "Disconnecting from HPE GreenLake" -Status "Failed" -Completed
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
                
                $payload = @{
                    'client_id'       = 'aquila-user-auth'
                    'token'           = $HPEGreenLakeSession.oauth2AccessToken
                    'token_type_hint' = 'access_token'
                    
                } 
                    
                $RevocationEndpoint = $response.revocation_endpoint

                "[{0}] About to execute POST request to revoke CCS OAuth2 token to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RevocationEndpoint | Write-Verbose
                
                try {
                    "[{0}] Request payload: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | Out-String) | Write-Verbose

                    $InvokeReturnData = Invoke-webrequest -Uri $RevocationEndpoint -Method 'POST' -Body $payload -ContentType "application/x-www-form-urlencoded" -ErrorAction stop -WebSession $HPEGreenLakeSession.session
                    
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose
                
                    "[{0}] CCS OAuth2 token '{1}' revoked!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.username | Write-Verbose

                    $_username = $HPEGreenLakeSession.username
                    
                    # Remove $HPEGreenLakeSession global variable
                    Remove-Variable HPEGreenLakeSession -Scope Global
                    "[{0}] Global variable `$HPEGreenLakeSession has been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    # Clear all HPEGL global variables
                    Get-Variable -Scope global | Where-Object name -match HPEGL | Remove-Variable -Force -Scope Global
                    "[{0}] All global variable starting with HPEGL have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # Clear all HPECOM global variables
                    Get-Variable -Scope global | Where-Object name -match HPECOM | Remove-Variable -Force -Scope Global
                    "[{0}] All global variable starting with HPECOM have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    
                }
                
                catch {

                    "[{0}] Exception thrown!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # Get Exception type
                    $exception = $_.Exception

                    do {
                        "[{0}] Exception Type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $exception.GetType().Name | Write-Verbose
                        $exception = $exception.InnerException
                    } while ($exception)

                    # Get exception stream
                    $result = $_.Exception.Response.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($result)
                    $reader.BaseStream.Position = 0
                    $reader.DiscardBufferedData()
                    $responseBody = $reader.ReadToEnd() 


                    "[{0}] Raw response `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseBody | Write-Verbose
                
                    $response = $responseBody | ConvertFrom-Json
                        
                    if ($Body) {
                        "[{0}] Request payload: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Body | Out-String) | Write-Verbose
                    }
                    if ($Headers) {
                        "[{0}] Request headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | Out-String) | Write-Verbose
                    }

                    Write-Progress -Id 3 -Activity "Disconnecting from HPE GreenLake" -Status "Failed" -Completed
                    Throw "Error -  $responseBody"          
                }
                
                $completedSteps++
                
                #endregion
                
                # Clear the progress bar upon completion
                Write-Progress -Id 3 -Activity "Disconnecting from HPE GreenLake" -Status "Completed" -Completed
                
                return ("{0} session disconnected!" -f $_username )

            }
            # Expiration = 0
            else { 

                "[{0}] The session has expired! Disconnection is not needed!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                # Remove $HPEGreenLakeSession global variable
                Remove-Variable HPEGreenLakeSession -Scope Global
                "[{0}] Global variable `$HPEGreenLakeSession has been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                # Clear all HPEGL global variables
                Get-Variable -Scope global | Where-Object name -match HPEGL | Remove-Variable -Force -Scope Global
                "[{0}] All global variable starting with HPEGL have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                # Clear all HPECOM global variables
                Get-Variable -Scope global | Where-Object name -match HPECOM | Remove-Variable -Force -Scope Global
                "[{0}] All global variable starting with HPECOM have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                Write-Warning "The session has already been disconnected due to expiration!"
                return
            }
        }
    }
}



Function Connect-HPEGLWorkspace { 
    <#
.SYNOPSIS
Connect to a workspace or switch between HPE GreenLake workspaces.

.DESCRIPTION
This cmdlet establishes a connection to an HPE GreenLake workspace. 
When you are already connected to a workspace, you can use this cmdlet to switch between workspaces. 

During the switching process, the cmdlet removes the temporary HPE GreenLake and COM API client credentials from the departing workspace and generates the necessary new ones in the newly connected workspace. 
These API credentials are required for this library to interact with the various service APIs. The credentials are updated in `$HPEGreenLakesession` and securely stored using encryption.
API client credentials for COM are created for each provisioned COM instance found in the newly connected workspace.

Note: This cmdlet is also used in the background by 'Connect-HPEGL' to initiate a session with an HPE GreenLake workspace and automatically generate the HPE GreenLake and COM API client credentials.

.PARAMETER Name 
Specifies the name of a workspace available in HPE GreenLake. You can retrieve the workspace name using the 'Get-HPEGLWorkspace' cmdlet.
This parameter is optional and should be used if you have more than one HPE GreenLake workspace.
By default, the cmdlet uses the first available workspace associated with your email address.

.PARAMETER Force
Forces reconnection to the current workspace and re-establishes connections to the various GLP and COM APIs (if applicable).
This option is commonly utilized by the library to automatically reconnect to the workspace and various APIs when tokens are about to expire.

.EXAMPLE
Connect-HPEGLWorkspace

Connect to the HPE GreenLake workspace associated with your email address if there is only one workspace available in HPE GreenLake associated with your account.
Temporary HPE GreenLake and COM API client credentials are generated and stored in the '$HPEGreenLakesession' tracking object environment variable.

.EXAMPLE
Connect-HPEGLWorkspace -Name 'DreamCompany' 

Connect to the 'DreamCompany' HPE GreenLake workspace if no workspace session is found in the current environment, and generate all temporary HPE GreenLake and COM API client credentials.
If the user is already connected to a workspace, the cmdlet will switch from the current workspace to the 'DreamCompany' workspace. In this case, temporary HPE GreenLake and COM API client credentials are deleted from the previous workspace and regenerated for the newly connected 'DreamCompany' workspace.
The '$HPEGreenLakesession' object is updated with the new API credentials and workspace details.

.EXAMPLE
Connect-HPEGLWorkspace -Force

Forces reconnection to the current workspace and re-establishes connections to the various GLP and COM APIs (if applicable).

.EXAMPLE
Get-HPEGLWorkspace -Name Workspace_2134168251 | Connect-HPEGLWorkspace

This example retrieves the workspace object with the name 'Workspace_2134168251' using the Get-HPEGLWorkspace cmdlet and then pipes it to the Connect-HPEGLWorkspace cmdlet to establish a connection to the 'HPE_Workspace_2134168251' HPE GreenLake workspace.

.INPUTS
System.Object
    A workspace object retrieved using 'Get-HPEGLWorkspace -name <workspacename>'.

.OUTPUTS     
System.Collections.ArrayList
    ${Global:HPEGreenLakeSession}

When a new valid connection is established with a workspace, ${Global:HPEGreenLakeSession} connection tracker variable is updated with the new customer id, workspace name properties and API credentials and is returned by the cmdlet.

#>

    [CmdletBinding()]
    Param(

        [Parameter(ValueFromPipelineByPropertyName)] 
        [ValidateNotNullOrEmpty()]
        [Alias("company_name")]
        [String]$Name,

        [Switch]$Force
        
    ) 
        
    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Oauth2AccessToken = $HPEGreenLakeSession.oauth2AccessToken
        $Oauth2IdToken = $HPEGreenLakeSession.oauth2IdToken

    }
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
      
        # SET PROGRESS BAR
        # Initialize a counter for completed steps
        $completedSteps = 0
        
        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id

            )
        
            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Connecting to workspace..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -Id $Id 
        }


        $Step = 1
        
        if (-not $HPEGreenLakeSession) {

            "[{0}] No session found! 'Connect-HPEGL' must be executed first!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            Write-Warning "No session found! 'Connect-HPEGL' must be executed first!" 
            Return

        }  
        # If already connected to the workspace $Name
        elseif ($HPEGreenLakeSession.workspace -eq $Name -and -not $force) {

            "[{0}] Warning, already connected to workspace {1}!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

            Write-Warning "You are already connected to workspace $Name!" 
            Return
        }


        # Access_token expiration date
        $AccessTokenExpirationDate = $HPEGreenLakeSession.oauth2TokenCreation.AddMinutes(120)

        # Number of minutes before expiration of the Access_token expiration date
        $BeforeExpirationinMinutes = [math]::Round(((New-TimeSpan -Start (Get-Date) -End ($AccessTokenExpirationDate)).TotalHours ) * 60)
    
        # Return if session expired
        if ($BeforeExpirationinMinutes -le 0) {

            "[{0}] The session has expired! 'Connect-HPEGL' must be executed again!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            Write-Warning "The session has expired! 'Connect-HPEGL' must be executed again!" 
            Return 

        }    


    
        #Region - If not connected to GLP, create a session (condition is met when 'Connect-HPEGL' is executed or when the cmdlet is used on its own)
        # Steps:
        #  1- Create CCS session and capture ccs SID (session ID) cookie value 
        #  2- Load workspace
        if (-not $HPEGreenLakeSession.workspace -and -not $force) {

            #Region 1 - Create CCS session and capture ccs SID (session ID) cookie value 
            "[{0}] ------------------------------------- STEP {1}  - Create CCS session -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
            
            # ccs-session cookie value is used for CCS API authentication 
            

            if (-Not $Name) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step  $Step / 3 - Creating session" -Id 1
    
            }
            else {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Creating session" -Id 1
            }

            $step++


            # Set a variable to update/complete the Connect-HPEGL progress bar
            $Connect_HPEGL_ProgressBar = $True

            # Check that the ID token is not expired (expires after 5 minutes)
            $ID_Token_Details = (Get-HPEGLJWTDetails -token $HPEGreenLakeSession.oauth2IdToken)

            if ($ID_Token_Details.expiryDateTime -lt (Get-Date)) {

                "[{0}] Error ! The CCS session cannot be created as the ID token has expired! Expiration date: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ID_Token_Details.expiryDateTime | Write-Verbose
                Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                throw "The identification token, which is only valid for 5 minutes, has expired! Please reconnect to HPE GreenLake using Connect-HPEGL."

            }
            
            "[{0}] The CCS session can be created because the identification token has not expired.! TimeToExpiry: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ID_Token_Details.timeToExpiry | Write-Verbose           

            $url = $AuthnSessionUri

            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Content-Type"] = "application/json"
            $headers["Authorization"] = "Bearer $Oauth2AccessToken"

            $tokenParams = @{
                'id_token' = $Oauth2IdToken
            } | ConvertTo-Json

            
            try {
                # Create CCS workspace session
                "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $tokenParams | Write-Verbose

                $response = Invoke-RestMethod -Method Post -Uri $url -Headers $headers -Body $tokenParams -SessionVariable CCSSession

                # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($response | convertto-json -Depth 10 ) | Write-verbose

                # Set global variables for all workspaces if any
                if ($response.accounts) {
                    $Global:HPEGLworkspaces = $response.accounts
                }
                
                $cookies = $CCSSession.Cookies.GetCookies($url)

                "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                foreach ($cookie in $cookies) { 
                    Write-Verbose "$($cookie.name) = $($cookie.value)"
                    # Extract the 'ccs-session' cookie value
                    if ($cookie.name -match 'ccs-session') {
                        $ccsSessionValue = $cookie.Value 
                    }
                }

                "[{0}] HPE GreenLake CCS first-session captured from response headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSessionValue | Write-Verbose

                # Set HPEGreenLakeSession.session global variable
                $Global:HPEGreenLakeSession.session = $CCSSession
                $Global:HPEGreenLakeSession.ccsSid = $ccsSessionValue
        
            }
            catch {
                Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                $PSCmdlet.ThrowTerminatingError($_)               
            }

            # Capture workspaces count
            $Global:HPEGreenLakeSession.workspacesCount = [int]$HPEGLworkspaces.Count
            "[{0}] Number of workspaces found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLworkspaces.Count | Write-Verbose
            

            # When a workspace name is provided and workspaces are found, select the workspace
            if ($Name -and $HPEGLWorkspaces.Count -gt 0) {
                
                $MyWorkspaceName = $HPEGLworkspaces | Where-Object company_name -eq $Name

                "[{0}] Workspace name '{1}' found in HPE GreenLake" -f $MyInvocation.InvocationName.ToString().ToUpper(), $MyWorkspaceName.company_name | Write-Verbose


                # When a workspace name is provided but no workspace exists, throw an error
                if (-not $MyWorkspaceName) {

                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                    Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed

                    $ErrorMsg = "Workspace '{0}' not found in HPE GreenLake for user '{1}'. Use 'Get-HPEGLWorkspace' to list available workspaces." -f $Name, $HPEGreenLakeSession.username
                    Throw $ErrorMsg
                }
            
            }
            # When a workspace name is provided but no workspace exists, throw an error
            elseif ($Name -and $HPEGLWorkspaces.Count -eq 0) {

                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed

                $ErrorMsg = "No workspaces found in HPE GreenLake. Please use 'New-HPEGLWorkspace' to create your first workspace."
                Throw $ErrorMsg
            }
            # When no workspace name is provided and there is only one workspace, connect to the workspace found
            elseif (-not $Name -and $HPEGLWorkspaces.Count -eq 1) {
                    
                $MyWorkspaceName = $HPEGLworkspaces 
                "[{0}] Workspace name found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $MyWorkspaceName.company_name | Write-Verbose

                    
            }
            # When no workspace name is provided and there is several workspaces, send a warning
            elseif (-not $Name -and $HPEGLWorkspaces.Count -gt 1) {
                    
                "[{0}] Multiple workspaces ({1}) found in HPE GreenLake. Use 'Connect-HPEGLWorkspace -Name <workspace name>' to connect to a specific workspace." -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLWorkspaces.Count | Write-Verbose
                Write-Warning "Multiple workspaces ($($HPEGLWorkspaces.Count)) found in HPE GreenLake. Use 'Connect-HPEGLWorkspace -Name <workspace name>' to connect to a specific workspace."
                
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed

                Return
                    
            }
            # When no workspace name is provided and no workspace found, send a warning
            elseif (-not $Name -and $HPEGLWorkspaces.Count -eq 0) {
                
                Write-Warning "No workspaces found in HPE GreenLake. Please use 'New-HPEGLWorkspace' to create your first workspace." 
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
        
                return
                
            }
            
            
            $completedSteps++
            #EndRegion
            
            #Region 2 - Load workspace to capture ccs SID (session ID) cookie value       
            
            if ($MyWorkspaceName) {

                "[{0}] ------------------------------------- STEP {1} - Load workspace to capture CCS SID (session ID) cookie value ---------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Loading workspace" -Id 1
                $Step++

                # Capture workspace ID and name
                $Global:HPEGreenLakeSession.workspaceId = $MyWorkspaceName.platform_customer_id
                $Global:HPEGreenLakeSession.workspace = $MyWorkspaceName.company_name
                
                "[{0}] HPE GreenLake Workspace ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspaceId | Write-Verbose
                "[{0}] HPE GreenLake Workspace: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

                # ccs-session cookie value is used for CCS API authentication 
               
                $url = $SessionLoadAccountUri + $HPEGreenLakeSession.workspaceId

                try {         

                    # "Load CCS workspace account" | Write-Verbose
                    "[{0}] About to make GET rest call to URL $url" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    $Timeout = 1

                    do {
                        try {
                            
                            $useraccount = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -WebSession $CCSSession

                            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount.StatusCode, $useraccount.StatusDescription | Write-verbose
                            "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount | Write-verbose   
                            
                            # Check if the status code is 200 (HTTP OK)
                            if ($useraccount.StatusCode -eq 200) {
                                $success = $true
                            }
                            else {
                                $success = $false
                            }
                        }
                        catch {
                            $success = $false
                        }

                        if (-not $success) {
                            Start-Sleep -Seconds 1
                            $Timeout++
                        }
                                            
                    } until ($success -or $Timeout -eq 60)

                    if ($Timeout -ge 60) {
                        Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
                        Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                        throw "Error ! Cannot load workspace at the current time!" 
                    }
            
                }
                catch {

                    if ($_.ErrorDetails.Message) {
                        $ErrorMsg = "Error: '{0}' - Error details: '{1}'" -f $_.Exception.Message, $_.ErrorDetails 

                    }
                    else {
                        $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message 

                    }

                    Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                    throw $ErrorMsg 
                    # $PSCmdlet.ThrowTerminatingError($PSitem)
                }
            }

            $completedSteps++

            #EndRegion
          
        }
        #EndRegion


        #Region -  If -Force is used to enforce a reconnection to the current workspace (condition is met when 'Invoke-HPEGLAutoReconnect' is executed automatically by the library).
        # Steps:
        #  - Load workspace to get cookies session values for CCS API authentication 
        elseif ($Force) {

            #Region 1 - Load ccs-session cookie value
            
            $MyWorkspaceName = $HPEGreenLakeSession.workspace

            if ($MyWorkspaceName) {
                
                "[{0}] ------------------------------------- STEP {1} - Load workspace to capture CCS SID (ccs-session cookie value) -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $step | Write-Verbose
                # $NoProgressBar = $True
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step $step / 3 - Loading workspace" -Id 1
                $step++


                # ccs-session cookie value is used for CCS API authentication            
    
                $url = $SessionLoadAccountUri + $HPEGreenLakeSession.workspaceId
    
                $headers = @{} 
                $headers["Accept"] = "application/json"
                $headers["Content-Type"] = "application/json"
                $headers["Authorization"] = "Bearer $Oauth2AccessToken"
                
                $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession
                [void] $session.Cookies.Add((New-Object System.Net.Cookie("ccs-session", $HPEGreenLakeSession.ccsSid, "/", "aquila-user-api.common.cloud.hpe.com")))
                
                # $HPEGreenLakeSession.session.Cookies.getcookies("https://aquila-user-api.common.cloud.hpe.com")
    
                try {         
    
                    "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                    "[{0}] Headers content: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | out-String) | Write-Verbose
                    "[{0}] Session cookie content: `nccs-session = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.ccsSid | Write-Verbose
    
                    $Timeout = 1
    
                    do {
                        $useraccount = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -WebSession $session
                        
                        #  Check if the status code is 200 (HTTP OK)
                        if ($useraccount.StatusCode -eq 200) {
                            $success = $true
                        }
                        else {
                            $success = $false
                        }
                
    
                        if (-not $success) {
                            Start-Sleep -Seconds 1
                            $Timeout++
    
                        }                                 
    
                    } until ($success -or $Timeout -eq 60)
                    
                    if ($Timeout -ge 60) {
                        Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                        throw "Error ! Cannot load workspace at the current time!" 
                    }
    
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount.StatusCode, $useraccount.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount | Write-verbose                
    
                    $cookies = $session.Cookies.GetCookies($url)
                    
                    "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    # Check and keep only the first instance of 'ccs-session' cookie
                    $uniqueCookies = @{}
    
                    foreach ($cookie in $cookies) { 
                        Write-Verbose "$($cookie.name) = $($cookie.value)"
                        # Extract the 'ccs-session' cookie value
                        if ($cookie.name -eq 'ccs-session') {
                            # $ccsSessionValue = $cookie.Value 
                            # Only add the ccs-session cookie if it hasn't been added before
                            
                            #if (-not $uniqueCookies.ContainsKey($cookie.name)) {
                            $uniqueCookies[$cookie.name] = $cookie
                            #}
                        } 
                        else {
                            # For other cookies, just add or replace as necessary
                            $uniqueCookies[$cookie.Name] = $cookie
                        }
                    }
    
                    "[{0}] CCS-session cookie to keep: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($uniqueCookies | Out-String) | Write-Verbose
    
                    # Create a cookie object with the new values
                    $newCookieContainer = New-Object System.Net.CookieContainer
    
                    foreach ($cookieName in $uniqueCookies.Keys) {
                        $originalCookie = $uniqueCookies[$cookieName]
                        $newCookie = New-Object System.Net.Cookie
                        $newCookie.Name = $originalCookie.Name
                        $newCookie.Value = $originalCookie.Value
                        $newCookie.Domain = $originalCookie.Domain
                        $newCookie.Path = $originalCookie.Path
                        $newCookie.Expires = $originalCookie.Expires
                        $newCookie.Secure = $originalCookie.Secure
                        $newCookie.HttpOnly = $originalCookie.HttpOnly
                    
                        [void]$newCookieContainer.Add($newCookie)
                    }
                    
                    $Session.Cookies = $newCookieContainer
    
                    $cookies = $session.Cookies.GetCookies($url)
                    
                    "[{0}] New cookies content after cleaning up duplicates:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                    foreach ($cookie in $cookies) { 
                        Write-Verbose "$($cookie.name) = $($cookie.value)"
                        if ($cookie.name -eq 'ccs-session') {
                            $ccsSessionValue = $cookie.Value 
                        }
                    }
    
                    "[{0}] HPE GreenLake CCS final-session captured from response headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSessionValue | Write-Verbose
                    
                    # Set HPEGreenLakeSession.session global variable
                               
                    $Global:HPEGreenLakeSession.session = $Session
                    $Global:HPEGreenLakeSession.ccsSid = $ccsSessionValue
                
                }
                catch {       
                    
                    "[{0}] Catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    Write-Progress -id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed   

                    if ($_.Exception.Response.StatusCode -eq "Unauthorized") {

                        "[{0}] Error: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.Message | Write-Verbose
                        throw "The GLP session refresh was unsuccessful due to prolonged inactivity. Please reconnect using 'Connect-HPEGL' to continue using the HPECOMCmdlets module."
    
                    }
                    elseif ($_.ErrorDetails.Message) {
                        $ErrorMsg = "Error: '{0}' - Error details: '{1}' - Code: '{2}'" -f $_.Exception.Message, $_.ErrorDetails , $_.Exception.Response.StatusCode
                        Write-Warning $ErrorMsg 
                    }
                    
                    else {
                        $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message 
                        Write-Warning $ErrorMsg 
                    }

                    Return                 
                }
            }

            $completedSteps++
            #EndRegion

            #Region 2 - Generate new access_token/refresh_token/id_token

            if ($MyWorkspaceName) {

                "[{0}] ------------------------------------- STEP {1} - Generate new access_token/refresh_token/id_token -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $step | Write-Verbose
                # $NoProgressBar = $True
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step $step / 3 - Generating new Oauth2 tokens" -Id 1
                $step++
        
                $Body = @{
                    'grant_type'    = 'refresh_token'
                    'client_id'     = 'aquila-user-auth'
                    'refresh_token' = $HPEGreenLakeSession.oauth2RefreshToken
                } 
        
                "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
        
                try {

                    $InvokeReturnData = Invoke-webrequest -Uri $HPEGLtokenEndpoint -Method 'POST' -ContentType "application/x-www-form-urlencoded" -Body $Body -WebSession $HPEGreenLakeSession.session 
                
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose
                    
                    $InvokeReturnData = $InvokeReturnData | ConvertFrom-Json

                    # Set new global variables

                    $NewAccessToken = $InvokeReturnData.access_token
                    "[{0}] New access token = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $NewAccessToken | Write-verbose
                    $global:HPEGreenLakeSession.oauth2AccessToken = $NewAccessToken 

                    $NewRefreshToken = $InvokeReturnData.refresh_token
                    "[{0}] New refresh token = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $NewRefreshToken | Write-verbose
                    $global:HPEGreenLakeSession.oauth2RefreshToken = $NewRefreshToken

                    $NewIdToken = $InvokeReturnData.id_token
                    "[{0}] New ID token = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $NewIdToken | Write-verbose
                    $global:HPEGreenLakeSession.oauth2IdToken = $NewIdToken 

                    $global:HPEGreenLakeSession.oauth2TokenCreation = [datetime]$( Get-Date -Format g )
                    "[{0}] `$HPEGreenLakeSession has been updated with new token creation date!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    $global:HPEGreenLakeSession.oauth2TokenCreationEpoch = $( (New-TimeSpan -Start (Get-Date "01/01/1970") -End (Get-Date)).TotalSeconds ) 
                    "[{0}] `$HPEGreenLakeSession has been updated with new token creation epoch!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                    "[{0}] `$HPEGreenLakeSession has been updated with new access_token/refresh_token/id_token!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # Cookies?
                    $allCookies = $HPEGreenLakeSession.session.Cookies.GetCookies($HPEGLtokenEndpoint)
                    # Output all cookies
                    foreach ($cookie in $allCookies) {
                        Write-Verbose "Session cookie content: `n$($cookie.Name) = $($cookie.Value)"
                    }

                    "[{0}] Tokens have been successfully refreshed! " -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                }
                
                catch {

                    Write-Progress -id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed   

                    "[{0}] Exception thrown!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # Get Exception type
                    $exception = $_.Exception
                    do {
                        "[{0}] Exception Type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $exception.GetType().Name | Write-Verbose
                        $exception = $exception.InnerException
                    } while ($exception)

                    # Get exception stream
                    $result = $_.Exception.Response.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($result)
                    $reader.BaseStream.Position = 0
                    $reader.DiscardBufferedData()
                    $responseBody = $reader.ReadToEnd() 


                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseBody | Write-Verbose
                
                    # $response = $responseBody | ConvertFrom-Json
                        
                    if ($Body) {
                        "[{0}] Request payload: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Body | Out-String) | Write-Verbose
                    }
                    if ($Headers) {
                        "[{0}] Request headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | Out-String) | Write-Verbose
                    }

                    Throw "Error -  $responseBody"          
                    
                }    
            }
    
            $completedSteps++    
            #EndRegion

        }
        #EndRegion


        #Region - If you are currently connected to GLP and wish to connect to another workspace
        # Steps:
        #  - Remove library API client credentials from the workspace being exited
        #  - Load workspace to get cookies session values for CCS API authentication 
        else {           
            
            #Region 1 - Remove library API client credentials from the workspace being exited (if any)
         
            # Set a variable to update/complete the Connect-HPEGL progress bar
            $ProgressBar_WhenConnectingToAnotherWorkspace = $True


            if (! $Name) {
                $name = $HPEGreenLakeSession.workspace
            }

            try {
                
                $Workspace = Get-HPEGLWorkspace -Name $Name
            }
            catch {

                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $Workspace) {

                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed

                $ErrorMessage = "Workspace '{0}' not found in HPE GreenLake for user '{1}'. Use 'Get-HPEGLWorkspace' to list available workspaces." -f $Name, $HPEGreenLakeSession.username

                $ErrorRecord = New-ErrorRecord WorkspaceNotFoundInCOM ObjectNotFound -TargetObject 'Workspace' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)


            }
            else {
           
                $WorkspaceId = $Workspace.platform_customer_id

                $MyWorkspaceName = $Workspace.company_name
                
                try {
                    $APIcredentials = Get-HPEGLAPICredential | Where-Object name -match $APIClientCredentialTemplateName 
                }
                catch {
        
                    "[{0}] Session gets expired! Connect-HPEGL must be executed!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                    Throw "Session gets expired! You must reconnect using 'Connect-HPEGL'!" 
                    # Write-Warning "Session gets expired! You must reconnect using 'Connect-HPEGL'!" 
                    # Return
                }

            
                if ($APIcredentials) {

                    "[{0}] ------------------------------------- STEP {1} - Remove library API client credentials from the workspace being exited -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
                    Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Removing library API credentials from current workspace" -Id 1       
                    $step++

                    try {
                        $APIcredentials | Remove-HPEGLAPICredential -Force | Out-Null
                        
                    }
                    catch {
                        Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    
                }

                $completedSteps++
                #EndRegion

                  
                #Region 2 - Load ccs-session cookie value

                "[{0}] ------------------------------------- STEP {1} - Load workspace to capture CCS SID (ccs-session cookie value) -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Loading workspace" -Id 1
                $step++
                
                # ccs-session cookie value is used for CCS API authentication 
                

                try {         

                    $url = $LoadAccountUri + $WorkspaceId
                    
                    "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose

                    $useraccount = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -WebSession $HPEGreenLakeSession.session 

                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount.StatusCode, $useraccount.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount | Write-verbose
                
                    $cookies = $HPEGreenLakeSession.session.Cookies.GetCookies($url)
                    "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                    foreach ($cookie in $cookies) { 
                        Write-Verbose "$($cookie.name) = $($cookie.value)"
                        # Extract the 'ccs-session' cookie value
                        if ($cookie.name -match 'ccs-session') {
                            $ccsSessionValue = $cookie.Value 
                        }
                    }
    
                    "[{0}] HPE GreenLake CCS session captured from response headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSessionValue | Write-Verbose
            

                    $Global:HPEGreenLakeSession.ccsSid = $ccsSessionValue
                     
                    $Global:HPEGreenLakeSession.workspaceId = $WorkspaceId
                    $Global:HPEGreenLakeSession.workspace = $Name

           
                    "[{0}] HPE GreenLake CCS Workspace ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Global:HPEGreenLakeSession.workspaceId | Write-Verbose
                    "[{0}] HPE GreenLake CCS Workspace name: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Global:HPEGreenLakeSession.workspace | Write-Verbose
        
                }
                catch {

                    if ($_.ErrorDetails.Message) {
                        $ErrorMsg = "Error: '{0}' - Error details: '{1}'" -f $_.Exception.Message, $_.ErrorDetails 

                    }
                    else {
                        $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message 

                    }

                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                    $ErrorRecord = New-ErrorRecord LoadWorkspaceError AuthenticationError -TargetObject 'Workspace' -Message $ErrorMsg -TargetType $WorkspaceId.GetType().Name
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                }

                #EndRegion

                $completedSteps++

            }
        }
        #EndRegion


        #Region - Generate new temporary API client credentials (COM and GLP) for this library using template $APIClientCredentialTemplateName 
        "[{0}] Generate new API client credentials in '{1}' workspace" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose
        
        if ($MyWorkspaceName -and -not $Force) {

            "[{0}] ------------------------------------- STEP {1} - Generate new API client credentials -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
            
            if ( $Connect_HPEGL_ProgressBar -or $ProgressBar_WhenConnectingToAnotherWorkspace) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Generating new library API credentials" -Id 1
                
            }
            else {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step $Step / 6 - Generating new library API credentials" -Id 1
            }

            $Step++ 

            # Clear $HPEGreenLakeSession.comApiAccessToken global variable
            $global:HPEGreenLakeSession.comApiAccessToken = [System.Collections.ArrayList]::new()

            # Clear $HPECOMAPICredentialRegions global variable
            $Global:HPECOMAPICredentialRegions = [System.Collections.ArrayList]::new()

            # "[{0}] Cookies content of `$HPEGreenLakeSession.session before running Get-HPEGLAPICredential: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), (($HPEGreenLakeSession.session.Cookies.getcookies("https://aquila-user-api.common.cloud.hpe.com")) | Out-String) | Write-Verbose

            # Remove library API client credentials if any
            try {
                $APIcredentials = Get-HPEGLAPICredential | Where-Object name -match $APIClientCredentialTemplateName 
                
            }
            catch {
                
                "[{0}] Get-HPEGLAPICredential error ! Cannot get the API client credentials..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                Write-Progress -id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed
                
                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
                    
                }

                $ErrorMessage = "API client credentials cannot be retrieved from COM!"
                $ErrorRecord = New-ErrorRecord GetGLAPICredentialError InvalidOperation -TargetObject 'APICredential' -Message $ErrorMessage 
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }
        
            if ($APIcredentials) {

                "[{0}] Library API client credentials found, let's remove them..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                try {
                    
                    $APIcredentials | Remove-HPEGLAPICredential -Force | Out-Null
                }
                catch {

                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 

                    if ($Connect_HPEGL_ProgressBar) {
                        Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'
                        
                    }
            
                    $PSCmdlet.ThrowTerminatingError($_)
                }
            }

            "[{0}] Cookies content of `$HPEGreenLakeSession.session after running Get-HPEGLAPICredential: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), (($HPEGreenLakeSession.session.Cookies.getcookies("https://aquila-user-api.common.cloud.hpe.com")) | Out-String) | Write-Verbose

            "[{0}] ------- Create HPE GreenLake temporary API client credential" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            # Save access token into $HPEGreenLakesession.glpApiAccessToken
            # It will save client_id / client_secret into $HPEGreenLakesession.apiCredentials.GLP-PowerShell_Library_Temporary_Credential
            
            try {
                $GLPAPICreationTask = New-HPEGLAPIcredential -HPEGreenLake -TemplateName $APIClientCredentialTemplateName -ErrorAction SilentlyContinue #| Out-Null
                    
            }
            catch {
                
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 

                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'
                    
                }
        
                $PSCmdlet.ThrowTerminatingError($_)
            }

        
            if ($GLPAPICreationTask.status -eq "Complete") {

                "[{0}] ------- Create HPE COM temporary API client credentials" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                # Create temporary API client credential for the HPE COM APIs for all regions
                # Save access token into $HPEGreenLakesession.glpApiAccessToken
                # It will Save client_id / client_secret into $HPEGreenLakesession.apiCredentials.COM-<region>-PowerShell_Library_Temporary_Credential
                
                try {
                    
                    $COMAPICreation = Get-HPEGLService -ShowProvisioned -Name 'Compute Ops Management' | New-HPEGLAPIcredential -TemplateName $APIClientCredentialTemplateName #-ErrorAction SilentlyContinue #| out-Null
            
                }
                catch {
        
                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 

                    if ($Connect_HPEGL_ProgressBar) {
                        Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'
                        
                    }
        
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
        
            }
            else {

                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 

                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'

                }

                # Throw "{0} API Credential cannot be created! '{1}' Any HPEGL cmdlets designed to interact with the official GLP APIs will not function!" -f ($GLPAPICreationTask.Name.substring(0, ($GLPAPICreationTask.Name.length - ($APIClientCredentialTemplateName.Length + 1))))  , $GLPAPICreationTask.Exception #| Write-Host -f Red
                $ErrorMessage = "{0} API Credential cannot be created! '{1}' Any HPEGL cmdlets designed to interact with the official GLP APIs will not function!" -f ($GLPAPICreationTask.Name.substring(0, ($GLPAPICreationTask.Name.length - ($APIClientCredentialTemplateName.Length + 1))))  , $GLPAPICreationTask.Exception
                $ErrorRecord = New-ErrorRecord GLAPICredentialCreationError InvalidOperation -TargetObject 'APICredential' -Message $ErrorMessage 
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }

            $completedSteps++
        }

            
        #EndRegion


        #Region - Create sessions with GLP and COM APIs at https://sso.common.cloud.hpe.com/as/token.oauth2 and capture access tokens
        
        if ($MyWorkspaceName) {

            "[{0}] ------------------------------------- STEP {1} - Create sessions with HPE GreenLake and COM APIs to capture access tokens -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
            
            
            if ($Connect_HPEGL_ProgressBar -or $ProgressBar_WhenConnectingToAnotherWorkspace) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Creating session" -Id 1
                
            }
            elseif ($Force) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step $step / 3 - Creating session" -Id 1

            }
            else {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step $Step / 6 - Creating session" -Id 1
            }

            $Step++

            $TemporaryCredentialsList = $HPEGreenLakeSession.apiCredentials | Where-Object name -match $APIClientCredentialTemplateName

            "[{0}] Credentials found: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $TemporaryCredentialsList.length | Write-Verbose

            foreach ($CurrentCredential in $TemporaryCredentialsList) {

                "[{0}] Create session with '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $CurrentCredential.name | Write-Verbose

                $SecureClientSecret = $CurrentCredential.secure_client_secret | ConvertTo-SecureString
                $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
                $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr) 

                $Payload = @{
                    'client_id'     = $CurrentCredential.client_id
                    'client_secret' = $ClientSecret
                    'grant_type'    = 'client_credentials'
                }

                "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | convertto-json) | Write-Verbose

                try {

                    $response = Invoke-RestMethod -Method Post -Uri $HPEGLtokenEndpoint -Body $Payload -ContentType 'application/x-www-form-urlencoded' 

                    # "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose


                    if ($CurrentCredential.name -match "COM" -and $CurrentCredential.name -match $APIClientCredentialTemplateName) {

                        $ServiceAPICredential = [PSCustomObject]@{
                            name          = $CurrentCredential.name
                            access_token  = $response.access_token 
                            expires_in    = $response.expires_in
                            creation_time = (Get-Date)

                        }
                
                        # Check if the access token for the current credential already exists
                        $existingCredential = $global:HPEGreenLakeSession.comApiAccessToken | Where-Object { $_.name -eq $CurrentCredential.name }
                                
                        if ($existingCredential) {
                            # Remove the existing credential
                            $global:HPEGreenLakeSession.comApiAccessToken.Remove($existingCredential)
                            "[{0}] Previous access token for '{1}' removed!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CurrentCredential.name | Write-Verbose

                        }
                            
                        [void]$global:HPEGreenLakeSession.comApiAccessToken.add($ServiceAPICredential)
                        "[{0}] COM API access token has been set in `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    }

                    if ($CurrentCredential.name -match "GLP-$APIClientCredentialTemplateName") {

                        $ServiceAPICredential = [PSCustomObject]@{
                            name          = $CurrentCredential.name
                            access_token  = $response.access_token 
                            expires_in    = $response.expires_in
                            creation_time = (Get-Date)
                        }

                        # Check if the access token for the current credential already exists
                        $existingCredential = $global:HPEGreenLakeSession.glpApiAccessToken | Where-Object { $_.name -eq $CurrentCredential.name }
                        
                        if ($existingCredential) {
                            # Remove the existing credential
                            $global:HPEGreenLakeSession.glpApiAccessToken.Remove($existingCredential)
                            "[{0}] Previous access token for '{1}' removed!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CurrentCredential.name | Write-Verbose

                        }

                        # Add the new credential
                        [void]$global:HPEGreenLakeSession.glpApiAccessToken.add($ServiceAPICredential)
                        "[{0}] GLP API access token has been set in `$HPEGreenLakeSession.glpApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose


                        # ------------ Create a session for GLP to generate a v1.2 token (used for v2 workspace API) ----------------

                        "[{0}] Create a GLP session to generate a v1.2 token (used for v2 workspace API)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-verbose
                        
                        $WorkspaceId = $HPEGreenLakeSession.workspaceId
                        
                        $tokenIssuerv2uri = $HPEGLAPIbaseURL + "/authorization/v2/oauth2/" + $WorkspaceId + "/token"

                        "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $tokenIssuerv2uri | Write-Verbose
                        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | convertto-json) | Write-Verbose

                        $response2 = Invoke-RestMethod -Method Post -Uri $tokenIssuerv2uri -Body $Payload -ContentType 'application/x-www-form-urlencoded' 

                        "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response2 | Write-verbose

                        # Check if access token is a v1.2 token
                        $token = Get-HPEGLJWTDetails $response2.access_token

                        if ($token.PSObject.Properties.Match("hpe_token_type")) {
                        
                            $tokenVersion = $token.hpe_token_type
                        }
                        else {
                            $tokenVersion = "api-v1.1"
                        }
                        
                        "[{0}] Token version found: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $tokenVersion | Write-verbose

                        if ($tokenVersion -eq "api-v1.2") {
                            
                            $ServiceAPICredential = [PSCustomObject]@{
                                name          = $CurrentCredential.name
                                access_token  = $response2.access_token 
                                expires_in    = $response2.expires_in
                                creation_time = (Get-Date)
                            }
                            
                            # Check if the access token v1.2 for the current credential already exists
                            $existingCredential = $global:HPEGreenLakeSession.glpApiAccessTokenv1_2 | Where-Object { $_.name -eq $CurrentCredential.name }
                            
                            if ($existingCredential) {
                                # Remove the existing credential
                                $global:HPEGreenLakeSession.glpApiAccessTokenv1_2.Remove($existingCredential)
                                "[{0}] Previous access token v1.2 for '{1}' removed!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CurrentCredential.name | Write-Verbose
                            }
                            
                            # Add the new credential
                            [void]$global:HPEGreenLakeSession.glpApiAccessTokenv1_2.add($ServiceAPICredential)
                            "[{0}] GLP API access token v1.2 has been set in `$HPEGreenLakeSession.glpApiAccessTokenv1_2` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        }                   
                        else {
                            $global:HPEGreenLakeSession.glpApiAccessTokenv1_2.Clear()
                            "[{0}] GLP API access token v1.2 has been cleared in `$HPEGreenLakeSession.glpApiAccessTokenv1_2` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        }                                                  

                    }
            
                }
                catch {

                    "[{0}] Exception caught: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose

                    if ($_.ErrorDetails.Message) {
                        Write-Warning $_.ErrorDetails
                    }

                    Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 

                    if ($Connect_HPEGL_ProgressBar) {
                        Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'
        
                    }
                
                    $PSCmdlet.ThrowTerminatingError($_) #.Exception.Message

                }
            }

            $completedSteps++
        }

        #endregion

        
        #Region - Generate $HPECOMjobtemplatesUris if not available and if COM instance present (used to store the URIs of each COM job templates)
        if (-not $HPECOMjobtemplatesUris -and ($HPEGreenLakeSession.apiCredentials | Where-Object application_name -eq "COM" )) {

            "[{0}] ------------------------------------- STEP {1} - Generate `$HPECOMjobtemplatesUris if not available to store the URIs of each COM job templates  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
            
            
            if ($Connect_HPEGL_ProgressBar) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Generating $HPECOMjobtemplatesUris" -Id 1
                
            }
            else {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step $Step / 6 - Generating $HPECOMjobtemplatesUris" -Id 1
            }

            $Step++

            # $FirstProvisionedCOMRegion = $HPEGreenLakeSession.apicredentials | Where-Object application_name -eq COM | Select-Object -first 1 -ExpandProperty region
            # "[{0}] About to retrieve the URIs of each COM job templates in '{1}' COM region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $FirstProvisionedCOMRegion | Write-Verbose
            
            try {
                Set-HPECOMJobTemplatesVariable #-region $FirstProvisionedCOMRegion
                
            }
            catch {
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 
                
                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'
                    
                }
                
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            $completedSteps++        
        }

        #endregion


        #Region - Set the user session idle timeout to 2 hours to prevent disconnection due to inactivity, and save it in the global variable.
    
        If (-Not $Force) {

            "[{0}] ------------------------------------- STEP {1} - Set user session idle timeout in global variable  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
            
            if (-Not $MyWorkspaceName -and -not $NoProgressBar) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step $Step / 3 - Setting user session idle timeout" -Id 1
                
            }
            elseif ($Connect_HPEGL_ProgressBar) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Setting user session idle timeout" -Id 1
                
            }
            else {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step $Step / 6 - Setting user session idle timeout" -Id 1
            }
    
            $Step++
    
            "[{0}] Set user session idle timeout in `$HPEGLworkspaces" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            
            # Get user session idle timeout 
            
            try {
                # Set the user session idle timeout to 2 hours (7200 seconds) to prevent disconnection due to inactivity if less than 2 hours
    
                $UserSessionTimeout = ((Get-HPEGLUserPreference).idle_timeout) / 60
    
                if ( $UserSessionTimeout -lt '120') {
    
                    Set-HPEGLUserPreference -SessionTimeoutInMinutes 120 
                    "[{0}] 120 minutes session idle timeout has been set in `$HPEGreenLakeSession global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                }
                else {
    
                    $Global:HPEGreenLakeSession.userSessionIdleTimeout = $UserSessionTimeout
                    "[{0}] '{1}' minutes session idle timeout has been set in `$HPEGreenLakeSession global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $UserSessionTimeout | Write-Verbose
                }
              
                
            }
            catch {
                Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Failed" -Completed 
                
                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed # progress bar from 'Connect-HPEGL'
                    
                }
                $PSCmdlet.ThrowTerminatingError($_)
            }
    
            $completedSteps++ 
        }
        
        #endregion


        #Region - Get HPE GreenLake schema meta data to get supported timezones and countries at https://onepass-enduserservice.it.hpe.com/v2-get-user-schema-metadata

        if (-not $Force) {
            
            "[{0}] ------------------------------------- STEP {1} - Get HPE GreenLake schema meta data to get HPE GL supported timezones and countries  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Step | Write-Verbose
    
            if (-not $MyWorkspaceName) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step $Step / 3 - Getting HPE GreenLake schema meta data" -Id 1
    
            }
            elseif ($Connect_HPEGL_ProgressBar) {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step $Step / 7 - Getting HPE GreenLake schema meta data" -Id 1
    
            }
            else {
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step $Step / 6 - Getting HPE GreenLake schema meta data" -Id 1
            }
    
            "[{0}] About to make call to fetch HPE GreenLake schema meta data at: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SchemaMetadataURI | Write-Verbose
            
            try {
                $Global:HPEGLSchemaMetadata = Invoke-HPEGLWebRequest -Uri $SchemaMetadataURI -Method Post 
               
            }
            catch {
                Write-Progress -Id 0 -Activity "Connecting to workspace" -Status "Failed" -Completed
                $PSCmdlet.ThrowTerminatingError($_)
            }
    
    
            # Register an argument completer for the TimeZone parameter
            Register-ArgumentCompleter -CommandName 'Set-HPEGLUserAccountDetails' -ParameterName TimeZone -ScriptBlock {
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    
                # Get all available time zone IDs
                $timeZoneIds = $HPEGLSchemaMetadata.definitions.custom.properties.hpeTimezone.enum
    
                # Filter time zone IDs based on input and create completions
                $timeZoneIds | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            }
    
            # Register an argument completer for the Country parameter (removed 'New-HPEGLWorkspace' from the list of commands due to isse when no workspace exits)
            Register-ArgumentCompleter -CommandName 'Set-HPEGLUserAccountDetails', 'Set-HPEGLWorkspace', 'New-HPEGLLocation', 'Set-HPEGLLocation' -ParameterName Country -ScriptBlock {
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    
                # Get all available country codes
                $Countries = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf.title[1..($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf.title.length - 1)]
    
                # Filter country codes based on input and create completions
                $Countries | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    $countryName = $_
            
                    # Check if the country name contains spaces
                    if ($countryName -match "\s") {
                        # Wrap the country name in single quotes
                        $completionText = "'$countryName'"
                    }
                    else {
                        $completionText = $countryName
                    }
            
                    [System.Management.Automation.CompletionResult]::new($completionText, $completionText, 'ParameterValue', $countryName)
                }
            }
    
            $completedSteps++ 
        }
        
        #endregion

            
        # Clear the progress bar upon completion
        Write-Progress -Id 1 -Activity "Connecting to workspace" -Status "Completed" -Completed

        return $HPEGreenLakeSession

    }

}


#EndRegion



#Region ------------------- COM ------------------------------------------------------------------------------------------------------------------------------------------------


#Region --- ACTIVITIES ---

Function Get-HPECOMActivity {
    <#
    .SYNOPSIS
    Retrieve the list of activities.

    .DESCRIPTION
    This Cmdlet returns a collection of the last seven days activities that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ResourceUri
    Optional parameter that can be used to specify the Uri of a resource to display.

    .PARAMETER SourceName
    Optional parameter that can be used to display the activities of a specific source name (e.g. server name, group name, etc).
    
    .PARAMETER Category 
    Optional parameter that can be used to display the activities of a specific category. Auto-completion (Tab key) is supported for this parameter, providing a list of categories.
    
    .PARAMETER ShowLastMonth
    This switch parameter can be used to display the activities of the last month.

    .PARAMETER ShowLastThreeMonths
    This switch parameter can be used to display the activities of the last three months.
    
    .PARAMETER ShowAll
    This switch parameter can be used to display the total number of activities. Be aware, however, that this may take some time, depending on your history.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central

    Return the last seven days activities resources located in the central european region. 

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -ShowLastMonth

    Return the last month activities resources located in the central european region.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SourceName CZJ11105MV 

    Retrieve the last seven days activities resources for a server specified by its serial number.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SourceName CZJ11105MV -ShowLastMonth

    Retrieve the last month activities resources for a server specified by its serial number.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SourceName CZJ11105MV -ShowLastThreeMonths

    Retrieve the last three months activities resources for a server specified by its serial number.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SourceName "ESXi_group" -ShowAll

    Retrieve all activities data for a group specified by its name.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -Category Server

    Retrieve the last seven days activities data for a specific category.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SourceName "ESXi_group" -Category Job

    Retrieve the last seven days activities data for a specific category and a specific server group.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -SourceName ESX-1 | Get-HPECOMActivity 

    Retrieve last seven days activities data for a server named 'ESX-1' in the "eu-central" region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -SourceName CZJ11105MV | Get-HPECOMActivity -ShowLastMonth

    Retrieve last last month activities data for a server with the serial number 'CZJ11105MV' in the "eu-central" region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model 'ProLiant DL385 Gen10 Plus' -ConnectedState True -PowerState ON | Get-HPECOMActivity | Select-Object -First 1

    Retrieve the most recent activity data for all "ProLiant DL385 Gen10 Plus" servers in the "us-west" region that are currently powered on and connected.
       
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Get-HPECOMActivity -ShowLastMonth

    Retrieve last last month activities data for all groups in the "eu-central" region.
    
    .EXAMPLE
    $job = Update-HPECOMServeriLOFirmware -Region eu-central -ServerSerialNumber CZJ1233444 -Async
    $job | Get-HPECOMJob 
    $job | Get-HPECOMActivity 
    $job | Wait-HPECOMJobComplete

    This example retrieves the job resource created by the 'Update-HPECOMServeriLOFirmware' cmdlet in the central EU region.
    Then it retrieves the activity resource associated with the job.
    Then it waits for the job to complete.


    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's names.
    System.Collections.ArrayList
        List of server, group or setting resources retrieved using 'Get-HPECOMServer' or 'Get-HPECOMGroup' or 'Get-HPECOMSetting'.
    System.Collections.ArrayList
        A job from one of the cmdlets creating a job or a list of jobs retrieved using 'Get-HPECOMJob'.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ShowAll')]
    Param( 
    
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'ShowLastMonth')]
        [Parameter (ParameterSetName = 'ShowLastThreeMonths')]
        [Parameter (ParameterSetName = 'ShowAll')]
        # [Alias('associatedResource')]
        [String]$SourceName,

        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ShowLastMonth')] 
        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ShowLastThreeMonths')]
        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ShowAll')]
        [Alias('JobUri', 'JobResourceUri')]
        [string]$ResourceUri,

        [Parameter (ParameterSetName = 'ShowLastMonth')]
        [Parameter (ParameterSetName = 'ShowLastThreeMonths')]
        [Parameter (ParameterSetName = 'ShowAll')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('"External service"', 'Filter', 'Firmware', 'Group', 'Job', '"OneView Appliance"', 'Report', 'Schedule', 'Server', 'Setting', 'Subscription', '"User Preferences"', 'Webhook')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
            $validOptions = @('External service', 'Filter', 'Firmware', 'Group', 'Job', 'OneView Appliance', 'Report', 'Schedule', 'Server', 'Setting', 'Subscription', 'User Preferences', 'Webhook')
            # case sensitive comparison as lower case is not supported for the category
            if ($validOptions -ccontains $_) {
                $True
            }
            else {
                throw "'$_' is not a valid option."
            }
            
            })]
        [String]$Category,
        
        [Parameter (ParameterSetName = 'ShowLastMonth')]
        [Switch]$ShowLastMonth,

        [Parameter (ParameterSetName = 'ShowLastThreeMonths')]
        [Switch]$ShowLastThreeMonths,        

        [Parameter (ParameterSetName = 'ShowAll')]
        [switch]$ShowAll,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $todayMinusSevenDays = (Get-Date).AddDays(-7).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ") 
        $todayMinusOneMonth = (Get-Date).AddMonths(-1).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
        $todayMinusThreeMonths = (Get-Date).AddMonths(-3).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

        # Construct the filter query
        $filterSevenDays = "createdAt gt $todayMinusSevenDays"
        $filterOneMonth = "createdAt gt $todayMinusOneMonth"
        $filterThreeMonths = "createdAt gt $todayMinusThreeMonths"
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        $Uri = $COMActivitiesUri

        # Helper function to add a filter to the URI
        function Add-FilterToUri {
            param (
                [string]$Uri,
                [string]$Filter
            )
            if ($Uri -match "\?") {
                if ($Uri -match "filter") {
                    $Uri + " and $Filter"
                }
                else {
                    $Uri + "&filter=$Filter"
                }
            }
            else {
                $Uri + "?filter=$Filter"
            }
        }

        # Add filters based on parameters
        if ($ResourceUri) {

            
            # Use different filters based on the resourceUri
            # For servers, use associatedServerId
            if ($ResourceUri -match '^/compute-ops-mgmt/[^/]+/servers/[^/]+$') {
                
                # Id of server contains a + sign that needs to be URL-encoded
                $ResourceId = [System.Web.HttpUtility]::UrlEncode($ResourceUri.Split("/")[-1])

                $Uri = Add-FilterToUri -Uri $Uri -Filter "associatedServerId eq '$ResourceId'" 

            }
            # For jobs, use source/resourceUri (in v1beta2) or source/resourceId (in v1 or soon in v1beta2)
            else {

                # encode the resourceId as appliance includes a + sign
                $ResourceId = [System.Web.HttpUtility]::UrlEncode($ResourceUri.Split("/")[-1])
                
                $Uri = Add-FilterToUri -Uri $Uri -Filter "contains(source/resourceUri, '$ResourceId')" # good for v1beta2
                # $Uri = Add-FilterToUri -Uri $Uri -Filter "contains(source/resourceId, '$ResourceId')" # good for v1beta2 (future addition of resourceId in the source object)
                # $Uri = Add-FilterToUri -Uri $Uri -Filter "source/resourceId eq '$ResourceId'" # good for v1
                
                # Not using the following as the source resourceUri is not always the same as the job resourceUri
                # A job created with a specific API version is not identified in Activity with the same job version as initially created.  
                # $Uri = Add-FilterToUri -Uri $Uri -Filter "source/resourceUri eq '$ResourceUri'"
            }

        }
        elseif ($SourceName) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "source/displayName eq '$SourceName'"
        } 
       
        if ($Category) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "source/type eq '$Category'"
        }
        

        # Filter 7 days except for the other cases
        if (-not $ShowAll -and -not $ShowLastMonth -and -not $ShowLastThreeMonths) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterSevenDays
        }
        # Filter 1 month
        elseif ($ShowLastMonth) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterOneMonth
        } 
        # Filter 3 months
        elseif ($ShowLastThreeMonths) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterThreeMonths
        }
        elseif ($ShowAll) {
            # No filter
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }

       
        if ($Null -ne $CollectionList) {     

            # Add formattedmessage to object
            foreach ($Item in $CollectionList) {

                if ($Item.message) {

                    # Decode the Unicode escape sequences in the message as there is usually Unicode Escape Sequence (e.g. \u003c) in the message
                    $_ActivityMessage = [System.Text.RegularExpressions.Regex]::Unescape($Item.message)
                    
                    # Format the message (split the message into an array, filter out the blank lines, and then use the -join operator to join the lines with " - ")
                    $FormattedActivityMessage = ($_ActivityMessage -split "`r?`n" | Where-Object { $_ -ne "" }) 

                    if ($FormattedActivityMessage.Count -gt 1) {
                        $FormattedActivityMessage = $FormattedActivityMessage -join " - "
                    }
                }
                else {
                    $FormattedActivityMessage = $null
                }

                $Item | Add-Member -type NoteProperty -name formattedmessage -value $FormattedActivityMessage
                    
            }

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            # Add job uri to object
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name sourceResourceUri -value $_.source.resourceUri }
            # Add category to object
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name Category -value $_.source.type }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Activities"    
    
            # $ReturnData = $ReturnData | Sort-Object activity, {$_.source.displayname}  # Not required as sorted by date by default
        
            return $ReturnData 
                
        }
        else {

            return
                
        }         
    }
}

#EndRegion


#Region --- APPLIANCES ---

Function Get-HPECOMAppliance {
    <#
    .SYNOPSIS
    Retrieve the list of appliances.
    
    .DESCRIPTION
    This Cmdlet returns a collection of appliance resources in the specified region. 
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.  

    .PARAMETER Name
    Specifies the name of the appliance resource.      

    .PARAMETER IPAddress
    Specifies the IP address of the appliance resource.      

    .PARAMETER Limit 
    This parameter allows you to define the number of appliances to be displayed. 
   
    .PARAMETER Type 
    Optional parameter that can be used to get a certain type of appliances such as HPE Secure Gateway appliances, HPE OneView VM - VMware vSphere appliances, or HPE Synergy Composer appliances.

    .PARAMETER ShowActivationKey
    Optional switch parameter that can be used to display the activation key of the appliance.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central

    Return all appliances in the central european region. 

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Name oneview.hpelab.net

    Return the OneView appliance named 'oneview.hpelab.net' in the central european region. 

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Name oneview.hpelab.net -ShowActivationKey

    Return the activation key for the OneView appliance named 'oneview.hpelab.net' in the central european region.
    
    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Type OneViewVM

    Return data for all HPE OneView VM - VMware vSphere appliances located in the central European region.

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Type SynergyComposer

    Return data for all HPE Synergy Composer appliances located in the central European region.

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Type SecureGateway

    Return data for all HPE Secure Gateway Appliance located in the central European region.

    .EXAMPLE
    Get-HPECOMAppliance -Region us-west -name comgw.lab -ShowActivationKey 

    Return the activation key for the Secure Gateway appliance named 'comgw.lab' in the "us-west" region.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Limit')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'IP')]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or $_ -match [Net.IPAddress]$_ })]
        [string]$IPAddress,

        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$Name,

        [Parameter (ParameterSetName = 'Limit')]
        [ValidateScript({ $_ -le 1000 })]
        [int]$Limit,

        [Parameter (ParameterSetName = 'Limit')]
        [Parameter (ParameterSetName = 'IP')]
        [Parameter (ParameterSetName = 'Name')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('SynergyComposer', 'OneViewVM', 'SecureGateway')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('SynergyComposer', 'OneViewVM', 'SecureGateway')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]                
        [String]$Type,

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (ParameterSetName = 'IP')]
        [Switch]$ShowActivationKey,

        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # No limit by default
        if ($Limit) {

            $Uri = $COMOneViewAppliancesUri + "?limit=$Limit"
       
        } 
        else {
            
            $Uri = $COMOneViewAppliancesUri 
        }           


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {

            "[{0}] Exception object: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_.Exception.data | Out-String) | Write-Verbose

            if ($_.Exception.Data.HttpCode -eq 412) {

                "[{0}] Received 412 error due to missing OneView Edition subscription" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
                Write-Warning "Looks like you do not have a Compute Ops Management - OneView Edition subscription to manage a OneView appliance."
                Return

            }
            else {

                $PSCmdlet.ThrowTerminatingError($_)
            }
        }
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {      

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            
            
            if ($Type) {
                
                switch ($Type) {
                    "SecureGateway" { $_applianceType = "GATEWAY" }
                    "SynergyComposer" { $_applianceType = "SYNERGY" }
                    "OneViewVM" { $_applianceType = "VM" }
                }
                
                $CollectionList = $CollectionList | Where-Object applianceType -eq $_applianceType
            }
            
            
            if ($IPAddress) {
            
                $CollectionList = $CollectionList | Where-Object ipaddress -eq $IPAddress
                  
            } 
            elseif ($Name) {
                
                $CollectionList = $CollectionList | Where-Object name -eq $Name 
                
            }       
            
            if ($CollectionList.applianceType -eq "GATEWAY" -and $ShowActivationKey) {

                try {
                    $ActivationKey = New-HPECOMAppliance -Region $Region -SecureGateway 
                    Return $ActivationKey
                
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
            }
            elseif ($ShowActivationKey) {
                    
                $CollectionList = $CollectionList.activationkey
                return $CollectionList 
                
            }
             

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Appliances"    
    
            $ReturnData = $ReturnData | Sort-Object name, ipaddress
        
            return $ReturnData 
           
        }
        else {

            return
                
        }     

    
    }
}



Function New-HPECOMAppliance {
    <#
    .SYNOPSIS
    Adds an HPE OneView or Secure Gateway appliance for management to a specific region. 

    .DESCRIPTION   
    This cmdlet adds an HPE OneView or Secure Gateway appliance to the specified Compute Ops Management region for management. It generates an activation key that is used to connect the appliance to Compute Ops Management.
    
    For OneView appliances, the activation key can be retrieved using the 'Get-HPECOMAppliance -Name <OV hostname> -ShowActivationKey' cmdlet. 
    This activation key is required to enable Compute Ops Management in OneView using the 'Enable-OVComputeOpsManagement -ActivationKey $ActivationKey' cmdlet from the HPE OneView PowerShell library.

    For Secure Gateway appliances, the same activation key can be used to connect multiple Secure Gateway appliances to Compute Ops Management within 72 hours.

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the appliance will be located.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER SecureGateway    
    Specifies that the appliance to be added is an HPE Secure Gateway appliance. This parameter is mandatory when adding an HPE Secure Gateway appliance.
    
    .PARAMETER OneView    
    Specifies that the appliance to be added is an HPE OneView appliance. This parameter is mandatory when adding an HPE OneView appliance.

    .PARAMETER OneViewID
    Specifies the ID of the OneView appliance to be added to the region. This parameter is mandatory when adding an HPE OneView appliance.

    Note: The OneView ID can be retrieved using the 'Get-OVComputeOpsManagement' cmdlet from the HPE OneView PowerShell library.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    $credentials = Get-Credential
    Connect-OVMgmt -Appliance OV.domain.com -Credential $credentials
    $AddTask = Get-OVComputeOpsManagement | New-HPECOMAppliance -Region eu-central -OneView
    Enable-OVComputeOpsManagement -ActivationKey $AddTask.activationkey
    
    In this example:
    1. Prompts the user to enter their credentials and stores them in the $credentials variable.
    2. Establishes a connection to the OV.domain.com appliance using the Connect-OVMgmt cmdlet, passing the appliance URL (OV.domain.com) and the credentials stored in the $credentials variable.
    3. Retrieves the Compute Ops Management configuration from OneView using the HPE OneView PowerShell library, then pipes the output to add the OneView appliance to the 'eu-central' region.
    4. Activates the Compute Ops Management configuration in OneView using the obtained activation key from the returned $AddTask object with the 'Enable-OVComputeOpsManagement' cmdlet. The activation key is required for enabling Compute Ops Management in OneView.

    .EXAMPLE
    $credentials = Get-Credential
    Connect-OVMgmt -Appliance OV.domain.com -Credential $credentials
    $ApplianceID = (Get-OVComputeOpsManagement).ApplianceID
    $AddTask = New-HPECOMAppliance -Region eu-central -OneView -OneViewID $ApplianceID 
    Enable-OVComputeOpsManagement -ActivationKey $AddTask.activationkey

    In this example:
    1. Prompts the user to enter their credentials and stores them in the $credentials variable.
    2. Establishes a connection to the OV.domain.com appliance using the Connect-OVMgmt cmdlet, passing the appliance URL (OV.domain.com) and the credentials stored in the $credentials variable.
    3. Retrieves the ApplianceID from 'Get-OVComputeOpsManagement'.
    4. Adds the OneView appliance to the 'eu-central' region using the appliance ID.
    5. Activates the Compute Ops Management configuration in OneView using the obtained activation key from the returned $AddTask object with the 'Enable-OVComputeOpsManagement' cmdlet. The activation key is required for enabling Compute Ops Management in OneView.

    .EXAMPLE
    New-HPECOMAppliance -Region us-west -SecureGateway 

    Adds an HPE Secure Gateway appliance to the 'us-west' region and returns the activation key to use in the secure gateway console to connect the appliance to Compute Ops Management.

    .INPUTS
    System.Collections.ArrayList
        OneView appliance details from 'Get-OVComputeOpsManagement' (HPE OneView PowerShell library).

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Region - Name of the region 
        * ApplianceType - Type of the appliance (OneView or Secure Gateway)
        * ID - ID of the OneView appliance attempted to be added to the region
        * ActivationKey - The activation key to be used in the appliance for enabling Compute Ops Management
        * ExpiresOn - The expiration date of the Secure Gateway activation key (72 hours from the time of appliance addition)
        * Status - The status of the addition attempt (Failed for HTTP error return; Complete if addition is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
#>

    [CmdletBinding(DefaultParameterSetName = 'OneView')]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'SecureGateway')]
        [Switch]$SecureGateway,

        [Parameter (Mandatory, ParameterSetName = 'OneView')]
        [Switch]$OneView,
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'OneView')]
        [alias('ApplianceID')]
        [String]$OneViewID,
                  
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $AddApplianceStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        if ($OneView) {

            # Build object for the output
            $objStatus = [pscustomobject]@{
  
                Region        = $Region   
                ApplianceType = "OneView"
                ID            = $OneViewID
                ActivationKey = $Null                         
                Status        = $Null
                Details       = $Null
                Exception     = $Null
            }

            $Uri = $COMOneViewAppliancesUri           
            
            try {
                $CurrentAppliances = Get-HPECOMAppliance -Region $Region 

                $ApplianceSubscrition = Get-HPEGLSubscription -ShowValid -ShowWithAvailableQuantity -ShowServiceSubscriptions | Where-Object { $_.skudescription -match "Compute Ops Management - OneView Edition" }
              
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }

            # Alert if appliance already exists in the region
            if ($CurrentAppliances | Where-Object { $_.ID -eq $OneViewID }) {

                "[{0}] OneView appliance with ID '{1}' is already present in this service instance!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $OneViewID | Write-Verbose
            
                if ($WhatIf) {
                    $ErrorMessage = "OneView appliance '{0}': Resource is already present in the '{1}' region! No action needed." -f $OneViewID, $Region
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "OneView appliance already exists in '$Region' region. No action needed."
                }

            }
            # Error if COM-OVE license is not available
            elseif (-not $ApplianceSubscrition) {

                "[{0}] No Compute Ops Management - OneView Edition license available in the workspace." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            
                if ($WhatIf) {
                    $ErrorMessage = "No Compute Ops Management - OneView Edition license available in the workspace. Please add a license first using 'New-HPEGLSubscription' to add the appliance."
                    Write-warning $ErrorMessage
                    return
                }
                else {
                  
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "No Compute Ops Management - OneView Edition license available in the workspace. Please add a license first using 'New-HPEGLSubscription' to add the appliance."
                }

            }
            else {
                
                # Build payload
                $payload = ConvertTo-Json @{
                    id = $OneViewID
                }          
                      
                # Add resource
                try {
                    $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                                
                    if (-not $WhatIf) {
        
                        "[{0}] Add OneView appliance call response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                            
                        "[{0}] OneView appliance '{1}' successfully added to '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $OneViewID, $Region | Write-Verbose
                                
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Use 'Enable-OVComputeOpsManagement -ActivationKey <activation key>' from the OneView Powershell library to activate the appliance for Compute Ops Management"
                        $objStatus.ActivationKey = $Response.ActivationKey
            
                    }
            
                }
                catch {
            
                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "OneView appliance cannot be added to $Region region!"
                        $objStatus.Exception = $_.Exception.message 
            
                    }
                }   
            }
    
                    
            [void] $AddApplianceStatus.add($objStatus)

        }
        elseif ($SecureGateway) {

            # Build object for the output
            $objStatus = [pscustomobject]@{
  
                Region        = $Region   
                ApplianceType = "Secure Gateway"
                ActivationKey = $Null   
                ExpiresOn     = (get-date).AddHours(72)
                Status        = $Null
                Details       = $Null
                Exception     = $Null
            }

            $Uri = $COMActivationKeysUri

            
            # Build payload
            $payload = ConvertTo-Json @{
                expirationInHours = 72
                targetDevice      = "SECURE_GATEWAY"
            }          
                  
  
            # Add resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                            
                if (-not $WhatIf) {
    
                    "[{0}] Add Secure gateway appliance call response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                        
                    "[{0}] Secure gateway appliance activation key successfully generated for '{1}' region: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, $Response.activationKey | Write-Verbose
                            
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Enter the activation key in the secure gateway console to connect the appliance(s) to Compute Ops Management."
                    $objStatus.ActivationKey = $Response.ActivationKey
        
                }
        
            }
            catch {
        
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Secure gateway appliance activation key cannot be generated!"
                    $objStatus.Exception = $_.Exception.message 
        
                }
            }   
                    
            [void] $AddApplianceStatus.add($objStatus)

        }          
    }

    end {

        if (-not $WhatIf) {

            if ($AddApplianceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more appliances failed to be added to $Region!"
          
            }

            if ($OneView) {

                $AddApplianceStatus = Invoke-RepackageObjectWithType -RawObject $AddApplianceStatus -ObjectName "COM.Appliances.OneView"    
            }
            elseif ($SecureGateway) {

                $AddApplianceStatus = Invoke-RepackageObjectWithType -RawObject $AddApplianceStatus -ObjectName "COM.Appliances.SecureGateway"    
            }

            Return $AddApplianceStatus
        }


    }
}



Function Remove-HPECOMAppliance {
    <#
    .SYNOPSIS
    Remove an appliance from management.

   .DESCRIPTION   
    This cmdlet removes an appliance from a specified Compute Ops Management region. 

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the appliance is located.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the appliance resource.      

    .PARAMETER IPAddress
    Specifies the IP address of the appliance resource.    

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

   .EXAMPLE
    Remove-HPECOMAppliance -Region eu-central -Name oneview.lab
    
    This example removes the appliance named 'oneview.lab' from the eu-central region.
        
    .EXAMPLE
    Remove-HPECOMAppliance -Region eu-central -IPAddress 192.168.1.22

    This example removes the appliance with the IP address '192.168.1.22' from the eu-central region.

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Type SynergyComposer | Remove-HPECOMAppliance 

    This example removes all Synergy Composer appliances from the eu-central region.

    .EXAMPLE
    "192.168.1.10", "192.168.1.20" | Remove-HPECOMAppliance -Region eu-central 

    This example removes the appliances with the IP addresses '192.168.1.10' and '192.168.1.20' from the eu-central region.

    .EXAMPLE
    $ApplianceID = (Get-OVComputeOpsManagement ).ApplianceID
    Remove-HPECOMAppliance -Region eu-central -Hostname $ApplianceID 

    This example removes a OneView appliance from the 'eu-central' region using the appliance ID returned by the 'Get-OVComputeOpsManagement' cmdlet from the HPE OneView PowerShell library. This is typically done for appliances that have not been activated.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the appliance's IP addresses.

    System.Collections.ArrayList
        A list of OneView appliances from 'Get-HPECOMAppliance'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the appliance attempted to be removed from the region
        * Region - Name of the region 
        * Status - The status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - Additional information about the status.
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 

        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Name')]
        [String]$Name,

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'IP')]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or $_ -match [Net.IPAddress]$_ })]
        [string]$IPAddress,
                  
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveApplianceStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Null
            Region    = $Region   
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {

            if ($Name) {
    
                $ParamUsed = $Name
    
                $_Appliance = Get-HPECOMAppliance -Region $Region -Name $Name
            }
            else {
    
                $ParamUsed = $IPAddress
    
                $_Appliance = Get-HPECOMAppliance -Region $Region -IPAddress $IPAddress
    
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        

        $objStatus.name = $ParamUsed

        if (-not $_Appliance) {
                
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Appliance '{0}': Resource cannot be found in the '{1}' region!" -f $ParamUsed, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Appliance cannot be found in the region!"
              
            }

        }
        else {   
            
            $Uri = $_Appliance.resourceUri                    
              
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 
                        
                if (-not $WhatIf) {

                    "[{0}] Remove appliance call response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                    "[{0}] Appliance '{1}' successfully removed from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ParamUsed, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Appliance successfully removed from $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Appliance cannot be removed from $Region region!"
                    $objStatus.Exception = $_.Exception.message 
    
                }
            }   
            
        }

        [void] $RemoveApplianceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveApplianceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more appliances failed to be removed from $Region!"
          
            }

            $RemoveApplianceStatus = Invoke-RepackageObjectWithType -RawObject $RemoveApplianceStatus -ObjectName "COM.objStatus.NSDE"  
            Return $RemoveApplianceStatus
        }


    }
}


#EndRegion


#Region --- APPLIANCE-FIRMWARE-BUNDLES ---

Function Get-HPECOMApplianceFirmwareBundle {
    <#
    .SYNOPSIS
    Retrieve the list of appliance firmware bundles in the specified region.

    .DESCRIPTION
    This Cmdlet returns a collection of appliance firmware bundles that are available to update an appliance.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Version 
    Optional parameter that can be used to display the appliance firmware bundles of a specific version such as 8.6, 8.60 or 8.60.01.

    .PARAMETER LatestVersion 
    Optional parameter that can be used to display the latest appliance firmware bundles version.

    .PARAMETER Type 
    Optional parameter that can be used to display the appliance firmware bundles of a specific type such as VM or Synergy.

    .PARAMETER SupportedUpgrades 
    Optional parameter that works with both -version and -type to show the supported upgrade paths for upgrading an appliance 
    to the specified version.
 
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central 

    Return all appliance firmware bundles data in the central european region. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -Version "8.9" 

    Return all appliance firmware bundles data for a specified version. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -Version "8.9" -Type Synergy

    Return all Synergy appliance firmware bundles data for a specified version. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -LatestVersion

    Return the latest appliance firmware bundles version. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -LatestVersion -Type VM -SupportedUpgrades

    Return the supported upgrade paths for upgrading a VM appliance to the latest version.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Version')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'SupportedUpgrades')]
        [Parameter (ParameterSetName = 'Version', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias("Name")]
        [String]$Version,

        [Parameter (ParameterSetName = 'Latest')]
        [Switch]$LatestVersion,

        [Parameter (ParameterSetName = 'Latest')]
        [Parameter (Mandatory, ParameterSetName = 'SupportedUpgrades')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('Synergy', 'VM')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('Synergy', 'VM')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]
        [String]$Type,

        [Parameter (ParameterSetName = 'Latest')]
        [Parameter (ParameterSetName = 'SupportedUpgrades')]
        [Switch]$SupportedUpgrades,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose    

        $Uri = $COMApplianceFirmwareBundlesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     
                

            if ($Version) {

                $CollectionList = $CollectionList | Where-Object applianceVersion -match $Version

            }   

            if ($Type) {

                $CollectionList = $CollectionList | Where-Object applianceType -match $Type

            }  

            if ($LatestVersion) {

                $Latestversionitems = @()
                $maxNumber = [int]::MinValue

                foreach ($item in $CollectionList) {
                    if ($item.applianceVersion -gt $maxNumber) {
                        $maxNumber = $item.applianceVersion
                        $Latestversionitems = @() 
                        $Latestversionitems += $item
                    } 
                    elseif ($item.applianceVersion -eq $maxNumber) {
                        # If current number matches the max number, add it to the list
                        $Latestversionitems += $item
                    }
                }

                $CollectionList = $Latestversionitems

            }  

            
            if ($SupportedUpgrades) {

                $CollectionList = $CollectionList.supportedUpgrades

            } 

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.ApplianceFirmwareBundles"    
    
            $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- EMAIL NOTIFICATION POLICY ---

Function Get-HPECOMEmailNotificationPolicy {
    <#
    .SYNOPSIS
    Get the email notification policy preference that is applied when servers are activated for management.

    .DESCRIPTION
    This Cmdlet returns the user preferences for the current user that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER SerialNumber
    Specifies the serial number of the server on which the email notification preferences will be retrieved.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMUserPreference -Region us-west

    Return the user preferences for the current user. 

    .EXAMPLE
    Get-HPECOMUserPreference -Region  eu-central -SerialNumber CZ12312312 


    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    
    
   #>
    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$SerialNumber,


        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        if ($SerialNumber) {
            
            try {

                $_server = Get-HPECOMServer -Region $Region -Name $SerialNumber

            }
            catch {
                
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            if (-not $_server) {

                Return

            }
            else {
                
                $_serverId = $_server.id

                "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverId | Write-Verbose

                $Uri = $COMServersUri + "/" + $_serverId + "/notifications"  
                
            }

        }
        else {
            
            $Uri = $COMUserPreferencesUri            
        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction Stop
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            if ($SerialNumber) {
                
                $CollectionList | Add-Member -type NoteProperty -name serialNumber -value $SerialNumber
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.NotificationStatus"    


            }
            else {

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.User.Preferences"    
            }

    
            # $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            Write-Warning "Looks like email notification policy preference has not been configured. See Enable-HPECOMEmailNotificationPolicy"
            return
                
        }     

    
    }
}



Function Enable-HPECOMEmailNotificationPolicy {
    <#
    .SYNOPSIS
    Enable a service instance email notification policy in a region.

    .DESCRIPTION   
    Compute Ops Management supports email notification policies that users can enable for each service instance. When enabled, the email notification policy preference settings are applied when a server is assigned to a service instance.

    HPE GreenLake user account holders can configure an email notification policy for each service instance in a workspace. Notifications are sent to the email address that is associated with the user account that is used to configure the policy.
        
    Note: If a server you configure for automatic support case creation or integration with ServiceNow experiences a supported service event, the support case ID or ServiceNow incident ID is included in the server notification.   
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the email notification preferences will be enabled.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the email notification preferences will be enabled.
    
    Note: Changing the email notification preferences at the individual server level does not reapply the service instance email notification policy.

    Note: Servers managed by HPE OneView are not supported.
        
    .PARAMETER ServiceEventIssues 
    Enables notifications for service events. A service event is a failure requiring an HPE support case and possibly a service repair.
    
    .PARAMETER ServiceEventAndCriticalIssues
    Enables notifications for service events and other critical severity events.

    .PARAMETER ServiceEventAndCriticalAndWarningIssues
    Enables notifications for service events and events of critical or warning severity.

    .PARAMETER DailySummary
    Enables a daily email summarizing the health of all servers configured for daily notifications. This email includes a summary of server health status values and potential actions such as activating or connecting servers, resolving subscription issues, and available firmware updates.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServiceEventIssues -DailySummary

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications (service event issues) and daily summary notifications.
    
    .EXAMPLE
    Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServiceEventAndCriticalIssues

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events and critical issues, without daily summary notifications.

    .EXAMPLE
    Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServerSerialNumber CZ12312312 -ServiceEventAndCriticalAndWarningIssues 

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events and critical issues for the server with serial number 'CZ12312312'.    

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name 'ESX-2.lab' | Enable-HPECOMEmailNotificationPolicy -ServiceEventAndCriticalIssues

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events and critical issues for the server with the name 'ESX-2.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectedState True -Model "ProLiant DL360 Gen10 Plus" | Enable-HPECOMEmailNotificationPolicy -DailySummary 

    Subscribe the user account, used with 'Connect-HPEGL', to daily summary notifications for all servers with the model 'ProLiant DL360 Gen10 Plus' that are connected.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServiceEventIssues

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events for the servers with serial numbers 'CZ12312312' and 'DZ12312312'.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * User - Email address of the current user
        * Server - Serial number of the server on which the email notification preferences will be enabled
        * Region - Name of the region where the email notification preferences will be enabled
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'ServiceEvent')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [alias('serialnumber')]
        [String]$ServerSerialNumber,
        
        [Parameter (ParameterSetName = 'ServiceEvent')]       
        [Switch]$ServiceEventIssues,

        [Parameter (ParameterSetName = 'ServiceEventAndCriticalIssues')]       
        [Switch]$ServiceEventAndCriticalIssues,

        [Parameter (ParameterSetName = 'ServiceEventAndCriticalAndWarningIssues')]       
        [Switch]$ServiceEventAndCriticalAndWarningIssues,

        [Switch]$DailySummary,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
  

        $EnableEmailPreferencesStatus = [System.Collections.ArrayList]::new()

        if ($ServiceEventIssues) {
            $criticalNotification = $true
            $warningNotification = $false
            $criticalNonServiceNotification = $false
        }
        elseif ($ServiceEventAndCriticalIssues) {
            $criticalNotification = $true
            $warningNotification = $false
            $criticalNonServiceNotification = $True
        } 
        elseif ($ServiceEventAndCriticalAndWarningIssues) {
            $criticalNotification = $true
            $warningNotification = $true
            $criticalNonServiceNotification = $True
        
        }
        else {
            $criticalNotification = $false
            $warningNotification = $false
            $criticalNonServiceNotification = $false
        }


        if ($DailySummary) {
            $healthNotification = $True

        }
        else {
            $healthNotification = $False

        }


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       

        # Check if at least one of the switches is used
        if (-not $DailySummary -and -not ($ServiceEventIssues -or $ServiceEventAndCriticalIssues -or $ServiceEventAndCriticalAndWarningIssues)) {
            Write-Error "You must specify either a service event notification or -DailySummary, or both."
            return
        }
                
        if ($ServerSerialNumber) {
            
            try {

                $_server = Get-HPECOMServer -Region $Region -Name $ServerSerialNumber

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            if (-not $_server) {

                # Must return a message if not found                    
                $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $ServerSerialNumber, $Region
                Write-Warning $ErrorMessage

            }
            else {

                $_serverId = $_server.id

                "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverId | Write-Verbose

                try {

                    $_serverNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region -SerialNumber $ServerSerialNumber -WarningAction SilentlyContinue
        
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                    
        
                if ($_serverNotifications) {
    
                    $Uri = $COMServersUri + "/" + $_serverId + "/notifications"

                    $Method = "PUT"
    
                    # Build object for the output
                    $objStatus = [pscustomobject]@{
            
                        Email     = $HPEGreenLakeSession.username
                        Server    = $ServerSerialNumber
                        Region    = $Region                            
                        Status    = $Null
                        Details   = $Null
                        Exception = $Null
                    }

    
                    if (-not $ServiceEventIssues -and -not $ServiceEventAndCriticalIssues -and -not $ServiceEventAndCriticalAndWarningIssues ) {
    
                        $criticalNotification = $_serverNotifications.criticalNotification  
                        $warningNotification = $_serverNotifications.warningNotification
                        $criticalNonServiceNotification = $_serverNotifications.criticalNonServiceNotification
                    }
                  
                    if (-not $DailySummary) {
                        $healthNotification = $_serverNotifications.healthNotification  
                    }
    
                }
                else {
    
                    Write-Error "You cannot specify a server serial number at this time as no user email notification policy exists yet!"
                    return
        
                }
            }
        }
        else {

            try {

                $_userNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region -WarningAction SilentlyContinue
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
                
    
            if ($_userNotifications) {

                $Uri = $COMUserPreferencesUri + "/" + $_userNotifications.id
                $Method = "PUT"

                if (-not $ServiceEventIssues -and -not $ServiceEventAndCriticalIssues -and -not $ServiceEventAndCriticalAndWarningIssues ) {

                    $criticalNotification = $_userNotifications.criticalNotification  
                    $warningNotification = $_userNotifications.warningNotification
                    $criticalNonServiceNotification = $_userNotifications.criticalNonServiceNotification
                }
              
                if (-not $DailySummary) {
                    $healthNotification = $_userNotifications.healthNotification  
                }

            }
            else {

                $Uri = $COMUserPreferencesUri
                $Method = "POST"
    
            }

            # Build object for the output
            $objStatus = [pscustomobject]@{

                Email     = $HPEGreenLakeSession.username
                Server    = "All unless an individual definition has been configured"
                Region    = $Region                            
                Status    = $Null
                Details   = $Null
                Exception = $Null
            }
        }
        
        $Payload = @{
            criticalNotification           = $criticalNotification
            criticalNonServiceNotification = $criticalNonServiceNotification 
            warningNotification            = $warningNotification
            healthNotification             = $healthNotification
        }   




        # Convert the hashtable to JSON
        $jsonPayload = $Payload | ConvertTo-Json


        # Set resource
        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method $Method -body $jsonPayload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                
            if (-not $WhatIf) {

                "[{0}] Email notification policy modification raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Email notification policy successfully modified in '{1}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Email notification policy successfully modified in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Email notification policy cannot be modified!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           
        

        [void] $EnableEmailPreferencesStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            $EnableEmailPreferencesStatus = Invoke-RepackageObjectWithType -RawObject $EnableEmailPreferencesStatus -ObjectName "COM.User.Preferences.NSDE"               
            Return $EnableEmailPreferencesStatus
        }


    }
}



Function Disable-HPECOMEmailNotificationPolicy {
    <#
    .SYNOPSIS
    Disable a service instance email notification policy in a region.

    .DESCRIPTION   
    This Cmdlet disables email notification policies for a specified service instance within a designated region.
    
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the email notification preferences will be disabled.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER SerialNumber
    Specifies the serial number of the server on which the email notification preferences will be disabled.
    
    Note: Changing the email notification preferences at the individual server level does not reapply the service instance email notification policy.

    Note: Servers managed by HPE OneView are not supported.
        
    .PARAMETER AllServiceEvents
    Disables all notifications for service events and issues. 
    
    .PARAMETER DailySummary
    Disables the daily email summary.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    Disable-HPECOMEmailNotificationPolicy -Region eu-central  -AllServiceEvents -DailySummary

    Unsubscribe the user account, used with 'Connect-HPEGL', from all server notifications and the daily summary notifications.

    .EXAMPLE
    Disable-HPECOMEmailNotificationPolicy -Region eu-central -SerialNumber CZ12312312 -AllServiceEvents

    Unsubscribe the user account, used with 'Connect-HPEGL', from all server notifications for the server with serial number 'CZ12312312'.    

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name 'ESX-2.lab' | Disable-HPECOMEmailNotificationPolicy -DailySummary

    Unsubscribe the user account, used with 'Connect-HPEGL', from the daily summary notifications for the server with the name 'ESX-2.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectedState True -Model "ProLiant DL360 Gen10 Plus" | Disable-HPECOMEmailNotificationPolicy -DailySummary 

    Unsubscribe the user account, used with 'Connect-HPEGL', from the daily summary notifications for all servers with the model 'ProLiant DL360 Gen10 Plus' that are connected.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Disable-HPECOMEmailNotificationPolicy -Region eu-central -AllServiceEvents

    Unsubscribe the user account, used with 'Connect-HPEGL', from all server notifications for the servers with serial numbers 'CZ12312312' and 'DZ12312312'.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * User - Email address of the current user
        * Server - Serial number of the server on which the email notification preferences will be disabled
        * Region - Name of the region where the email notification preferences will be disabled
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [alias('serialnumber')]
        [String]$ServerSerialNumber,
        
        [Switch]$AllServiceEvents,
        
        [Switch]$DailySummary,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $DisableEmailPreferencesStatus = [System.Collections.ArrayList]::new()

        if ($AllServiceEvents) {
            $criticalNotification = $false
            $warningNotification = $false
            $criticalNonServiceNotification = $false
        }

       
        if ($DailySummary) {
            $healthNotification = $False

        }


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        # Check if at least one of the switches is used
        if (-not $AllServiceEvents -and -not $DailySummary) {
            Write-Error "You must specify either -AllServiceEvents, -DailySummary, or both."
            return
        }
    
        if ($ServerSerialNumber) {
            
            try {

                $_server = Get-HPECOMServer -Region $Region -Name $ServerSerialNumber

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            if (-not $_server) {

                # Must return a message if not found
                $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $ServerSerialNumber, $Region
                Write-Warning $ErrorMessage

            }
            else {

                $_serverId = $_server.id

                "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverId | Write-Verbose


                try {

                    $_serverNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region -SerialNumber $ServerSerialNumber -WarningAction SilentlyContinue
        
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                    
        
                if ($_serverNotifications) {
    
                    $Uri = $COMServersUri + "/" + $_serverId + "/notifications"

                    $Method = "PUT"
    
                    # Build object for the output
                    $objStatus = [pscustomobject]@{
            
                        Email     = $HPEGreenLakeSession.username
                        Server    = $ServerSerialNumber
                        Region    = $Region                            
                        Status    = $Null
                        Details   = $Null
                        Exception = $Null
                    }

    
                    if (-not $ServiceEventIssues -and -not $ServiceEventAndCriticalIssues -and -not $ServiceEventAndCriticalAndWarningIssues ) {
    
                        $criticalNotification = $_serverNotifications.criticalNotification  
                        $warningNotification = $_serverNotifications.warningNotification
                        $criticalNonServiceNotification = $_serverNotifications.criticalNonServiceNotification
                    }
                  
                    if (-not $DailySummary) {
                        $healthNotification = $_serverNotifications.healthNotification  
                    }
    
                }
                else {
    
                    Write-Error "You cannot specify a server serial number at this time as no user email notification policy exists yet!"
                    return
        
                }
               
            }
        }
        else {

            try {

                $_userNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region -WarningAction SilentlyContinue
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
                
    
            if ($_userNotifications) {

                $Uri = $COMUserPreferencesUri + "/" + $_userNotifications.id
                $Method = "PUT"

                if (-not $AllServiceEvents) {

                    $criticalNotification = $_userNotifications.criticalNotification  
                    $warningNotification = $_userNotifications.warningNotification
                    $criticalNonServiceNotification = $_userNotifications.criticalNonServiceNotification
                }

                if (-not $DailySummary) {
                    $healthNotification = $_userNotifications.healthNotification  
                }

            }
            else {

                $Uri = $COMUserPreferencesUri
                $Method = "POST"

    
            }

            # Build object for the output
            $objStatus = [pscustomobject]@{

                Email     = $HPEGreenLakeSession.username
                Server    = "All unless an individual definition has been configured"
                Region    = $Region                            
                Status    = $Null
                Details   = $Null
                Exception = $Null
            }
        }
        
        $Payload = @{
            criticalNotification           = $criticalNotification
            criticalNonServiceNotification = $criticalNonServiceNotification 
            warningNotification            = $warningNotification
            healthNotification             = $healthNotification
        }   


        # Convert the hashtable to JSON
        $jsonPayload = $Payload | ConvertTo-Json


        # Set resource
        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method $Method -body $jsonPayload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                
            if (-not $WhatIf) {

                "[{0}] Email notification policy modification raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Email notification policy successfully modified in '{1}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Email notification policy successfully modified in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Email notification policy cannot be modified!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           
        

        [void] $DisableEmailPreferencesStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {
           
            $DisableEmailPreferencesStatus = Invoke-RepackageObjectWithType -RawObject $DisableEmailPreferencesStatus -ObjectName "COM.User.Preferences.NSDE"               
            Return $DisableEmailPreferencesStatus
        }


    }
}


#EndRegion


#Region --- EXTERNAL-SERVICES ---

Function Get-HPECOMExternalService {
    <#
    .SYNOPSIS
    Retrieve the list of external services configured.

    .DESCRIPTION
    This Cmdlet returns a collection of external services configured that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Name of an external services resource.

    .PARAMETER ServiceType
    Specifies the type of external service to retrieve. The available options are 'SERVICE_NOW' and 'DSCC'.
   
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central

    Return all external services configured in the central european region. 

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central -name MyServiceNow

    Return the external services 'MyServiceNow' configured in the central european region. 

    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$Name,

        [ValidateSet("SERVICE_NOW", "DSCC")]
        [String]$ServiceType,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $Uri = $COMExternalServicesUri

        if ($ServiceType -eq "SERVICE_NOW") {
            $Uri = $Uri + "?filter=serviceType eq 'SERVICE_NOW'"
        }
        elseif ($ServiceType -eq "DSCC") {
            $Uri = $Uri + "?filter=serviceType eq 'DSCC'"    
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            if ($Name) {
                $CollectionList = $CollectionList | Where-Object name -eq $Name

            }
                
            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.ExternalServices"    
    
            $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

Function New-HPECOMExternalService {
    <#
    .SYNOPSIS
    Deploy an external service application in a specified region.

    .DESCRIPTION
    This cmdlet deploys either a ServiceNow or Data Services Cloud Console (DSCC) external service application in a specified region.
    - The ServiceNow integration enables COM to automatically create incidents in ServiceNow when iLOs report hardware-related service events.
    - The Data Services Cloud Console (DSCC) integration allows COM to configure and manage external storage.

    .PARAMETER Name 
    Name of the external service application to deploy. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) to deploy the external web service. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ServiceNow
    Switch parameter to specify the deployment of a ServiceNow integration.
    
    .PARAMETER DSCC
    Switch parameter to specify the deployment of a Data Services Cloud Console integration

    .PARAMETER Description 
    Parameter to specify a description. 

    .PARAMETER Credential 
    Parameter to specify the credential (clientID and client secret) of the external service. 

    .PARAMETER RefreshToken 
    Parameter to specify the refresh token of the external web service. 
 
    .PARAMETER OauthUrl 
    Authentication URL of the external web service to obtain OAuth tokens. 

    .PARAMETER IncidentUrl 
    Incident URL of the external web service that is used to create incidents.
    
    .PARAMETER RefreshTokenExpiryInDays 
    Parameter to specify the number of days after which the refresh token will expire.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    $ExternalServiceCredential = Get-Credential -Message "Enter your clientID and clientSecret"
    New-HPECOMExternalService -Name MyServiceNow -Region eu-central -Description "This is my ServiceNow integration" -Credential $ExternalServiceCredential -RefreshToken "541646646434684343" -OauthUrl "https://example.service-now.com/oauth_token.do" -IncidentUrl "https://example.service-now.com/api/now/import/u_demo_incident_inbound_api" -refreshTokenExpiryInDays 100 
    
    Create a ServiceNow integration in the central EU region. 

    .EXAMPLE
    $DSCCcredentials = Get-Credential -Message "Enter your clientID and clientSecret"
    New-HPECOMExternalService -Region eu-central -DSCC -Name "Data Services Cloud Console integration" -Description "This is my DSCC service in US-West" -DSCCRegion us-west -Credential $DSCCcredentials

    Create in the central EU region a Data Services Cloud Console integration configured in the US-west region.

    .INPUTS
    Pipeline input is not supported

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be deployed
        * Region - Name of the region where the external service is deployed
        * Status - Status of the deployment attempt (Failed for http error return; Complete if deployment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'ServiceNow')]
    Param( 
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [Parameter(Mandatory, ParameterSetName = 'ServiceNow')]
        [switch]$ServiceNow,

        [Parameter(Mandatory, ParameterSetName = 'DSCC')]
        [switch]$DSCC,

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Description,

        [Parameter (Mandatory)]
        [PSCredential]$Credential,

        [Parameter (Mandatory, ParameterSetName = 'ServiceNow')]
        [String]$RefreshToken,

        [Parameter (Mandatory, ParameterSetName = 'ServiceNow')]
        [String]$OauthUrl,

        [Parameter (Mandatory, ParameterSetName = 'ServiceNow')]
        [String]$IncidentUrl,

        [Parameter (Mandatory, ParameterSetName = 'ServiceNow')]
        [ValidateRange(100, 365)]
        [Int]$RefreshTokenExpiryInDays,

        [Parameter (Mandatory, ParameterSetName = 'DSCC')]
        [String]$DSCCRegion,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMExternalServicesUri  
        $DeployExternalServiceStatus = [System.Collections.ArrayList]::new()

        $AuthenticationType = "OAUTH"

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name        = $Name
            ServiceType = $Null
            Region      = $Region                            
            Status      = $Null
            Details     = $Null
            Exception   = $Null
        }

        try {
            $ExternalServiceResource = Get-HPECOMExternalService -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($ExternalServiceResource) {

            "[{0}] External service '{1}' already exists in '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "External service '{0}': Resource already exists in the '{1}' region! No action needed." -f $OneViewID, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "External service already exists in the region! No action needed."

            }

        }
        else {

            $ClientID = $Credential.UserName
            $clientSecret = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password))
    
            if ($ServiceNow) {            
    
                $ServiceType = "SERVICE_NOW"
    
                $Authentication = @{
                    clientId     = $ClientID
                    clientSecret = $clientSecret
                    refreshToken = $RefreshToken
                }
    
                $ServiceData = @{
                    oauthUrl                 = $OauthUrl
                    incidentUrl              = $IncidentUrl
                    refreshTokenExpiryInDays = $refreshTokenExpiryInDays
                }           
            }
            # ServiceType is DSCC
            else {
    
                $ServiceType = "DSCC"
    
                $Authentication = @{
                    clientId     = $ClientID
                    clientSecret = $clientSecret
                }
    
                $ServiceData = @{
                    region = $DSCCRegion       
                }           
            }
    
            $objStatus.ServiceType = $ServiceType 
    
            # Build payload
            $payload = ConvertTo-Json @{
                name               = $Name
                serviceType        = $ServiceType 
                authenticationType = $authenticationType
                description        = $Description
                authentication     = $Authentication
                serviceData        = $ServiceData
            }
    
    
            # Deploy the external service. 
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 
    
                
                if (-not $WhatIf) {
    
                    "[{0}] '{1}' external service creation raw response: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceType, $Response | Write-Verbose
    
                    do {
                        $ExternalService_status = (Get-HPECOMExternalService -Region $Region | Where-Object name -eq $Name ).status
                        Start-Sleep 1
                    } until ($ExternalService_status -eq "ENABLED")
                    
                    "[{0}] '{1}' external service successfully deployed in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External service successfully deployed in $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External service cannot be deployed!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }


        [void] $DeployExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($DeployExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more external services failed the deployment attempt!"
          
            }
            
            
            $DeployExternalServiceStatus = Invoke-RepackageObjectWithType -RawObject $DeployExternalServiceStatus -ObjectName "COM.ExternalServices.NSDE"   
            Return $DeployExternalServiceStatus
        }


    }
}

Function Remove-HPECOMExternalService {
    <#
    .SYNOPSIS
    Remove a ServiceNow application in a region.

    .DESCRIPTION
    This Cmdlet can be used to remove the ServiceNow application in a region.    
        
    .PARAMETER Name 
    Name of the ServiceNow application to remove. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where to remove ServiceNow. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMExternalService -Region eu-central -Name 'MyServiceNow_Name' 
    
    Remove the ServiceNow integration from the central EU region. 

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name  | Remove-HPECOMExternalService 

    Remove the ServiceNow integration 'MyServiceNow_Name' from the central EU region. 

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central | Remove-HPECOMExternalService 

    Remove from the central EU region all external services returned by the 'Get-HPECOMExternalService' cmdlet. 

    .INPUTS
    System.Collections.ArrayList
        List of external service(s) from 'Get-HPECOMExternalService'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be removed
        * Region - Name of the region where the external service is removed
        * Status - Status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveExternalServiceStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
            $ExternalServicesResource = Get-HPECOMExternalService -Region $Region -Name $Name
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name        = $Name
            Region      = $Region    
            ServiceType = $ExternalServicesResource.ServiceType                       
            Status      = $Null
            Details     = $Null
            Exception   = $Null
        }
                     
        $ExternalServiceID = $ExternalServicesResource.id
        
        if (-not $ExternalServiceID) {
            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "External service '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be found in the region!"

            }
        }
        else {
            
            $Uri = $COMExternalServicesUri + "/" + $ExternalServiceID

            # Deploy the external service. 
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] External service removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] External service '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External service successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External service cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more external services has failed!"

          
            }
            
            $RemoveExternalServiceStatus = Invoke-RepackageObjectWithType -RawObject $RemoveExternalServiceStatus -ObjectName "COM.ExternalServices.NSDE"   
            Return $RemoveExternalServiceStatus
        }


    }
}

Function Set-HPECOMExternalService {
    <#
    .SYNOPSIS
    Updates an external services item in a specified region.

    .DESCRIPTION
    This Cmdlet modifies the ServiceNow application settings in a specified region. If a parameter is not provided, the cmdlet retains the current setting and only updates the provided parameters.
            
    .PARAMETER Name 
    Specifies the name of the external web service to update. 

    .PARAMETER NewName
    Specifies the new name for the external web service.
        
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the external web service is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Description 
    Specifies a description for the external web service. 

    .PARAMETER Credential 
    Specifies the credentials (clientID and client secret) of the external web service. 

    .PARAMETER RefreshToken 
    Specifies the refresh token of the external web service. 
    
    .PARAMETER OauthUrl 
    Specifies the authentication URL of the external web service used to obtain OAuth tokens. 

    .PARAMETER IncidentUrl 
    Specifies the incident URL of the external web service that is used to create incidents.
        
    .PARAMETER RefreshTokenExpiryInDays 
    Specifies the number of days after which the refresh token will expire.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request, useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name -NewName MyServiceNow_for_COM -Description "This is my new description" -Credential $credentials -RefreshToken "541646646434684343" 

    Updates the external service 'MyServiceNow_Name' in the 'eu-central' region with a new name 'MyServiceNow_for_COM' and a new description.
    
    .EXAMPLE
    Set-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name -Description "This is my new description" -Credential $credential -RefreshToken "541646646434684343" -OauthUrl "https://example.service-now.com/oauth_token.do" -IncidentUrl "https://example.service-now.com/api/now/import/u_demo_incident_inbound_api" -RefreshTokenExpiryInDays 200
        
    Updates the external service 'MyServiceNow_Name' in the central EU region with new parameters.

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name | Set-HPECOMExternalService -Description "This is my new description" -Credential $credential -RefreshToken "541646646434684343" -OauthUrl "https://example.service-now.com/oauth_token.do" -IncidentUrl "https://example.service-now.com/api/now/import/u_demo_incident_inbound_api" -RefreshTokenExpiryInDays 150

    Updates the external service 'MyServiceNow_Name' in the central EU region with new parameters.

    .INPUTS
    System.Collections.ArrayList
        List of external service(s) from 'Get-HPECOMExternalService'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be updated
        * Region - Name of the region where the external service is updated
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if modification is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,

        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Description,

        [Parameter (Mandatory)]
        [PSCredential]$Credential,

        [Parameter (Mandatory)]
        [String]$RefreshToken,

        # [Parameter (Mandatory)]
        [String]$OauthUrl,

        # [Parameter (Mandatory)]
        [String]$IncidentUrl,

        # [Parameter (Mandatory)]
        [ValidateRange(100, 365)]
        [Int]$RefreshTokenExpiryInDays,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetExternalServiceStatus = [System.Collections.ArrayList]::new()

        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
            
            $ExternalServicesResource = Get-HPECOMExternalService -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name        = $Name
            ServiceType = $ExternalServicesResource.ServiceType                       
            Region      = $Region                            
            Status      = $Null
            Details     = $Null
            Exception   = $Null
        }

        $ExternalServiceID = $ExternalServicesResource.id

        
        if (-not $ExternalServiceID) {
            # Must return a message if not found
            if ($WhatIf) {
                            
                $ErrorMessage = "External service '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be found in the region!"
            }
        }
        else {
            
            $Uri = $COMExternalServicesUri + "/" + $ExternalServiceID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }
                       
            if (-not $PSBoundParameters.ContainsKey('Description')) {
	
                if ($ExternalServicesResource.description) {
                       
                    $Description = $ExternalServicesResource.description

                }
                else {
                    $Description = $Null
                }
            }


            if (-not $OauthUrl) {
                $OauthUrl = $ExternalServicesResource.serviceData.oauthUrl
            }

            if (-not $IncidentUrl) {
                $IncidentUrl = $ExternalServicesResource.serviceData.incidentUrl
            }

            if (-not $refreshTokenExpiryInDays) {
                $refreshTokenExpiryInDays = $ExternalServicesResource.serviceData.refreshTokenExpiryInDays
            }

            # Deploy the external service. 
                     
            $ClientID = $Credential.UserName
            $clientSecret = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password))

            $Authentication = @{
                clientId     = $ClientID
                clientSecret = $clientSecret
                refreshToken = $RefreshToken
            }



            $ServiceData = @{
                oauthUrl                 = $OauthUrl
                incidentUrl              = $IncidentUrl
                refreshTokenExpiryInDays = $refreshTokenExpiryInDays
            }

            # Build payload
            $payload = ConvertTo-Json @{
                name           = $Name
                state          = "ENABLED"
                description    = $Description
                authentication = $Authentication
                serviceData    = $ServiceData
            }

        

            # Deploy the external service. 
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] External service update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] External service '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External service successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External service cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $SetExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more external service failed the update attempt!"
          
            }
            
            $SetExternalServiceStatus = Invoke-RepackageObjectWithType -RawObject $SetExternalServiceStatus -ObjectName "COM.ExternalServices.NSDE"   
            Return $SetExternalServiceStatus
        }


    }
}

Function Test-HPECOMExternalService {
    <#
    .SYNOPSIS
    Generate a test incident in a region.

    .DESCRIPTION
    This Cmdlet can be used to generate a test incident in a region. For external service with serviceType as SERVICE_NOW, the cmdlet will generate a test incident for ServiceNow.
    For external service with serviceType as DSCC, the cmdlet will test the integration connection to Data Services Cloud Console. 
       
    An activity will be generated as a result of this test and indicates the success or failure of creating the test incident.   
        
    .PARAMETER Name 
    Name of the external web service to test. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) to update the external web service. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Test-HPECOMExternalServiceServiceNow -Region eu-central -Name MyServiceNow_Name
    
    Generate a test incident for ServiceNow.

    .EXAMPLE
    Test-HPECOMExternalServiceServiceNow -Region eu-central  | Test-HPECOMExternalService 

    Generate a test incident for ServiceNow.

    .INPUTS
    System.Collections.ArrayList
        List of external service(s) from 'Get-HPECOMExternalService'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be tested
        * Region - Name of the region where the external services is tested
        * Status - Status of the testing attempt (Failed for http error return; Complete if testing is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $TestExternalServiceStatus = [System.Collections.ArrayList]::new()

        $_Date = Get-Date

        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
            
            $ExternalServicesResource = Get-HPECOMExternalService -Region $Region -Name $Name 
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name        = $Name
            ServiceType = $ExternalServicesResource.ServiceType                       
            Region      = $Region                            
            Status      = $Null
            Details     = $Null
            Exception   = $Null
        }

        $ExternalServiceID = $ExternalServicesResource.id

        
        if (-not $ExternalServiceID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "External service '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be found in the region!"
            }

        }
        else {
            
            $Uri = $COMExternalServicesUri + "/" + $ExternalServiceID + "/test"

            # Generate a test incident 
                     
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -ContentType 'application/json' -Body (@{} | ConvertTo-Json) -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] External service test raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Test incident '{1}' has been successfully generated for ServiceNow in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Test incident has been successfully generated for ServiceNow in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Test incident cannot be generated for ServiceNow"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $TestExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($TestExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more ServiceNow test attempts failed!"
          
            }

            do {
                $_Activity = Get-HPECOMActivity -Region eu-central -Name 'External service test' -Category "External service" | Where-Object { $_.createdAt.addHours($HPEGLGMTTimeDifferenceInHour) -gt $_Date } 
                
            } until ($_Activity)

            $TestExternalServiceStatus = Invoke-RepackageObjectWithType -RawObject $TestExternalServiceStatus -ObjectName "COM.ExternalServices.NSDE"   
            Write-Host $TestExternalServiceStatus.details -ForegroundColor Green
            Return  $_Activity
        }


    }
}

#EndRegion


#Region --- FILTERS ---

Function Get-HPECOMFilter {
    <#
    .SYNOPSIS
    Retrieve the list of saved filter resources.

    .DESCRIPTION
    This Cmdlet returns a collection of saved filters that have been saved in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name 
    Optional parameter that can be used to specify the name of a saved filter to display.

    .PARAMETER MatchingResources 
    Optional switch parameter that can be used with -Name to get ressources matching a saved filter.

    .PARAMETER Filterableproperties 
    Optional switch parameter that can be used to get information about resource properties usable in saved filters.
   
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMFilter -Region eu-central

    Return all saved filter resources located in the central european region. 

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name gen11 

    Return the saved filter resource named 'gen11' located in the Central European region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name gen11 -MatchingResources 

    Return all ressources matching the saved filter named 'gen11'.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Filterableproperties 

    Return information about resource properties usable in saved filters. 

    .INPUTS
    No pipeline support

   
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (Mandatory, ParameterSetName = 'MatchingResources')]
        [String]$Name,

        [Parameter (ParameterSetName = 'MatchingResources')]
        [Switch]$MatchingResources,

        [Parameter (ParameterSetName = 'Filterableproperties')]
        [Switch]$Filterableproperties,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      
        
        if ($Filterableproperties) {
            $Uri = $COMFiltersUri + "/properties"
            
        }
        elseif ($MatchingResources) {

            $Uri = $COMFiltersUri

            try {
                [Array]$FilterList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                $FilterID = $FilterList | Where-Object { $_.name -eq $Name } | ForEach-Object id

                "[{0}] ID found for filter '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $FilterID | Write-Verbose

                if ($Null -eq $FilterID) { Throw "Filter with this name cannot be found!" }

                $Uri = $COMFiltersUri + "/" + $FilterID + "/matches"


            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        else {
            $Uri = $COMFiltersUri
            
        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            if ($name -and -not $MatchingResources) {

                $CollectionList = $CollectionList | Where-Object name -eq $Name

            }   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
          
            if ($MatchingResources) {
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Filters.MatchingResources"    
                
            }
            elseif ($Filterableproperties) {
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Filters.Filterableproperties"    
                
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Filters"    
    
                $ReturnData = $ReturnData | Sort-Object name
            }

            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function New-HPECOMFilter {
    <#
    .SYNOPSIS
    Create a new saved filter resource in a region.

    .DESCRIPTION
    This Cmdlet can be used to create a new saved filter.    
        
    .PARAMETER Name 
    Name of the external web service to deploy. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) to deploy the external web service. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Filter  
    Parameter to specify a server filter expression such as "serverGeneration eq 'GEN_11'", "state/connected eq 'false"
    The filter grammar is a subset of OData 4.0 using 'eq', 'ne', 'gt', 'ge', 'lt', 'le' and 'in' operations 
    and 'and', 'or' logics.

    Servers can be filtered by:
        - biosFamily
        - createdAt
        - firmwareBundleUri
        - hardware and all nested properties
        - host and all nested properties
        - id
        - name
        - oneview and all nested properties
        - platformFamily
        - processorVendor
        - resourceUri
        - serverGeneration
        - state and all nested properties
    
        See https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/openapi/compute-ops-mgmt-latest/operation/get_v1beta2_servers/#tag/servers-v1beta2/operation/get_v1beta2_servers!in=query&path=filter&t=request

    
    .PARAMETER FilterTags 
    Parameter to specify a tag filter expression such as 'Location' eq 'Houston', 'App' eq 'RHEL'.
    
    .PARAMETER Description 
    Optional parameter to describe the filter. 
    
    .PARAMETER EnabledForRRP
    Parameter to Flag the filter for use with scope-based access control (SBAC) used by resource restriction policies in HPE GreenLake.
    Only administrators with full access to all scopes can create, edit, or delete RRP-enabled filters. The use of some resource properties may be disallowed in RBAC-enabled filters.
 
    .PARAMETER DryRun 
    Switch parameter to not create the saved filter but instead to perform validation of the filter name and syntax as if creating the filter.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMFilter -Region us-west -Name Gen11 -EnabledForRRP -Description "Filter for Gen11 servers" -Filter "serverGeneration eq 'GEN_11'"
    
    Create a new saved filter named 'Gen11' in the central western US region using the property 'serverGeneration' equal to 'GEN_11'" to create the filter. 
    Also flags the filter for use with resource restriction policies used by scope-based access control (SBAC) (can be created using New-HPEGLResourceRestrictionPolicy).

    .EXAMPLE
    New-HPECOMFilter -Region us-west -Name Gen11-RHEL-Workload-Dev -Filter "serverGeneration in ('GEN_11') and host/osName in ('Red Hat Enterprise Linux')" -FilterTags "'Workload' eq 'Dev' and 'Location' eq 'Paris'" 
    
    Create a new saved filter named 'Gen11-RHEL-Workload-Dev' in the central western US region using multiple filters properties and multiple filter tags properties to create the filter. 
    
    .EXAMPLE
    New-HPECOMFilter -Region us-west -Name Powered-Off-servers -Filter "hardware/powerState eq 'OFF'" -DryRun

    Perform validation of the filter name and syntax of a new filter using the property 'hardware/powerState' equal to 'OFF'". 

    .INPUTS
    Pipeline input is not supported

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the filter attempted to be created
        * Region - Name of the region where to create the filter
        * Status - Status of the creation attempt (Failed for http error return; Complete if creation is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,
        
        [Parameter (Mandatory)] 
        [String]$Filter,
        
        [String]$FilterTags,
        
        [String]$Description,
        
        [switch]$EnabledForRRP,
     
        [switch]$DryRun,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $CreateFilterStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($DryRun) {
            $Uri = $COMFiltersUri + "?dry-run=true"
        }
        else {
            $Uri = $COMFiltersUri
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $FilterResource = Get-HPECOMFilter -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($FilterResource) {

            "[{0}] Filter '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Filter '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Filter already exists in the region! No action needed."
            }
        }
        else {

            # Build payload
            if ($FilterTags -and -not $Filter) {
    
                $payload = ConvertTo-Json @{
                    name               = $Name
                    description        = $Description
                    filterResourceType = "compute-ops-mgmt/server"
                    enabledForRRP      = [bool]$EnabledForRRP
                    filterTags         = $FilterTags
                }
            }
            elseif ($FilterTags -and $Filter) {
    
                $payload = ConvertTo-Json @{
                    name               = $Name
                    description        = $Description
                    filterResourceType = "compute-ops-mgmt/server"
                    enabledForRRP      = [bool]$EnabledForRRP
                    filterTags         = $FilterTags
                    filter             = $Filter
                }
            }
            else {
    
                $payload = ConvertTo-Json @{
                    name               = $Name
                    description        = $Description
                    filterResourceType = "compute-ops-mgmt/server"
                    enabledForRRP      = [bool]$EnabledForRRP
                    filter             = $Filter
                }
                
            }
    
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 
    
                
                if (-not $WhatIf) {
    
                    "[{0}] Filter creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                    "[{0}] Filter '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Filter successfully created in $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $CreateFilterStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($CreateFilterStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more filters failed the creation attempt!"
          
            }
            
            $CreateFilterStatus = Invoke-RepackageObjectWithType -RawObject $CreateFilterStatus -ObjectName "COM.objStatus.NSDE"  
            Return $CreateFilterStatus
        }


    }
}


Function Remove-HPECOMFilter {
    <#
    .SYNOPSIS
    Removes a saved filter resource from a specified region.

    .DESCRIPTION
    This Cmdlet removes a saved filter resource from a specific region using its name property.

    .PARAMETER Name 
    The name of the saved filter to remove. 

    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the saved filter should be removed.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of executing the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMFilter -Region eu-central -Name 'Gen11' 
    
    Removes the saved filter named 'Gen11' from the central EU region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name 'Gen-11-Filter' | Remove-HPECOMFilter 

    Removes the filter 'Gen-11-Filter' from the western US region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west | Where-Object {$_.name -eq 'Gen10-Workload-Dev' -or $_.name -eq 'Gen11-Workload-Dev'} | Remove-HPECOMFilter 

    Removes the filters 'Gen10-Workload-Dev' and 'Gen11-Workload-Dev' from the western US region.

    .EXAMPLE
    Get-HPECOMFilter -Region eu-central | Remove-HPECOMFilter 

    Removes all filters from the central EU region.

    .INPUTS
    System.Collections.ArrayList
        A list of filters retrieved from 'Get-HPECOMFilter'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following properties:  
        * Name - The name of the filter attempted to be removed.
        * Region - The name of the region where the filter was removed.
        * Status - The status of the removal attempt (Failed for HTTP error; Complete if removal is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveFilterStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
              

        try {
            $FiltersResource = Get-HPECOMFilter -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $FilterID = $FiltersResource.id

        
        if (-not $FilterID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Filter '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Filter cannot be found in the region!"

            }

        }
        else {
            
            $Uri = $COMFiltersUri + "/" + $FilterID

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Filter removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Filter '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Filter successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveFilterStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveFilterStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more filters has failed!"

          
            }
            
            $RemoveFilterStatus = Invoke-RepackageObjectWithType -RawObject $RemoveFilterStatus -ObjectName "COM.objStatus.NSDE"  
            Return $RemoveFilterStatus
        }


    }
}


Function Set-HPECOMFilter {
    <#
    .SYNOPSIS
    Update a filter resource in a specified region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.

    .DESCRIPTION
    This cmdlet modifies a filter resource in a specific region.

    .PARAMETER Name 
    The name of the filter to update. 

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the filter will be updated.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    Specifies the new name of the filter.

    .PARAMETER Filter  
    Specifies a filter expression such as "serverGeneration eq 'GEN_11'" or "state/connected eq 'false'".
    The filter grammar is a subset of OData 4.0 using 'eq', 'ne', 'gt', 'ge', 'lt', 'le' and 'in' operations,
    and 'and', 'or' logics.

    Servers can be filtered by:
    - `biosFamily`
    - `createdAt`
    - `firmwareBundleUri`
    - `hardware` and all nested properties
    - `host` and all nested properties
    - `id`
    - `name`
    - `oneview` and all nested properties
    - `platformFamily`
    - `processorVendor`
    - `resourceUri`
    - `serverGeneration`
    - `state` and all nested properties

    For more information, see [HPE GreenLake Documentation](https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/openapi/compute-ops-mgmt-latest/operation/get_v1beta2_servers/#tag/servers-v1beta2/operation/get_v1beta2_servers!in=query&path=filter&t=request).

    .PARAMETER FilterTags 
    Optional. Specifies a filter expression for tags such as "'Location' eq 'Houston'", "'App' eq 'RHEL'", or "'OS' eq 'Linux'".

    .PARAMETER Description 
    Optional. Describes the filter.

    .PARAMETER EnabledForRRP
    Boolean. Flags the filter for use with resource restriction policies used by scope-based access control (SBAC). Only administrators with full access to all scopes can create, edit, or delete RRP-enabled filters. The use of some resource properties may be disallowed in RRP-enabled filters.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMFilter -Region us-west -Name Gen11 -EnabledForRRP:$True -NewName Gen11-servers

    Changes the name of the filter named 'Gen11' to 'Gen11-servers' in the western US region and enables it for resource restriction policy.

    .EXAMPLE
    Set-HPECOMFilter -Region us-west -Name Gen11-Workload-Dev -FilterTags "'Workload-Dev' eq 'Dev' and 'Discover' eq 'Demo'"

    Changes the filter expression for tags of a filter named 'Gen11-Workload-Dev' in the western US region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name Gen11-Workload-Dev | Set-HPECOMFilter -Filter "hardware/powerState eq 'OFF'" -Description "My filter for Gen11 servers"

    Gets the filter named 'Gen11-Workload-Dev' in the western US region and modifies its filter and description properties.

    .INPUTS
    System.Collections.ArrayList
    List of filter(s) from 'Get-HPECOMFilter'.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
    - **Name**: Name of the filter attempted to be updated.
    - **Region**: Name of the region where the filter is updated.
    - **Status**: Status of the modification attempt (`Failed` for HTTP error return; `Complete` if modification is successful; `Warning` if no action is needed).
    - **Details**: More information about the status.
    - **Exception**: Information about any exceptions generated during the operation.

    #>


    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,

        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 2000 })]
        [String]$Filter,
        
        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 2000 })]
        [String]$FilterTags,
        
        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 10000 })]
        [String]$Description,

        [Parameter (ValueFromPipelineByPropertyName)] 
        [bool]$EnabledForRRP,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetFilterStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $FilterResource = Get-HPECOMFilter -Region $Region -Name $Name
            $FilterID = $FilterResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        "[{0}] Filter ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $FilterID | Write-Verbose
       
        if (-not $FilterID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Filter '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Filter cannot be found in the region!"
            }
        }
        else {
            
            $Uri = $COMFiltersUri + "/" + $FilterID
            
            $Payload = @{}
            $Payload.filterResourceType = "compute-ops-mgmt/server"


            # Conditionally add properties
            if ($NewName) {
                $Payload.name = $NewName
            }
            else {
                $Payload.name = $Name
                
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
                if ($FilterResource.description) {
                    $Payload.description = $FilterResource.description

                }
                else {
                    $Payload.description = $Null
                }
            }
            else {
                $Payload.description = $Description
            }


            if (-not $PSBoundParameters.ContainsKey('EnabledForRRP')) {
                $Payload.enabledForRRP = $FilterResource.enabledForRRP
            }
            else {
                $Payload.enabledForRRP = [bool]$EnabledForRRP
            }


            if (-not $PSBoundParameters.ContainsKey('FilterTags')) {
                if ($FilterResource.filterTags) {
                    $Payload.filterTags = $FilterResource.filterTags
                }
                # No need to add 'FilterTags' with a null value if not set
                # else {
                #     $Payload.filterTags = $Null
                # }
            }
            else {
                $Payload.filterTags = $FilterTags
            }


            if (-not $PSBoundParameters.ContainsKey('Filter')) {
                if ($FilterResource.filter) {
                    $Payload.filter = $FilterResource.filter
                }
                # Filter cannot be $Null
            }
            else {
                $Payload.filter = $Filter
                
            }
            

            # Convert the hashtable to JSON
            $jsonPayload = $Payload | ConvertTo-Json


            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $jsonPayload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Filter update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Filter '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Filter successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $SetFilterStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetFilterStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more filter failed the update attempt!"
          
            }
            
            $SetFilterStatus = Invoke-RepackageObjectWithType -RawObject $SetFilterStatus -ObjectName "COM.objStatus.NSDE"
            Return $SetFilterStatus
        }


    }
}

#EndRegion


#Region --- FIRMWARE BUNDLES ---

Function Get-HPECOMFirmwareBundle {
    <#
    .SYNOPSIS
    Retrieve the list of firmware bundles.

    .DESCRIPTION
    This Cmdlet returns a collection of firmware bundles that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ReleaseVersion 
    Optional parameter that can be used to specify the release version of firmware bundles to display.
    
    .PARAMETER LatestVersion 
    Optional parameter that can be used to display the latest appliance firmware bundles version.

    .PARAMETER IsActive 
    Optional switch parameter that can be used to only get the supported firmware bundles.

    .PARAMETER BundleType 
    Optional parameter parameter that can be used to specify the bundle type of firmware bundles to display such as 'BASE', 'PATCH' and 'HOTFIX'. 

    .PARAMETER Generation 
    Optional parameter parameter that can be used to specify the server generation of firmware bundles to display such as '10', '11'... 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region us-west 

    Return all firmware bundles resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region us-west -BundleType BASE  

    Return all firmware bundles type base resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region eu-central  -IsActive -Generation 11 -LatestVersion

    Return the latest and supported firmware bundle located in the central EU region for Gen11 servers.

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region us-west -ReleaseVersion 2023.10.00.01 -IsActive 

    Return all firmware bundles 2023.10.00.01 resources that are active (supported). 

    .INPUTS
    No pipeline support

   
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ReleaseVersion')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'ReleaseVersion')]
        [String]$ReleaseVersion,
        
        [Parameter (ParameterSetName = 'Latest')]
        [Switch]$LatestVersion,

        [Switch]$IsActive,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('BASE', 'PATCH', 'HOTFIX')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('BASE', 'PATCH', 'HOTFIX')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]            
        [String]$BundleType,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @('10', '11', '12')
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('10', '11', '12')]
        [String]$Generation,


        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      
        
        $Uri = $COMFirmwareBundlesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            if ($ReleaseVersion) {

                $CollectionList = $CollectionList | Where-Object releaseVersion -eq $ReleaseVersion

            }   
            if ($IsActive) {

                $CollectionList = $CollectionList | Where-Object isActive -match $IsActive

            }   
            if ($Generation) {

                $CollectionList = $CollectionList | Where-Object bundleGeneration -match $Generation

            }   
            if ($BundleType) {

                $CollectionList = $CollectionList | Where-Object bundleType -match $BundleType

            }   

            if ($LatestVersion) {
                $Latestversionitems = @()
                $maxDate = [DateTime]::MinValue
            
                foreach ($item in $CollectionList) {
                    Write-Verbose "Processing item with createdAt: $($item.createdAt)"
                    $currentDate = [DateTime]::Parse($item.createdAt)
                    if ($currentDate -gt $maxDate) {
                        Write-Verbose "New max createdAt found: $($item.createdAt)"
                        $maxDate = $currentDate
                        $Latestversionitems = @() 
                        $Latestversionitems += $item
                    } 
                    elseif ($currentDate -eq $maxDate) {
                        # If current date matches the max date, add it to the list
                        Write-Verbose "Matching max createdAt found: $($item.createdAt)"
                        $Latestversionitems += $item
                    }
                }
            
                Write-Verbose "Final max createdAt: $maxDate"
                Write-Verbose "Items with max createdAt: $($Latestversionitems | Out-String)"
                $CollectionList = $Latestversionitems
            }

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
          
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.FirmwareBundles"    
    
            # $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- GROUPS ---

Function Get-HPECOMGroup {
    <#
    .SYNOPSIS
    Retrieve the list of groups.

    .DESCRIPTION
    This Cmdlet returns a collection of groups that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Optional parameter that can be used to specify the name of a group to display.

    .PARAMETER ShowCompliance
    Optional switch parameter that can be used to get a specific device compliance detail of a group.

    .PARAMETER ShowMembers
    Optional parameter that can be used to obtain a list of servers that are members of the designated group. 

    .PARAMETER ShowPolicies
    Optional parameter that can be used to obtain a list of policies that are assigned to the designated group.
    
    .PARAMETER ShowSettings
    Optional parameter that can be used to obtain a list of server settings that are assigned to the designated group. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMGroup -Region us-west

    Return all groups resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name DLV24-ESX8-Mgmt-Cluster

    Return the group resource named 'DLV24-ESX8-Mgmt-Cluster' located in the western US region. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name DLV24-ESX8-Mgmt-Cluster -ShowCompliance

    Return the device compliance details of the group resource named 'DLV24-ESX8-Mgmt-Cluster'. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name Hypervisors -ShowMembers

    Return the list of servers that are members of the group 'Hypervisors'.

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name Hypervisors -ShowSettings

    Return the list of server settings that are assigned to the group 'Hypervisors'.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_group -ShowPolicies

    Return the list of policies that are assigned to the group 'ESXi_group'.
    
    .INPUTS
    No pipeline support   
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (Mandatory, ParameterSetName = 'ShowMembers')]
        [Parameter (Mandatory, ParameterSetName = 'Compliance')]
        [Parameter (Mandatory, ParameterSetName = 'ShowSettings')]
        [Parameter (Mandatory, ParameterSetName = 'ShowPolicies')]
        [String]$Name,

        [Parameter (ParameterSetName = 'Compliance')]
        [Switch]$ShowCompliance,

        [Parameter (ParameterSetName = 'ShowMembers')]
        [Switch]$ShowMembers,
        
        [Parameter (ParameterSetName = 'ShowPolicies')]
        [Switch]$ShowPolicies,
                
        [Parameter (ParameterSetName = 'ShowSettings')]
        [Switch]$ShowSettings,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
        if ($Filterableproperties) {
            $Uri = $COMGroupsUri + "/properties"
            
        }
        elseif ($ShowMembers -or $ShowCompliance) {

            $Uri = $COMGroupsUri + "?filter=name eq '$name'"

            try {
                $GroupID = (Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region).id

                "[{0}] ID found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $GroupID | Write-Verbose

                if ($Null -eq $GroupID) { 
                    # Write-warning "Group '$name' cannot be found in the Compute Ops Management instance!" 
                    return
                }

                if ($ShowCompliance) {
                    $Uri = $COMGroupsUri + "/" + $GroupID + "/compliance"
                }

                if ($ShowMembers) {
                    $Uri = $COMGroupsUri + "/" + $GroupID + "/devices"
                }
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        elseif ($Name) {

            $Uri = $COMGroupsUri + "?filter=name eq '$name'" 
        }
        else {
            $Uri = $COMGroupsUri
            
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
      
        if ($Null -ne $CollectionList) {   
            
            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
                       
            if ($ShowCompliance) {
                
                # Add groupName, servername and serialNumber (only serial is provided)
                # groupName is used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. 
                Foreach ($Item in $CollectionList) {

                    try {
                        $ServerName = Get-HPECOMServer -Region $Region -Name $Item.serial                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    $Item | Add-Member -type NoteProperty -name groupName -value $Name
                    $Item | Add-Member -type NoteProperty -name serialNumber -value $Item.serial
                    $item | Add-Member -Type NoteProperty -Name serverName -Value $ServerName.name
                    
                }

                $CollectionList = $CollectionList | Sort-Object serverName
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance"    

            }
            elseif ($ShowMembers) {

                # Add groupName, servername and serialNumber (only serial is provided)
                # groupName is used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. 
                Foreach ($Item in $CollectionList) {

                    try {
                        $ServerName = Get-HPECOMServer -Region $Region -Name $Item.serial                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    $Item | Add-Member -type NoteProperty -name groupName -value $Name
                    $Item | Add-Member -type NoteProperty -name serialNumber -value $Item.serial
                    $item | Add-Member -Type NoteProperty -Name serverName -Value $ServerName.name
                    
                }

                $CollectionList = $CollectionList | Sort-Object serverName
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Members"    

            }
            elseif ($ShowSettings) {

                $_CollectionList = [System.Collections.ArrayList]::new()

                $_Settings = Get-HPECOMSetting -Region $Region 

                foreach ($SettingUri in $CollectionList.settingsUris) {

                    "[{0}] Setting uri found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $SettingUri | Write-Verbose

                    $_serversetting = $_Settings | Where-Object resourceUri -eq $SettingUri

                    "[{0}] Setting found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serversetting.name | Write-Verbose

                    [void]$_CollectionList.add($_serversetting)
                }

                # Add groupName to object (used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. )
                $_CollectionList | Add-Member -type NoteProperty -name groupName -value $Name

                $_CollectionList = $_CollectionList | Sort-Object name
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $_CollectionList -ObjectName "COM.Settings"    

            }
            elseif ($ShowPolicies) {

                $ListOfGroupSettingCategories = [System.Collections.ArrayList]::new()

                $_Settings = Get-HPECOMSetting -Region $Region 

                foreach ($SettingUri in $CollectionList.settingsUris) {

                    "[{0}] Setting uri found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $SettingUri | Write-Verbose

                    $_serversetting = $_Settings | Where-Object resourceUri -eq $SettingUri

                    "[{0}] Setting found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serversetting.name | Write-Verbose

                    $SettingCategoryFound = $_serversetting.category
                        
                    [void]$ListOfGroupSettingCategories.add($SettingCategoryFound)

                    "[{0}] List of category settings found: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ListOfGroupSettingCategories | out-string) | Write-Verbose

                }

                # Removing the firmwareDowngrade property (deprecated) as it is now in OnDeviceApply policy
                $ReturnData = $CollectionList.policies
  
                $PoliciesList = [System.Collections.ArrayList]::new()

                # BIOS
                if ($ListOfGroupSettingCategories -like 'BIOS') {      

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {    
                        if ($item.name -eq "biosApplySettings") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply BIOS setting when server is added to the group"
                                Setting  = $item.value
                                Category = "BIOS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -eq "biosFactoryReset") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Reset BIOS configuration settings to defaults"
                                Setting  = $item.value
                                Category = "BIOS"
                            }
                        
                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # EXTERNAL_STORAGE
                if ($ListOfGroupSettingCategories -like 'EXTERNAL_STORAGE') {
                    
                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {

                        if ($item.name -eq "externalStorageConfiguration") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply external storage setting when server is added to the group"
                                Setting  = $item.value
                                Category = "EXTERNAL_STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # FIRMWARE
                if ($ListOfGroupSettingCategories -like 'FIRMWARE') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {
                        if ($item.name -eq "firmwareUpdate") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply firmware baseline when server is added to the group"
                                Setting  = $item.value
                                Category = "FIRMWARE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -eq "firmwarePowerOff") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Power off server after firmware update"
                                Setting  = $item.value
                                Category = "FIRMWARE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                    foreach ($item in $ReturnData.onDeviceApply.psobject.properties) {

                        if ($item.name -eq "firmwareDowngrade") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Downgrade components to match baseline"
                                Setting  = $item.value
                                Category = "FIRMWARE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # ILO
                if ($ListOfGroupSettingCategories -like 'ILO_SETTINGS') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {

                        if ($item.name -eq "iloApplySettings") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply iLO settings when server is added to the group"
                                Setting  = $item.value
                                Category = "ILO_SETTINGS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # OS
                if ($ListOfGroupSettingCategories -like 'OS') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {
                        
                        if ($item.name -like "osInstall") {
                      
                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto install operating system when a server is added to the group"
                                Setting  = $item.value
                                Category = "OS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -like "osCompletionTimeoutMin") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "OS install completion timeout"
                                Setting  = $item.value
                                Category = "OS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                
                if ($ListOfGroupSettingCategories -like 'STORAGE') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {
                        if ($item.name -like "storageConfiguration") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply storage setting when server is added to the group"
                                Setting  = $item.value
                                Category = "STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -like "storageVolumeDeletion") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Erase existing internal storage configuration when server is added to the group"
                                Setting  = $item.value
                                Category = "STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -like "storageVolumeName") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Volume label name when server is added to the group"
                                Setting  = $item.value
                                Category = "STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
               
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $PoliciesList -ObjectName "COM.Groups.Policies"    
                $ReturnData = $ReturnData | Sort-Object Category, policy
               
            }
            else {

                # Add groupName to object (used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. )
                foreach ($item in $CollectionList) {
                    $item | Add-Member -MemberType NoteProperty -Name groupName -Value $item.name
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups"    
                $ReturnData = $ReturnData | Sort-Object name
            }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function New-HPECOMGroup {
    <#
    .SYNOPSIS
    Create a new group resource in a region.

    .DESCRIPTION
    This Cmdlet can be used to create a new group. Alternatively, it can create a new group using the settings and group policies of an existing group.
        
    .PARAMETER Name 
    Name of the group to create. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where to create the group. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Description 
    Optional parameter to describe the group. 

    .PARAMETER DeviceType
    Specifies the type of device to be added to the group. Servers is the only supported device type at the moment.

    .PARAMETER SettingsObject
    Specifies the server settings to assign to the group. The settings object must be retrieved from 'Get-HPECOMSetting -Region $Region'.

    .PARAMETER BiosSettingName
    Name of a bios server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Bios'.

    .PARAMETER ExternalStorageSettingName
    Name of an external storage server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category ExternalStorage'.

    .PARAMETER FirmwareSettingName
    Name of a firmware server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Firmware'.

    .PARAMETER OSSettingName
    Name of an OS server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Os'.

    .PARAMETER StorageSettingName
    Name of a storage server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Storage'.

    .PARAMETER EnableiLOSettingsForSecurity 
    Switch to enable iLO settings in the group that reduce the overall security risk of a server. This switch applies the HPE-recommended security settings for iLOs.
    
    .PARAMETER AutoBiosApplySettingsOnAdd
    Enable automatic application of BIOS settings when a server is added to a group. 
    A server group must have one of the HPE pre-defined BIOS/Workload profiles to allow the auto apply of BIOS settings.
    Note: This parameter is effective only when a bios server setting is defined in the group.

    .PARAMETER ResetBIOSConfigurationSettingsToDefaultsonAdd
    Reset BIOS configuration settings to defaults when a server is added to a group.
    Note: This parameter is effective only when a bios server setting is defined in the group.

    .PARAMETER AutoFirmwareUpdateOnAdd
    Enable automatic firmware updates to the configured baseline when a server is added to a group. 
    Note: This parameter is effective only when a firmware server setting is defined in the group.
    
    .PARAMETER PowerOffServerAfterFirmwareUpdate
    Power off server after firmware update is performed.
    Note: This parameter is effective only when a firmware server setting is defined in the group.

    .PARAMETER FirmwareDowngrade
    Allow or forbid downgrade of a firmware when firmware update is performed.
    Note: This parameter is effective only when a firmware server setting is defined in the group.

    .PARAMETER AutoOsImageInstallOnAdd
    When a server is added to the group, install the operating system image immediately if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when an OS server setting is defined in the group.
    
    .PARAMETER OsCompletionTimeoutMin
    When a server is added to the group and automatic install of operating system is enabled, this property sets the amount of time (in minutes) the operating system 
    installation will be allowed to continue before it times out. The timeout specified is applicable for each individual server in the group.
    Note: This parameter is effective only when an OS server setting is defined in the group.
    
    .PARAMETER AutoStorageVolumeCreationOnAdd
    When server is added to the group, the OS volume will be created immediately if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when an OS server setting is defined in the group.
    
    .PARAMETER AutoStorageVolumeDeletionOnAdd
    When server is added to the group, any existing internal storage configuration will be erased prior to creating the new OS volume if the server 
    is activated or when the server is activated at a later time.
    Note: This parameter is effective only when a storage server setting is defined in the group.
    
    .PARAMETER StorageVolumeName
    When a server is added to the group, associate a name with the created volume if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when a storage server setting is defined in the group.
    
    .PARAMETER AutoIloApplySettingsOnAdd
    Enable automatic application of iLO settings when a server is added to a group. A server group must have HPE pre-defined 
    iLO settngs to allow the auto apply of iLO settings.
    Note: This parameter is effective only when an iLO settings server setting is defined in the group.

    .PARAMETER AutoExternalStorageConfigurationOnAdd
    When a server is added to the group, apply the external storage configuration immediately if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when an external storage server setting is defined in the group.

    .PARAMETER TagUsedForAutoAddServer    
    Associates a case-insensitive tag with a group to automatically add servers to the group when they are activated. 
    
    The tag must meet the following string format <Name>=<Value> and can contain any alphaneumeric characters, any Unicode space separators, and the following characters: _ . : + - @ such as:
     - "Country=US"
     - "App=ESX-8"
     - "Site=Houston site"
     - "Domain=my.lab@domain.com"
    
    Note: 
        - A group can have a maximum of one tag and multiple groups can not have the same tag.
        - Automatic addition to groups can only occur before server activation. If a servers tags match more than one group, it wont be added to any group, and will need to be added using a different method.
        - When a server is onboarded or has its tags changed, the server's tags will be checked against the group's autoAddServerTags. 
        - If at least one of the server tags matches one group's autoAddServerTags, the server will be placed into the associated group. 
        - Once a server has been connected, the server becomes ineligible for automatically being placed into groups, even if it is later disconnected.
        - If a server is in a group, any further tag changes will not move it to another group. 
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE    
    New-HPECOMGroup -Name Hypervisors_Group -Region eu-central `
    -Description "My group for hypervisors"  `
    -BiosSettingName "Virtualization - Power Efficient" -FirmwareSettingName "ESXi_firmware_baseline_24_04_Gen10" -StorageSettingName "RAID1" `
    -AutoBiosApplySettingsOnAdd -AutoFirmwareUpdateOnAdd -AutoStorageVolumeCreationOnAdd `
    -FirmwareDowngrade -StorageVolumeName "OS_Boot_Volume" `
    -TagUsedForAutoAddServer "App=ESXi-802"
    
    Create a new server group named "Hypervisors_Group" in the "eu-central" region and provides a description for the group. 
    The command specifies settings for BIOS, firmware, and storage configurations. 
    It includes options to automatically apply BIOS, storage volume creation and firmware updates whenever a server is added to the group. 
    The command also allows for firmware downgrades when firmware update is performed in the group. 
    Additionally, it uses a specific tag for auto-adding servers to the group and specifies a storage volume name for the OS boot volume.
        
    .EXAMPLE
    $Settings = Get-HPECOMSetting -Region us-west | Where-Object {$_.name -eq "Firmware_Baseline" -or $_.name -eq "Virtualization - Power Efficient"}
    
    New-HPECOMGroup -Region us-west -Name Hypervisors_Group `
    -Description "My group for hypervisors" -SettingsObject $Settings `
    -AutoFirmwareUpdateOnAdd -AutoBiosApplySettingsOnAdd `
    -PowerOffServerAfterFirmwareUpdate -FirmwareDowngrade `
    -TagUsedForAutoAddServer "App=ESXi"

    Create a new group named 'Hypervisors_Group' in the central western US region using a list of bios and firmware settings URIs.  
    Set the group with automatic firmware update and Bios apply settings when a server is added to the group.
    Set also the group to power off server after firmware update is performed and allow firmware downgrade. 
    Set the "App=ESXi" tag so that any server defined with this tag during onboarding will automatically be added to this group.    

    .EXAMPLE
    $Settings = Get-HPECOMSetting -Region eu-central | Where-Object { $_.name -eq "ESXi_firmware_baseline_24_04_Gen10" -or $_.name -eq "Virtualization - Power Efficient" -or $_.name -eq "iLO settings enabled for security" }
    $Settings | New-HPECOMGroup -Region eu-central -Name Hypervisors_Group -Description "My group for hypervisors" `
     -AutoFirmwareUpdateOnAdd -AutoBiosApplySettingsOnAdd -PowerOffServerAfterFirmwareUpdate -FirmwareDowngrade -TagUsedForAutoAddServer "Domain=lab@lab.net" 

    Create a new group named 'Hypervisors_Group' in the central European region using a list of bios, firmware, and iLO settings URIs.
    Set the group with automatic firmware update and Bios apply settings when a server is added to the group.
    Set also the group to power off server after firmware update is performed and allow firmware downgrade.
    Set the "Domain=lab@lab.net" tag so that any server defined with this tag during onboarding will automatically be added to this group.    
    
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name "RHEL_group" | New-HPECOMGroup -Name K8s_group 

    This command creates a new group named 'K8s_group' in the central European region using the settings and group policies of the existing 'RHEL_group', except for the autoAddServerTag, as an autoAddServerTag can only be associated with one group at a time.

    .INPUTS
    System.Collections.ArrayList
        List of server settings from 'Get-HPECOMSetting'.
        or
        A single group obtained from 'Get-HPECOMGroup -Name <GroupName>' if you want to copy an existing group to a new one.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the group attempted to be created
        * Region - Name of the region
        * Status - Status of the creation attempt (Failed for http error return; Complete if creation is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,
        
        # [Parameter (ValueFromPipelineByPropertyName)] # Removed to avoid taking it from Get-HPECOMSetting pipeline object
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,

        [Parameter (ValueFromPipelineByPropertyName)] 
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Servers') #, 'OneView Synergy appliances', 'OneView VM appliances')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        # [ValidateSet ('Servers')] # , 'OneView Synergy appliances', 'OneView VM appliances')]
        [String]$DeviceType = "Servers",

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "SettingsObject")] 
        [Alias("settingsUris", "resourceuri")]
        [object]$SettingsObject,

        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = "SettingsObject")] 
        [Alias("policies")]
        [object]$PoliciesObject,

        [Parameter (ParameterSetName = "Settings")] 
        [String]$BiosSettingName,        
       
        [Parameter (ParameterSetName = "Settings")] 
        [String]$ExternalStorageSettingName,

        [Parameter (ParameterSetName = "Settings")] 
        [string]$FirmwareSettingName,
                
        [Parameter (ParameterSetName = "Settings")] 
        [String]$OSSettingName,
        
        [Parameter (ParameterSetName = "Settings")] 
        [String]$StorageSettingName,
        
        [Parameter (ParameterSetName = "Settings")] 
        [Switch]$EnableiLOSettingsForSecurity,

        # BIOS settings
        [switch]$AutoBiosApplySettingsOnAdd,
        [switch]$ResetBIOSConfigurationSettingsToDefaultsonAdd,  

        # Firmware settings
        [switch]$AutoFirmwareUpdateOnAdd,
        [switch]$PowerOffServerAfterFirmwareUpdate,
        [switch]$FirmwareDowngrade,

        # OS settings
        [switch]$AutoOSImageInstallOnAdd,
        [ValidateScript({ $_ -ge 60 -and $_ -le 720 })]
        [Int]$OsCompletionTimeoutMin = 240,

        # Storage settings
        [switch]$AutoStorageVolumeCreationOnAdd,
        [switch]$AutoStorageVolumeDeletionOnAdd,
        [String]$StorageVolumeName,

        # iLO settings
        [switch]$AutoIloApplySettingsOnAdd,

        # External storage settings       
        [switch]$AutoExternalStorageConfigurationOnAdd,

        # Tags settings
        # [Parameter (ValueFromPipelineByPropertyName)] # Removed as an autoAddServerTag can only exist in one group
        [ValidateScript({
                # Allows empty strings to pass the validation when a group without tag is provided in the pipeline
                # if (($_.psobject.properties | Where-Object { $_.MemberType -eq 'NoteProperty' }).count -eq 0) {
                #     $True
                # }   
                # Checks if the input string matches a specific pattern that starts with '@{' and ends with '}', 
                # containing letters, digits, underscores, spaces, dots, colons, plus signs, hyphens, and at signs.
                if ($_ -match '^@\{[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+\}$') {
                    $True
                }
                elseif (($_ -split '=').Count -gt 2) {
                    throw "Input '$_' is not in a valid tag format. Only one tag is expected such as <Name>=<Value>"
                }
                elseif ($_ -match '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') { 
                    $True
                }
                elseif ($_ -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                    throw "Input '$_' is not in a valid tag format. Expected format is <Name>=<Value> and can only contain alphanumeric characters, Unicode space separators, and the following: _ . : + - @"
                }
            })] 
        # [alias("autoAddTags")]
        [Object]$TagUsedForAutoAddServer,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMGroupsUri  
        $CreateGroupStatus = [System.Collections.ArrayList]::new()
        $ListOfSettingURIs = [System.Collections.ArrayList]::new()
        $ListOfSettingURIsFromSetting = [System.Collections.ArrayList]::new()
        $ListOfSettingURIsFromGroup = [System.Collections.ArrayList]::new()
        $ListOfPoliciesFromGroup = [System.Collections.ArrayList]::new()

        $count = 0

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }


        try {
            $GroupResource = Get-HPECOMGroup -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($GroupResource) {

            "[{0}] Group '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Group '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                $objStatus.Status = "Warning" # required to not display the Whatif when group already exists
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Group already exists in the region! No action needed."

            }
        }
        else {

            if ($PSCmdlet.MyInvocation.ExpectingInput) {
                
                # If pipeline is Get-HPECOMGroup, add to list group object
                if ($PSBoundParameters.ContainsKey('SettingsObject') -and $SettingsObject.GetType().baseType -eq [System.Array]) {
                    [void]$ListOfSettingURIsFromGroup.add($SettingsObject)
                    [void]$ListOfPoliciesFromGroup.add($PoliciesObject)
                    $count++ 
                }
                # If pipeline is Get-HPECOMSettings, add to list group object
                elseif ($PSBoundParameters.ContainsKey('SettingsObject')) {
                    [void]$ListOfSettingURIsFromSetting.add($SettingsObject)
    
                }
            }     
        }
    }

    end {

        if ($objStatus.Status -eq "Warning" ) {

            if (-not $WhatIf) {
                
                return $objStatus
            }

        }
        else {

            if ($count -gt 1) {
            
                Throw "Error: The group pipeline input contains more than one group. Please refine your query to filter to only one group."
               
            }
    
            if (-not $ListOfSettingURIsFromSetting -and -not $ListOfSettingURIsFromGroup -and -not $SettingsObject) {
    
                "[{0}] Detected no ListOfSettingURIs and no SettingsObject" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                try {
                    $Settings = Get-HPECOMSetting -Region $Region -ErrorAction Stop
    
                }
                catch {
    
                    $PSCmdlet.ThrowTerminatingError($_)
                }
    
                if ($BiosSettingName) {
                    
                    $resourceUri = ($Settings | Where-Object category -eq "BIOS" | Where-Object name -eq $BiosSettingName).resourceUri
    
                    if (-not $resourceUri) {
                        
                        # Throw "Bios setting '$BiosSettingName' cannot be found in the Compute Ops Management instance!"   
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $BiosSettingName, "BIOS"
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $BiosSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)
    
                    }
                    else {
    
                        [void]$ListOfSettingURIs.add($resourceUri) 
                    }
                }
                if ($ExternalStorageSettingName) {
                    
                    $resourceUri = ($Settings | Where-Object category -eq "EXTERNAL_STORAGE" | Where-Object name -eq $ExternalStorageSettingName).resourceUri
    
                    if (-not $resourceUri) {
                        
                        # Throw "External storage setting '$ExternalStorageSettingName' cannot be found in the Compute Ops Management instance!"
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $ExternalStorageSettingName, "EXTERNAL_STORAGE"
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $ExternalStorageSettingName.GetType().Name
                        
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)
    
    
                    }
                    else {
    
                        [void]$ListOfSettingURIs.add($resourceUri) 
                    }
                }
                if ($FirmwareSettingName) {
                    
                    $resourceUri = ($Settings | Where-Object category -eq "FIRMWARE" | Where-Object name -eq $FirmwareSettingName).resourceUri
    
                    if (-not $resourceUri) {
                        
                        # Throw "Firmware setting '$FirmwareSettingName' cannot be found in the Compute Ops Management instance!"
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $FirmwareSettingName, "FIRMWARE"
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $FirmwareSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)       
    
    
                    }
                    else {
    
                        [void]$ListOfSettingURIs.add($resourceUri) 
                    }
                }
                if ($EnableiLOSettingsForSecurity) {
                    
                    $resourceUri = ($Settings | Where-Object category -eq "ILO_SETTINGS" | Where-Object name -eq "iLO settings enabled for security").resourceUri
    
                    if (-not $resourceUri) {
                        
                        Throw "HPE pre-defined 'iLO settings enabled for security' cannot be found!"
    
                    }
                    else {
    
                        [void]$ListOfSettingURIs.add($resourceUri) 
                    }
                }
                if ($OSSettingName) {
                    
                    $resourceUri = ($Settings | Where-Object category -eq "OS" | Where-Object name -eq $OSSettingName).resourceUri
    
                    if (-not $resourceUri) {
                        
                        # Throw "OS setting '$OSSettingName' cannot be found in the Compute Ops Management instance!"
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $OSSettingName, "OS"
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $OSSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   
    
    
                    }
                    else {
    
                        [void]$ListOfSettingURIs.add($resourceUri) 
                    }
                }
                if ($StorageSettingName) {
                    
                    $resourceUri = ($Settings | Where-Object category -eq "STORAGE" | Where-Object name -eq $StorageSettingName).resourceUri
    
                    if (-not $resourceUri) {
                        
                        # Throw "Storage setting '$StorageSettingName' cannot be found in the Compute Ops Management instance!"
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $StorageSettingName, "STORAGE"
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $StorageSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)        
    
                    }
                    else {
    
                        [void]$ListOfSettingURIs.add($resourceUri) 
                    }
                }
    
                $SettingsObject = $ListOfSettingURIs
                
            }
            # Pipeline is Get-HPECOMGroup 
            elseif ($ListOfSettingURIsFromGroup) {
    
                "[{0}] Detected SettingURIs from Get-HPECOMGroup in pipeline: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ListOfSettingURIsFromGroup | out-string) | Write-Verbose
                # Need top flatten the list of lists
                $SettingsObject = ($ListOfSettingURIsFromGroup | out-string) -split '\r\n' | Where-Object { $_ -ne "" }
            }
            # Pipeline is Get-HPECOMSetting
            elseif ($ListOfSettingURIsFromSetting) {
        
                "[{0}] Detected SettingURIs from Get-HPECOMSetting in pipeline: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ListOfSettingURIsFromSetting | out-string) | Write-Verbose
    
                $SettingsObject = $ListOfSettingURIsFromSetting
    
            }
            # Direct (when -SettingsObject $Settings is used with $Settings = Get-HPECOMSetting)
            elseif ($SettingsObject.GetType().baseType -eq [System.Array]) {
    
                "[{0}] Detected SettingURIs in direct from -SettingsObject: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($SettingsObject.resourceuri | out-string) | Write-Verbose
    
                $SettingsObject = $SettingsObject.resourceuri
            }
            else {
                "[{0}] Detected nothing!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                $SettingsObject = @{}
            }
    
    
            if ($TagUsedForAutoAddServer) {
           
                if ($TagUsedForAutoAddServer -is [string]) {
               
                    # Remove space at the end of the string if any
                    $AutoAddServerTag = $TagUsedForAutoAddServer.TrimEnd()
        
                    # Check for more than one '=' character (if more than one tag is provided)
                    if (($AutoAddServerTag -split '=').Count -gt 2) {
        
                        "[{0}] Tag '{1}' is not supported! Only one tag is expected such as <tagname>=<value>" -f $MyInvocation.InvocationName.ToString().ToUpper(), $TagUsedForAutoAddServer | Write-Verbose
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Tag not supported! Only one tag is expected such as <tagname>=<value>"
                        [void] $CreateGroupStatus.add($objStatus)
                        return  
                    }
        
                    # Check tag format, if format is not <tagname>=<value>, return error
                    if ($AutoAddServerTag -notmatch "^[A-Za-z0-9_-]+=[A-Za-z0-9_-][^=]*$") {
        
                        "[{0}] Tag '{1}' format not supported! Expected format is <tagname>=<value>" -f $MyInvocation.InvocationName.ToString().ToUpper(), $TagUsedForAutoAddServer | Write-Verbose
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Tag format not supported! Expected format is <tagname>=<value>"
                        [void] $CreateGroupStatus.add($objStatus)
                        return  
                    }
        
                    $tagname = $AutoAddServerTag.split('=')[0]
                    $tagvalue = $AutoAddServerTag.split('=')[1]
                    
                    $TagList = @{
                        $tagname = $tagvalue 
                    }
                    
                }
                else {
                    $TagList = $TagUsedForAutoAddServer 
                }
    
            }
            else {
                $TagList = @{}
            }
    
                
            If ($ListOfPoliciesFromGroup) {
    
                $AutoBiosApplySettingsOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.biosApplySettings
                $ResetBIOSConfigurationSettingsToDefaultsonAdd = $ListOfPoliciesFromGroup.onDeviceAdd.biosFactoryReset
                $AutoExternalStorageConfigurationOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.externalStorageConfiguration
                $PowerOffServerAfterFirmwareUpdate = $ListOfPoliciesFromGroup.onDeviceAdd.firmwarePowerOff
                $AutoFirmwareUpdateOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.firmwareUpdate
                $AutoIloApplySettingsOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.iloApplySettings
                $osCompletionTimeoutMin = $ListOfPoliciesFromGroup.onDeviceAdd.osCompletionTimeoutMin
                $AutoOsImageInstallOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.osInstall
                $AutoStorageVolumeCreationOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.storageConfiguration
                $AutoStorageVolumeDeletionOnAdd = $ListOfPoliciesFromGroup.onDeviceAdd.storageVolumeDeletion
                $storageVolumeName = $ListOfPoliciesFromGroup.onDeviceAdd.storageVolumeName
    
                $firmwareDowngrade = $ListOfPoliciesFromGroup.onDeviceApply.firmwareDowngrade
            }
    
    
            $onDeviceAdd = @{
                biosApplySettings            = [bool]$AutoBiosApplySettingsOnAdd
                biosFactoryReset             = [bool]$ResetBIOSConfigurationSettingsToDefaultsonAdd
                externalStorageConfiguration = [bool]$AutoExternalStorageConfigurationOnAdd
                firmwarePowerOff             = [bool]$PowerOffServerAfterFirmwareUpdate
                firmwareUpdate               = [bool]$AutoFirmwareUpdateOnAdd
                iloApplySettings             = [bool]$AutoIloApplySettingsOnAdd
                osCompletionTimeoutMin       = [int]$osCompletionTimeoutMin
                osInstall                    = [bool]$AutoOsImageInstallOnAdd
                storageConfiguration         = [bool]$AutoStorageVolumeCreationOnAdd
                storageVolumeDeletion        = [bool]$AutoStorageVolumeDeletionOnAdd
                storageVolumeName            = $Null
            }
    
         
    
    
            if ($storageVolumeName) {
                $onDeviceAdd.storageVolumeName = $storageVolumeName
                $onDeviceAdd.storageConfiguration = $True
            }
            
            if ($FirmwareDowngrade) {
                
                $onDeviceApply = @{ 
                    firmwareDowngrade = [bool]$firmwareDowngrade 
                }
                            
                $Policies = @{
                    onDeviceAdd   = $onDeviceAdd
                    onDeviceApply = $onDeviceApply                
                }
            }
            else {
                 
                $Policies = @{
                    onDeviceAdd = $onDeviceAdd
                    
                }
            }
    
            if ($DeviceType -eq "Servers") {
                $DeviceTypeValue = "DIRECT_CONNECT_SERVER"
            }
            elseif ($DeviceType -eq "OneView Synergy appliances") {
                $DeviceTypeValue = "OVE_APPLIANCE_SYNERGY"
            }
            elseif ($DeviceType -eq "OneView VM appliances") {
                $DeviceTypeValue = "OVE_APPLIANCE_VM"
            }
            else {
                # When pipeline is group, we capture DeviceType directly from the object
                $DeviceTypeValue = $DeviceType
            }
                         
            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                name         = $Name
                description  = $Description
                deviceType   = $DeviceTypeValue 
                settingsUris = $SettingsObject
                policies     = $Policies
                autoAddTags  = $TagList
    
            }
    
    
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
    
                    "[{0}] Group creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                    "[{0}] Group '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Group successfully created in $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Group cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
    
    
            [void] $CreateGroupStatus.add($objStatus)
    
            if (-not $WhatIf) {
    
                if ($CreateGroupStatus | Where-Object { $_.Status -eq "Failed" }) {
      
                    write-error "One or more groups failed the creation attempt!"
              
                }
                
                $CreateGroupStatus = Invoke-RepackageObjectWithType -RawObject $CreateGroupStatus -ObjectName "COM.objStatus.NSDE"
                Return $CreateGroupStatus
            }
            
        }
    }
}


Function Remove-HPECOMGroup {
    <#
    .SYNOPSIS
    Deletes a group from a specified region.

    .DESCRIPTION
    This Cmdlet deletes a group from a specified region.
    
    Note: If you want to delete a group without modifying the server configuration, you must first remove the servers from the group using 'Remove-HPECOMServerfromGroup' before deleting the group.

    Note: If the group you want to delete is part of a resource restriction policy (RRP) saved filter, this filter will not be updated and should be manually reviewed. Check the user accounts associated with the RRP in HPE GreenLake using 'Get-HPEGLUserRole' or 'Get-HPEGLResourceRestrictionPolicy'.
    If necessary, adjust the user account RRP settings using 'Add-HPEGLRoleToUser' to ensure that the intended resource restrictions are preserved.

    .PARAMETER Name 
    The name of the group to remove. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) from which to remove the group. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Force
    A switch parameter to force the removal of the group even if servers are still assigned to it. With this parameter, all group policies and configurations on the servers will be removed.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMGroup -Region eu-central -Name 'vmware_horizon'
    
    Removes the group named 'vmware_horizon' from the central EU region. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name ESXi_Hypervisors | Remove-HPECOMGroup 

    Removes the group 'ESXi_Hypervisors' from the western US region. 

    .EXAMPLE 
    Get-HPECOMGroup -Region us-west | Where-Object {$_.name -eq 'ESXi_Hypervisors' -or $_.name -eq 'RHEL_Hypervisor'} | Remove-HPECOMGroup
    
    Removes the groups 'ESXi_Hypervisors' and 'RHEL_Hypervisor' from the western US region. 

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Remove-HPECOMGroup -Force

    Removes all groups from the central EU region, even if servers are still assigned to the groups, using the -Force switch. In this case, all group policies and configurations on the servers will be removed.

    .INPUTS
    System.Collections.ArrayList
        A list of groups from 'Get-HPECOMGroup'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - The name of the group attempted to be removed
        * Region - The name of the region from which the group is removed
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.

    
#>
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveGroupStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        try {
            $GroupResource = Get-HPECOMGroup -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $GroupID = $GroupResource.id

        
        if (-not $GroupID) {

            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Group '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Group cannot be found in the region!"
            }
        }
        else {
            
            if ($Force) {

                $Uri = $COMGroupsUri + "/" + $GroupID + "?force=true"
            }
            else {
                
                $Uri = $COMGroupsUri + "/" + $GroupID
            }

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Group removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Group '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Group successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Group cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveGroupStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveGroupStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more groups has failed!"

          
            }
            
            $RemoveGroupStatus = Invoke-RepackageObjectWithType -RawObject $RemoveGroupStatus -ObjectName "COM.objStatus.NSDE"
            Return $RemoveGroupStatus
        }


    }
}


Function Set-HPECOMGroup {
    <#
    .SYNOPSIS
    Update a group resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies a group resource in a given region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.

    .PARAMETER Name 
    Specifies the name of the group to update. 

    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group will be updated. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    Specifies the new name for the group. 

    .PARAMETER Description 
    Specifies a new description of the group.

    .PARAMETER DeviceType
    Specifies the type of device to be added to the group. Servers is the only supported device type at the moment.

    .PARAMETER BiosSettingName
    Specifies the name of a BIOS setting resource.

    .PARAMETER ExternalStorageSettingName
    Specifies the name of an external storage setting resource.

    .PARAMETER FirmwareSettingName
    Specifies the name of a firmware setting resource.

    .PARAMETER OSSettingName
    Specifies the name of an OS setting resource.

    .PARAMETER StorageSettingName
    Specifies the name of a storage setting resource.

    .PARAMETER EnableiLOSettingsForSecurity
    Specifies the name of an iLO-settings setting resource.
    Switch to enable iLO settings in the group that reduce the overall security risk of a server. This switch applies the HPE-recommended security settings for iLOs.

    .PARAMETER AutoBiosApplySettingsOnAdd
    Enables automatic application of BIOS settings when a server is added to the group. A group must have one of the HPE pre-defined BIOS/Workload profiles for this setting to be effective.
    Note: Effective only when a BIOS setting is defined in the group.

    .PARAMETER ResetBIOSConfigurationSettingsToDefaultsonAdd
    Resets the BIOS configuration settings to default when a server is added to the group.
    Note: Effective only when a BIOS setting is defined in the group.

    .PARAMETER AutoFirmwareUpdateOnAdd
    Enables automatic firmware updates to the configured baseline when a server is added to the group. 
    Note: Effective only when a firmware setting is defined in the group.
       
    .PARAMETER PowerOffServerAfterFirmwareUpdate
    Powers off the server after performing a firmware update.
    Note: Effective only when a firmware setting is defined in the group.
        
    .PARAMETER FirmwareDowngrade
    Allows or forbids the downgrade of firmware during updates.
    Note: Effective only when a firmware setting is defined in the group.
    
    .PARAMETER AutoOsImageInstallOnAdd
    Installs the operating system image immediately when a server is added to the group if it is activated; otherwise, it will install when the server is activated at a later time.
    Note: Effective only when an OS setting is defined in the group.

    .PARAMETER OsCompletionTimeoutMin
    Sets the timeout duration (in minutes) for operating system installation when a server is added to the group with automatic OS installation enabled. The timeout applies per individual server.
    Note: Effective only when an OS setting is defined in the group.
        
    .PARAMETER AutoStorageVolumeCreationOnAdd
    Creates the storage volume for the Operating system immediately when the server is added to the group if it is activated; otherwise, it will create when the server is activated at a later time.
    Note: Effective only when an OS setting is defined in the group.
        
    .PARAMETER AutoStorageVolumeDeletionOnAdd
    Erases any existing internal storage configuration prior to creating a new OS volume when a server is added to the group if the server is activated; otherwise, it will erase when the server is activated at a later time.
    Note: Effective only when a storage setting is defined in the group.
    
    .PARAMETER StorageVolumeName
    Assigns a name to the created storage volume when a server is added to the group if the server is activated; otherwise, it will assign when the server is activated at a later time.
    Note: Effective only when a storage setting is defined in the group.

    .PARAMETER AutoIloApplySettingsOnAdd
    Enables automatic application of iLO settings when a server is added to the group. A group must have HPE pre-defined iLO settings for this setting to be effective.
    Note: Effective only when an iLO-settings setting is defined in the group.
        
    .PARAMETER AutoExternalStorageConfigurationOnAdd
    Applies the external storage configuration immediately when a server is added to the group if the server is activated; otherwise, it will apply when the server is activated at a later time.
    Note: Effective only when an external storage setting is defined in the group.

    .PARAMETER TagUsedForAutoAddServer
    Associates a case-insensitive tag with a group to automatically add servers to the group when they are activated. 
    
    The tag must meet the following string format <Name>=<Value> and can contain any alphaneumeric characters, any Unicode space separators, and the following characters: _ . : + - @ such as:
     - "Country=US"
     - "App=ESX-8"
     - "Site=Houston site"
     - "Domain=my.lab@domain.com"
    
    Note: 
        - A group can have a maximum of one tag and multiple groups can not have the same tag.
        - Automatic addition to groups can only occur before server activation. If a servers tags match more than one group, it wont be added to any group, and will need to be added using a different method.
        - When a server is onboarded or has its tags changed, the server's tags will be checked against the group's autoAddServerTags. 
        - If at least one of the server tags matches one group's autoAddServerTags, the server will be placed into the associated group. 
        - Once a server has been connected, the server becomes ineligible for automatically being placed into groups, even if it is later disconnected.
        - If a server is in a group, any further tag changes will not move it to another group. 

    .PARAMETER WhatIf
    Displays the raw REST API call to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMGroup -Region eu-central -Name AI_Group -Description "Group for AI systems" `
        -BiosSettingName "Virtualization - Power Efficient" -AutoBiosApplySettingsOnAdd:$true -ResetBIOSConfigurationSettingsToDefaultsonAdd:$True `
        -FirmwareSettingName "ESXi firmware baseline"   -AutoFirmwareUpdateOnAdd:$True -PowerOffServerAfterFirmwareUpdate:$True -FirmwareDowngrade:$True `
        -OSSettingName OS_ESXi -AutoOsImageInstallOnAdd:$True -OsCompletionTimeoutMin 60 `
        -StorageSettingName "RAID1" -StorageVolumeName "OS-vol" -AutoStorageVolumeCreationOnAdd:$True -AutoStorageVolumeDeletionOnAdd:$True  `
        -EnableiLOSettingsForSecurity:$True -AutoIloApplySettingsOnAdd:$True  `
        -TagUsedForAutoAddServer "App=RHEL"

    This example demonstrates how to configure a group named "AI_Group" in the "eu-central" region with various settings.
    The group is described as "Group for AI systems".
    BIOS settings are applied automatically with the "Virtualization - Power Efficient" profile, and BIOS settings are reset to defaults on add.
    Firmware settings are configured with the "ESXi firmware baseline", enabling automatic firmware updates.
    The server is powered off after firmware updates, and firmware downgrades are permitted.
    OS settings are configured with "OS_ESXi", enabling automatic OS image installation with a completion timeout of 60 minutes.
    Storage settings are configured with "RAID1", naming the storage volume "OS-vol".
    Automatic storage volume creation and deletion are enabled.
    iLO settings for security are enabled, with automatic application of iLO settings.
    The group is tagged with "App=RHEL" for automatic server addition based on this tag.

    .EXAMPLE
    Set-HPECOMGroup -Region eu-central -Name AI_Group -AutoBiosApplySettingsOnAdd:$false -AutoFirmwareUpdateOnAdd:$false -AutoOsImageInstallOnAdd:$false -AutoStorageVolumeCreationOnAdd:$false -AutoStorageVolumeDeletionOnAdd:$false -AutoIloApplySettingsOnAdd:$false 

    This example demonstrates how to disable all automatic settings when servers are added to the group named "AI_Group" in the "eu-central" region.
        
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name 'Hypervisors_Group' | Set-HPECOMGroup `
    -NewName "ESX_Hypervisors_Group" `
    -Description "My new description" `
    -AutoFirmwareUpdateOnAdd:$False -AutoBiosApplySettingsOnAdd:$True `
    -BiosSettingName "Virtualization - Power Efficient"

    The first command retrieves the server group named 'Hypervisors_Group' located in the 'eu-central' region. 
    The second command updates the group with a new name 'ESX_Hypervisors_Group', a new description 'My new description', and disables automatic firmware updates when a server is added to the group.
       
    .EXAMPLE
    Set-HPECOMGroup -Name AI_Group -Region eu-central -TagUsedForAutoAddServer "" -OSSettingName "" -EnableiLOSettingsForSecurity:$false 
    
    This example demonstrates how to remove the tag and OS settings from the group named "AI_Group" in the "eu-central" region and disable iLO settings for security.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Set-HPECOMGroup -AutoFirmwareUpdateOnAdd:$False

    This example modifies all groups in the eu-central region to disable automatic firmware updates when a server is added to the group.

    .INPUTS
    System.Collections.ArrayList
        List of groups from 'Get-HPECOMGroup'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:  
        * Name - Name of the group attempted to be updated
        * Region - Name of the region where the group is updated
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Filter')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        # [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 10000 })]
        [String]$Description,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Servers') #, 'OneView Synergy appliances', 'OneView VM appliances')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Servers')] # , 'OneView Synergy appliances', 'OneView VM appliances')]
        # [Parameter (ValueFromPipelineByPropertyName)] 
        [String]$DeviceType = "Servers",

        [String]$BiosSettingName,        
       
        [String]$ExternalStorageSettingName,

        [string]$FirmwareSettingName,
                
        [String]$OSSettingName,
        
        [String]$StorageSettingName,
        
        [bool]$EnableiLOSettingsForSecurity,

        
        # BIOS settings
        [bool]$AutoBiosApplySettingsOnAdd,
        [bool]$ResetBIOSConfigurationSettingsToDefaultsonAdd,  
        
        
        # Firmware settings
        [bool]$AutoFirmwareUpdateOnAdd,
        [bool]$PowerOffServerAfterFirmwareUpdate,
        [bool]$FirmwareDowngrade,

        
        # OS settings
        [bool]$AutoOsImageInstallOnAdd,
        [ValidateScript({ $_ -ge 60 -and $_ -le 720 })]
        [Int]$OsCompletionTimeoutMin,

        
        # Storage settings
        [bool]$AutoStorageVolumeCreationOnAdd,
        [bool]$AutoStorageVolumeDeletionOnAdd,
        [String]$StorageVolumeName,


        # iLO settings
        [bool]$AutoIloApplySettingsOnAdd,


        # External storage settings       
        [bool]$AutoExternalStorageConfigurationOnAdd,
        

        # Tags settings  
        [ValidateScript({
                # Allows empty strings to pass the validation when "" is provided to remove the tag or when group in the pipeline does not have a tag
                if ($_ -eq '' -or $_ -eq $null) {
                    $True
                }    
                # Checks if the input string matches a specific pattern that starts with '@{' and ends with '}', 
                # containing letters, digits, underscores, spaces, dots, colons, plus signs, hyphens, and at signs.
                elseif ($_ -match '^@\{[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+\}$') {
                    $True
                }
            
                elseif (($_ -split '=').Count -gt 2) {
                    throw "Input '$_' is not in a valid tag format. Only one tag is expected such as <Name>=<Value>"
                }
                # Checks if the input string matches a specific pattern <Name>=<Value> that starts with a letter, followed by letters, digits, underscores, spaces, dots, colons, plus signs, hyphens, and at signs,
                elseif ($_ -match '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') { 
                    $True
                }
                elseif ($_ -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                    throw "Input '$_' is not in a valid tag format. Expected format is <Name>=<Value> and can only contain alphanumeric characters, Unicode space separators, and the following: _ . : + - @"
                }
            })] 
        [String]$TagUsedForAutoAddServer,      

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetGroupStatus = [System.Collections.ArrayList]::new()
        $onDeviceAdd = [System.Collections.Hashtable]::new()
        $Policies = [System.Collections.Hashtable]::new()

        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
           
            $GroupResource = Get-HPECOMGroup -Region $Region -Name $Name 
            $GroupID = $GroupResource.id
        }   
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

      
     
        if (-not $GroupID) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Group '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Group cannot be found in the region!"
            }
        }
        else {
            
            $Uri = $COMGroupsUri + "/" + $GroupID

            # Get existing group settings
            $ExistingGroupSettings = Get-HPECOMGroup -Region $Region -Name $Name -ShowSettings
                           
            # Get settings from the Compute Ops Management instance
            try {
                $Settings = Get-HPECOMSetting -Region $Region -ErrorAction Stop
                
            }
            catch {
                
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            
            $SettingsUris = [System.Collections.ArrayList]::new()

            # Check if settings are provided or not, if provided, get the resourceUri and add it to the settingsUris list, if not, get the existing settings from the group
            if (-not $PSBoundParameters.ContainsKey('BiosSettingName')) {

                $Category = 'BIOS'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $BiosSettingFound = $True
                    }
                }
            }
            else {
                
                if ($BiosSettingName) {

                    $Category = 'BIOS'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $BiosSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $BiosSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $BiosSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }   
                else {
                    # Need to disable bios configuration if bios setting name provided is ""
                    $DeleteBiosSettings = $True

                }              
            }           

            if (-not $PSBoundParameters.ContainsKey('ExternalStorageSettingName')) {

                $Category = 'EXTERNAL_STORAGE'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $ExternalStorageSettingFound = $True

                    }
                }
            }
            else {
                
                if ($ExternalStorageSettingName) {

                    $Category = 'EXTERNAL_STORAGE'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $ExternalStorageSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $ExternalStorageSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $ExternalStorageSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }
                else {
                    # Need to disable external configuration if external storage setting name provided is ""
                    $DeleteExternalStorageSettings = $True

                }                   
            }
            
            if (-not $PSBoundParameters.ContainsKey('FirmwareSettingName')) {

                $Category = 'FIRMWARE'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $FirmwareSettingFound = $True

                    }
                }
            }
            else {
                
                if ($FirmwareSettingName) {

                    $Category = 'FIRMWARE'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $FirmwareSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $FirmwareSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $FirmwareSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }  
                else {
                    # Need to disable Firmware configuration if firmware setting name provided is ""
                    $DeleteFirmwareSettings = $True

                }                
            }
            
            if (-not $PSBoundParameters.ContainsKey('EnableiLOSettingsForSecurity')) {

                $Category = 'ILO_SETTINGS'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {
            
                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] iLO settings setting found in group: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $iLOSettingFound = $True

                    }
                }
            }
            else {

                if ($EnableiLOSettingsForSecurity) {
                
                    $_RessourceUri = ($Settings | Where-Object category -eq "ILO_SETTINGS" | Where-Object name -eq "iLO settings enabled for security").resourceUri

                    if (-not $_RessourceUri) {
                        
                        # Must return a message if not found
                        Throw "HPE pre-defined 'iLO settings enabled for security' cannot be found!"

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }
                else {
                    # Need to disable iLO configuration if EnableiLOSettingsForSecurity is $False
                    $DeleteiLOSettings = $True

                }   
            }

            if (-not $PSBoundParameters.ContainsKey('OSSettingName')) {

                $Category = 'OS'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $OSSettingFound = $True

                    }
                }
            }
            else {
                
                if ($OSSettingName) {

                    $Category = 'OS'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $OSSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $OSSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $OSSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }  
                else {
                    # Need to disable OS configuration if OS setting name provided is ""
                    $DeleteOSSettings = $True

                }             
            }

            if (-not $PSBoundParameters.ContainsKey('StorageSettingName')) {

                $Category = 'STORAGE'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $StorageSettingFound = $True

                    }
                }
            }
            else {
                
                if ($StorageSettingName) {

                    $Category = 'STORAGE'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $StorageSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $StorageSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $StorageSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }      
                else {
                    # Need to disable storage configuration if storage setting name provided is ""
                    $DeleteStorageSettings = $True

                }        
            }
            

            if (-not $PSBoundParameters.ContainsKey('TagUsedForAutoAddServer')) {

                if ($GroupResource.autoAddTags) {

                    $TagList = $GroupResource.autoAddTags
                }
                else {
                    $TagList = @{}
                }
            
            }
            else {

                if ($TagUsedForAutoAddServer) {
                    
                    "[{0}] TagUsedForAutoAddServer value: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $TagUsedForAutoAddServer | Write-Verbose

                    # Remove space at the end of the string if any
                    $AutoAddServerTag = $TagUsedForAutoAddServer.TrimEnd()
    
                    $Tagname = $AutoAddServerTag.split('=')[0]
                    $Tagvalue = $AutoAddServerTag.split('=')[1]


                    # Remove existing tag (if any) and if the new tag is different from the existing tag name 
                    if ( ($GroupResource.autoAddTags.psobject.properties.name -and $GroupResource.autoAddTags.psobject.properties.name -ne $Tagname) ) {

                        "[{0}] Existing AutoAddTags object: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($GroupResource.autoAddTags.psobject.properties | out-string) | Write-Verbose
                    
                        $TagNameToRemove = $GroupResource.autoAddTags.psobject.properties.name
                        $TagList += @{ $TagNameToRemove = $Null }
                    }
                    
                    # Set existing tag (if any) and if the new tag name is the same as the existing one but with a different value 
                    if ( $GroupResource.autoAddTags.psobject.properties.name -and $GroupResource.autoAddTags.psobject.properties.name -eq $Tagname -and $GroupResource.autoAddTags.psobject.properties.value -ne $Tagvalue ) {

                        "[{0}] Existing AutoAddTags object: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($GroupResource.autoAddTags.psobject.properties | out-string) | Write-Verbose
                    
                        $TagList += @{ $Tagname = $Tagvalue }
                    }
                    else {

                        $TagList += @{ $Tagname = $Tagvalue }
                    }
                }
                else {
                    if ( $GroupResource.autoAddTags.psobject.properties.name) {
                        
                        $Tagname = $GroupResource.autoAddTags.psobject.properties.name
                        $TagList = @{ $Tagname = $Null }
                    }
                    else {
                        $TagList = @{}
                    }    
                }           
            }


            # BIOS settings
            if (-not $PSBoundParameters.ContainsKey('AutoBiosApplySettingsOnAdd')) {
                if ($BiosSettingFound -and $GroupResource.policies.onDeviceAdd.biosApplySettings) {
                    $onDeviceAdd["biosApplySettings"] = $GroupResource.policies.onDeviceAdd.biosApplySettings
                }
            }
            else {
                $onDeviceAdd["biosApplySettings"] = $AutoBiosApplySettingsOnAdd
            }

            if (-not $PSBoundParameters.ContainsKey('ResetBIOSConfigurationSettingsToDefaultsonAdd')) {
                if ($BiosSettingFound -and $GroupResource.policies.onDeviceAdd.biosFactoryReset) {
                    $onDeviceAdd["biosFactoryReset"] = $GroupResource.policies.onDeviceAdd.biosFactoryReset
                }
            }
            else {
                $onDeviceAdd["biosFactoryReset"] = $ResetBIOSConfigurationSettingsToDefaultsonAdd
            }

            # Firmware settings
            if (-not $PSBoundParameters.ContainsKey('AutoFirmwareUpdateOnAdd')) {
                if ($FirmwareSettingFound -and $GroupResource.policies.onDeviceAdd.firmwareUpdate) {
                    $onDeviceAdd["firmwareUpdate"] = $GroupResource.policies.onDeviceAdd.firmwareUpdate
                }
            }  
            else {
                $onDeviceAdd["firmwareUpdate"] = $AutoFirmwareUpdateOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('firmwareDowngrade')) {
                if ($FirmwareSettingFound -and $GroupResource.policies.onDeviceApply.firmwareDowngrade) {
                    $onDeviceApply = @{ firmwareDowngrade = $GroupResource.policies.onDeviceApply.firmwareDowngrade }
                }
            }
            else {
                $onDeviceApply = @{ firmwareDowngrade = $FirmwareDowngrade }
            }
            if (-not $PSBoundParameters.ContainsKey('PowerOffServerAfterFirmwareUpdate')) {
                if ($FirmwareSettingFound -and $GroupResource.policies.onDeviceAdd.firmwarePowerOff) {
                    $onDeviceAdd["firmwarePowerOff"] = $GroupResource.policies.onDeviceAdd.firmwarePowerOff
                }
            }
            else {
                $onDeviceAdd["firmwarePowerOff"] = $PowerOffServerAfterFirmwareUpdate
            }
             
            # OS settings
            if (-not $PSBoundParameters.ContainsKey('AutoOsImageInstallOnAdd')) {
                if ($OSSettingFound -and $GroupResource.policies.onDeviceAdd.osInstall) {
                    $onDeviceAdd["osInstall"] = $GroupResource.policies.onDeviceAdd.osInstall
                }
            }
            else {
                $onDeviceAdd["osInstall"] = $AutoOsImageInstallOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('osCompletionTimeoutMin')) {
                if ($OSSettingFound -and $GroupResource.policies.onDeviceAdd.osCompletionTimeoutMin) {
                    $onDeviceAdd["osCompletionTimeoutMin"] = $GroupResource.policies.onDeviceAdd.osCompletionTimeoutMin
                }
            }
            else {
                $onDeviceAdd["osCompletionTimeoutMin"] = $OsCompletionTimeoutMin
            }
            
            # Storage settings
            if (-not $PSBoundParameters.ContainsKey('AutoStorageVolumeCreationOnAdd')) {
                if ($StorageSettingFound -and $GroupResource.policies.onDeviceAdd.storageConfiguration) {
                    $onDeviceAdd["storageConfiguration"] = $GroupResource.policies.onDeviceAdd.storageConfiguration
                }
            }
            else {
                $onDeviceAdd["storageConfiguration"] = $AutoStorageVolumeCreationOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('AutoStorageVolumeDeletionOnAdd')) {
                if ($StorageSettingFound -and $GroupResource.policies.onDeviceAdd.storageVolumeDeletion) {
                    $onDeviceAdd["storageVolumeDeletion"] = $GroupResource.policies.onDeviceAdd.storageVolumeDeletion
                }
            }
            else {
                $onDeviceAdd["storageVolumeDeletion"] = $AutoStorageVolumeDeletionOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('storageVolumeName')) {
                if ($StorageSettingFound -and $GroupResource.policies.onDeviceAdd.storageVolumeName) {
                    $onDeviceAdd["storageVolumeName"] = $GroupResource.policies.onDeviceAdd.storageVolumeName
                }
            }
            else {
                $onDeviceAdd["storageVolumeName"] = $storageVolumeName

            }
          
            # iLO settings

            if (-not $PSBoundParameters.ContainsKey('AutoIloApplySettingsOnAdd')) {
                if ($iLOSettingFound -and $GroupResource.policies.onDeviceAdd.iloApplySettings) {
                    $onDeviceAdd["iloApplySettings"] = $GroupResource.policies.onDeviceAdd.iloApplySettings
                }
            }
            else {
                $onDeviceAdd["iloApplySettings"] = $AutoIloApplySettingsOnAdd
            }

            # External storage settings
            if (-not $PSBoundParameters.ContainsKey('AutoExternalStorageConfigurationOnAdd')) {
                if ($ExternalStorageSettingFound -and $GroupResource.policies.onDeviceAdd.externalStorageConfiguration) {
                    $onDeviceAdd["externalStorageConfiguration"] = $GroupResource.policies.onDeviceAdd.externalStorageConfiguration
                }
            }
            else {
                $onDeviceAdd["externalStorageConfiguration"] = $AutoExternalStorageConfigurationOnAdd
            }


            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }
           
            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($GroupResource.description) {
                              
                    $Description = $GroupResource.description
                }
                else {
                    $Description = $Null
                }
            }
            else {
                $Description = $Description
            }

            # $onDeviceAdd = @{
            #     biosApplySettings            = [bool]$AutoBiosApplySettingsOnAdd
            #     biosFactoryReset	           = [bool]$ResetBIOSConfigurationSettingsToDefaultsonAdd
            #     externalStorageConfiguration = [bool]$AutoExternalStorageConfigurationOnAdd
            #     firmwarePowerOff             = [bool]$PowerOffServerAfterFirmwareUpdate
            #     firmwareUpdate               = [bool]$AutoFirmwareUpdateOnAdd
            #     iloApplySettings             = [bool]$AutoIloApplySettingsOnAdd
            #     osCompletionTimeoutMin       = [int]$osCompletionTimeoutMin
            #     osInstall                    = [bool]$AutoOsImageInstallOnAdd
            #     storageConfiguration         = [bool]$AutoStorageVolumeCreationOnAdd
            #     storageVolumeDeletion        = [bool]$AutoStorageVolumeDeletionOnAdd
            #     storageVolumeName            = $Null
            # }

   

            # Disabling bios configuration if bios setting is ""
            If ($DeleteBiosSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty biosApplySettings, biosFactoryReset

            }

            # Disabling firmware configuration if firmware setting is ""
            If ($DeleteFirmwareSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty firmwareUpdate, firmwarePowerOff

            }

            # Disabling iLO configuration if iLO setting is $False
            If ($DeleteIloSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty iloApplySettings

            }

            # Disabling OS configuration if OS setting is ""
            If ($DeleteOSSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty osCompletionTimeoutMin, osInstall

            }

            # Disabling external storage configuration if external storage setting is ""
            If ($DeleteExternalStorageSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty externalStorageConfiguration

            }

            # Disabling storage configuration if storage setting is ""
            If ($DeleteStorageSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty storageVolumeDeletion, storageConfiguration, storageVolumeName
                
            }

            
            If ($onDeviceApply) {
               
                $Policies = @{
                    onDeviceAdd   = $onDeviceAdd
                    onDeviceApply = $onDeviceApply
                }

            }
            elseif ($onDeviceAdd.count -gt 0) {
                $Policies = @{
                    onDeviceAdd = $onDeviceAdd
                }
            }
            else {
                $Policies = @{}
            }

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                name         = $Name
                description  = $Description
                settingsUris = $SettingsUris
                policies     = $Policies
                autoAddTags  = $TagList
            }          
          
            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Group update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Group '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Group successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Group cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $SetGroupStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetGroupStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Group failed the update attempt!"
          
            }
            
            $SetGroupStatus = Invoke-RepackageObjectWithType -RawObject $SetGroupStatus -ObjectName "COM.objStatus.NSDE"
            Return $SetGroupStatus
        }
    }
}


Function Add-HPECOMServerToGroup {
    <#
    .SYNOPSIS
    Add server to a group in a specified region.

    .DESCRIPTION   
    This cmdlet adds a server to a group within a specified region. It does not support transferring a server directly from one group to another. 
    To transfer a server, first use `Remove-HPECOMServerFromGroup` to remove the server from its current group, and then use `Add-HPECOMServerToGroup` to add it to the new group.

    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server to be assigned to the group.

    .PARAMETER GroupName 
    Specifies the name of the group to which servers will be added. 

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    Add-HPECOMServerToGroup -Region us-west -ServerSerialNumber "J208PP0026" -GroupName RHEL_Hypervisors 
   
    This example adds a server with the serial number 'J208PP0026' to the group 'RHEL_Hypervisors' in the western US region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "esx5-2.domain.lab" | Add-HPECOMServerToGroup -GroupName ESXi_group 

    This command retrieves a server named 'esx5-2.domain.lab' in the central EU region and adds it to the group 'ESXi_group'.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model "ProLiant DL345 Gen10 Plus" | Add-HPECOMServerToGroup -GroupName RHEL_Hypervisors

    This command retrieves servers with the model 'ProLiant DL345 Gen10 Plus' in the western US region and adds them to the group 'RHEL_Hypervisors'.
    
    .EXAMPLE
    "J208PP0026", "J208PP000X" | Add-HPECOMServerToGroup -Region us-west -GroupName RHEL_Hypervisors 

    This command adds servers with serial numbers 'J208PP0026' and 'J208PP000X' to the group 'RHEL_Hypervisors' in the western US region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:  
        * SerialNumber - Serial number of the server attempted to be added to the group
        * Region - Name of the region where the group is located
        * Group - Name of the group to which the server is added
        * Status - The status of the addition attempt (`Failed` for HTTP error return; `Complete` if successful; `Warning` if no action is needed) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.

    
    #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory)]
        [String]$GroupName,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $ServerSerialNumber
            Region       = $Region         
            Group        = $GroupName                   
            Status       = $Null
            Details      = $Null
            Exception    = $Null
        }

       
        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        
        try {
            $Group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $Group.devices 

            $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices"
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $Group) {

            $ErrorMessage = "Group '{0}' cannot be found in the region!" -f $GroupName

            throw $ErrorMessage

        }


        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of servers to add to group: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose


        foreach ($Object in $ObjectStatusList) {

            "[{0}] Checking server '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber | Write-Verbose

            $Server = $Servers | Where-Object serialNumber -eq $Object.SerialNumber

            if ( -not $Server) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server cannot be found in the region!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $Object.SerialNumber, $Region
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ($GroupMembers | Where-Object serial -eq $Object.SerialNumber) {  

                # Must return a message if server already member of the group
                $Object.Status = "Warning"
                $Object.Details = "Server already a member of the group!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource is already a member of the '{1}' group!" -f $Object.SerialNumber, $GroupName
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       

                "[{0}] Server '{1}' is not a member of the group '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber, $GroupName | Write-Verbose
            
                # Build DeviceList object for paylaod
                $DeviceList = [PSCustomObject]@{
                    deviceId = $server.id
                  
                }

                # Build DeviceInfo object for tracking
                $DeviceInfo = [PSCustomObject]@{
                    serialnumber = $server.serialNumber
                  
                }

                # Building the list of devices object for payload
                [void]$DevicesList.Add($DeviceList)

                # Building the list of devices object for tracking
                [void]$DevicesTrackingList.Add($DeviceInfo)
                    
            }
        }

        
        if ($DevicesList) {

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                devices = $DevicesList
            } 
        
            # Add Devices to group  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Server successfully added to '$groupname' group in '$Region' region"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Server cannot be added to '$groupname' group!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed to join '$groupname' group!"
          
            }
            
            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Groups.SGSDE"
            Return $ObjectStatusList
        }


    }
}



Function Remove-HPECOMServerFromGroup {
    <#
    .SYNOPSIS
    Remove a server from a group in a specified region.

    .DESCRIPTION   
    This cmdlet removes a server from a specified group within a region. It can also remove all servers from the group and initiate a factory reset of the server BIOS once the removal is complete.

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server to be removed from the group. Serial numbers can be found using 'Get-HPECOMGroup -Region $Region -Name $GroupName -ShowMembers'.
    
    .PARAMETER GroupName 
    The name of the group from which the servers will be removed. 
 
    .PARAMETER All
    An optional parameter to remove all servers from the group.

    .PARAMETER ResetBios
    An optional parameter that initiates a factory reset of the server BIOS once the removal is complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMServerFromGroup -Region us-west -ServerSerialNumber "J208PP0026" -GroupName RHEL_Hypervisors 
   
    This example removes the server with serial number 'J208PP0026' from the group 'RHEL_Hypervisors' in the western US region.

    .EXAMPLE
    Remove-HPECOMServerFromGroup -Region us-west -GroupName RHEL_Hypervisors -All -ResetBios 
 
    This example removes all servers from the group 'RHEL_Hypervisors' in the western US region and initiates a factory reset of all servers' BIOS once the removal is complete.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_group -ShowMembers | Remove-HPECOMServerFromGroup

    This example retrieves all servers from the group 'ESXi_group' in the central EU region and removes them from the group.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-Gen10P-1.lab | Remove-HPECOMServerFromGroup -GroupName ESXi_group 

    This example retrieves the server named 'ESX-Gen10P-1.lab' in the central EU region and removes it from the group 'ESXi_group'.

    .EXAMPLE
    "J208PP0026", "J208PP000X" | Remove-HPECOMServerFromGroup -Region us-west -GroupName RHEL_Hypervisors 

    This example removes servers with serial numbers 'J208PP0026' and 'J208PP000X' from the group 'RHEL_Hypervisors' in the western US region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model "ProLiant DL345 Gen10 Plus" | Remove-HPECOMServerFromGroup -GroupName RHEL_Hypervisors 

    This example retrieves servers with the model 'ProLiant DL345 Gen10 Plus' in the western US region and removes them from the group 'RHEL_Hypervisors'.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the server attempted to be removed from the group
        * Region - Name of the region where the group is located
        * Group - Name of the group from which the server is removed
        * Status - The status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = "serialnumber")] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,
        
        [Parameter(ParameterSetName = "All")]
        [Switch]$All,

        [Switch]$ResetBios,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $Null
            Region       = $Region                            
            Group        = $GroupName                   
            Status       = $Null
            Details      = $Null
            Exception    = $Null
        }

        if ($ServerSerialNumber) {

            $objStatus.SerialNumber = $ServerSerialNumber
        }

       

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            $Group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $Group.devices 

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $Group) {

            $ErrorMessage = "Group '{0}': Resource cannot be found in the '{1}' region!" -f $GroupName, $Region

            throw $ErrorMessage

        }

        
        If (-not $All) {
        
            try {
        
                $Servers = Get-HPECOMServer -Region $Region
                    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)                
            }
                
            "[{0}] List of servers to remove from group: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose
        

            foreach ($Object in $ObjectStatusList) {
                
                "[{0}] Checking server '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber | Write-Verbose

                $Server = $Servers | Where-Object serialNumber -eq $Object.SerialNumber

                if ( -not $Server) {

                    # Must return a message if device not found
                    $Object.Status = "Failed"
                    $Object.Details = "Server cannot be found in the region!"

                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $Object.SerialNumber, $Region
                        Write-warning $ErrorMessage
                        continue
                    }
                    
                } 
                elseif (-not ( $GroupMembers | Where-Object serial -eq $Object.SerialNumber)) { 

                    # Must return a message if server already member of the group
                    $Object.Status = "Warning"
                    $Object.Details = "Server is not a member of the group!"
                    
                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}': Resource is not a member of the '{1}' group!" -f $Object.SerialNumber, $GroupName
                        Write-warning $ErrorMessage
                        continue
                    }
                    
                }
                else {    

                    "[{0}] Server '{1}' is a member of the group '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber, $GroupName | Write-Verbose
                    
                    # Build DeviceList object for paylaod
                    $DeviceList = [PSCustomObject]@{
                        deviceId = $server.id
                        
                    }
                    
                    # Build DeviceInfo object for tracking
                    $DeviceInfo = [PSCustomObject]@{
                        serialnumber = $server.serialNumber
                        
                    }
                    
                    # Building the list of devices object for payload
                    [void]$DevicesList.Add($DeviceList)
                    
                    # Building the list of devices object for tracking
                    [void]$DevicesTrackingList.Add($DeviceInfo)
                    
                }
            }
        }
        elseif ($all -and -not $GroupMembers) {

            "[{0}] Tracking object: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | out-string) | Write-Verbose

            # Must return a message if no servers are member of the group when all is used
            $ObjectStatusList[0].SerialNumber = "[All]"
            $ObjectStatusList[0].Status = "Warning"
            $ObjectStatusList[0].Details = "No servers are member of the group!"
            
            if ($WhatIf) {
                $ErrorMessage = "Group '{0}': No servers are member of the group!" -f $GroupName
                Write-warning $ErrorMessage
            }
        }

        
       
      

        if ($DevicesList) {

            if ($ResetBios) {

                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" + "?reset-subsystems=BIOS"

            }
            else {
                
                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" 
            
            }

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                devices = $DevicesList
            } 

            # Remove Devices from group  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Server successfully removed from '$groupname' group in '$Region' region"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Server cannot be removed from '$groupname' group!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        elseif ($All -and $_group.devices) {

            if ($ResetBios) {

                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" + "?force=true&reset-subsystems=BIOS"
                
            }
            else {
                
                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" + "?force=true"

            }

            # Remove all devices from group  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                    
                    $ObjectStatusList[0].SerialNumber = "[All]"
                    $ObjectStatusList[0].Status = "Complete"
                    $ObjectStatusList[0].Details = "All servers successfully removed from '$groupname' group in '$Region' region"
                }                    
            }
            catch {
                
                if (-not $WhatIf) {
                    
                    $ObjectStatusList[0].SerialNumber = "[All]"
                    $ObjectStatusList[0].Status = "Failed"
                    $ObjectStatusList[0].Details = "Servers cannot be removed from '$groupname' group!"
                    $ObjectStatusList[0].Exception = $_.Exception.message 
                }
            }
        }


        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed to be removed from $groupname group!"
          
            }
            
            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Groups.SGSDE"
            Return $ObjectStatusList
        }
    }
}

#EndRegion


#Region --- JOB TEMPLATES ---

Function Get-HPECOMJobTemplate {
    <#
    .SYNOPSIS
    Retrieve the list of job templates.

    .DESCRIPTION
    This Cmdlet returns a collection of job templates that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Optional parameter that can be used to specify the name of a job template to display.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMJobTemplate -Region us-west

    Return all job templates resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMJobTemplate -Region us-west -Name OrchestratorGroupIloSettings

    Return the job template resource named 'OrchestratorGroupIloSettings' located in the western US region. 

    .INPUTS
    No pipeline support

   
    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."

                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$Name,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose     
        
        $Uri = $COMJobTemplatesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            

            if ($Name) {

                $CollectionList = $CollectionList | Where-Object name -eq $Name

            }   
             
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.JobTemplates"    
    
            $ReturnData = $ReturnData | Sort-Object name 
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- JOBS ---

function Wait-HPECOMJobComplete {
    <#
    .SYNOPSIS
    Wait for a job to complete.
    
    .DESCRIPTION    
    This blocking Cmdlet assists a caller with monitoring a specific job resource, and will wait for the given job to "complete" (get to a terminal state, including error) or timeout.  
    The Cmdlet accepts either the job URI or resource object via pipeline.
    Once the job is no longer in a running state, the cmlet will return the job resource object.  
    The caller should examine the taskState property/key for the final task status.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER Job
    Job URI or resource object  
    
    .PARAMETER Timeout
    Timeout in seconds before the cmdlet stops. Default is 300 seconds (5 minutes).

    .PARAMETER Interval
    Polling interval in seconds

    .EXAMPLE
    Get-HPECOMJob -Region us-west -ShowRunning | Wait-HPECOMJobComplete

    This example retrieves all job resources that are running in the western US region and waits for them to complete.

    .EXAMPLE
    Wait-HPECOMJobComplete -Region us-west -Job '/compute-ops-mgmt/v1beta3/jobs/1649bcb6-6362-44bf-a737-8caa5142be6e' 

    .EXAMPLE
    Stop-HPECOMserver -Region us-west -Name HOL58 -Async | Wait-HPECOMJobComplete 

    .EXAMPLE
    '/compute-ops-mgmt/v1beta3/jobs/1649bcb6-6362-44bf-a737-8caa5142be6e', '/compute-ops-mgmt/v1beta3/jobs/e8b39555-1dd0-4baf-8f62-bc39d584d8f3' | Wait-HPECOMJobComplete -Region us-west 
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the job URIs.
    System.Collections.ArrayList
        A job from one of the cmdlets creating a job or a list of jobs retrieved using 'Get-HPECOMJob'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
                
    #>

    [CmdletBinding ()]
    Param(

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [Alias ('resourceUri', 'jobUri')]
        [Object]$Job,

        # Timeout in seconds
        [Parameter (Mandatory = $false)]
        [int]$Timeout = 300, # $DefaultTimeout,

        # Polling interval in seconds
        [int]$Interval = 5

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $startTime = Get-Date
        $endTime = $startTime.AddSeconds($Timeout)
        $jobState = ""
        $jobResource = $null
        # $jobResourceSN = $null
        $percentComplete = 0

        $JobCollection = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Validate the job object

        "[{0}] Job object type is: $($Job.GetType())" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose


        if (($Job -is [String]) -and ($Job.StartsWith($COMJobsUri))) {

            "[{0}] Processing job resource uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Job | Write-Verbose       
    
            $Uri = $Job

        }

        elseif ($Job -is [PSCustomObject] -and $Job.type -ieq 'compute-ops-mgmt/job') {

            "[{0}] Job is $($Job.GetType()). Job URI: $($Job.resourceUri)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $Uri = $Job.resourceUri

        }
        elseif (($Job -is [String]) -and ($Job.StartsWith($COMSchedulesUri))) {

            $ErrorMessage = "Invalid job resource provided. You cannot use 'Wait-HPECOMJobComplete' with a Schedule resource type."         
            Write-Error $ErrorMessage
            return

        }    
        else {

            $ErrorMessage = "Invalid job resourceUri provided. Please verify the job object you are passing and try again."         
            Write-Error $ErrorMessage
            return

        }    

        while ($true) {

            # Update the progress bar
            $elapsedTime = (Get-Date) - $startTime
            $percentComplete = [math]::Min((($elapsedTime.TotalSeconds / $Timeout) * 100), 100)
            
            
            try {
                
                $jobResource = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method GET -WhatIfBoolean $WhatIf 
                
                "[{0}] Get job raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobResource | Write-Verbose
                
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }                                
            
            # Extract job state from the resource object
            $jobState = $jobResource.State
            
            if ($jobResource.associatedResourceId -like "*+*") {
                
                $_jobResource = ($jobResource.associatedResourceId -split "\+")[-1]

                Write-Progress -Activity "Waiting for job completion" `
                    -Status "$_jobResource - Current state: $jobState" `
                    -PercentComplete $percentComplete
            }
            else {

                Write-Progress -Activity "Waiting for job completion" `
                    -Status "Current state: $jobState" `
                    -PercentComplete $percentComplete

            }
          

            "[{0}] Current job state: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobState | Write-Verbose
            
            if ($jobState -match "COMPLETE|ERROR|STALLED") {

                Write-Progress -Activity "Job completion" -Status "Failed" -Completed
                break
            }

            if ((Get-Date) -ge $endTime) {
                # throw "Timeout reached waiting for job to complete."
                $errorMessage = "Timeout reached waiting for job '{0}' to complete." -f $jobResource.name
                $errorRecord = New-ErrorRecord TimeoutError OperationTimeout -Message $ErrorMessage 
                Write-Progress -Activity "Job timeout reached" -Status "Failed" -Completed
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            }

            Start-Sleep -Seconds $Interval
        }

        Write-Progress -Activity "Job has reached terminal state" -Status "Completed" -Completed
        "[{0}] Job has reached terminal state: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobState | Write-Verbose
        "[{0}] Job URI: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobResource.resourceuri | Write-Verbose

        # Get activity resource message generated by the job        
        $_Message = Get-HPECOMActivity -Region $Region -JobResourceUri $jobResource.resourceuri | Select-Object -ExpandProperty formattedmessage

        # Add message to object
        $jobResource | Add-Member -type NoteProperty -name message -value $_Message

        [void]$JobCollection.Add($jobResource)

    }

    End {

        $ReturnData = Invoke-RepackageObjectWithType -RawObject $JobCollection -ObjectName "COM.Jobs"    

        return $ReturnData 

    }
}


Function Get-HPECOMJob {
    <#
    .SYNOPSIS
    Retrieve the list of jobs.

    .DESCRIPTION
    This Cmdlet returns a collection of the last seven days jobs that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER JobResourceUri
    Optional parameter that can be used to specify the Uri of a job to display.
    
    .PARAMETER Name
    Optional parameter that can be used to specify the name of a job to display.

    .PARAMETER Category 
    Optional parameter that can be used to display the jobs of a specific category. Auto-completion (Tab key) is supported for this parameter, providing a list of categories.
    
    .PARAMETER ShowRunning
    Optional switch parameter that can be used to display only running jobs.
    
    .PARAMETER ShowPending
    Optional switch parameter that can be used to display only pending jobs.
    
    .PARAMETER ShowLastMonth
    Optional switch parameter that can be used to display the jobs of the last month.  

    .PARAMETER ShowAll
    This switch parameter can be used to display the total number of jobs. Be aware, however, that this may take some time, depending on your history.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMJob -Region us-west 

    Return the last seven days jobs resources located in the western US region.

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Name IloOnlyFirmwareUpdate

    Return the last seven days jobs resources named 'IloOnlyFirmwareUpdate' located in the central EU region.

    .EXAMPLE
    Get-HPECOMJob -Region us-west -ShowLastMonth

    Return the last month jobs resources located in the western US region.

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Category server

    Return the last seven days jobs resources of type 'server' located in the central EU region. 

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Category server -ShowLastMonth 

    Return the last month jobs resources of type 'server' located in the central EU region.

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Category Analyze -ShowAll

    Return all jobs resources of type 'Analyze' located in the western US region.

    .EXAMPLE
    Get-HPECOMJob -Region us-west -ShowAll

    Return all jobs resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMJob -Region us-west -JobResourceUri '/compute-ops-mgmt/v1beta3/jobs/1649bcb6-6362-44bf-a737-8caa5142be6e'

    Return the job resource with the specified resource URI located in the western US region. 

    .EXAMPLE
    $job = Update-HPECOMServeriLOFirmware -Region eu-central -ServerSerialNumber CZJ1233444 -Async
    $job | Get-HPECOMJob 
    $job | Get-HPECOMActivity 
    $job | Wait-HPECOMJobComplete

    This example retrieves the job resource created by the 'Update-HPECOMServeriLOFirmware' cmdlet in the central EU region.
    Then it retrieves the activity resource associated with the job.
    Then it waits for the job to complete.

    .INPUTS
    System.Collections.ArrayList
        A job from one of the cmdlets creating a job.
        
    
   #>
    [CmdletBinding(DefaultParameterSetName = "JobResourceUri")]
    Param( 
    
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'ShowPending')]
        [Parameter (ParameterSetName = 'ShowRunning')]
        [Parameter (ParameterSetName = 'ShowLastMonth')]
        [Parameter (ParameterSetName = 'ShowLastThreeMonths')]
        [Parameter (ParameterSetName = 'ShowAll')]
        [Parameter (ParameterSetName = 'JobResourceUri')]
        [String]$Name,
        
        # Pipeline is supported but it requires to change the default parameter set to JobResourceUri but then 
        # it generates an error when -Name and -Category parameters are used alone as the parameter set name cannot then be identified. 
        # So I had to add the parameter set name JobResourceUri to the -Name and -Category parameters to avoid this issue + clear the $Name PS bound parameter if pipeline input
        [Parameter(ValueFromPipelineByPropertyName, ParameterSetName = 'JobResourceUri')]
        [Alias('jobUri', 'resourceUri')]
        [string]$JobResourceUri,

        [Parameter (ParameterSetName = 'ShowPending')]
        [Parameter (ParameterSetName = 'ShowRunning')]
        [Parameter (ParameterSetName = 'ShowLastMonth')]
        [Parameter (ParameterSetName = 'ShowLastThreeMonths')]
        [Parameter (ParameterSetName = 'ShowAll')]
        [Parameter (ParameterSetName = 'JobResourceUri')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Analyze', 'Filter', 'Group', 'Oneview-appliance', 'Report', 'Server', 'Server-hardware', 'Setting')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Analyze', 'Filter', 'Group', 'Oneview-appliance', 'Report', 'Server', 'Server-hardware', 'Setting')]
        [string]$Category,
        
        [Parameter (ParameterSetName = 'ShowRunning')]
        [Switch]$ShowRunning,
        
        [Parameter (ParameterSetName = 'ShowPending')]
        [Switch]$ShowPending,
        
        [Parameter (ParameterSetName = 'ShowLastMonth')]
        [Switch]$ShowLastMonth,

        [Parameter (ParameterSetName = 'ShowLastThreeMonths')]
        [Switch]$ShowLastThreeMonths,

        [Parameter (ParameterSetName = 'ShowAll')]
        [Switch]$ShowAll,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command
  
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        # Validate the job object

        if ($JobResourceUri) {

            if ($JobResourceUri -match '^/compute-ops-mgmt/[^/]+/jobs/[^/]+$') {

                "[{0}] Processing job resource uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $JobResourceUri | Write-Verbose       

            }

            else {

                $ErrorMessage = "Invalid job resourceUri provided. Please verify the job object you are passing and try again."         
                $ErrorRecord = New-ErrorRecord InvalidResourceUri InvalidArgument -TargetObject 'Job' -Message $ErrorMessage -TargetType $JobResourceUri.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )

            }  
        }

        # Get today's date in ISO 8601 format (UTC)
        $todayMinusSevenDays = (Get-Date).AddDays(-7).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ") 
        $todayMinusOneMonth = (Get-Date).AddMonths(-1).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
        $todayMinusThreeMonths = (Get-Date).AddMonths(-3).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

        # Construct the filter query
        $filterSevenDays = "createdAt gt $todayMinusSevenDays"
        $filterOneMonth = "createdAt gt $todayMinusOneMonth"
        $filterThreeMonths = "createdAt gt $todayMinusThreeMonths"


    }
    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # If pipeline input, then don't take name PS bound parameter into account as it stores the name of the job and not the displayName of a resource
        if ($JobResourceUri) {
            $Name = $null
        }

        # Determine the base URI
        $Uri = if ($JobResourceUri) {
            "[{0}] Processing job resource uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $JobResourceUri | Write-Verbose
            $JobResourceUri
        }
        else {
            $COMGetJobUri
        }

        # Helper function to add a filter to the URI
        function Add-FilterToUri {
            param (
                [string]$Uri,
                [string]$Filter
            )
            if ($Uri -match "\?") {
                if ($Uri -match "filter") {
                    $Uri + " and $Filter"
                }
                else {
                    $Uri + "&filter=$Filter"
                }
            }
            else {
                $Uri + "?filter=$Filter"
            }
        }

        # Add filters based on parameters
        if ($Name) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "name eq '$Name'"
        }

        if ($ShowRunning) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "state eq 'RUNNING'"
        }
        elseif ($ShowPending) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "state eq 'PENDING'"
        }

        # Filter 7 days except for the other cases
        if (-not $ShowAll -and -not $JobResourceUri -and -not $ShowRunning -and -not $ShowPending -and -not $ShowLastMonth -and -not $ShowLastThreeMonths) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterSevenDays
        }
        # Filter 1 month
        elseif ($ShowLastMonth) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterOneMonth
        } 
        # Filter 3 months
        elseif ($ShowLastThreeMonths) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterThreeMonths
        }
        elseif ($ShowAll) {
            # No filter
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            # Add category to object
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name Category -value $_.resource.type }
                       
            if ($Category) {

                $CollectionList = $CollectionList | Where-Object Category -match $Category

            }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Jobs"    
            $ReturnData = $ReturnData | Sort-Object -Property createdAt -Descending
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function Start-HPECOMserver {
    <#
    .SYNOPSIS
    Power on a server resource.

    .DESCRIPTION
    This cmdlet initiates the power-on operation for a server using the virtual power button.
    It provides options for scheduling the execution at a specific time and setting recurring schedules.

    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ServerSerialNumber 
    Specifies the serial number of the server to power on. 

    .PARAMETER ScheduleTime
    Indicates when to schedule the power on operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Start-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312
    
    This command powers on the server with the serial number 'CZ12312312' and waits for the job to complete before returning the job resource object. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-2  | Start-HPECOMserver -Async

    This command powers on the server named 'ESX-2' and immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -PowerState OFF -ConnectionType Direct | Start-HPECOMserver 

    This command powers on all servers in the 'us-west' region that are currently powered off and are directly managed (not OneView managed, as power controls are unsupported).

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Start-HPECOMserver -Region eu-central

    This command powers on the servers with the serial numbers 'CZ12312312' and 'DZ12312312' in the `eu-central` region.

    .EXAMPLE
    Start-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6)  

    This command schedules a power on operation for the server with the serial number 'CZ12312312' in the `eu-central` region to occur six hours from the current time. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name CZ12312312 | Start-HPECOMserver -ScheduleTime (Get-Date).AddDays(2)
  
    This command retrieves the server with the serial number 'CZ12312312' in the `eu-central` region and schedules a power on to occur two days from the current date.
    
    .EXAMPLE
    Start-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W
 
    Schedules a weekly power-on operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,        

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [String]$Interval,    

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [Switch]$WhatIf
    ) 
    
    Begin {

        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'PowerOn.New'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id
        
        $Uri = $COMJobsUri  
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
                
        # Build tracking object for a schedule output
        if ($ScheduleTime) {

            $objStatus = [pscustomobject]@{
                name               = $Null
                description        = "Scheduled task to power on server '$ServerSerialNumber'"
                associatedResource = $ServerSerialNumber
                purpose            = "SERVER_POWER_ON"
                id                 = $Null
                nextStartAt        = $Null
                lastRun            = $Null
                scheduleUri        = $Null
                schedule           = $Null
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }

        }
        # Build tracking object for non-schedule output
        else {

            $objStatus = [pscustomobject]@{               
                name               = $_JobTemplateName
                associatedResource = $ServerSerialNumber
                date               = "$((Get-Date).ToString())"
                state              = $Null
                duration           = $Null
                status             = $Null
                jobUri             = $Null 
                region             = $Region  
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {

        try {
            if ($Region) {
                $Servers = Get-HPECOMServer -Region $Region
            }
            else {
                return
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

         
        foreach ($Resource in $ObjectStatusList) {
            
            $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource
              
            if (-not $Server) {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.connectionType -eq "ONEVIEW") {

                # Not supported on OneView managed servers!
                # Must return a message if OneView managed server

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Operation not supported on OneView managed servers!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Operation not supported on OneView managed servers!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Operation not supported on OneView managed servers!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ($Server.hardware.powerState -eq "ON") {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server requested power state is already on!"

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server requested power state is already on!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Requested power state is already on!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            else {       
        
                $_serverResourceUri = $Server.resourceUri

                # Build payload

                if ($ScheduleTime) {

                    $uri = $COMSchedulesUri
    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_serverResourceUri
                        # data           = $data
                    }      
    
                    $Operation = @{
                        type   = "REST"
                        method = "POST"
                        uri    = "/api/compute/v1/jobs"
                        body   = $_Body
    
                    }
    
                    $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                    $Name = "$($ServerSerialNumber)_ServerPowerOn_Schedule_$($randomNumber)"
                    $Resource.name = $Name 

                    $Description = $Resource.description
    
    
                    if ($Interval) {
                        
                        $Schedule = @{
                            startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                            interval = $Interval
                        }
                    }
                    else {
    
                        $Schedule = @{
                            startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                            interval = $Null
                        }
                    }

                    $Resource.schedule = $Schedule 
    
                    $Payload = @{
                        name                  = $Name
                        description           = $Description
                        associatedResourceUri = $_serverResourceUri
                        purpose               = "SERVER_POWER_ON"
                        schedule              = $Schedule
                        operation             = $Operation
    
                    }
    
                }
                else {
                    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_serverResourceUri
                    }
                    
                }          
                
                $payload = ConvertTo-Json $payload -Depth 10 


                try {
        
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
        
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                            
                            $Resource.name = $_resp.name
                            $Resource.id = $_resp.id
                            $Resource.nextStartAt = $_resp.nextStartAt
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.scheduleUri = $_resp.resourceUri
                            $Resource.schedule = $Schedule
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.resultCode = "SUCCESS"
                            $Resource.details = $_resp
                            $Resource.message = "The schedule to power on the server has been successfully created."
    
                        }
    
                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {    
                             
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 420
            
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
            
                        }
                        
                        if (-not $WhatIf ) {
            
                            $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
    
                            $Resource.state = $_resp.state
                            $Resource.duration = $Duration
                            $Resource.resultCode = $_resp.resultCode
                            $Resource.message = $_resp.message
                            $Resource.status = $_resp.Status
                            $Resource.details = $_resp
                            $Resource.jobUri = $_resp.resourceUri        
                            
                        }
                    }
                    
                    "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose

                }
                catch {
        
                    if (-not $WhatIf) {
                        
                        if ($ScheduleTime) {
                            
                            $Resource.name = $Name
                            $Resource.schedule = $Schedule
                            $Resource.resultCode = "FAILURE"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                        }
                        else {
                            
                            $Resource.state = "ERROR"
                            $Resource.duration = '00:00:00'
                            $Resource.resultCode = "FAILURE"
                            $Resource.status = "Failed"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
                        }      
                    }
                }  
            }
        }
        
        if (-not $WhatIf) {

            if ($ScheduleTime) {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Schedules.Status" 
            }
            else {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 
            }

            "[{0}] Output content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

            if ($ObjectStatusList | Where-Object { $_.resultCode -eq "FAILURE" }) {

                Write-Error "One or more servers failed to power on. Please check the iLO event log for more details."
            
            }

            Return $ObjectStatusList
        }
    }        
}  


Function Restart-HPECOMserver {
    <#
    .SYNOPSIS
    Restart a server resource.

    .DESCRIPTION
    This cmdlet initiates a server restart, performing a warm boot that resets the CPUs and I/O resources. 
    It provides options for scheduling the restart at a specific time and setting recurring schedules.
    
    A warm-boot means that the server is restarted without completely powering it off. The system performs a reset of the CPUs and I/O resources while keeping the power on. 
    This type of reboot is quicker than a cold boot (where the system is completely powered off and then turned back on).
        
    During the warm boot, CPUs and I/O resources of the server are reset. This helps to clear any temporary issues or states that might be affecting the server's performance or stability.
        
    Note: This operation bypasses the operating system's graceful shutdown features. A graceful shutdown allows the operating system to close all running applications 
          and processes properly, saving any necessary data and ensuring that the system is in a consistent state before shutting down. By forcing a warm boot, this cmdlet 
          bypasses these graceful shutdown procedures, which means that any unsaved data or open applications may be lost, and the system may not be in a consistent state when it restarts.
            
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ServerSerialNumber 
    Specifies the serial number of the server to restart. 

    .PARAMETER ScheduleTime
    Indicates when to schedule the restart operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Restart-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312
    
    This command restarts the server with the serial number 'CZ12312312' and waits for the job to complete then return the job resource object. 

    .EXAMPLE
    Restart-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312 -Async 

    This command restarts the server with the serial number 'CZ12312312' and immediately returns the asynchronous job resource to monitor.
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-2  | Restart-HPECOMserver -Async

    This command restarts the server named 'ESX-2' and immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -PowerState ON -ConnectionType Direct | Restart-HPECOMserver 

    This command restarts on all servers in the 'us-west' region that are currently powered on and are directly managed (not OneView managed, as power controls are unsupported).
    
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Restart-HPECOMserver -Region eu-central

    This command restarts the servers with the serial numbers 'CZ12312312' and 'DZ12312312' in the `eu-central` region.

    .EXAMPLE
    Restart-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6)  

    This command schedules a restart operation for the server with the serial number 'CZ12312312' in the `eu-central` region to occur six hours from the current time. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name CZ12312312 | Restart-HPECOMserver -ScheduleTime (Get-Date).AddDays(2)
  
    This command retrieves the server with the serial number 'CZ12312312' in the `eu-central` region and schedules a restart to occur two days from the current date.

    .EXAMPLE
    Restart-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W
 
    Schedules a weekly restart operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [String]$Interval,    

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [Switch]$WhatIf
    ) 


    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'Restart.New'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $Uri = $COMJobsUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        
        # Build tracking object for a schedule output
        if ($ScheduleTime) {

            $objStatus = [pscustomobject]@{
                name               = $Null
                description        = "Scheduled task to restart server '$ServerSerialNumber'"
                associatedResource = $ServerSerialNumber
                purpose            = "SERVER_RESTART"
                id                 = $Null
                nextStartAt        = $Null
                lastRun            = $Null
                scheduleUri        = $Null
                schedule           = $Null
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }

        }
        # Build tracking object for non-schedule output
        else {

            $objStatus = [pscustomobject]@{               
                name               = $_JobTemplateName
                associatedResource = $ServerSerialNumber
                date               = "$((Get-Date).ToString())"
                state              = $Null
                duration           = $Null
                status             = $Null
                jobUri             = $Null 
                region             = $Region  
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {

        try {
            if ($Region) {
                $Servers = Get-HPECOMServer -Region $Region
            }
            else {
                return
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

         
        foreach ($Resource in $ObjectStatusList) {
            
            $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource
              
            if (-not $Server) {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.connectionType -eq "ONEVIEW") {

                # Not supported on OneView managed servers!
                # Must return a message if OneView managed server

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "The attempted operation is not supported on OneView managed servers!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "The attempted operation is not supported on OneView managed servers!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Operation not supported on OneView managed servers!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ($Server.hardware.powerState -eq "OFF") {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server power state must be ON to be restarted."

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server power state must be ON to be restarted."
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Power state must be ON to be restarted." -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            else {       
        
                $_serverResourceUri = $Server.resourceUri

                # Build payload

                if ($ScheduleTime) {

                    $uri = $COMSchedulesUri
    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_serverResourceUri
                        # data           = $data
                    }      
    
                    $Operation = @{
                        type   = "REST"
                        method = "POST"
                        uri    = "/api/compute/v1/jobs"
                        body   = $_Body
    
                    }
    
                    $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                    $Name = "$($ServerSerialNumber)_ServerRestart_Schedule_$($randomNumber)"
                    $Resource.name = $Name 

                    $Description = $Resource.description
    
    
                    if ($Interval) {
                        
                        $Schedule = @{
                            startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                            interval = $Interval
                        }
                    }
                    else {
    
                        $Schedule = @{
                            startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                            interval = $Null
                        }
                    }

                    $Resource.schedule = $Schedule 
    
                    $Payload = @{
                        name                  = $Name
                        description           = $Description
                        associatedResourceUri = $_serverResourceUri
                        purpose               = "SERVER_RESTART"
                        schedule              = $Schedule
                        operation             = $Operation
    
                    }
    
                }
                else {
                    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_serverResourceUri
                    }
                    
                }          
                
                $payload = ConvertTo-Json $payload -Depth 10 


                try {
        
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
        
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                            
                            $Resource.name = $_resp.name
                            $Resource.id = $_resp.id
                            $Resource.nextStartAt = $_resp.nextStartAt
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.scheduleUri = $_resp.resourceUri
                            $Resource.schedule = $Schedule
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.resultCode = "SUCCESS"
                            $Resource.details = $_resp
                            $Resource.message = "The schedule to restart the server has been successfully created."
    
                        }
    
                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {    
                             
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri  -Timeout 420
            
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
            
                        }
                        
                        if (-not $WhatIf ) {
            
                            $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
    
                            $Resource.state = $_resp.state
                            $Resource.duration = $Duration
                            $Resource.resultCode = $_resp.resultCode
                            $Resource.message = $_resp.message
                            $Resource.status = $_resp.Status
                            $Resource.details = $_resp
                            $Resource.jobUri = $_resp.resourceUri        
                            
                        }
                    }
                    
                    "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose

                }
                catch {
        
                    if (-not $WhatIf) {
                        
                        if ($ScheduleTime) {

                            $Resource.name = $Name
                            $Resource.schedule = $Schedule
                            $Resource.resultCode = "FAILURE"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                        }
                        else {
                            
                            $Resource.state = "ERROR"
                            $Resource.duration = '00:00:00'
                            $Resource.resultCode = "FAILURE"
                            $Resource.status = "Failed"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
                        }      
                    }
                }  
            }
        }
        
        if (-not $WhatIf) {

            if ($ScheduleTime) {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Schedules.Status" 
            }
            else {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 
            }

            "[{0}] Output content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

            if ($ObjectStatusList | Where-Object { $_.resultCode -eq "FAILURE" }) {

                Write-Error "One or more servers failed to restart. Please check the iLO event log for more details."

            
            }

            Return $ObjectStatusList
        }
    }   
}

Function Stop-HPECOMserver {
    <#
    .SYNOPSIS
    Power off a server resource.

    .DESCRIPTION
    This cmdlet initiates a graceful shutdown of a server using the virtual power button. It also provides options for scheduling the shutdown at a specific time and setting recurring schedules.

    Note: If the operating system does not shut down gracefully, this cmdlet will forcibly power off the server using the force-off option.
            
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ServerSerialNumber 
    Specifies the serial number of the server to power off. 

    .PARAMETER ScheduleTime
    Indicates when to schedule the power off operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Force 
    Switch parameter to force the power off, akin to pressing the physical power button for 5 seconds and then releasing it.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Stop-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312
    
    This command initiates a graceful shutdown of the server with the serial number 'CZ12312312' and waits for the job to complete before returning the job resource object. 
    
    .EXAMPLE
    Stop-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312 -Force
    
    This command forces the server with the serial number 'CZ12312312' to power off without waiting for a graceful shutdown of the OS, then waits for the job to complete, and finally returns the job resource object.

    .EXAMPLE 
    Get-HPECOMServer -Region eu-central -Name ESX-2  | Stop-HPECOMserver -Async

    This command powers off the server named 'ESX-2' and immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -PowerState ON -ConnectionType Direct | Stop-HPECOMserver 

    This command initiates a graceful shutdown of all servers in the 'us-west' region that are currently powered on and are directly managed (not OneView managed, as power controls are unsupported).
    
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Stop-HPECOMserver -Region eu-central

    This command powers off the servers with the serial numbers 'CZ12312312' and 'DZ12312312' in the `eu-central` region.

    .EXAMPLE
    Stop-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6)  

    This command schedules a power off operation for the server with the serial number 'CZ12312312' in the `eu-central` region to occur six hours from the current time. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name CZ12312312 | Stop-HPECOMserver -ScheduleTime (Get-Date).AddDays(2)
  
    This command retrieves the server with the serial number 'CZ12312312' in the `eu-central` region and schedules a power off to occur two days from the current date.
    
    .EXAMPLE
    Stop-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W
 
    This command schedules a weekly graceful shutdown operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .EXAMPLE
    Stop-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W -Force
 
    This command schedules a weekly forced shutdown operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,    

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,
        
        [Parameter (ParameterSetName = 'SerialNumber')]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [switch]$Force,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [String]$Interval,    

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [Switch]$WhatIf
    ) 

    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'PowerOff.New'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $Uri = $COMJobsUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        
        # Build tracking object for a schedule output
        if ($ScheduleTime) {

            $objStatus = [pscustomobject]@{
                name               = $Null
                description        = "Scheduled task to power off server '$ServerSerialNumber'"
                associatedResource = $ServerSerialNumber
                purpose            = "SERVER_POWER_OFF"
                id                 = $Null
                nextStartAt        = $Null
                lastRun            = $Null
                scheduleUri        = $Null
                schedule           = $Null
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }

        }
        # Build tracking object for non-schedule output
        else {

            $objStatus = [pscustomobject]@{               
                name               = $_JobTemplateName
                associatedResource = $ServerSerialNumber
                date               = "$((Get-Date).ToString())"
                state              = $Null
                duration           = $Null
                status             = $Null
                jobUri             = $Null 
                region             = $Region  
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {

        try {
            if ($Region) {
                $Servers = Get-HPECOMServer -Region $Region
            }
            else {
                return
            }
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

         
        foreach ($Resource in $ObjectStatusList) {
            
            $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource
              
            if (-not $Server) {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.connectionType -eq "ONEVIEW") {

                # Not supported on OneView managed servers!
                # Must return a message if OneView managed server

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "The attempted operation is not supported on OneView managed servers!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "The attempted operation is not supported on OneView managed servers!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Operation not supported on OneView managed servers!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ($Server.hardware.powerState -eq "OFF") {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server requested power state is already off!"

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server requested power state is already off!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Requested power state is already off." -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            else {       
        
                $_serverResourceUri = $Server.resourceUri

                # Build payload

                if ($ScheduleTime) {

                    if ($Force) {

                        $data = @{operationType = "ForceOff" }
                        
                    }
                    else {
    
                        $data = @{operationType = "GracefulShutdown" }
                        
                    }

                    $uri = $COMSchedulesUri
    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_serverResourceUri
                        data           = $data
                    }      
    
                    $Operation = @{
                        type   = "REST"
                        method = "POST"
                        uri    = "/api/compute/v1/jobs"
                        body   = $_Body
    
                    }
    
                    $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                    $Name = "$($ServerSerialNumber)_ServerPowerOff_Schedule_$($randomNumber)"
                    $Resource.name = $Name 

                    $Description = $Resource.description
    
    
                    if ($Interval) {
                        
                        $Schedule = @{
                            startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                            interval = $Interval
                        }
                    }
                    else {
    
                        $Schedule = @{
                            startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                            interval = $Null
                        }
                    }

                    $Resource.schedule = $Schedule 
    
                    $Payload = @{
                        name                  = $Name
                        description           = $Description
                        associatedResourceUri = $_serverResourceUri
                        purpose               = "SERVER_POWER_OFF"
                        schedule              = $Schedule
                        operation             = $Operation
    
                    }
    
                }
                else {
                    
                    if ($Force) {

                        $payload = @{
                            jobTemplateUri = $JobTemplateUri
                            resourceUri    = $_serverResourceUri
                            data           = @{operationType = "ForceOff" }
                        } 
                    }
                    else {
    
                        $payload = @{
                            jobTemplateUri = $JobTemplateUri
                            resourceUri    = $_serverResourceUri
                            data           = @{operationType = "GracefulShutdown" }
                        } 
                    }
                    
                }          
                
                $payload = ConvertTo-Json $payload -Depth 10 


                try {
        
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
        
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                            
                            $Resource.name = $_resp.name
                            $Resource.id = $_resp.id
                            $Resource.nextStartAt = $_resp.nextStartAt
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.scheduleUri = $_resp.resourceUri
                            $Resource.schedule = $Schedule
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.resultCode = "SUCCESS"
                            $Resource.details = $_resp
                            $Resource.message = "The schedule to power off the server has been successfully created."
    
                        }
    
                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {    
                             
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri  -Timeout 420
            
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
            
                        }
                        
                        if (-not $WhatIf ) {
            
                            $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
    
                            $Resource.state = $_resp.state
                            $Resource.duration = $Duration
                            $Resource.resultCode = $_resp.resultCode
                            $Resource.message = $_resp.message
                            $Resource.status = $_resp.Status
                            $Resource.details = $_resp
                            $Resource.jobUri = $_resp.resourceUri        
                            
                        }
                    }
                    
                    "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose

                }
                catch {
        
                    if (-not $WhatIf) {
                        
                        if ($ScheduleTime) {

                            $Resource.name = $Name
                            $Resource.schedule = $Schedule
                            $Resource.resultCode = "FAILURE"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                        }
                        else {
                            
                            $Resource.state = "ERROR"
                            $Resource.duration = '00:00:00'
                            $Resource.resultCode = "FAILURE"
                            $Resource.status = "Failed"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
                        }      
                    }
                }  
            }
        }
        
        if (-not $WhatIf) {

            if ($ScheduleTime) {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Schedules.Status" 
            }
            else {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 
            }

            "[{0}] Output content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

            if ($ObjectStatusList | Where-Object { $_.resultCode -eq "FAILURE" }) {

                Write-Error "One or more servers failed to power off. Please check the iLO event log for more details."
            
            }

            Return $ObjectStatusList
        }
    }   
}
  

function Update-HPECOMServerFirmware {
    <#
    .SYNOPSIS
    Update the firmware on a server.
    
    .DESCRIPTION   
    This cmdlet updates the firmware on a specified server, identified by its serial number. It also provides an option to schedule the update at a specific time.

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the firmware update will be performed.
    
    .PARAMETER FirmwareBundleReleaseVersion
    Mandatory parameter that defines the firmware bundle release version to use for updating the server. This release version can be found using 'Get-HPECOMFirmwareBundle'.

    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER InstallHPEDriversAndSoftware
    Specifies whether to install HPE drivers and software during the firmware update.

    .PARAMETER WaitForPowerOfforReboot
    Enable this to cause the update to wait for the user to reboot or power off the server before performing the installation.
    
    Note: Server reboot or power off must be performed outside of Compute Ops Management console.

    .PARAMETER WaitForPowerOfforRebootTimeout
    Specifies the timeout duration (in hours) to wait for the user to power off or reboot the server. If the timeout expires, the firmware update will be canceled. 
    The default timeout duration is 4 hours.    

    .PARAMETER PowerOffAfterUpdate
    Specifies whether to power off the server after the firmware update is complete.

    .PARAMETER DisablePrerequisiteCheck
    Specifies whether to disable the prerequisites check before running the firmware update.

    .PARAMETER AllowFirmwareDowngrade
    Specifies whether to allow the downgrade of firmware during the firmware update.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMServerFirmware -Region us-west -ServerSerialNumber 2M28490180 -FirmwareBundleReleaseVersion "2024.04.00.01" -InstallHPEDriversAndSoftware -PowerOffAfterUpdate -DisablePrerequisiteCheck -AllowFirmwareDowngrade

    This command updates the firmware on a server with serial number `2M28490180` located in the `us-west` region using firmware bundle release version `2024.04.00.01`. The cmdlet waits for the job to complete and displays a progress bar. 
    It also installs HPE drivers and software, powers off the server after the update, disables the prerequisite check, and allows firmware downgrade.
    
    .EXAMPLE
    Update-HPECOMServerFirmware -Region us-west -ServerSerialNumber 2M28490180 -FirmwareBundleReleaseVersion "2024.04.00.01" -Async

    This command updates the firmware on a server with serial number `2M28490180` located in the `us-west` region using firmware bundle release version `2024.04.00.01`. The cmdlet immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Update-HPECOMServerFirmware -Region eu-central -FirmwareBundleReleaseVersion "2024.04.00.01"

    This command updates the firmware on servers with serial numbers `CZ12312312` and `DZ12312312` located in the `eu-central` region using firmware bundle release version `2024.04.00.01`.
    By default, it does not install HPE drivers and software, does not power off the server after the update, enables the prerequisite check, and does not allow firmware downgrade.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name HOL58 | Update-HPECOMServerFirmware -FirmwareBundleReleaseVersion "2024.04.00.01"

    This command updates the firmware on a server with the name `HOL58` located in the `us-west` region using firmware bundle release version `2024.04.00.01`. 
    By default, it does not install HPE drivers and software, does not power off the server after the update, enables the prerequisite check, and does not allow firmware downgrade.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectedState True -PowerState OFF -Model 'ProLiant DL385 Gen10 Plus' | Update-HPECOMServerFirmware -FirmwareBundleReleaseVersion "2024.04.00.01" -PowerOffAfterUpdate -AllowFirmwareDowngrade -Async 

    This command update all DL385 Gen10 Plus servers that are powered off and connected to COM with the specified firmware bundle release version. 
    The first command retrieves a list of all "ProLiant DL385 Gen10 Plus" servers in the "us-west" region that are currently powered off and connected.
    The retrieved servers are then piped (|) to the Update-HPECOMServerFirmware cmdlet, which updates their firmware to the specified version.
    The command also powers off the servers after the update, allows firmware downgrade and returns mmediately the async task.

    .EXAMPLE
    Update-HPECOMServerFirmware -Region eu-central -ServerSerialNumber DZ12312312 -FirmwareBundleReleaseVersion 2024.04.00.02 -ScheduleTime (Get-Date).AddMonths(6) -InstallHPEDriversAndSoftware -PowerOffAfterUpdate -AllowFirmwareDowngrade

    This command creates a schedule to update the firmware of a server with the serial number `DZ12312312` in the `eu-central` region using firmware bundle release version `2024.04.00.01`. 
    The update is scheduled to occur six months from the current date and includes installing HPE drivers and software while allowing firmware downgrade.
    The command also powers off the server after the update.

    .EXAMPLE
    Update-HPECOMServerFirmware -Region eu-central -ServerSerialNumber DZ12312312 -FirmwareBundleReleaseVersion "2024.04.00.01" -WaitForPowerOfforReboot -WaitForPowerOfforRebootTimeout 24 

    This command updates the firmware on a server with serial number `DZ12312312` located in the `eu-central` region using firmware bundle release version `2024.04.00.01`.
    The cmdlet waits for the user to power off or reboot the server before performing the installation, with a timeout of 24 hours.
    After 24 hours, if the server is not powered off or rebooted, the firmware update will be canceled.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Model "ProLiant DL360 Gen10 Plus" | Update-HPECOMServerFirmware -FirmwareBundleReleaseVersion 2024.04.00.02 -ScheduleTime (Get-Date).AddDays(4) -InstallHPEDriversAndSoftware  -AllowFirmwareDowngrade

    This example retrieves a list of all "ProLiant DL360 Gen10 Plus" servers in the `eu-central` region and schedules a firmware update for them using bundle version `2024.04.00.02`. 
    The update is scheduled to occur four days from the current date and includes installing HPE drivers and software while allowing firmware downgrade.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,
        
        [Parameter (Mandatory)]
        [String]$FirmwareBundleReleaseVersion,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [switch]$InstallHPEDriversAndSoftware,

        [switch]$WaitForPowerOfforReboot,

        [ValidateSet(1, 2, 4, 8, 12, 24)]
        [int]$WaitForPowerOfforRebootTimeout = 4,

        [switch]$PowerOffAfterUpdate,

        [switch]$DisablePrerequisiteCheck,

        [switch]$AllowFirmwareDowngrade,

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600 # Timeout 1 hour

        $Caller = (Get-PSCallStack)[1].Command
    
        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'FirmwareUpdate.New'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()

        
    }
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for a schedule output
        if ($ScheduleTime) {

            $objStatus = [pscustomobject]@{
                name               = $Null
                description        = $Null
                associatedResource = $ServerSerialNumber
                purpose            = $Null
                id                 = $Null
                nextStartAt        = $Null
                lastRun            = $Null
                scheduleUri        = $Null
                schedule           = $Null
                resultCode         = $Null
                message            = $Null    
                details            = $Null           
            }

        }
        # Build tracking object for non-schedule output
        else {

            $objStatus = [pscustomobject]@{

                associatedResource = $ServerSerialNumber
                date               = "$((Get-Date).ToString())"
                state              = $Null
                name               = $_JobTemplateName
                duration           = $Null
                resultCode         = $Null
                status             = $Null
                message            = $Null    
                region             = $Region  
                jobUri             = $Null 
                Details            = $Null        
            
            }
        }
       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {
 
        try {
            if ($Region) {
                $Bundles = Get-HPECOMFirmwareBundle -Region $Region -ReleaseVersion $FirmwareBundleReleaseVersion 
            }
            else {
                return
            }
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if (-not $Bundles) {

            # Must return a message if not found
            $ErrorMessage = "Firmware bundle release version '{0}' cannot be found in the Compute Ops Management instance!" -f $FirmwareBundleReleaseVersion
            throw $ErrorMessage
            
        }


        try {
            $Servers = Get-HPECOMServer -Region $Region
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

           
        foreach ($Resource in $ObjectStatusList) {
            
            $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource

            "[{0}] Server {1} - Found: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource.associatedResource, $Server | Write-Verbose


            if ($Server.serverGeneration -eq "UNKNOWN") {

                "[{0}] Server {1} - Unable to retrieve server hardware information. Please check the iLO event logs for further details." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource.associatedResource | Write-Verbose
            }
            else {

                [int]$_serverGeneration = $Server.serverGeneration -replace "GEN_", ""
                "[{0}] Server {1} - Generation: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource.associatedResource, $_serverGeneration | Write-Verbose

            }


            if (-not $Server) {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"
                    
                }
                 
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.serverGeneration -eq "UNKNOWN") {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Unable to retrieve server hardware information. Please check the iLO event logs for further details."

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "Unable to retrieve server hardware information. Please check the iLO event logs for further details."
                    
                }
                 
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Unable to retrieve hardware information. Please check the iLO event logs for further details." -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.connectionType -eq "ONEVIEW") {

                # Not supported on OneView managed servers!
                # Must return a message if OneView managed server

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Operation not supported on OneView managed servers!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "Operation not supported on OneView managed servers!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Operation not supported on OneView managed servers!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            else {       
        
                $_serverResourceUri = $Server.resourceUri


                try {
                    $Bundle = $Bundles | Where-Object { $_.bundleGeneration -match $_serverGeneration }
                    $BundleID = $Bundle.id
                    
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }
    
                if (-not $BundleID) {

                    # Must return a message if not found
                       
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "Firmware bundle release version '{0}' cannot be found in the Compute Ops Management instance!" -f $FirmwareBundleReleaseVersion
                    
                    if ($WhatIf) {
                        $ErrorMessage = "Firmware bundle release version '{0}' cannot be found in the Compute Ops Management instance!" -f $FirmwareBundleReleaseVersion
                        Write-warning $ErrorMessage
                        continue
                    }
                }
                else {

                    if ($WaitForPowerOfforReboot) {
                        $WaitPowerOff = $true
                    }
                    else {
                        $WaitPowerOff = $false
                    }

                    if ($AllowFirmwareDowngrade) {
                        $Downgrade = $true
                    }
                    else {
                        $Downgrade = $false
                    }
    
                    if ($PowerOffAfterUpdate) {
                        $PowerOff = $true
                    }
                    else {
                        $PowerOff = $false
                    }
    
                    if ($InstallHPEDriversAndSoftware) {
                        $InstallSwDrivers = $true
                    }
                    else {
                        $InstallSwDrivers = $false
                    }
    
                    if ($DisablePrerequisiteCheck) {
                        $PrerequisiteCheck = $false
                    }
                    else {
                        $PrerequisiteCheck = $true
                    }
            
                    $data = @{
                        bundle_id                               = $BundleID
                        downgrade                               = $Downgrade
                        install_sw_drivers                      = $InstallSwDrivers
                        power_off                               = $PowerOff
                        prerequisite_check                      = $PrerequisiteCheck
                        wait_for_power_off_or_reboot            = $WaitPowerOff
                        wait_for_power_off_or_reboot_timeout    = $WaitForPowerOfforRebootTimeout
                    }
    
                    if ($ScheduleTime) {
    
                        $uri = $COMSchedulesUri
    
                        $_Body = @{
                            jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                            # jobTemplateUri = $JobTemplateUri
                            resourceUri    = $_serverResourceUri
                            data           = $data
                        }      
        
                        $Operation = @{
                            type   = "REST"
                            method = "POST"
                            uri    = "/api/compute/v1/jobs"
                            body   = $_Body
        
                        }
    
                        $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                        $Name = "$($ServerSerialNumber)_ServerFirmwareUpdate_Schedule_$($randomNumber)"
                        $Description = "Scheduled task to update firmware for '$ServerSerialNumber' server"
        
    
                        $Schedule = @{
                            startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                            # interval = $Null
                        }
        
    
                        $Payload = @{
                            name                  = $Name
                            description           = $Description
                            associatedResourceUri = $_serverResourceUri
                            purpose               = "SERVER_FW_UPDATE"
                            schedule              = $Schedule
                            operation             = $Operation
        
                        }
    
                    }
                    else {
                    
                        $Payload = @{
                            jobTemplateUri = $JobTemplateUri
                            resourceUri    = $_serverResourceUri
                            data           = $data
                        }      
                    }
    
                    $payload = ConvertTo-Json $payload -Depth 10 


                    try {
            
                        $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   
    
                        if ($ScheduleTime) {
    
                            if (-not $WhatIf) {
        
                                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                                
                                $Resource.name = $_resp.name
                                $Resource.description = $_resp.description
                                $Resource.id = $_resp.id
                                $Resource.purpose = $_resp.purpose
                                $Resource.nextStartAt = $_resp.nextStartAt
                                $Resource.lastRun = $_resp.lastRun
                                $Resource.scheduleUri = $_resp.resourceUri
                                $Resource.schedule = $Schedule
                                $Resource.lastRun = $_resp.lastRun
                                $Resource.resultCode = "SUCCESS"
                                $Resource.details = $_resp
                                $Resource.message = "The schedule to update server firmware has been successfully created."
        
                            }
                        }
                        else {
    
                            if (-not $WhatIf -and -not $Async) {    
                                 
                                "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
                
                                $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri  -Timeout $TimeoutinSecondsPerServer
                
                                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                
                            }
                            
                            if (-not $WhatIf ) {
                
                                $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
        
                                $Resource.state = $_resp.state
                                $Resource.duration = $Duration
                                $Resource.resultCode = $_resp.resultCode
                                $Resource.message = $_resp.message
                                $Resource.status = $_resp.Status
                                $Resource.details = $_resp
                                $Resource.jobUri = $_resp.resourceUri
                                
                            }
                        }
                        
                        "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose

                    }
                    catch {
            
                        if (-not $WhatIf) {

                            if ($ScheduleTime) {

                                $Resource.name = $Name
                                $Resource.description = $Description
                                $Resource.schedule = $Schedule
                                $Resource.resultCode = "FAILURE"
                                $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
    
                            }
                            else {
                                
                                $Resource.state = "ERROR"
                                $Resource.duration = '00:00:00'
                                $Resource.resultCode = "FAILURE"
                                $Resource.Status = "Failed"
                                $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                            }
                        }
                    } 
                }             
            }
        }
        
        if (-not $WhatIf) {

            if ($ScheduleTime) {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Schedules.Status" 
            }
            else {
                
                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 
            }

            if ($ObjectStatusList | Where-Object { $_.resultCode -eq "FAILURE" }) {

                Write-Error "Firmware update failed on one or more servers. Please review the iLO event logs for further details."
            
            }

            Return $ObjectStatusList
        }
    }        
}  
    

function Update-HPECOMServeriLOFirmware {
    <#
    .SYNOPSIS
    Updates the iLO firmware component on a server. 
    
    .DESCRIPTION   
    This cmdlet updates the iLO firmware of a specified server using its serial number by installing the firmware version required by Compute Ops Management.
    It also provides an option to schedule the update at a specific time.

    Note: This cmdlet can ONLY be used when automatic iLO firmware updates are disabled in your workspace. 
          Refer to 'Get-HPECOMServer -Region $Region -Name $SerialNumber -ShowAutoiLOFirmwareUpdateStatus', 'Enable-HPECOMServerAutoiLOFirmwareUpdate', and 'Disable-HPECOMServerAutoiLOFirmwareUpdate' for more information.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the iLO firmware update will be performed.
    
    .PARAMETER ScheduleTime
    Indicates when to schedule the firmware update operation..

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMServeriLOFirmware -Region us-west -ServerSerialNumber 2M240400JN 

    This command updates the iLO firmware on a server with serial number `2M240400JN` located in the `us-west` region.
   
    .EXAMPLE
    Update-HPECOMServeriLOFirmware -Region us-west -ServerSerialNumber 2M240400JN -Async

    This command updates the iLO firmware on a server with serial number `2M240400JN` located in the `us-west` region and immediately returns the async task.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "HOL58" | Update-HPECOMServeriLOFirmware 

    This command updates the iLO firmware on a server with the name `HOL58` located in the `eu-central` region.
    
    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model 'ProLiant DL385 Gen10 Plus' | Update-HPECOMServeriLOFirmware 

    This command updates the iLO firmware on all 'ProLiant DL385 Gen10 Plus' servers located in the `us-west` region. 

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Update-HPECOMServeriLOFirmware -Region eu-central 
    
    This command updates the iLO firmware on the servers with serial numbers `CZ12312312` and `DZ12312312` located in the `eu-central` region.
    
    .EXAMPLE
    Update-HPECOMServeriLOFirmware -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddMinutes(10)

    This command schedules the iLO firmware update for the server with serial number `CZ12312312` located in the `eu-central` region to run ten minutes from now.
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectedState True -Model "ProLiant DL360 Gen10 Plus" | Update-HPECOMServeriLOFirmware -ScheduleTime (Get-Date).AddHours(12)

    This command schedules the iLO firmware update for all 'ProLiant DL360 Gen10 Plus' servers located in the `eu-central` region to run twelve hours from now. 

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.


    #>

    [CmdletBinding(DefaultParameterSetName = 'Scheduled')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'IloOnlyFirmwareUpdate'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri      
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()

        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for a schedule output
        if ($ScheduleTime) {

            $objStatus = [pscustomobject]@{

                name               = $Null
                description        = $Null
                associatedResource = $ServerSerialNumber
                purpose            = $Null
                id                 = $Null
                nextStartAt        = $Null
                lastRun            = $Null
                scheduleUri        = $Null
                schedule           = $Null
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }

        }
        # Build tracking object for non-schedule output
        else {

            $objStatus = [pscustomobject]@{

                associatedResource = $ServerSerialNumber
                date               = "$((Get-Date).ToString())"
                state              = $Null
                name               = $_JobTemplateName
                duration           = $Null
                resultCode         = $Null
                status             = $Null
                message            = $Null    
                region             = $Region  
                jobUri             = $Null 
                details            = $Null        
            
            }
        }
       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {

        try {
            if ($Region) {
                $Servers = Get-HPECOMServer -Region $Region
            }
            else {
                return
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }



        foreach ($Resource in $ObjectStatusList) {
            
            $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource

            "[{0}] Server {1} - Found: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource.associatedResource, $Server | Write-Verbose


            if ($Server.serverGeneration -eq "UNKNOWN") {

                "[{0}] Server {1} - Unable to retrieve server hardware information. Please check the iLO event logs for further details." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource.associatedResource | Write-Verbose
            }
            else {

                [int]$_serverGeneration = $Server.serverGeneration -replace "GEN_", ""
                "[{0}] Server {1} - Generation: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource.associatedResource, $_serverGeneration | Write-Verbose

            }


            if (-not $Server) {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Server cannot be found in the Compute Ops Management instance!"
                    
                }
                 
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.serverGeneration -eq "UNKNOWN") {

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Unable to retrieve server hardware information. Please check the iLO event logs for further details."

                }
                else {
                    
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Unable to retrieve server hardware information. Please check the iLO event logs for further details."
                    
                }
                 
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Unable to retrieve hardware information. Please check the iLO event logs for further details." -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            elseif ($Server.connectionType -eq "ONEVIEW") {

                # Not supported on OneView managed servers!
                # Must return a message if OneView managed server

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Operation not supported on OneView managed servers!"

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Operation not supported on OneView managed servers!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Operation not supported on OneView managed servers!" -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ($Server.autoIloFwUpdate -eq $True) {

                # Not supported if autoIloFwUpdate is enabled

                if ($ScheduleTime) {

                    $Resource.resultCode = "FAILURE"
                    $Resource.message = "Operation not supported because auto iLO firmware update is enabled. To proceed, disable auto iLO firmware update using 'Disable-HPECOMServerAutoiLOFirmwareUpdate'."

                }
                else {

                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.status = "Failed"
                    $Resource.message = "Operation not supported because auto iLO firmware update is enabled. To proceed, disable auto iLO firmware update using 'Disable-HPECOMServerAutoiLOFirmwareUpdate'."
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Operation not supported because auto iLO firmware update is enabled. To proceed, disable auto iLO firmware update using 'Disable-HPECOMServerAutoiLOFirmwareUpdate'." -f $Resource.associatedResource
                    Write-warning $ErrorMessage
                    continue
                }
            }
            else {    

                $_serverResourceUri = $Server.resourceUri

                if ($ScheduleTime) {

                    $uri = $COMSchedulesUri
    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_serverResourceUri
                        # data           = $data
                    }      
    
                    $Operation = @{
                        type   = "REST"
                        method = "POST"
                        uri    = "/api/compute/v1/jobs"
                        body   = $_Body
    
                    }
    
                    $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                    $Name = "$($ServerSerialNumber)_ServeriLOFirmwareUpdate_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to update iLO firmware for '$ServerSerialNumber' server"
    
    
                    $Schedule = @{
                        startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                        # interval = $Null
                    }
    
    
                    $Payload = @{
                        name                  = $Name
                        description           = $Description
                        associatedResourceUri = $_serverResourceUri
                        purpose               = "SERVER_ILO_FW_UPDATE"
                        schedule              = $Schedule
                        operation             = $Operation
    
                    }
    
                }
                else {
    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_serverResourceUri
                    
                    }      
                }
    
                $payload = ConvertTo-Json $payload -Depth 10 

                try {
            
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
    
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                            
                            $Resource.name = $_resp.name
                            $Resource.description = $_resp.description
                            $Resource.id = $_resp.id
                            $Resource.purpose = $_resp.purpose
                            $Resource.nextStartAt = $_resp.nextStartAt
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.scheduleUri = $_resp.resourceUri
                            $Resource.schedule = $Schedule
                            $Resource.lastRun = $_resp.lastRun
                            $Resource.resultCode = "SUCCESS"
                            $Resource.details = $_resp
                            $Resource.message = "The schedule to update iLO firmware has been successfully created."
    
                        }
                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {    
                             
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri  -Timeout 600
            
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
            
                        }
                        
                        if (-not $WhatIf ) {
            
                            $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
    
                            $Resource.state = $_resp.state
                            $Resource.duration = $Duration
                            $Resource.resultCode = $_resp.resultCode
                            $Resource.message = $_resp.message
                            $Resource.status = $_resp.Status
                            $Resource.details = $_resp
                            $Resource.jobUri = $_resp.resourceUri
                            
                        }
                    }
                    
                    "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose

                }
                catch {
        
                    if (-not $WhatIf) {

                        if ($ScheduleTime) {

                            $Resource.name = $Name
                            $Resource.description = $Description
                            $Resource.schedule = $Schedule
                            $Resource.resultCode = "FAILURE"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                        }
                        else {
                            
                            $Resource.state = "ERROR"
                            $Resource.duration = '00:00:00'
                            $Resource.resultCode = "FAILURE"
                            $Resource.status = "Failed"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                        }
                    }
                } 
            }             
        }
    
    
        if (-not $WhatIf) {

            if ($ScheduleTime) {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Schedules.Status" 
            }
            else {
                
                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 
            }

            if ($ObjectStatusList | Where-Object { $_.resultCode -eq "FAILURE" }) {

                Write-Error "iLO firmware update failed on one or more servers. Please review the iLO event logs for further details."
            
            }

            Return $ObjectStatusList
        }
    }        
}  



function Update-HPECOMGroupFirmware {
    <#
    .SYNOPSIS
    Updates the firmware of a group of servers.
    
    .DESCRIPTION   
    This cmdlet initiates a parallel server group firmware update that will affect some or all of the server group members. It also provides an option to schedule the update at a specific time.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER GroupName
    Name of the group on which the firmware update will be performed.     
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the firmware update will be performed.

    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER InstallHPEDriversAndSoftware
    Specifies whether to install HPE drivers and software during the firmware update.

    .PARAMETER WaitForPowerOfforReboot
    Enable this to cause the update to wait for the user to reboot or power off the server before performing the installation.
    
    Note: Server reboot or power off must be performed outside of Compute Ops Management console.

    .PARAMETER WaitForPowerOfforRebootTimeout
    Specifies the timeout duration (in hours) to wait for the user to power off or reboot the server. If the timeout expires, the firmware update will be canceled. 
    The default timeout duration is 4 hours.  

    .PARAMETER SerialUpdates
    Specifies to perform the firmware updates to each server in the group in serial (instead of parallel by default). 

    .PARAMETER StopOnFailure
    Specifies if the group firmware serial update process will continue after the first failure. 
    When StopOnFailure is not used, the update continues after a failure. When used, the update stops after a failure and the remaining servers in the group will not be updated. 
    
    Note: This switch is only applicable for serial firmware updates (i.e. when SerialUpdates switch is used). 

    .PARAMETER PowerOffAfterUpdate
    Specifies whether to power off the server after the firmware update.

    .PARAMETER DisablePrerequisiteCheck
    Specifies whether to disable the prerequisites check before running the firmware update.

    .PARAMETER AllowFirmwareDowngrade
    Specifies whether to allow the downgrade of firmware during the firmware update.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -PowerOffAfterUpdate 

    This command updates in parallel the firmware for all servers in a group named `ESXi_800` located in the `eu-central` region. It also powers off the servers after the update.
   
    .EXAMPLE
    $task = Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -Async
    $task | Wait-HPECOMJobComplete

    This command updates in parallel the firmware for all servers in a group named `ESXi_800` located in the `eu-central` region. 
    The update runs asynchronously, and the task is monitored using the `Wait-HPECOMJobComplete` cmdlet.

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -SerialUpdates -StopOnFailure -AllowFirmwareDowngrade -InstallHPEDriversAndSoftware -DisablePrerequisiteCheck 
    
    This command updates in serial the firmware for all servers in a group named `ESXi_800` located in the `eu-central` region. It specifies that after a failure, the firmware update process will stop,
    and the remaining devices in the group will not be updated. It also installs HPE drivers and software, disables the prerequisites check, and allows firmware downgrade. 

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ2311004H' -AllowFirmwareDowngrade 

    This command updates the firmware for a specific server with the serial number `CZ2311004H` in a group named `ESXi_800` located in the `eu-central` region. It allows firmware downgrade.

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -WaitForPowerOfforReboot -WaitForPowerOfforRebootTimeout 8 

    This command updates in parallel the firmware for all servers in a group named `ESXi_800` located in the `eu-central` region. 
    It waits for the user to power off or reboot the server before performing the installation. The timeout for waiting is set to 8 hours.
    After 8 hours, if the server is not powered off or rebooted, the firmware update will be canceled.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Update-HPECOMGroupFirmware -GroupName  ESXi_800 -AllowFirmwareDowngrade -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command updates the firmware of the selected servers as part of the 'ESXi_800' group.
    The update runs in parallel across the selected servers. Firmware downgrades are allowed if necessary. The update runs asynchronously, allowing other tasks to continue without waiting for completion.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_800 -ShowMembers | Update-HPECOMGroupFirmware 
    
    This command retrieves the list of servers in a group named 'ESXi_800' located in the 'eu-central' region and updates the firmware for all servers in the group.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800
    
    This command updates the firmware for servers with serial numbers 'CZ12312312' and 'DZ12312312' in a group named 'ESXi_800' located in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Update-HPECOMGroupFirmware } 

    This command retrieves all groups in the 'eu-central' region and updates the firmware for each group.

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -ScheduleTime (Get-Date).AddDays(4)

    This command creates a schedule to update the firmware of all servers in a group named 'ESXi_800' located in the 'eu-central' region. The schedule is set to run four days from now.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object { $_.SerialNumber -eq "CZ12312312" -or $_.SerialNumber -eq "DZ12312312" } | Update-HPECOMGroupFirmware -GroupName ESXi_800 -ScheduleTime (Get-Date).AddHours(12)

    This command retrieves servers with specific serial numbers from the 'eu-central' region and schedules a firmware update for them in the 'ESXi_800' group in twelve hours.
   
    .EXAMPLE    
    Get-HPECOMGroup -Region eu-central -name ESXi_800 -ShowMembers | Select-Object -Last 2 | Update-HPECOMGroupFirmware -GroupName ESXi_800 -ScheduleTime (Get-Date).AddMonths(6)

    This example retrieves the last two servers from the 'ESXi_800' in the 'eu-central' region and schedules a firmware update for them six months from the current date.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.


    #>

    [CmdletBinding(DefaultParameterSetName = 'Scheduled')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,
        
        [switch]$InstallHPEDriversAndSoftware,

        [switch]$WaitForPowerOfforReboot,

        [ValidateSet(1, 2, 4, 8, 12, 24)]
        [int]$WaitForPowerOfforRebootTimeout = 4,
                
        [switch]$PowerOffAfterUpdate,
        
        [switch]$DisablePrerequisiteCheck,
        
        [switch]$SerialUpdates,
        
        [switch]$StopOnFailure,

        [switch]$AllowFirmwareDowngrade,

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600  # Timeout 1 hour

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupFirmwareUpdate'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()

        if ($WaitForPowerOfforReboot) {
            $WaitPowerOff = $true
        }
        else {
            $WaitPowerOff = $false
        }

        if ($AllowFirmwareDowngrade) {
            $Downgrade = $true
        }
        else {
            $Downgrade = $false
        }
       
        if ($StopOnFailure) {
            $StopOnFailureValue = $true
        }
        else {
            $StopOnFailureValue = $false
        }
        
        if ($PowerOffAfterUpdate) {
            $PowerOff = $true
        }
        else {
            $PowerOff = $false
        }

        if ($InstallHPEDriversAndSoftware) {
            $InstallSwDrivers = $true
        }
        else {
            $InstallSwDrivers = $false
        }

        if ($DisablePrerequisiteCheck) {
            $PrerequisiteCheck = $false
        }
        else {
            $PrerequisiteCheck = $true
        }
        
        if ($SerialUpdates -or $StopOnFailure) {
            $Parallel = $False
        }
        else {
            $Parallel = $True
        }

        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Not match strings that start with @{, contain any characters in between, and end with }
        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {
            
            [void]$ServersList.add($ServerSerialNumber)
        }

    }

    End {

        try {
            if ($Region) {
                $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
                $GroupMembers = $_group.devices
    
                $_groupName = $_group.name
                $_groupResourceUri = $_group.resourceUri
                $NbOfServers = $_group.devices.count
    
                "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose
            }
            else {
                return
            }           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) { 

            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            throw $ErrorMessage

        }

        
        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        
        
        if ($ServersList) {

            "[{0}] List of servers to update: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}': Resource is not a member of '{1}' group!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {
                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be updated!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }
            

        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to update: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose
            
    
            $uri = $COMJobsUri

            # Serial updates
            if (-not $Parallel -and -not $ServerIdsList) {

                $data = @{
                    parallel                                = $Parallel
                    stopOnFailure                           = $StopOnFailureValue
                    downgrade                               = $Downgrade
                    installSWDrivers                        = $InstallSwDrivers
                    powerOff                                = $PowerOff
                    prerequisite_check                      = $PrerequisiteCheck
                    wait_for_power_off_or_reboot            = $WaitPowerOff
                    wait_for_power_off_or_reboot_timeout    = $WaitForPowerOfforRebootTimeout
                }

            }
            elseif (-not $Parallel -and $ServerIdsList) {

                $data = @{
                    parallel                                = $Parallel
                    stopOnFailure                           = $StopOnFailureValue
                    downgrade                               = $Downgrade
                    installSWDrivers                        = $InstallSwDrivers
                    powerOff                                = $PowerOff
                    prerequisite_check                      = $PrerequisiteCheck
                    devices                                 = $ServerIdsList
                    wait_for_power_off_or_reboot            = $WaitPowerOff
                    wait_for_power_off_or_reboot_timeout    = $WaitForPowerOfforRebootTimeout
                }

            }

            # Parallel updates
            elseif ($Parallel -and -not $ServerIdsList) {

                $data = @{
                    parallel                                = $Parallel
                    downgrade                               = $Downgrade
                    installSWDrivers                        = $InstallSwDrivers
                    powerOff                                = $PowerOff
                    prerequisite_check                      = $PrerequisiteCheck
                    wait_for_power_off_or_reboot            = $WaitPowerOff
                    wait_for_power_off_or_reboot_timeout    = $WaitForPowerOfforRebootTimeout
                }

            }
            elseif ($Parallel -and $ServerIdsList) {

                $data = @{
                    parallel                                = $Parallel
                    downgrade                               = $Downgrade
                    installSWDrivers                        = $InstallSwDrivers
                    powerOff                                = $PowerOff
                    prerequisite_check                      = $PrerequisiteCheck
                    devices                                 = $ServerIdsList
                    wait_for_power_off_or_reboot            = $WaitPowerOff
                    wait_for_power_off_or_reboot_timeout    = $WaitForPowerOfforRebootTimeout
                }

            }
            
            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    # jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_groupResourceUri
                    data           = $data
                }      
    
                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body
    
                }
    
                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                $Name = "$($GroupName)_ServerFirmwareUpdate_Schedule_$($randomNumber)"
                $Description = "Scheduled task to update firmware for '$_GroupName' group"
    
                
                # Get GMT time difference in hours
                # $GMTTimeDifferenceInHour = Get-GMTTimeDifferenceInMinutes
                
                # Calculate the schedule time for GMT
                # $ScheduleTimeForGMT = $ScheduleTime.AddMinutes(-$GMTTimeDifferenceInMinutes)
  
                $Schedule = @{
                    startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation' 
                    # interval = $Null
                }



                # Build payload
                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_groupResourceUri
                    purpose               = "GROUP_FW_UPDATE"
                    schedule              = $Schedule
                    operation             = $Operation
    
                }    

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_groupResourceUri
                    data           = $data
                }      
            }


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {    
                                  
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }

                }
                else {
                    
                    if (-not $WhatIf -and -not $Async) {    
                    
                        # Timeout for parallel group FW update 
                        if ($ParallelUpdates) {
                            $Timeout = $TimeoutinSecondsPerServer
                        
                        }
                        # Timeout for serial (default):  default timeout x nb of servers found in the group
                        else {
                            $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                        }
                    
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
    
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                    else {

                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
            
                    Return $ReturnData
            
                }
        
            }
            else {

                if (-not $WhatIf ) {
                
                    Return $_resp
            
                }
            }
        }
    }
}


function Stop-HPECOMGroupFirmware {
    <#
    .SYNOPSIS
    Cancel an ongoing serial firmware update job.
    
    .DESCRIPTION   
    This cmdlet can be used to cancel an ongoing server group firmware update job that is running. Note that this job cannot be canceled if the Parallel update option is enabled. 
    Additionally, updates cannot be canceled on servers that have already started or completed the firmware update, or on servers that are in a stalled state.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group/job is located.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER InputJobObject 
    The server group firmware update job resource from 'Get-HPECOMJob'. 

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    $Job = Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_group -Async 
    Stop-HPECOMGroupFirmware -Region eu-central -InputJobObject $Job

    The first command initiates an asynchronous firmware update for the server group named ESXi_group in the eu-central region. The second command cancels this ongoing firmware update job.

    .EXAMPLE
    $Job = Update-HPECOMGroupFirmware -Region  eu-central -GroupName ESXi_group -Async 
    $Job | Stop-HPECOMGroupFirmware 

    This command starts an asynchronous firmware update for all servers in a group named `ESXi_group` located in the `eu-central` region, and then it stops the update process.

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Type groups | Select-Object -last 1 | Stop-HPECOMGroupFirmware 

    This command retrieves the last group firmware update job in the `eu-central` region and stops the update process.

    .INPUTS
    System.Collections.ArrayList
        List of jobs from 'Get-HPECOMJob'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding(DefaultParameterSetName = 'GroupNameSerial')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      

        [Parameter (ValueFromPipeline)]
        [Object]$InputJobObject,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $StopGroupFirmwareStatus = [System.Collections.ArrayList]::new()

    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {            
            
            if ($InputJobObject) {
                
                
                if ($InputJobObject.type -ieq "compute-ops-mgmt/job") {
                
                    "[{0}] Pipeline object detected as job type" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    # $Server_InputObject_pipeline = $True
    
                    "[{0}] ID = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InputJobObject.id | Write-Verbose
                    $uri = $COMJobsUri + '/' + $InputJobObject.id

                    $_job = Get-HPECOMJob -Region $Region -JobResourceUri $uri

    
                }
                else {    
                    
                    $ErrorMessage = "The parameter 'InputJobObject' value is invalid. Please validate the 'InputJobObject' parameter value you passed and try again."
                    throw $ErrorMessage
                    
                }
            }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_job) {
            
            # Must return a message if not found
            $ErrorMessage = "Job ID '{0}' cannot be found in the Compute Ops Management instance!" -f $InputJobObject.id
            Throw $ErrorMessage
            
        }
        elseif ($_job.state -eq "COMPLETE") {

            $ErrorMessage = "Job ID '{0}' is already in 'COMPLETE' state and cannot be stopped!" -f $InputJobObject.id
            Write-Warning $ErrorMessage

        }
        elseif ($_job.jobParams.parallel -eq $True) {

            $ErrorMessage = "Job ID '{0}' cannot be stopped because the server group firmware update is not set with the Serial update option enabled!" -f $InputJobObject.id
            Write-Error $ErrorMessage

        }
        else {
            
            # Build payload
            $payload = @{
                input = @{ 
                    stopOnRequest = $true
                }
            }      
    
    
            $payload = ConvertTo-Json $payload -Depth 10 
    
            try {

                if ($Region) {

                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 
        
                    # Add region to object
                    $_resp | Add-Member -type NoteProperty -name region -value $Region
                    # Apply Jobs format
                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 
        
                    if (-not $WhatIf -and -not $Async) {
            
                        $Timeout = 3600 # 1 hour
                                        
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
        
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $MyInvocation.InvocationName.ToString().ToUpper(), $_resp.resourceuri -Timeout $Timeout 
        
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
        
                    }
                    else {
    
                        $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 
    
                    }
                }
            }
            catch {
    
                if (-not $WhatIf) {
    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
            }  
            
            [void]$StopGroupFirmwareStatus.add($_resp)
        }
    }
    
    End {
        
        if (-not $WhatIf ) {
            
            Return $StopGroupFirmwareStatus
        
        }
    }
}


function Invoke-HPECOMGroupFirmwareComplianceCheck {
    <#
    .SYNOPSIS
    Initiate a firmware compliance check on all servers in a group.
    
    .DESCRIPTION   
    This cmdlet initiates a group firmware compliance check to ensure all server components are at or above the group's baseline versions. 
    It also provides options for scheduling execution at a specific time and setting recurring schedules.

    Note: A firmware server setting must be configured in the server group for the compliance feature to be available. 
          This feature does not monitor HPE driver and software versions.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER GroupName
    Name of the group on which the firmware compliance check will be performed.    

    .PARAMETER ScheduleTime
    Indicates when to schedule the power off operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) referencing days, weeks, months, years but not time (T) designations that reference hours, minutes, and seconds.

    This parameter supports common ISO 8601 period durations such as:
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupFirmwareComplianceCheck -Region eu-central -GroupName ESX-800  

    This command checks firmware compliance of all servers in the group 'ESX-800' in the 'eu-central' region.
   
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_group | Invoke-HPECOMGroupFirmwareComplianceCheck

    This command checks firmware compliance of all servers in the group named 'ESXi_group' in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Invoke-HPECOMGroupFirmwareComplianceCheck 

    This command checks firmware compliance of all servers in all groups of the 'eu-central' region.

    .EXAMPLE
    Invoke-HPECOMGroupFirmwareComplianceCheck -Region eu-central -GroupName ESX-800 -ScheduleTime (get-Date).addminutes(10) 

    Schedules the execution of a group firmware compliance check on the group named 'ESX-800' in the `eu-central` region starting 10 minutes from now. 

    .EXAMPLE
    Invoke-HPECOMGroupFirmwareComplianceCheck -Region eu-central -GroupName ESX-800 -ScheduleTime (get-Date).addhours(6) -Interval P1M

    Schedules a monthly execution of a group firmware compliance check on the group named 'ESX-800' in the `eu-central` region. The first execution will start in 6 hours. 

    .EXAMPLE
    "ESXi_group", "RHEL_group" | Invoke-HPECOMGroupFirmwareComplianceCheck -Region  eu-central

    This command checks firmware compliance of all servers in the groups 'ESXi_group' and 'RHEL_group' in the `eu-central` region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the group's names.
    
    System.Collections.ArrayList
        List of groups from 'Get-HPECOMGroup'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'Async')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [alias('name')]
        [String]$GroupName,

        [Parameter (Mandatory, ParameterSetName = 'Schedule')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Schedule')]
        [String]$Interval,    
        
        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 900  # 15 minutes

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupFirmwareCompliance'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri   
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $GroupFirmwareComplianceStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName      
            # $_groupMembers = Get-HPECOMGroup -Region $Region -Name $GroupName -ShowMembers

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_group) {
        
            # Must return a message if resource not found
            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            Write-warning $ErrorMessage
            return
            
        }
        # elseif ($_groupCompliance.complianceState -like "Not Applicable") {
            
        #     # Must return an error if one of the server is not in good condition to run a compliance report (I had a 'Power stalled' condition which causes exception)
        #     $ErrorMessage = "Group '{0}' is not applicable for a compliance check. Please verify the state of each server in the group using 'Get-HPECOMGroup -ShowCompliance'." -f $GroupName
        #     Write-warning $ErrorMessage
        # }
        else {
            
            $_ResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $GroupName, $_ResourceUri, $NbOfServers | Write-Verbose         

            if ($NbOfServers -eq 0) {

                # Must return a message if no servers in group
                $ErrorMessage = "Group '{0}': Operation cannot be executed because no server has been found in the group!" -f $GroupName
                Write-warning $ErrorMessage
                return
            }


            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_ResourceUri
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($GroupName)_GroupFirmwareComplianceCheck_Schedule_$($randomNumber)"
                $Description = "Scheduled task to run a group firmware compliance check on '$($GroupName)'"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "GROUP_FIRMWARE_COMPLIANCE_CHECK"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_ResourceUri
                    
                }      
            }


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region
                
                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
    
                        # Timeout: default timeout x nb of servers found in the group
    
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer 
        
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
        
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                    else {

                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $GroupFirmwareComplianceStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $GroupFirmwareComplianceStatus
        
        }

    }
}


function Get-HPECOMGroupFirmwareCompliance {
    <#
    .SYNOPSIS
    Retrieves the firmware compliance details of servers within a specified group.
    
    .DESCRIPTION   
    The `Get-HPECOMGroupFirmwareCompliance` cmdlet allows you to obtain detailed information about the firmware compliance of all servers in a designated group. 
    This cmdlet can be useful for identifying deviations from the group's firmware baseline, ensuring that all devices are up to date and compliant with organizational standards.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER GroupName
    Specifies the name of the server group on which the firmware compliance details will be retrieved.

    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to retrieve its specific compliance details within the group.

    .PARAMETER Deviations
    Switch parameter that retrieves only the firmware components which have deviations from the group's firmware baseline.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMGroupFirmwareCompliance -Region eu-central -GroupName ESX-800  

    This command returns the firmware compliance of all servers in the group 'ESX-800' in the 'eu-central' region.
   
    .EXAMPLE
    Get-HPECOMGroupFirmwareCompliance -Region eu-central -GroupName ESX-800 -ServerSerialNumber CZ12312312 

    This command returns the firmware compliance of the server with serial number 'CZ12312312' in the group 'ESX-800' in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMGroupFirmwareCompliance -Region eu-central -GroupName ESX-800 -ServerSerialNumber CZ12312312 -Deviations

    This command returns the firmware components which have a deviation with the group 'ESX-800' firmware baseline in the 'eu-central' region.
    
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Get-HPECOMGroupFirmwareCompliance 

    This command returns the firmware compliance of all servers in all groups in the 'eu-central' region.

    .INPUTS
    System.Collections.ArrayList
        List of groups retrieved using the `Get-HPECOMGroup` cmdlet.


    #>

    [CmdletBinding(DefaultParameterSetName = "ServerSerialNumber")]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ServerSerialNumber')]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'DeviationsServerSerialNumber')]
        [alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'DeviationsServerSerialNumber')]
        [Parameter (ParameterSetName = 'DeviationsServerName')]
        [switch]$Deviations,

        [switch]$WhatIf

    )

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      

        $Uri = $COMGroupsUri + "?filter=name eq '$GroupName'"

        try {

            $_group = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
            $GroupID = $_group.id

            "[{0}] ID found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $GroupID | Write-Verbose

            if ($Null -eq $GroupID) { return }

            $Uri = $COMGroupsUri + "/" + $GroupID + "/compliance"
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }
        

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
      
        if ($Null -ne $CollectionList) {   
            
            # Add groupName, servername and serialNumber (only serial is provided)
            # groupName is used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. 
            Foreach ($Item in $CollectionList) {

                try {
                    $_ServerName = Get-HPECOMServer -Region $Region -Name $Item.serial                        
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                $Item | Add-Member -type NoteProperty -name region -value $Region
                $Item | Add-Member -type NoteProperty -name groupName -value $GroupName
                $Item | Add-Member -type NoteProperty -name serialNumber -value $Item.serial
                $item | Add-Member -Type NoteProperty -Name serverName -Value $_ServerName.name
                
            }
                        
            if ($ServerSerialNumber) {

                
                if ($Deviations) {
                    
                    $CollectionList = $CollectionList | Where-Object serial -eq $ServerSerialNumber | ForEach-Object deviations | Sort-Object -Property ComponentName


                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance.Deviations"   
                    
                }
                else {
                    
                    $CollectionList = $CollectionList | Where-Object serial -eq $ServerSerialNumber

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance"   
                                        
                }
                
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance"   
                
            }
            
            $ReturnData = $ReturnData | Sort-Object -Property serverName, serial
            return $ReturnData 
                
        }
        else {

            return
                
        }     
    }
}


function Invoke-HPECOMGroupInternalStorageConfiguration {
    <#
    .SYNOPSIS
    Initiate a server group internal storage configuration.
    
    .DESCRIPTION   
    This cmdlet initiates a server group internal storage configuration that will affect some or all of the server group members.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER GroupName
    Name of the group on which the internal storage configuration will be performed.     
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to configure its internal storage within the group.

    .PARAMETER AllowStorageVolumeDeletion
    Specifies to delete any existing internal storage configuration prior to creating the new OS volume.

    .PARAMETER StorageVolumeName 
    Specifies the name of the volume to create.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800

    This command initiates a server group internal storage configuration of all servers in a group named `ESXi_800` located in the `eu-central` region. 
   
    .EXAMPLE
    Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800 -AllowStorageVolumeDeletion -StorageVolumeName ESX_Boot_Volume 

    This command initiates a server group internal storage configuration of all servers in a group named `ESXi_800` located in the `eu-central` region. 
    It also specifies to delete any existing internal storage configuration prior to creating the new OS volume that will be named 'ESX_Boot_Volume'.

    .EXAMPLE
    Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ12312312' 

    This command initiates a server group internal storage configuration of the server with the serial number 'CZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "ESX-1" | Invoke-HPECOMGroupInternalStorageConfiguration -GroupName ESXi_800

    This command initiates a server group internal storage configuration of the server named 'ESX-1' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Invoke-HPECOMGroupInternalStorageConfiguration -GroupName ESXi_800 -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command initiates a server group internal storage configuration of the specified servers as part of the 'ESXi_800' group.
    The configuration runs asynchronously, allowing other tasks to continue without waiting for completion.
       
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800 
    
    This command initiates a server group internal storage configuration of the servers with serial numbers 'CZ12312312' and 'DZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupInternalStorageConfiguration }
    
    This command retrieves a list of all groups in the 'eu-central' region and initiates a server group internal storage configuration for each group.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [switch]$AllowStorageVolumeDeletion,

        [string]$StorageVolumeName,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupApplyInternalStorageSettings'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()
        
        if ($AllowStorageVolumeDeletion) {
            $isStorageVolumeDeletionAllowed = $true
        }
        else {
            $isStorageVolumeDeletionAllowed = $false
        }     
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {
            
            [void]$ServersList.add($ServerSerialNumber)
        }

    }

    End {

        try {

            if ($Region) {

                $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
                $GroupMembers = $_group.devices
                # $GroupMembers = Get-HPECOMGroup -Region $Region -Name $GroupName -ShowMembers
                
                $_groupName = $_group.name
                $_groupResourceUri = $_group.resourceUri
                $NbOfServers = $_group.devices.count
                
                "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose
            }
            else {
                Return
            }
            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            throw $ErrorMessage

        }

        
        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        
        
        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}': Resource is not a member of '{1}' group!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {

                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }
            

        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose
            

            # Build payload
            if ($StorageVolumeName) {

                $data = @{
                    devices                        = $ServerIdsList
                    isStorageVolumeDeletionAllowed = $isStorageVolumeDeletionAllowed
                    storageVolumeName              = $storageVolumeName
                }
            }
            else {

                $data = @{
                    devices                        = $ServerIdsList
                    isStorageVolumeDeletionAllowed = $isStorageVolumeDeletionAllowed
                }
            
            }
          
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
                data           = $data                 
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                 
                    $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
                else {

                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                }
                 
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }
        }
    }
}


function Invoke-HPECOMGroupOSInstallation {
    <#
    .SYNOPSIS
    Initiate a group OS installation.
    
    .DESCRIPTION   
    This cmdlet initiates a group operating system installation that will affect some or all of the server group members.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER GroupName
    Name of the group on which the operating system installation will be performed.     

    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to install the operating system within the group.

    .PARAMETER StopOnFailure
    Specifies if the operating system installation process will continue after the first failure. 
    When StopOnFailure is not used, the installation continues after a failure. When used, the installation stops after a failure and the remaining servers in the group will not be installed. 
    
    Note: This switch is applicable for serial operating system installation (i.e. when ParallelInstallations switch is not used). 

    .PARAMETER ParallelInstallations
    Specifies to perform the operating system installation to each server in the group in parallel instead of serial by default. 
    
    .PARAMETER OSCompletionTimeoutMin
    Specifies the amount of time (minutes) that Compute Ops Management waits before automatically marking an OS installation job complete. 
    The operating system image is then unmounted from the server. The specified timeout value applies to each server group member.
    Supported value:
    - Default: 240
    - Minimum: 60
    - Maximum: 720

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800

    This command initiates a group operating system installation of all servers in a group named `ESXi_800` located in the `eu-central` region.
    
    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 -ParallelInstallations

    This command initiates a group operating system installation of all servers in a group named `ESXi_800` located in the `eu-central` region.
    The installation is performed in parallel instead of serial by default.
   
    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 -StopOnFailure -OSCompletionTimeoutMin 100

    This command initiates a group operating system installation of all servers in a group named `ESXi_800` located in the `eu-central` region.
    The installation halts upon the first failure, and the operating system image is unmounted from the server after 100 minutes, reduced from the default 240 minutes.

    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ12312312' 

    This command initiates a group operating system installation of the server with the serial number 'CZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "ESX-1" | Invoke-HPECOMGroupOSInstallation -GroupName ESXi_800

    This command initiates a group operating system installation of the server named 'ESX-1' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Invoke-HPECOMGroupOSInstallation -GroupName ESXi_800 -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command initiates a group operating system installation of the specified servers as part of the 'ESXi_800' group. 
    The configuration runs asynchronously, allowing other tasks to continue without waiting for completion.
       
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 
    
    This command initiates a group operating system installation of the servers with serial numbers 'CZ12312312' and 'DZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupOSInstallation }

    This command retrieves a list of all groups in the 'eu-central' region and initiates a group operating system installation for each group.
      
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMGroup -ShowMembers'.    

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding(DefaultParameterSetName = 'GroupNameSerial')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "GroupNameSerial")]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "GroupNameParallel")]
        [String]$GroupName,
        
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'GroupNameSerial')]
        [switch]$StopOnFailure,

        [Parameter (ParameterSetName = 'GroupNameParallel')]
        [switch]$ParallelInstallations,

        [ValidateRange(60, 720)]
        [int]$OSCompletionTimeoutMin,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupOSInstallation'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()
        
      
        if ($StopOnFailure) {
            $StopOnFailureValue = $true
        }
        else {
            $StopOnFailureValue = $false
        }
                
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {
            
            [void]$ServersList.add($ServerSerialNumber)
        }

           

    }

    End {

        try {
            if ($Region) {

                $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
                $GroupMembers = $_group.devices

                $_groupName = $_group.name
                $_groupResourceUri = $_group.resourceUri
                $NbOfServers = $_group.devices.count

                "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose
            }
            else {
                Return
            }            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            throw $ErrorMessage

        }


        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}': Resource is not a member of '{1}' group!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {
                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }


        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose
               
            # Parallel updates
            if ($ParallelInstallations -and -not $ServerIdsList -and -not $OSCompletionTimeoutMin) {

                $data = @{
                    parallel = $True
                }

            }
            elseif ($ParallelInstallations -and $ServerIdsList -and -not $OSCompletionTimeoutMin) {

                $data = @{
                    parallel = $True
                    devices  = $ServerIdsList
                }
            
            }
            elseif ($ParallelInstallations -and -not $ServerIdsList -and $OSCompletionTimeoutMin) {

                $data = @{
                    parallel               = $True
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin
                }
            }
            elseif ($ParallelInstallations -and $ServerIdsList -and $OSCompletionTimeoutMin) {
                
                $data = @{
                    parallel               = $True
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin
                    devices                = $ServerIdsList

                }
            }

            # Serial updates
            elseif (-not $ParallelInstallations -and -not $ServerIdsList -and -not $OSCompletionTimeoutMin) {
            
                $data = @{
                    parallel      = $False
                    stopOnFailure = $StopOnFailureValue
                   
                }
            
            }
            elseif (-not $ParallelInstallations -and $ServerIdsList -and -not $OSCompletionTimeoutMin) {
           
                $data = @{
                    parallel      = $False
                    stopOnFailure = $StopOnFailureValue
                    devices       = $ServerIdsList
                }

            }
            elseif (-not $ParallelInstallations -and $ServerIdsList -and $OSCompletionTimeoutMin) {
           
                $data = @{
                    parallel               = $False
                    stopOnFailure          = $StopOnFailureValue
                    devices                = $ServerIdsList
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin

                }

            }
            elseif (-not $ParallelInstallations -and -not $ServerIdsList -and $OSCompletionTimeoutMin) {
           
                $data = @{
                    parallel               = $False
                    stopOnFailure          = $StopOnFailureValue
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin

                }

            }

          
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
                data           = $data                 
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                
                    # Timeout for parallel group FW update 
                    if ($ParallelInstallations) {
                        $Timeout = $TimeoutinSecondsPerServer
                    
                    }
                    # Timeout for serial (default):  default timeout x nb of servers found in the group
                    else {
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                    }
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
                else {

                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }

        }
    }
}


function Invoke-HPECOMGroupBiosConfiguration {
    <#
    .SYNOPSIS
    Initiate a server group bios configuration.
    
    .DESCRIPTION   
    This cmdlet initiates a server group bios configuration that will affect some or all of the server group members.

    Note: A server reboot is necessary for the new BIOS settings to take effect. COM will attempt to restart the server automatically. If the server cannot be restarted by COM, you must manually reboot the server (or use 'Restart-HPECOMserver') to complete the configuration process.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER GroupName
    Name of the group on which the bios configuration will be performed.     
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to configure its BIOS settings within the group.     

    .PARAMETER ParallelConfigurations
    Specifies to perform the bios configuration to each server in the group in parallel (20 max) instead of serial by default. 

    .PARAMETER ResetBiosSettingsToDefaults
    Specifies to perform a reset server's BIOS settings to default values before applying the BIOS setting.
    
    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800

    This command initiates a server group bios configuration of all servers in a group named `ESXi_800` located in the `eu-central` region.

    .EXAMPLE
    Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800 -ResetBiosSettingsToDefaults -ParallelConfigurations

    This command initiates a server group bios configuration of all servers in a group named `ESXi_800` located in the `eu-central` region.
    The configuration is performed in parallel instead of serial by default, and the server's BIOS settings are reset to default values before applying the new BIOS settings.

    .EXAMPLE
    Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ12312312' 

    This command initiates a server group bios configuration of the server with the serial number 'CZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "ESX-1" | Invoke-HPECOMGroupBiosConfiguration -GroupName ESXi_800

    This command initiates a server group bios configuration of the server named 'ESX-1' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Invoke-HPECOMGroupBiosConfiguration -GroupName ESXi_800 -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command initiates a server group bios configuration of the specified servers as part of the 'ESXi_800' group.
    The configuration runs asynchronously, allowing other tasks to continue without waiting for completion.
       
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800 
    
    This command initiates a server group bios configuration of the servers with serial numbers 'CZ12312312' and 'DZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupBiosConfiguration }
    
    This command retrieves a list of all groups in the 'eu-central' region and initiates a server group bios configuration for each group.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,
        
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [switch]$ParallelConfigurations,

        [switch]$ResetBiosSettingsToDefaults,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 600 # 10 minutes

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupApplyServerSettings'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()
      
                
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {

            [void]$ServersList.add($ServerSerialNumber)
        }

    }

    End {

        try {

            if ($Region) {
                $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
                $GroupMembers = $_group.devices 

                $_groupName = $_group.name
                $_groupResourceUri = $_group.resourceUri
                $NbOfServers = $_group.devices.count

                "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose
            }
            else {
                Return
            }            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            throw $ErrorMessage

        }

        
        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        
        
        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}': Resource is not a member of '{1}' group!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {
                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }

      
        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose

          
            # Parallel updates
            if ($ParallelConfigurations -and -not $ServerIdsList) {

                $data = @{
                    batch_size        = 20
                    redfish_subsystem = "BIOS"
                }

            }
            elseif ($ParallelConfigurations -and $ServerIdsList) {

                $data = @{
                    batch_size        = 20
                    devices           = $ServerIdsList
                    redfish_subsystem = "BIOS"

                }
            
            }

            # Serial updates
            elseif (-not $ParallelConfigurations -and -not $ServerIdsList) {
            
                $data = @{
                    batch_size        = 1
                    redfish_subsystem = "BIOS"
                   
                }
            
            }
            elseif (-not $ParallelConfigurations -and $ServerIdsList) {
           
                $data = @{
                    batch_size        = 1
                    devices           = $ServerIdsList
                    redfish_subsystem = "BIOS"

                }

            }

            if ($ResetBiosSettingsToDefaults) {

                $data.factory_reset	= $true
            }


            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
                data           = $data                 
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                
                    # Timeout for parallel group FW update 
                    if ($ParallelConfigurations) {
                        $Timeout = $TimeoutinSecondsPerServer
                    
                    }
                    # Timeout for serial (default):  default timeout x nb of servers found in the group
                    else {
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                    }
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
                else {

                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }

        }
    }
}


function Invoke-HPECOMGroupExternalStorageConfiguration {
    <#
    .SYNOPSIS
    Initiate a server group external storage configuration.
    
    .DESCRIPTION   
    This cmdlet initiates a server group external storage configuration that will affect all server group members.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER GroupName
    Name of the group on which the external storage configuration will be performed.     
    
    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
    
    .EXAMPLE
    Invoke-HPECOMGroupExternalStorageConfiguration -Region eu-central -GroupName ESXi_800

    This command initiates a server group external storage configuration of all servers in a group named `ESXi_800` located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupExternalStorageConfiguration } 
    
    This command retrieves a list of all groups in the 'eu-central' region and initiates a server group external storage configuration for each group.
    
    .INPUTS
    No pipeline input is supported

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [String]$GroupName,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 60

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupApplyExternalStorageSettings' # ERROR CASE 5383889168
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        # $JobTemplateUri = "/compute-ops-mgmt/v1beta2/job-templates/1262f08e-79eb-4e9f-91d2-6984da9d31cd"

        $uri = $COMJobsUri
                
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

    }

    End {
      
        try {
            if ($Region) {
                $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
                $GroupMembers = $_group.devices
                
                $_groupName = $_group.name
                $_groupResourceUri = $_group.resourceUri
                $NbOfServers = $_group.devices.count
                
                "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose
            }
            else {
                Return
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            throw $ErrorMessage

        }
        elseif (-not $GroupMembers) {

            # Must return a message if no server members are found in the group
            $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
            Write-warning $ErrorMessage
            
        }
        else {
        
            # Build payload          
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                 
                    $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
                else {

                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }

        }
    }
}


function Invoke-HPECOMGroupExternalStorageComplianceCheck {
    <#
    .SYNOPSIS
    Initiate an external storage compliance check on all servers in a group.
    
    .DESCRIPTION   
    This cmdlet initiates an external storage compliance check on all servers within a specified group.
    It also provides options for scheduling the execution at a specific time and setting recurring schedules.

    Note: An external storage server setting must be configured in the server group for the compliance feature to be available.
        
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the group is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER GroupName
    Name of the group on which the external storage compliance check will be performed.    

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupExternalStorageComplianceCheck -Region eu-central -GroupName ESX-800  

    This command checks the external storage compliance of all servers in the group 'ESX-800' in the 'eu-central' region.
       
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Invoke-HPECOMGroupExternalStorageComplianceCheck 

    This command checks the external storage compliance of all servers in all groups within the 'eu-central' region.
    
    .EXAMPLE
    Invoke-HPECOMGroupExternalStorageComplianceCheck -Region eu-central -GroupName ESX-800 -ScheduleTime (Get-Date).AddHours(1) 

    Schedules the execution of a group external storage compliance check on the group named 'ESX-800' in the `eu-central` region starting 1 hour from now. 
    
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Invoke-HPECOMGroupExternalStorageComplianceCheck -ScheduleTime (Get-Date).AddDays(1) -Interval P1M 

    Schedules a monthly execution of a group external storage compliance check on all groups within the `eu-central` region. The first execution will occur one day from now.

    .EXAMPLE
    "ESXi_group", "RHEL_group" | Invoke-HPECOMGroupExternalStorageComplianceCheck -Region  eu-central
    
    This command checks the external storage compliance of all servers in the groups 'ESXi_group' and 'RHEL_group' in the 'eu-central' region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the group's names.

    System.Collections.ArrayList
        List of groups from 'Get-HPECOMGroup'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'Async')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [alias('name')]
        [String]$GroupName,
                
        [Parameter (Mandatory, ParameterSetName = 'Schedule')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Schedule')]
        [String]$Interval,    
        
        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 900  # 15 minutes

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $_JobTemplateName = 'GroupExternalStorageCompliance'  # ERROR CASE 5383889168
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri    
        # $JobTemplateUri = "/compute-ops-mgmt/v1beta2/job-templates/977139e0-f9d9-4940-9418-e0c321b5a458"
        # $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id
        $JobTemplateId = $JobTemplateUri.split('/')[-1]

        $uri = $COMJobsUri
        $GroupFirmwareComplianceStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_group) {
            
            # Must return a message if resource not found
            $ErrorMessage = "Group '{0}' cannot be found in the '{1}' region!" -f $GroupName, $Region
            Write-warning $ErrorMessage
            return
            
        }
        else {
            
            $_ResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count
            
            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $GroupName, $_ResourceUri, $NbOfServers | Write-Verbose         

            if ($NbOfServers -eq 0) {

                # Must return a message if no servers in group
                Write-Warning "Operation on group '$GroupName' cannot be executed because no server has been found in the group!"
                return
            }


            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_ResourceUri
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($GroupName)_GroupExternalStorageComplianceCheck_Schedule_$($randomNumber)"
                $Description = "Scheduled task to run a group external storage compliance check on '$($GroupName)'"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "GROUP_EXTERNAL_STORAGE_COMPLIANCE_CHECK"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {
                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_ResourceUri
                    
                }      
            }


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region
                # Apply Jobs format
                $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
    
                        # Timeout: default timeout x nb of servers found in the group
    
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer 
        
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
        
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                    else {

                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 
    
                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  
            
            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }
        if (-not $ScheduleTime) {

            [void] $GroupFirmwareComplianceStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $GroupFirmwareComplianceStatus
        
        }

    }
}


function Update-HPECOMApplianceFirmware {
    <#
    .SYNOPSIS
    UUpdates the firmware on a specified appliance.
    
    .DESCRIPTION   
    This cmdlet updates the firmware on an appliance using its IP address. It also provides an option to schedule the update at a specific time.
        
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the appliance is located.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER IPAddress
    Specifies the IP address of the appliance for the firmware update.

    .PARAMETER ApplianceFirmwareBundleReleaseVersion
    Mandatory parameter specifying the appliance firmware bundle release version to use for the update. 
    The release version can be obtained using 'Get-HPECOMApplianceFirmwareBundle'.

    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMApplianceFirmware -Region eu-central -IPAddress 192.168.7.59 -ApplianceFirmwareBundleReleaseVersion 9.00.00 

    This command updates the firmware on a OneView appliance with the IP address `192.168.7.59` located in the `eu-central` region using firmware bundle release version `9.00.00`. 
    
    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Name composer.lab | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00

    This command retrieves OneView appliances with the hostname 'composer.lab' in the `eu-central` region.
    It then updates the firmware on these appliances using firmware bundle release version `9.00.00`.

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00 
    
    This command updates all OneView appliances in the 'eu-central' region with the specified firmware bundle release version.
    First, it retrieves a list of all OneView appliances in the "eu-central" region.
    Then, the retrieved appliances are piped (|) to the Update-HPECOMApplianceFirmware cmdlet to update their firmware to the specified version.

    .EXAMPLE
    "192.168.1.2", "192.168.1.10" | Update-HPECOMApplianceFirmware -Region eu-central -ApplianceFirmwareBundleReleaseVersion 9.00.00

    This command updates the firmware on the appliances with the IP addresses `192.168.1.2'and '192.168.1.10'.
    The firmware update is performed in the `eu-central` region using firmware bundle release version `9.00.00`.

    .EXAMPLE
    Update-HPECOMApplianceFirmware -Region eu-central -IPAddress 192.168.7.59 -ApplianceFirmwareBundleReleaseVersion 9.00.00 -ScheduleTime ((Get-Date).AddMinutes(10))   

    This command schedules a firmware update for the appliance with the IP address `192.168.7.59` in the `eu-central` region using firmware bundle release version `9.00.00`, starting 10 minutes from now. 

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Name composer.domain.net | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00 -ScheduleTime ((Get-Date).AddHours(2))  

    This command first retrieves OneView appliances with the hostname 'composer.domain.net' in the `eu-central` region.
    It then schedules a firmware update for this appliance using firmware bundle release version `9.00.00`, starting 2 hours from now.

    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00 -ScheduleTime ((Get-Date).AddDays(5))  

    This command first retrieves all OneView appliances in the `eu-central` region.
    It then schedules a firmware update for these appliances using firmware bundle release version `9.00.00`, starting 5 days from now.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the appliance's IP addresses.

    System.Collections.ArrayList
        List of appliances from 'Get-HPECOMAppliance'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.


    #>

    [CmdletBinding(DefaultParameterSetName = 'Scheduled')]
    Param
    (

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        # [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'IP')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or $_ -match [Net.IPAddress]$_ })]
        [string]$IPAddress,
        
        [Parameter (Mandatory)]
        [String]$ApplianceFirmwareBundleReleaseVersion,

        [Parameter (ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'ApplianceUpdate'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $ApplianceFWUpdateStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_appliance = Get-HPECOMAppliance -Region $Region -IPAddress $IPAddress                 

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_appliance) {

            # Must return a message if not found
            $ErrorMessage = "OneView appliance '{0}' cannot be found in the '{1}' region!" -f $IPAddress, $Region
            Write-warning $ErrorMessage

        }
        else {

            $_applianceResourceUri = $_appliance.resourceUri
            $_applianceType = $_appliance.applianceType
            $_applianceName = $_appliance.name

            try {
                $Bundle = Get-HPECOMApplianceFirmwareBundle -Region $Region -Version $ApplianceFirmwareBundleReleaseVersion -Type $_applianceType

                $BundleID = $Bundle.id
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $BundleID) {
                # Must return a message if not found
                    
                $ErrorMessage = "Appliance firmware bundle release version '{0}' cannot be found in the '{1}' region!" -f $ApplianceFirmwareBundleReleaseVersion, $Region
                throw $ErrorMessage
    
            }
            else {

                $data = @{
                    applianceFirmwareId = $BundleID

                }

                if ($ScheduleTime) {

                    $uri = $COMSchedulesUri
    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_applianceResourceUri
                        data           = $data
                    }      
    
                    $Operation = @{
                        type   = "REST"
                        method = "POST"
                        uri    = "/api/compute/v1/jobs"
                        body   = $_Body
    
                    }
    
                    $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                    $Name = "$($_applianceName)_ApplianceFirmwareUpdate_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to update firmware for '$IPAddress' appliance"
    
    
                    $Schedule = @{
                        startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                        # interval = $Null
                    }
    
    
                    $Payload = @{
                        name                  = $Name
                        description           = $Description
                        associatedResourceUri = $_applianceResourceUri
                        purpose               = "APPLIANCE_FW_UPDATE"
                        schedule              = $Schedule
                        operation             = $Operation
    
                    }
    
                }
                else {
    
                    # Build payload
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_applianceResourceUri
                        data           = $data
                    }      
                }


                $payload = ConvertTo-Json $payload -Depth 10 

                try {
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                    # Add region to object
                    $_resp | Add-Member -type NoteProperty -name region -value $Region
                    # Apply Jobs format
                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
        
                            $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"
    
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                        }
    
                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {
            
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 3600 # Timeout 1 hour
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                        }
                        else {

                            $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 
        
                        }
                    }
                }
                catch {

                    if (-not $WhatIf) {

                        $PSCmdlet.ThrowTerminatingError($_)

                    }
                }  

                if ($ScheduleTime) {

                    if (-not $WhatIf ) {
            
                        Return $ReturnData
                    
                    }
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $ApplianceFWUpdateStatus.add($_resp)
        }

    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $ApplianceFWUpdateStatus
        
        }

    }
}


function Get-HPECOMIloSecuritySatus {
    <#
    .SYNOPSIS
    Retrieve the list of iLO security status.
    
    .DESCRIPTION   
    This cmdlet can be used to retrieve the list of iLO security risk settings of a server.
        
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER ServerName
    Name or serial number of the server for which the iLO security risk settings will be retrieved.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMIloSecuritySatus -Region eu-central -ServerName "CZ12312312" 

    This command returns the iLO security risk settings of the server with serial number 'CZ12312312' located in the `eu-central` region. 

    .EXAMPLE
    Get-HPECOMIloSecuritySatus -Region eu-central -ServerName ESX-1.domain.com

    This command returns the iLO security risk settings of the server with the name 'ESX-1.domain.com' located in the `eu-central` region.
   
    .INPUTS
    System.Collections.ArrayList
        List of servers retrieved using 'Get-HPECOMServer'.

    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ByName')]
        # [Alias('name')]
        [String]$ServerName,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


    }
    
    Process {
        
        # $Uri = $COMServersUri + "?filter=host/hostname eq '$ServerName' or name eq '$ServerName'"   # Filter that supports both serial numbers and server names


        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        try {

            $Server = Get-HPECOMServer -Region $Region -Name $ServerName

            "[{0}] ID found for server name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerName, $Server.ID | Write-Verbose
                    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
       
        }

        if ($server.connectionType -eq "ONEVIEW" ) {
            Write-Error "The iLO security settings are not supported on server '$ServerName'."
            Return

        }
        elseif ($Server) {
            
            $Uri = $COMServersUri + "/" + $Server.id + "/security-parameters"
            
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {

                Write-Error "Unable to retrieve iLO security parameters details for '$ServerName'. Please check the iLO event logs for more details."
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }

            if ($Null -ne $CollectionList) {     
            
                # Add region and serverName to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serverName -value $_.name }


                $NewCollectionList = [System.Collections.ArrayList]::new()

                $_ServerName = (Get-HPECOMServer -Region $Region -Name  ($CollectionList.Id -split '\+')[1]).name

                if ($CollectionList.IloSecurityParams) {

                    foreach ($IloSecurityParam in $CollectionList.IloSecurityParams) {
                        # Add serial number and region to object
                        $IloSecurityParam | Add-Member -type NoteProperty -name serialNumber -value ($CollectionList.Id -split '\+')[1]  
                        $IloSecurityParam | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                        $IloSecurityParam | Add-Member -type NoteProperty -name region -value $Region
                        
                        [void]$NewCollectionList.add($IloSecurityParam)
                    }
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters.Details"    
                }    
                else {
                    Return
                } 
            }

            if (-not $WhatIf) {
                
                return $ReturnData 

            }
        }                       
        
        else {
            Return
        }

    }
}


function Enable-HPECOMIloIgnoreRiskSetting {
    <#
    .SYNOPSIS
    Enable ignore iLO security risk settings.
    
    .DESCRIPTION   
    This cmdlet can be used to enable ignore iLO security risk settings on a server.
        
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER SerialNumber
    Serial number of the server on which the ignore iLO security risk will be enabled.
    
    .PARAMETER AccessPanelStatus 
    Parameter to enable the option to ignore the access panel status security risk warning.

    .PARAMETER AuthenticationFailureLogging 
    Parameter to enable the option to ignore the authentication failure logging security risk warning.

    .PARAMETER DefaultSSLCertificateInUse 
    Parameter to enable the option to ignore the default SSL Certificate In Use security risk warning.

    .PARAMETER GlobalComponentIntegrity
    Parameter to enable the option to ignore the global component integrity security risk warning.

    .PARAMETER IPMIDCMIOverLAN
    Parameter to enable the option to ignore the IPMI/DCMI Over LAN security risk warning.

    .PARAMETER LastFirmwareScanResult 
    Parameter to enable the option to ignore the last firmware scan result security risk warning.

    .PARAMETER MinimumPasswordLength 
    Parameter to enable the option to ignore the minimum password length security risk warning.

    .PARAMETER PasswordComplexity 
    Parameter to enable the option to ignore the password complexity security risk warning.

    .PARAMETER RequireHostAuthentication 
    Parameter to enable the option to ignore the require host authentication security risk warning.

    .PARAMETER RequireLoginforiLORBSU 
    Parameter to enable the option to ignore the require login for iLO RBSU security risk warning.

    .PARAMETER SecureBoot 
    Parameter to enable the option to ignore the secure boot security risk warning.

    .PARAMETER SecurityOverrideSwitch 
    Parameter to enable the option to ignore the security override switch security risk warning.

    .PARAMETER SNMPv1 
    Parameter to enable the option to ignore the SNMPv1 request: disabled security risk warning.

    .PARAMETER All
    Parameter to enable all ignore iLO security risk settings.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Enable-HPECOMIloIgnoreRiskSetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging

    This command enables the ignore iLO security risk settings "Access Panel Status" and "Authentication Failure Logging" on the server with serial number 'CZ12312312' located in the `eu-central` region. 
   
    .EXAMPLE
    Enable-HPECOMIloIgnoreRiskSetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse -IPMIDCMIOverLAN -LastFirmwareScanResult -MinimumPasswordLength -PasswordComplexity -RequireHostAuthentication -RequireLoginforiLORBSU -SecureBoot -SecurityOverrideSwitch -SNMPv1 

    This command enables all ignore iLO security risk settings on the server with serial number 'CZ12312312' located in the `eu-central` region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1 | Enable-HPECOMIloIgnoreRiskSetting -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse 

    This command enables the ignore iLO security risk settings "Access Panel Status", "Authentication Failure Logging", and "Default SSL Certificate In Use" on the server named 'ESX-1' located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType Direct | Enable-HPECOMIloIgnoreRiskSetting -All 

    This command enables all ignore iLO security risk settings on the servers with a direct connection type located in the `eu-central` region.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Enable-HPECOMIloIgnoreRiskSetting -Region eu-central -MinimumPasswordLength 

    This command enables the ignore iLO security risk setting "Minimum Password Length" on the servers with serial numbers 'CZ12312312' and 'DZ12312312' located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Select-Object -First 3 | Enable-HPECOMIloIgnoreRiskSetting -MinimumPasswordLength -PasswordComplexity

    The first command retrieves all servers in the 'eu-central' region. The second command selects the first three servers.
    The third command enables the ignore iLO security risk settings "Minimum Password Length" and "Password Complexity" on the selected servers.
 
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [alias('serial')]
        [String]$SerialNumber,

        [Parameter (ParameterSetName = 'Custom')]
        [switch]$AccessPanelStatus,

        [Parameter (ParameterSetName = 'Custom')]
        [switch]$AuthenticationFailureLogging,
        
        [Parameter (ParameterSetName = 'Custom')]    
        [switch]$DefaultSSLCertificateInUse,

        [Parameter (ParameterSetName = 'Custom')]
        [switch]$GlobalComponentIntegrity,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$IPMIDCMIOverLAN,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$LastFirmwareScanResult,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$MinimumPasswordLength,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$PasswordComplexity,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$RequireHostAuthentication,

        [Parameter (ParameterSetName = 'Custom')]    
        [switch]$RequireLoginforiLORBSU,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$SecureBoot,

        [Parameter (ParameterSetName = 'Custom')]           
        [switch]$SecurityOverrideSwitch,
            
        [Parameter (ParameterSetName = 'Custom')]
        [switch]$SNMPv1,

        [Parameter (ParameterSetName = 'All')]
        [switch]$All,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 60

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'iLOSecurity'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri      
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()

        if (-not $All -and -not ($AccessPanelStatus -or $AuthenticationFailureLogging -or $DefaultSSLCertificateInUse -or $IPMIDCMIOverLAN -or $LastFirmwareScanResult -or $MinimumPasswordLength -or $PasswordComplexity -or $RequireHostAuthentication -or $RequireLoginforiLORBSU -or $SecureBoot -or $SecurityOverrideSwitch -or $SNMPv1)) {
            
            # Must return a message if no parameter is used    
            $ErrorMessage = "At least one ignore iLO security risk setting must be used with this cmdlet!" -f $ParamUsed
            $ErrorRecord = New-ErrorRecord IgnoreParameterNotFound InvalidArgument -TargetObject 'Server' -Message $ErrorMessage 
            $PSCmdlet.ThrowTerminatingError($ErrorRecord)
        }

    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for the output
        $objStatus = [pscustomobject]@{
  
            associatedResource     = $SerialNumber
            date                   = "$((Get-Date).ToString())"
            state                  = $Null
            name                   = $_JobTemplateName
            duration               = $Null
            resultCode             = $Null
            status                 = $Null
            message                = $Null    
            region                 = $Region  
            jobUri                 = $Null 
            details                = $Null        
            ignoreSecuritySettings = [System.Collections.ArrayList]::new()       
        
        }

        try {
            $ServerIloSecurityStatus = Get-HPECOMIloSecuritySatus -Region $Region -ServerName $SerialNumber -ErrorAction SilentlyContinue
        
        }
        catch {

            $objStatus.state = "ERROR"
            $objStatus.duration = '00:00:00'
            $objStatus.resultCode = "FAILURE"
            $objStatus.Status = "Failed"
            $objStatus.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

            if ($WhatIf) {
                $ErrorMessage = "Unable to retrieve iLO security parameters details for '$SerialNumber'. Please check the iLO event logs for more details."
                Write-warning $ErrorMessage
                return
            }
        }

        if ($ServerIloSecurityStatus) {

            # Build $IgnoreSecuritySettings
            function New-Setting {
                param (
                    [string]$Name,
                    [string]$Id
                )
            
                return @{
                    name   = $Name
                    ignore = $true
                    id     = $Id
                }
            }

            if ($All) {

                $ServerIloSecurityStatus | ForEach-Object {
                    $Name = $_ | ForEach-Object name
                    $ID = $_ | ForEach-Object id

                    $PayloadSetting = New-Setting $Name $ID
                    [void]$objStatus.ignoreSecuritySettings.add($PayloadSetting)

                    "[{0}] Ignore iLO security risk setting '{1}' enabled for server '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $SerialNumber | Write-Verbose
                }

            }
            else {

                $settings = @(
                    @{ Name = "Access Panel Status"; Flag = $AccessPanelStatus },
                    @{ Name = "Authentication Failure Logging"; Flag = $AuthenticationFailureLogging },
                    @{ Name = "Default SSL Certificate In Use"; Flag = $DefaultSSLCertificateInUse },
                    @{ Name = "Global Component Integrity"; Flag = $GlobalComponentIntegrity },
                    @{ Name = "IPMI/DCMI Over LAN"; Flag = $IPMIDCMIOverLAN },
                    @{ Name = "Last Firmware Scan Result"; Flag = $LastFirmwareScanResult },
                    @{ Name = "Minimum Password Length"; Flag = $MinimumPasswordLength },
                    @{ Name = "Password Complexity"; Flag = $PasswordComplexity },
                    @{ Name = "Require Host Authentication"; Flag = $RequireHostAuthentication },
                    @{ Name = "Require Login for iLO RBSU"; Flag = $RequireLoginforiLORBSU },
                    @{ Name = "Secure Boot"; Flag = $SecureBoot },
                    @{ Name = "Security Override Switch"; Flag = $SecurityOverrideSwitch },
                    @{ Name = "SNMPv1"; Flag = $SNMPv1 }
                )
    
                foreach ($setting in $settings) {
    
                    if ($setting.Flag) {
                        $Name = $ServerIloSecurityStatus | Where-Object name -eq $setting.Name | ForEach-Object name
                        $ID = $ServerIloSecurityStatus | Where-Object name -eq $setting.Name | ForEach-Object id
    
                        if ($Name) {
                            $PayloadSetting = New-Setting $Name $ID
                            [void]$objStatus.ignoreSecuritySettings.add($PayloadSetting)
    
                            "[{0}] Ignore iLO security risk setting '{1}' enabled for server '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $setting.Name, $SerialNumber | Write-Verbose
                        } 
                        else {
    
                            Write-Warning "The iLO security risk setting '$($setting.Name)' is not available for server '$SerialNumber'. This setting will be ignored."
                        }
                    }
                }
            }            
        }
       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {       

        try {
            if ($Region) {

                $Servers = Get-HPECOMServer -Region $Region
            }
            else {
                Return
            }
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        
        
        foreach ($Resource in $ObjectStatusList) {

            if ($Resource.state -eq "ERROR") {
                continue
            }
            else {
                
                $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource


                if (-not $Server) {
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "The server with serial number '$($Resource.associatedResource)' cannot be found in the Compute Ops Management instance."
                    
                    if ($WhatIf) {
                        $ErrorMessage = "The server with serial number '$($Resource.associatedResource)' cannot be found in the Compute Ops Management instance."
                        Write-warning $ErrorMessage
                        continue
                    }
                }
                elseif ($Server.connectionType -eq "ONEVIEW") {
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "The iLO security settings are not supported on this server."
                    
                    if ($WhatIf) {
                        $ErrorMessage = "The iLO security settings are not supported on server '{0}'" -f $Resource.associatedResource
                        Write-warning $ErrorMessage
                        continue
                    }
                }
    
                else {
    
                    # Build payload
                    $data = @{
                        ignoreSecuritySettings = $Resource.ignoreSecuritySettings
                    }
                        
                    # Build payload
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $Server.ResourceUri
                        data           = $data                 
                    } | ConvertTo-Json -Depth 5
            
            
        
                    try {
            
                        $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   
            
                        if (-not $WhatIf -and -not $Async) {    
                                
                            $Timeout = $TimeoutinSecondsPerServer
                            
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
            
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
            
                        }
                        
                        if (-not $WhatIf ) {
            
                            $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
        
                            $Resource.state = $_resp.state
                            $Resource.duration = $Duration
                            $Resource.resultCode = $_resp.resultCode
                            $Resource.status = $_resp.Status
                            $Resource.details = $_resp
                            $Resource.jobUri = $_resp.resourceUri
        
                            "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose
                        
                        }
                    }
                    catch {
            
                        if (-not $WhatIf) {
        
                            $Resource.state = "ERROR"
                            $Resource.duration = '00:00:00'
                            $Resource.resultCode = "FAILURE"
                            $Resource.status = "Failed"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
                            
                        }
                    }  
                }
            }
        }
        
        if (-not $WhatIf) {

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more servers failed the modification attempt! Check the iLO event log for more information."
            
            }

            Return $ObjectStatusList
        }
    }  
   
}


function Disable-HPECOMIloIgnoreRiskSetting {
    <#
    .SYNOPSIS
    Disable ignore iLO security risk settings.
    
    .DESCRIPTION   
    This cmdlet can be used to disable ignore iLO security risk settings on a server.
        
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
        
    .PARAMETER SerialNumber
    Serial number of the server on which the ignore iLO security risk will be disabled.
        
    .PARAMETER AccessPanelStatus 
    Parameter to disable the option to ignore the access panel status security risk warning.

    .PARAMETER AuthenticationFailureLogging 
    Parameter to disable the option to ignore the authentication failure logging security risk warning.

    .PARAMETER DefaultSSLCertificateInUse 
    Parameter to disable the option to ignore the default SSL Certificate In Use security risk warning.

    .PARAMETER GlobalComponentIntegrity
    Parameter to disable the option to ignore the global component integrity security risk warning.

    .PARAMETER IPMIDCMIOverLAN
    Parameter to disable the option to ignore the IPMI/DCMI Over LAN security risk warning.

    .PARAMETER LastFirmwareScanResult 
    Parameter to disable the option to ignore the last firmware scan result security risk warning.

    .PARAMETER MinimumPasswordLength 
    Parameter to disable the option to ignore the minimum password length security risk warning.

    .PARAMETER PasswordComplexity 
    Parameter to disable the option to ignore the password complexity security risk warning.

    .PARAMETER RequireHostAuthentication 
    Parameter to disable the option to ignore the require host authentication security risk warning.

    .PARAMETER RequireLoginforiLORBSU 
    Parameter to disable the option to ignore the require login for iLO RBSU security risk warning.

    .PARAMETER SecureBoot 
    Parameter to disable the option to ignore the secure boot security risk warning.

    .PARAMETER SecurityOverrideSwitch 
    Parameter to disable the option to ignore the security override switch security risk warning.

    .PARAMETER SNMPv1 
    Parameter to disable the option to ignore the SNMPv1 request: disabled security risk warning.

    .PARAMETER All
    Parameter to disable all ignore iLO security risk settings.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Disable-HPECOMIloIgnoreRiskSetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging

    This command disables the ignore iLO security risk settings "Access Panel Status" and "Authentication Failure Logging" on the server with serial number 'CZ12312312' located in the `eu-central` region. 
   
    .EXAMPLE
    Disable-HPECOMIloIgnoreRiskSetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse -IPMIDCMIOverLAN -LastFirmwareScanResult -MinimumPasswordLength -PasswordComplexity -RequireHostAuthentication -RequireLoginforiLORBSU -SecureBoot -SecurityOverrideSwitch -SNMPv1 

    This command disables all ignore iLO security risk settings on the server with serial number 'CZ12312312' located in the `eu-central` region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType Direct | Disable-HPECOMIloIgnoreRiskSetting -All 

    This command disables all ignore iLO security risk settings on the servers with a direct connection type located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1 | Disable-HPECOMIloIgnoreRiskSetting -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse

    This command disables the ignore iLO security risk settings "Access Panel Status", "Authentication Failure Logging", and "Default SSL Certificate In Use" on the server named 'ESX-1' located in the `eu-central` region.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Disable-HPECOMIloIgnoreRiskSetting -Region eu-central -MinimumPasswordLength

    This command disables the ignore iLO security risk setting "Minimum Password Length" on the servers with serial numbers 'CZ12312312' and 'DZ12312312' located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Select-Object -First 3 | Disable-HPECOMIloIgnoreRiskSetting -MinimumPasswordLength -PasswordComplexity

    The first command retrieves all servers in the 'eu-central' region. The second command selects the first three servers.
    The third command disables the ignore iLO security risk settings "Minimum Password Length" and "Password Complexity" on the selected servers.
 
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [alias('serial')]
        [String]$SerialNumber,   

        [Parameter (ParameterSetName = 'Custom')]
        [switch]$AccessPanelStatus,

        [Parameter (ParameterSetName = 'Custom')]
        [switch]$AuthenticationFailureLogging,
        
        [Parameter (ParameterSetName = 'Custom')]    
        [switch]$DefaultSSLCertificateInUse,

        [Parameter (ParameterSetName = 'Custom')]
        [switch]$GlobalComponentIntegrity,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$IPMIDCMIOverLAN,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$LastFirmwareScanResult,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$MinimumPasswordLength,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$PasswordComplexity,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$RequireHostAuthentication,

        [Parameter (ParameterSetName = 'Custom')]    
        [switch]$RequireLoginforiLORBSU,

        [Parameter (ParameterSetName = 'Custom')]            
        [switch]$SecureBoot,

        [Parameter (ParameterSetName = 'Custom')]           
        [switch]$SecurityOverrideSwitch,
            
        [Parameter (ParameterSetName = 'Custom')]
        [switch]$SNMPv1,

        [Parameter (ParameterSetName = 'All')]
        [switch]$All,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 60

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'iLOSecurity'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri      
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()

        if (-not $All -and -not ($AccessPanelStatus -or $AuthenticationFailureLogging -or $DefaultSSLCertificateInUse -or $IPMIDCMIOverLAN -or $LastFirmwareScanResult -or $MinimumPasswordLength -or $PasswordComplexity -or $RequireHostAuthentication -or $RequireLoginforiLORBSU -or $SecureBoot -or $SecurityOverrideSwitch -or $SNMPv1)) {
            
            # Must return a message if no parameter is used    
            $ErrorMessage = "At least one ignore iLO security risk setting must be used with this cmdlet!" -f $ParamUsed
            $ErrorRecord = New-ErrorRecord IgnoreParameterNotFound InvalidArgument -TargetObject 'Server' -Message $ErrorMessage 
            $PSCmdlet.ThrowTerminatingError($ErrorRecord)
        }

    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for the output
        $objStatus = [pscustomobject]@{
  
            associatedResource     = $SerialNumber
            date                   = "$((Get-Date).ToString())"
            state                  = $Null
            name                   = $_JobTemplateName
            duration               = $Null
            resultCode             = $Null
            status                 = $Null
            message                = $Null    
            region                 = $Region  
            jobUri                 = $Null 
            details                = $Null        
            ignoreSecuritySettings = [System.Collections.ArrayList]::new()       
        
        }

        try {
            $ServerIloSecurityStatus = Get-HPECOMIloSecuritySatus -Region $Region -ServerName $SerialNumber -ErrorAction SilentlyContinue
        
        }
        catch {

            $objStatus.state = "ERROR"
            $objStatus.duration = '00:00:00'
            $objStatus.resultCode = "FAILURE"
            $objStatus.Status = "Failed"
            $objStatus.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

            if ($WhatIf) {
                $ErrorMessage = "Unable to retrieve iLO security parameters details for '$SerialNumber'. Please check the iLO event logs for more details."
                Write-warning $ErrorMessage
                return
            }
            
        }

        if ($ServerIloSecurityStatus) {

            # Build $IgnoreSecuritySettings
            function New-Setting {
                param (
                    [string]$Name,
                    [string]$Id
                )
            
                return @{
                    name   = $Name
                    ignore = $false
                    id     = $Id
                }
            }

            if ($All) {

                $ServerIloSecurityStatus | ForEach-Object {
                    $Name = $_ | ForEach-Object name
                    $ID = $_ | ForEach-Object id

                    $PayloadSetting = New-Setting $Name $ID
                    [void]$objStatus.ignoreSecuritySettings.add($PayloadSetting)

                    "[{0}] Ignore iLO security risk setting '{1}' enabled for server '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $SerialNumber | Write-Verbose
                }

            }
            else {

                $settings = @(
                    @{ Name = "Access Panel Status"; Flag = $AccessPanelStatus },
                    @{ Name = "Authentication Failure Logging"; Flag = $AuthenticationFailureLogging },
                    @{ Name = "Default SSL Certificate In Use"; Flag = $DefaultSSLCertificateInUse },
                    @{ Name = "Global Component Integrity"; Flag = $GlobalComponentIntegrity },
                    @{ Name = "IPMI/DCMI Over LAN"; Flag = $IPMIDCMIOverLAN },
                    @{ Name = "Last Firmware Scan Result"; Flag = $LastFirmwareScanResult },
                    @{ Name = "Minimum Password Length"; Flag = $MinimumPasswordLength },
                    @{ Name = "Password Complexity"; Flag = $PasswordComplexity },
                    @{ Name = "Require Host Authentication"; Flag = $RequireHostAuthentication },
                    @{ Name = "Require Login for iLO RBSU"; Flag = $RequireLoginforiLORBSU },
                    @{ Name = "Secure Boot"; Flag = $SecureBoot },
                    @{ Name = "Security Override Switch"; Flag = $SecurityOverrideSwitch },
                    @{ Name = "SNMPv1"; Flag = $SNMPv1 }
                )

                foreach ($setting in $settings) {

                    if ($setting.Flag) {
                        $Name = $ServerIloSecurityStatus | Where-Object name -eq $setting.Name | ForEach-Object name
                        $ID = $ServerIloSecurityStatus | Where-Object name -eq $setting.Name | ForEach-Object id

                        if ($Name) {
                            $PayloadSetting = New-Setting $Name $ID
                            [void]$objStatus.ignoreSecuritySettings.add($PayloadSetting)

                            "[{0}] Ignore iLO security risk setting '{1}' enabled for server '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $setting.Name, $SerialNumber | Write-Verbose
                        } 
                        else {

                            Write-Warning "The iLO security risk setting '$($setting.Name)' is not available for server '$SerialNumber'. This setting will be ignored."
                        }
                    }
                }
            }            
        }
       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {       

        try {
            if ($Region) {
                $Servers = Get-HPECOMServer -Region $Region
            }
            else {
                Return
            }
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        
        
        foreach ($Resource in $ObjectStatusList) {

            if ($Resource.state -eq "ERROR") {
                continue
            }
            else {
                
                $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource


                if (-not $Server) {
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "The server with serial number '$($Resource.associatedResource)' cannot be found in the Compute Ops Management instance."
                    
                    if ($WhatIf) {
                        $ErrorMessage = "The server with serial number '$($Resource.associatedResource)' cannot be found in the Compute Ops Management instance."
                        Write-warning $ErrorMessage
                        continue
                    }
                }
                elseif ($Server.connectionType -eq "ONEVIEW") {
                    $Resource.state = "ERROR"
                    $Resource.duration = '00:00:00'
                    $Resource.resultCode = "FAILURE"
                    $Resource.Status = "Failed"
                    $Resource.message = "The iLO security settings are not supported on this server."
                    
                    if ($WhatIf) {
                        $ErrorMessage = "The iLO security settings are not supported on server '{0}'" -f $Resource.associatedResource
                        Write-warning $ErrorMessage
                        continue
                    }
                }
    
                else {
    
                    # Build payload
                    $data = @{
                        ignoreSecuritySettings = $Resource.ignoreSecuritySettings
                    }
                        
                    # Build payload
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $Server.ResourceUri
                        data           = $data                 
                    } | ConvertTo-Json -Depth 5
            
            
        
                    try {
            
                        $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf   
            
                        if (-not $WhatIf -and -not $Async) {    
                                
                            $Timeout = $TimeoutinSecondsPerServer
                            
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
            
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
            
                        }
                        
                        if (-not $WhatIf ) {
            
                            $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')
        
                            $Resource.state = $_resp.state
                            $Resource.duration = $Duration
                            $Resource.resultCode = $_resp.resultCode
                            $Resource.status = $_resp.Status
                            $Resource.details = $_resp
                            $Resource.jobUri = $_resp.resourceUri
        
                            "[{0}] Resource content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Resource | Write-Verbose
                        
                        }
                    }
                    catch {
            
                        if (-not $WhatIf) {
        
                            $Resource.state = "ERROR"
                            $Resource.duration = '00:00:00'
                            $Resource.resultCode = "FAILURE"
                            $Resource.status = "Failed"
                            $Resource.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
            
                            
                            
                        }
                    }  
                }
            }
        }
        
        if (-not $WhatIf) {

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more servers failed the modification attempt! Check the iLO event log for more information."
            
            }

            Return $ObjectStatusList
        }
    }  
}  


#EndRegion


#Region --- METRICS CONFIGURATION ---

Function Get-HPECOMMetricsConfiguration {
    <#
    .SYNOPSIS
    Retrieve the metrics data collection configuration.

    .DESCRIPTION
    This Cmdlet returns a collection of metrics data configuration that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMMetricsConfiguration -Region us-west 

    Return metrics data collection configuration located in the western US region. 

    .INPUTS
    No pipeline support

    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      
        
        $Uri = $COMMetricsConfigurationsUri
            
        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            
             
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Jobs"    
            
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- REPORTS ---

Function Get-HPECOMReport {
    <#
    .SYNOPSIS
    Retrieve the list of reports.

    .DESCRIPTION
    This Cmdlet returns a collection of reports and their associated data that are available in the specified region.

    Note: To get more information about report details, you can use Get-HPECOMServerInventory and Get-HPECOMSustainabilityReport.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) from which to retrieve the reports.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ServerHardwareInventoryReport
    Optional switch parameter that can be used to display the server hardware inventory report.

    .PARAMETER ServerHardwareInventoryData
    Optional switch parameter that can be used to display the data of the server hardware inventory report.  

    .PARAMETER SustainabilityReport
    Optional switch parameter that can be used to display the sustainability report.
    
    .PARAMETER SustainabilityData
    Optional switch parameter that can be used to display the data of the sustainability report.  

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMReport -Region us-west 

    Return all reports resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMReport -Region us-west -ServerHardwareInventoryReport 

    Return the server hardware inventory report located in the western US region. 

    .EXAMPLE
    Get-HPECOMReport -Region us-west -ServerHardwareInventoryData 
    
    Return the data of the server hardware inventory report. 
    
    .EXAMPLE
    Get-HPECOMReport -Region eu-central -SustainabilityReport 

    Return the sustainability report located in the western US region. 

    .EXAMPLE
    Get-HPECOMReport -Region eu-central -SustainabilityData 
    
    Return the data of the sustainability report. 

    
   #>
    [CmdletBinding(DefaultParameterSetName = "Region")]
    Param( 
        [Parameter (Mandatory, ParameterSetName = 'Region')]
        [Parameter (Mandatory, ParameterSetName = 'ServerHardwareInventoryReport')]
        [Parameter (Mandatory, ParameterSetName = 'ServerHardwareInventoryData')]
        [Parameter (Mandatory, ParameterSetName = 'SustainabilityReport')]
        [Parameter (Mandatory, ParameterSetName = 'Co2Emissions')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumption')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCost')]
        [Parameter (Mandatory, ParameterSetName = 'Co2EmissionsTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumptionTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCostTotal')]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  


        [Parameter (ParameterSetName = 'ServerHardwareInventoryReport')]
        [Switch]$ServerHardwareInventoryReport,

        [Parameter (ParameterSetName = 'ServerHardwareInventoryData')]
        [Switch]$ServerHardwareInventoryData,

        [Parameter (ParameterSetName = 'SustainabilityReport')]
        [Switch]$SustainabilityReport,

        [Parameter (ParameterSetName = 'Co2Emissions')]
        [Switch]$SustainabilityData,
    
        [Switch]$WhatIf
       
    ) 

    Begin {
    
        $Caller = (Get-PSCallStack)[1].Command
    
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


    }


    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        
        if ($ServerHardwareInventoryReport) {
            $Uri = $COMReportsUri + "?filter=reportType eq 'SERVER_HARDWARE_INVENTORY'&limit=10"
            
        }        
        elseif ($ServerHardwareInventoryData) {

            $Uri = $COMReportsUri + "?limit=10"

            try {

                $ReportList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
                
                "[{0}] Server hardware inventory report: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ReportList | ConvertTo-Json -d 10) | Write-Verbose

                $ReportID = ($ReportList | Where-Object reportType -eq "SERVER_HARDWARE_INVENTORY" ).id

                "[{0}] ID found for 'Server hardware inventory report': '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ReportID | Write-Verbose

                if ($Null -eq $ReportID) { Throw "Error: Server hardware inventory report not found! You need to run New-HPECOMServerInventory first" }
    
                $Uri = $COMReportsUri + "/" + $ReportID + "/data" + "?limit=10"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        elseif ($SustainabilityReport) {
            $Uri = $COMReportsUri + "?filter=reportType eq 'CARBON_FOOTPRINT'&limit=10"
            
        }
        elseif ($SustainabilityData) {
           
            $Uri = $COMReportsUri + "?limit=10"

            try {

                $ReportList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
                
                "[{0}] Sustainability report: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ReportList | ConvertTo-Json -d 10) | Write-Verbose

                $ReportID = ($ReportList | Where-Object reportType -eq "CARBON_FOOTPRINT" ).id

                "[{0}] ID found for 'sustainability report': '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ReportID | Write-Verbose

                if ($Null -eq $ReportID) { Throw "Error: Sustainability report not found! You need to run New-HPECOMSustainabilityReport first" }
    
                $Uri = $COMReportsUri + "/" + $ReportID + "/data" + "?limit=10"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
            
        }
        else {
            $Uri = $COMReportsUri + "?limit=10"
            
        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {    
            
            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            


            if ($ServerHardwareInventoryData) {

                $CollectionList = $CollectionList.data.rows.items
               
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.ServerHardwareInventoryData"    
                $ReturnData = $ReturnData | Sort-Object name

            }
            
            elseif ($SustainabilityData) {

                $CollectionList = $CollectionList.data.series

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    
                $ReturnData = $ReturnData | Sort-Object { $_.name, $_.subject.displayName }

            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports"    
                $ReturnData = $ReturnData | Sort-Object name
            }

        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}



function New-HPECOMServerInventory {
    <#
    .SYNOPSIS
    Collect server inventory data.
    
    .DESCRIPTION   
    This cmdlet collects inventory data from all directly managed or OneView managed servers or from a specified server resource.
    It also provides options for scheduling execution at a specific time and setting recurring schedules.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER SerialNumber
    Serial number of the server on which server inventory data will be collected. 
    
    .PARAMETER Chassis
    Switch parameter that can be used to collect the chassis inventory data.
    When no inventory list is provided, all inventory resources will be collected.
    
    .PARAMETER Devices
    Switch parameter that can be used to collect the devices inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Fans
    Switch parameter that can be used to collect the fans inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Firmware
    Switch parameter that can be used to collect the firmware inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER LocalStorage
    Switch parameter that can be used to collect the local storage inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Memory
    Switch parameter that can be used to collect the memory inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER NetworkAdapters
    Switch parameter that can be used to collect the network adapters inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER PowerSupplies
    Switch parameter that can be used to collect the power supplies inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Processor
    Switch parameter that can be used to collect the processor inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Software
    Switch parameter that can be used to collect the software inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER ScheduleTime
    Indicates when to schedule the server inventory operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) referencing days, weeks, months, years but not time (T) designations that reference hours, minutes, and seconds.

    This parameter supports common ISO 8601 period durations such as:
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMServerInventory -Region us-west 
    
    Collects a full inventory data from all directly managed or OneView managed servers in the western US region.

    .EXAMPLE
    New-HPECOMServerInventory -Region us-west -SerialNumber CN70490RXQ  

    Collects a full inventory data from server 'CN70490RXQ' in the western US region.

    .EXAMPLE
    New-HPECOMServerInventory -Region us-west -SerialNumber CN70490RXQ -Chassis -Fans 

    Collects the chassis and fans inventory data from server 'CN70490RXQ' in the western US region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Name HOL19  | New-HPECOMServerInventory

    Collects the full inventory data from server named 'HOL19' in the western US region.    
    
    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model 'ProLiant DL380a Gen11' -ConnectedState True  | New-HPECOMServerInventory

    The first command retrieves all 'ProLiant DL380a Gen11' servers in the 'us-west' region that are connected to the COM. 
    The second command collects full inventory data of these servers provided through the pipeline.

    .EXAMPLE
    New-HPECOMServerInventory -Region eu-central -SerialNumber CZ12312312 -ScheduleTime (Get-Date).AddDays(1) 

    Creates a new server inventory in the 'eu-central' region with serial number 'CZ12312312', scheduled to start one day from the current date.

    .EXAMPLE
    New-HPECOMServerInventory -Region eu-central -SerialNumber CZ12312312 -ScheduleTime (Get-Date).AddDays(1) -Interval P1W

    Creates a new server inventory in the 'eu-central' region with serial number 'CZ12312312', scheduled to start one day from the current date and recur weekly.

    .EXAMPLE
    "CZ12312312", "CZ12312313" | New-HPECOMServerInventory -Region eu-central

    Collects a full inventory data from servers 'CZ12312312' and 'CZ12312313' in the 'eu-central' region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects that represent the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'. 

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Async')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [String]$SerialNumber,
        
        [switch]$Chassis,

        [switch]$Devices,

        [switch]$Fans,

        [switch]$Firmware,
        
        [switch]$LocalStorage,

        [switch]$Memory,
        
        [switch]$NetworkAdapters,
        
        [switch]$PowerSupplies,

        [switch]$Processor,

        [switch]$Software,

        [Parameter (Mandatory, ParameterSetName = 'Schedule')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Schedule')]
        [String]$Interval, 

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf


    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GetFullServerInventory'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()

        
    }

    Process {  

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $Filters = [System.Collections.ArrayList]::new()

        # Build tracking object for a schedule output
        if ($ScheduleTime) {

            $objStatus = [pscustomobject]@{
                name               = $Null
                description        = if ($SerialNumber) { "Scheduled task to collect inventory data from server '$SerialNumber'" } else { "Scheduled task to collect inventory data from all servers" }
                associatedResource = if ($SerialNumber) { $SerialNumber } else { "All servers" }
                purpose            = "INVENTORY_REPORT"
                id                 = $Null
                nextStartAt        = $Null
                lastRun            = $Null
                scheduleUri        = $Null
                schedule           = $Null
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }

        }
        # Build tracking object for non-schedule output
        else {

            $objStatus = [pscustomobject]@{               
                name               = $_JobTemplateName
                associatedResource = if ($SerialNumber) { $SerialNumber } else { "All servers" }
                date               = "$((Get-Date).ToString())"
                state              = $Null
                duration           = $Null
                status             = $Null
                jobUri             = $Null 
                region             = $Region  
                resultCode         = $Null
                message            = $Null    
                details            = $Null        
            }
        }

        try {

            if ($SerialNumber) {

                $_ResourceUri = (Get-HPECOMServer -Region $Region -Name $SerialNumber).resourceUri

                "[{0}] Resource is 'SERVERS' type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ResourceUri | Write-Verbose

            } 
            else {

                $_ResourceUri = (Get-HPECOMFilter -Region $Region -Name "All servers" ).resourceUri

                "[{0}] Resource is 'FILTERS' type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ResourceUri | Write-Verbose

            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_ResourceUri) {
            # Must return a message if not found

            if ($SerialNumber) {

                if ($ScheduleTime) {

                    $objStatus.resultCode = "FAILURE"
                    $objStatus.message = "Server cannot be found in the Compute Ops Management instance!"

                }
                else {

                    $objStatus.state = "ERROR"
                    $objStatus.duration = '00:00:00'
                    $objStatus.resultCode = "FAILURE"
                    $objStatus.status = "Failed"
                    $objStatus.message = "Server cannot be found in the Compute Ops Management instance!"
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the Compute Ops Management instance!" -f $SerialNumber
                    Write-warning $ErrorMessage
                    return

                }
            }
            else {

                if ($ScheduleTime) {

                    $objStatus.resultCode = "FAILURE"
                    $objStatus.message = "Filter 'All servers' cannot be found in the Compute Ops Management instance!" 

                }
                else {

                    $objStatus.state = "ERROR"
                    $objStatus.duration = '00:00:00'
                    $objStatus.resultCode = "FAILURE"
                    $objStatus.status = "Failed"
                    $objStatus.message = "Filter 'All servers' cannot be found in the Compute Ops Management instance!" 
                }
                
                if ($WhatIf) {
                    $ErrorMessage = "Filter 'All servers' cannot be found in the Compute Ops Management instance!" 
                    Write-warning $ErrorMessage
                    continue
                }
            }
        }
        else {

            $componentMap = @{
                Chassis         = "Chassis"
                Processor       = "Processor"
                Memory          = "memory"
                NetworkAdapters = "networkAdapters"
                LocalStorage    = "localStorageV2"
                LocalStorageV2  = "localStorageV2"
                Devices         = "devicesV2"
                DevicesV2       = "devicesV2"
                PowerSupplies   = "powerSupplies"
                Fans            = "fans"
                Firmware        = "firmware"
                Software        = "software"
            }
            
            foreach ($param in $componentMap.Keys) {
                if ($PSBoundParameters.ContainsKey($param)) {
                    [void]$Filters.Add($componentMap[$param])
                }
            }
            
            if ($Filters.Count -gt 0) {
                $data = @{
                    filters = $Filters
                    is_activity_message_needed = $true
                }
            }   
            else {
                $data = @{
                    is_activity_message_needed = $true
                }
            }                   

            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                if ($data) {
                    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_ResourceUri
                        data           = $data
                    }      
                }
                else {

                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_ResourceUri
                    }    

                }
                
                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                if ($SerialNumber) {

                    $Name = "$($SerialNumber)_Inventory_Report_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to run an inventory report on server '$($SerialNumber)'"

                }
                else {

                    $Name = "All_Servers_Inventroy_Report_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to run an inventory report for all servers"
                }

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "INVENTORY_REPORT"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                if ($data) {
    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_ResourceUri
                        data           = $data
                    }
                    
                }
                else {
    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_ResourceUri
                    }      
                }
            }
            

            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
        
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                        
                        $objStatus.name = $_resp.name
                        $objStatus.id = $_resp.id
                        $objStatus.nextStartAt = $_resp.nextStartAt
                        $objStatus.lastRun = $_resp.lastRun
                        $objStatus.scheduleUri = $_resp.resourceUri
                        $objStatus.schedule = $Schedule
                        $objStatus.lastRun = $_resp.lastRun
                        $objStatus.resultCode = "SUCCESS"
                        $objStatus.details = $_resp
                        $objStatus.message = "The schedule to collect inventory data has been successfully created."

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
            
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
            
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 600 # 10 minutes timeout
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }

                    if (-not $WhatIf ) {
            
                        $Duration = ((Get-Date $_resp.updatedAt) - (Get-Date $_resp.createdAt)).ToString('hh\:mm\:ss')

                        $objStatus.state = $_resp.state
                        $objStatus.duration = $Duration
                        $objStatus.resultCode = $_resp.resultCode
                        $objStatus.message = $_resp.message
                        $objStatus.status = $_resp.Status
                        $objStatus.details = $_resp
                        $objStatus.jobUri = $_resp.resourceUri        
                        
                    }
                }

                "[{0}] objStatus content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $objStatus | Write-Verbose


            }
            catch {

                if (-not $WhatIf) {
                        
                    if ($ScheduleTime) {
                        
                        $objStatus.name = $Name
                        $objStatus.schedule = $Schedule
                        $objStatus.resultCode = "FAILURE"
                        $objStatus.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "

                    }
                    else {
                        
                        $objStatus.state = "ERROR"
                        $objStatus.duration = '00:00:00'
                        $objStatus.resultCode = "FAILURE"
                        $objStatus.status = "Failed"
                        $objStatus.message = $_.Exception.Message -replace "`r`n", " " -replace "`n", " " -replace "`r", " "
                    }      
                }
            } 
            
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

        
    }

    end {

        if (-not $WhatIf) {

            if ($ScheduleTime) {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Schedules.Status" 
            }
            else {

                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "COM.Jobs.Status" 
            }

            "[{0}] Output content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

            if ($ObjectStatusList | Where-Object { $_.resultCode -eq "FAILURE" }) {

                Write-Error "The inventory data collection failed on one or more servers."
            
            }

            Return $ObjectStatusList
        }
    }
}


Function Get-HPECOMServerInventory {
    <#
    .SYNOPSIS
    Retrieve the inventories of a server.
    
    .DESCRIPTION
    This Cmdlet can be used to retrieve firmware, software, storage inventories, PCI devices and smart update tool settings for a server specified by the 
    name or serial number of the server.
    
    Note: 
    A server hardware inventory report must be available or created with `New-HPECOMServerInventory` before using this cmdlet. 
    You can check reports using `Get-HPECOMReport`.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER Name 
    Parameter that can be used to specify a server's name in order to obtain its inventory.

    .PARAMETER SerialNumber 
    Parameter that can be used to specify a server's serial number in order to obtain its inventory.
    
   .PARAMETER ShowChassis
    Parameter that can be used to get the chassis inventory.   

   .PARAMETER ShowDevice
    Parameter that can be used to get the device inventory (OCP, PCI, embedded, etc.).

   .PARAMETER ShowFans
    Parameter that can be used to get the fan inventory.

   .PARAMETER ShowFirmware
    Parameter that can be used to get the firmware inventory.

   .PARAMETER ShowMemory
    Parameter that can be used to get the memory inventory.

   .PARAMETER ShowNetworkAdapter
    Parameter that can be used to get the network adapter inventory (NIC, CNA, HBA, etc.).

   .PARAMETER ShowPowerSupply
    Parameter that can be used to get the power supply inventory.

   .PARAMETER ShowProcessor
    Parameter that can be used to get the processor inventory.

   .PARAMETER ShowSmartUpdateTool
    Parameter that can be used to get the Smart Update Tool (SUT) information details.

   .PARAMETER ShowSoftware
    Parameter that can be used to get the software inventory.

   .PARAMETER ShowStorageController
    Parameter that can be used to get the storage controller inventory.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
    
    .EXAMPLE
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6
    
    Retrieves the inventory for the server with the serial number TWA22565A6 in the western US region.
    
    .EXAMPLE
    # Retrieve the firmware inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowFirmware
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowFirmware
    
    This command returns the firmware inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the software inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowSoftware
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowSoftware
    
    This command returns the software inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the device inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowDevice
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowDevice
    
    This command returns the device inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the fan inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowFans
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowFans
    
    This command returns the fan inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the memory inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowMemory
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowMemory
    
    This command returns the memory inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers retrieved using 'Get-HPECOMServer -Name $Name'.

   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 
    
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'InventoryName')]
        [String]$Name,
    
        [Parameter (Mandatory, ParameterSetName = 'SerialNumber', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorySN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorysoftwareSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventoryFirmwareSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorystorageSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorysmartStorageSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorydeviceSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorysmartUpdateToolSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorychassisSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorymemorySN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorynetworkAdapterSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventoryprocessorSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorypowerSupplySN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorythermalSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias ('serial_number')]
        [String]$SerialNumber,
       
        # [Parameter (ParameterSetName = 'InventorychassisName')]
        [Parameter (ParameterSetName = 'InventorychassisSN')]
        [Switch]$ShowChassis,

        # [Parameter (ParameterSetName = 'InventorydeviceName')]
        [Parameter (ParameterSetName = 'InventorydeviceSN')]
        [Switch]$ShowDevice,
        
        # [Parameter (ParameterSetName = 'InventorythermalName')]
        [Parameter (ParameterSetName = 'InventorythermalSN')]
        [Switch]$ShowFans,

        # [Parameter (ParameterSetName = 'InventoryFirmwareName')]
        [Parameter (ParameterSetName = 'InventoryFirmwareSN')]
        [Switch]$ShowFirmware,
        
        # [Parameter (ParameterSetName = 'InventorymemoryName')]
        [Parameter (ParameterSetName = 'InventorymemorySN')]
        [Switch]$ShowMemory,

        # [Parameter (ParameterSetName = 'InventorynetworkAdapterName')]
        [Parameter (ParameterSetName = 'InventorynetworkAdapterSN')]
        [Switch]$ShowNetworkAdapter,

        # [Parameter (ParameterSetName = 'InventorypowerSupplyName')]
        [Parameter (ParameterSetName = 'InventorypowerSupplySN')]
        [Switch]$ShowPowerSupply,

        # [Parameter (ParameterSetName = 'InventoryprocessorName')]
        [Parameter (ParameterSetName = 'InventoryprocessorSN')]
        [Switch]$ShowProcessor,

        # [Parameter (ParameterSetName = 'InventorysmartStorageName')]
        # [Parameter (ParameterSetName = 'InventorysmartStorageSN')]
        # [Switch]$ShowSmartStorage,

        [Parameter (ParameterSetName = 'InventorysmartUpdateToolName')]
        [Parameter (ParameterSetName = 'InventorysmartUpdateToolSN')]
        [Switch]$ShowSmartUpdateTool,

        # [Parameter (ParameterSetName = 'InventorysoftwareName')]
        [Parameter (ParameterSetName = 'InventorysoftwareSN')]
        [Switch]$ShowSoftware,
        
        # [Parameter (ParameterSetName = 'InventorystorageName')]
        [Parameter (ParameterSetName = 'InventorystorageSN')]
        [Switch]$ShowStorageController,

        [Switch]$WhatIf
        
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

    
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose  

        # Get server ID using SN   
        if ($SerialNumber) {
            $Uri = $COMServersUri + "?filter=hardware/serialNumber eq '$SerialNumber'"
                
        }
        elseif ($Name) {
            $Uri = $COMServersUri + "?filter=host/hostname eq '$Name'"     
                
        }

        try {
            [Array]$Server = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

        
            if ($Null -eq $Server) { 
            
                Return
        
            }
            else {
                
                $ServerID = $Server.id
                
                if ($SerialNumber) {
                    
                    "[{0}] ID found for server serial number '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $ServerID | Write-Verbose
                    
                    
                }
                elseif ($Name) {
                    
                    "[{0}] ID found for server name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $ServerID | Write-Verbose
                    
                }
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }
       

     
        # Requests using $ServerID
        $Uri = $COMServersUri + "/" + $ServerID + "/inventory"

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

            $FullInventoryAlreadyRun = if ($CollectionList.lastFullInventoryCollectionAt) { $True }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }



        $ReturnData = @()
               
        # Format response with Repackage Object With Type
        if ($Null -ne $CollectionList) {      
            
            # Add region, servername and serialNumber (only serial is provided)
            try {
                $_ServerName = Get-HPECOMServer -Region $Region -Name $CollectionList.serial                        
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            $CollectionList | Add-Member -type NoteProperty -name serialNumber -value $CollectionList.serial  
            $CollectionList | Add-Member -Type NoteProperty -Name serverName -Value $_ServerName.name


            if ($Showsoftware) {
                $ReturnData = $CollectionList.software.data 
                $ReturnData | Add-Member -Type NoteProperty -Name serverName -Value $_ServerName.name
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Software"    

            }
    
            elseif ($Showfirmware) {
                $ReturnData = $CollectionList.firmware.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Software"    

            }

            elseif ($ShowStorageController) {
                $ReturnData = $CollectionList.storage.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Storage"    

            }

            elseif ($ShowsmartStorage) {
                $ReturnData = $CollectionList.smartStorage.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Storage"    

            }

            elseif ($Showdevice) {
                $ReturnData = $CollectionList.device.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Device"    

            }

            elseif ($ShowSmartUpdateTool) {
                $ReturnData = $CollectionList.smartUpdateToolInventory.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.smartUpdateToolInventory"    

            }

            elseif ($Showchassis) {
                $ReturnData = $CollectionList.chassis.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Chassis"    

            }

            elseif ($Showmemory) {
                $ReturnData = $CollectionList.memory.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Memory"    

            }

            elseif ($ShownetworkAdapter) {
                $ReturnData = $CollectionList.networkAdapter.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.NetworkAdapter"    

            }

            elseif ($Showprocessor) {
                $ReturnData = $CollectionList.processor.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Processor"    

            }

            elseif ($ShowpowerSupply) {
                $ReturnData = $CollectionList.powerSupply.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.PowerSupply"    

            }

            elseif ($ShowFans) {
                $ReturnData = $CollectionList.thermal.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Thermal"    

            }
            else {
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.Inventory"    
                
            }

            if ($Null -eq $ReturnData -and -not $FullInventoryAlreadyRun) {

                Write-Verbose ($PSCmdlet.MyInvocation.BoundParameters.Keys | Where-Object { $_ -like 'Show*' } )

                $ErrorMessage = "{0} inventory data is not populated. Please run New-HPECOMServerInventory first." -f (($PSCmdlet.MyInvocation.BoundParameters.Keys | Where-Object { $_ -like 'Show*' } ) -replace "Show")
                Write-Warning $ErrorMessage

            }
            else {
                
                return $ReturnData 
            }
        }
    }
}


function New-HPECOMSustainabilityReport {
    <#
    .SYNOPSIS
    Generates a carbon footprint report.
    
    .DESCRIPTION   
    This cmdlet generates a Carbon Footprint Report for all managed servers. It also provides options to schedule the execution at a specific time and to set recurring schedules.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) referencing days, weeks, months, years but not time (T) designations that reference hours, minutes, and seconds.

    This parameter supports common ISO 8601 period durations such as:
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSustainabilityReport -Region us-west 
    
    Generates a carbon footprint report in the western US region for all managed servers.

    .EXAMPLE
    New-HPECOMSustainabilityReport -Region eu-central -ScheduleTime (get-Date).addminutes(10) 

    Schedules the execution of a sustainability report in the `eu-central` region starting 10 minutes from now. 

    .EXAMPLE
    New-HPECOMSustainabilityReport -Region eu-central -ScheduleTime (get-Date).addhours(6) -Interval P1M

    Schedules a monthly execution of a sustainability report in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    You cannot pipe objects to this cmdlet.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      

        [Parameter (Mandatory, ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Scheduled')]
        [String]$Interval,    
        
        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,
        
        [switch]$WhatIf

    )



    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'DataRoundupReportOrchestrator'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $SustainabilityReportStatus = [System.Collections.ArrayList]::new()

        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            
            $_ResourceUri = (Get-HPECOMFilter -Region $Region -Name "All servers" ).resourceUri
            "[{0}] Resource is 'FILTERS' type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ResourceUri | Write-Verbose

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_ResourceUri) {

            # Must return a message if not found
            $ErrorMessage = "Filter 'All servers' cannot be found in the Compute Ops Management instance!" 
            $ErrorRecord = New-ErrorRecord FilterNotFoundInCOM ObjectNotFound -TargetObject 'Filter' -Message $ErrorMessage 
            $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }
        else {

            $data = @{
                reportType = "CARBON_FOOTPRINT"

            }
             
            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_ResourceUri
                    data           = $data
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "All_Servers_SustainabilityReport_Schedule_$($randomNumber)"
                $Description = "Scheduled task to run a sustainability report for all servers"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is converted by PS5.1 to '/Date(...)\/ notation'
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "SUSTAINABILITY_REPORT"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_ResourceUri
                    data           = $data
                }
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
            
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
            
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                    else {

                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                    }
                    
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $SustainabilityReportStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $SustainabilityReportStatus
        
        }

    }
}


Function Get-HPECOMSustainabilityReport {
    <#
    .SYNOPSIS
    Retrieve the sustainability report.

    .DESCRIPTION
    This Cmdlet can be used to display the sustainability report and data available in the specified region.

    Note: 
    An sustainability report must be available or created with `New-HPECOMSustainabilityReport` before using this cmdlet. 
    You can check reports using `Get-HPECOMReport`.

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) from which to retrieve the sustainability report.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER SerialNumber
    Optional parameter that can be used to get the report data of a specific server.
    
    .PARAMETER Co2Emissions
    Optional switch parameter that can be used to display the carbon emissions data.    
    
    .PARAMETER Co2EmissionsTotal
    Optional switch parameter that can be used to display the total carbon emissions data.    

    .PARAMETER EnergyConsumption
    Optional switch parameter that can be used to display the energy consumption data.   
    
    .PARAMETER EnergyConsumptionTotal
    Optional switch parameter that can be used to display the total energy consumption data.  
        
    .PARAMETER EnergyCost
    Optional switch parameter that can be used to display the energy cost data.    

    .PARAMETER EnergyCostTotal
    Optional switch parameter that can be used to display the total energy cost data.     

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west 
    
    Return the sustainability report information available in the us-west region.
        
    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -Co2Emissions
    
    Return the carbon emissions data of individual servers located the western US region.
    
    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region eu-central -Co2EmissionsTotal 

    Return the total carbon emissions data of all servers located in the central EU region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -SerialNumber MXQ73301YK -Co2Emissions 
    
    Return the carbon emissions data of the server with serial number MXQ73301YK.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyConsumption

    Return the energy consumption data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyConsumptionTotal

    Return the total energy consumption data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -SerialNumber MXQ73301YK -EnergyConsumption 
    
    Return the energy consumption data of the server with serial number MXQ73301YK.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyCost

    Return the energy cost data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyCostTotal

    Return the total energy cost data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region eu-central -SerialNumber MXQ73301YK -EnergyCost

    Return the energy cost data of the server with serial number MXQ73301YK.
  
    
   #>
    [CmdletBinding(DefaultParameterSetName = "Region")]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'Region')]
        [Parameter (Mandatory, ParameterSetName = 'Co2Emissions')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumption')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCost')]
        [Parameter (Mandatory, ParameterSetName = 'Co2EmissionsTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumptionTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCostTotal')]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
    

        [Parameter (ParameterSetName = 'Co2Emissions', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (ParameterSetName = 'EnergyConsumption', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (ParameterSetName = 'EnergyCost', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [alias('serial')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ParameterSetName = 'Co2Emissions')]
        [Switch]$Co2Emissions,

        [Parameter (Mandatory, ParameterSetName = 'Co2EmissionsTotal')]
        [Switch]$Co2EmissionsTotal,

        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumption')]
        [Switch]$EnergyConsumption,

        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumptionTotal')]
        [Switch]$EnergyConsumptionTotal,

        [Parameter (Mandatory, ParameterSetName = 'EnergyCost')]
        [Switch]$EnergyCost,

        [Parameter (Mandatory, ParameterSetName = 'EnergyCostTotal')]
        [Switch]$EnergyCostTotal,

        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        
        if (        $Co2Emissions `
                -or $Co2EmissionsTotal `
                -or $EnergyConsumption `
                -or $EnergyConsumptionTotal `
                -or $EnergyCost `
                -or $EnergyCostTotal 

        ) {

            $Uri = $COMReportsUri + "?limit=10"

            try {
                [Array]$ReportList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                $ReportID = $ReportList | Where-Object { $_.name -eq "Sustainability report" } | ForEach-Object id

                "[{0}] ID found for 'Sustainability report': '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ReportID | Write-Verbose

                if ($Null -eq $ReportID) { Throw "Error: Sustainability report not found! You need to run New-HPECOMSustainabilityReport first" }
    
                $Uri = $COMReportsUri + "/" + $ReportID + "/data"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        else {
            $Uri = $COMReportsUri + "?filter=reportType eq 'CARBON_FOOTPRINT'&limit=10"
            
        }
     

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {        

            if (        $Co2Emissions `
                    -or $Co2EmissionsTotal `
                    -or $EnergyConsumption `
                    -or $EnergyConsumptionTotal `
                    -or $EnergyCost `
                    -or $EnergyCostTotal 
                     
            ) {
                $CollectionList = $CollectionList.data.series

            }


            if ($Co2Emissions) {

                if ($SerialNumber) {
                    $CollectionList = $CollectionList | Where-Object { ((($_.subject.id) -split "\+")[1]) -eq $SerialNumber } | Where-Object { $_.seriesType -eq "CO2_EMISSIONS" }
                  
                }
                else {
                    # Exclude the first property that contains ALL emissions
                    $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "CO2_EMISSIONS" })[1..($CollectionList.count - 1)]
                }
                
                # Add serial number and region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  

                Foreach ($Item in $CollectionList) {
                    If ($Item.subject.id -match "\+") { 
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.subject.id.split('+')[-1] ) 
                    } 
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    

            }
            elseif ($Co2EmissionsTotal) {

                $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "CO2_EMISSIONS" })[0]

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityDataAllServers"    

            }  
            elseif ($EnergyConsumption) {

                if ($SerialNumber) {
                    $CollectionList = $CollectionList | Where-Object { ((($_.subject.id) -split "\+")[1]) -eq $SerialNumber } | Where-Object { $_.seriesType -eq "ENERGY_CONSUMPTION" }
                    
                }
                else {
                    # Exclude the first property that contains ALL energy consumption
                    $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_CONSUMPTION" })[1..($CollectionList.count - 1)]
                }
                
                # Add serial number and region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  

                Foreach ($Item in $CollectionList) {
                    If ($Item.subject.id -match "\+") { 
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.subject.id.split('+')[-1] ) 
                    } 
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    

            }
            elseif ($EnergyConsumptionTotal) {

                $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_CONSUMPTION" })[0]

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityDataAllServers"    

            }
            elseif ($EnergyCost) {

                if ($SerialNumber) {
                    $CollectionList = $CollectionList | Where-Object { ((($_.subject.id) -split "\+")[1]) -eq $SerialNumber } | Where-Object { $_.seriesType -eq "ENERGY_COST" }
                    
                }
                else {
                    # Exclude the first property that contains ALL energy cost
                    $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_COST" })[1..($CollectionList.count - 1)]
                }
                
                # Add serial number and region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region 
                
                Foreach ($Item in $CollectionList) {
                    If ($Item.subject.id -match "\+") { 
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.subject.id.split('+')[-1] ) 
                    } 
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    

            }
            elseif ($EnergyCostTotal) {

                $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_COST" })[0]

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityDataAllServers"    

            }
            else {

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region        

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports"    

            }
        
            $ReturnData = $ReturnData | Sort-Object { $_.subject.displayname }
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- SCHEDULES ---

Function Get-HPECOMSchedule {
    <#
    .SYNOPSIS
    Retrieve the list of schedules.

    .DESCRIPTION
    This Cmdlet returns a collection of all schedules that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Optional parameter that can be used to specify the name of a schedule to display.

    .PARAMETER History
    Optional switch parameter that can be used together with -Name to get all history of a schedule.

    .PARAMETER ShowPendingSchedules
    Optional switch parameter that can be used to display scheduled tasks that are not yet executed.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central 

    Return the last 50 schedules resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -name "Firmware update for group Prod"
    
    Return the schedule resource named "Firmware update for group Prod" located in the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -name "Firmware update for group Prod" -History
    
    Return the list of history entries of the schedule resource named "Firmware update for group Prod" located in the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central  -ShowPendingSchedules

    Return the list of pending schedules located in the central EU region.

    .INPUTS
        None. You cannot pipe objects to this cmdlet.
  
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'NameShowPendingSchedules')]
    Param( 

        [Parameter(Mandatory)]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter(Mandatory, ParameterSetName = 'NameHistory')]
        [Parameter(ParameterSetName = 'NameShowPendingSchedules')]
        [String]$Name,
                
        [Parameter(ParameterSetName = 'NameHistory')]
        [Switch]$History,

        [Parameter(ParameterSetName = 'NameShowPendingSchedules')]
        [Switch]$ShowPendingSchedules,
        
        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
        
        if ($Name) {       

            $Uri = $COMSchedulesUri + "?filter=name eq '$Name'"     
   
        }
        elseif ($ID) {
            $Uri = $COMSchedulesUri + "?filter=id eq '$ID'"     
            
        }
        else {

            $Uri = $COMSchedulesUri 
            
        }

        if ($History) {

            $Uri = $COMSchedulesUri + "?filter=name eq '$Name'"     

            try {
                [Array]$SchedulesList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                $ScheduleID = $SchedulesList.id

                "[{0}] ID found for the schedule '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $ScheduleID | Write-Verbose

                if ($Null -eq $ScheduleID) { 
                    
                    "[{0}] Schedule name '{1}' cannot be found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    Return
                }
    
                $Uri = $COMSchedulesUri + "/" + $ScheduleID + "/history"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            if ($ShowPendingSchedules) {
                $CollectionList = $CollectionList | Where-Object { $Null -ne $_.nextStartAt }
            }


            if ($History) {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Schedules.History"    
            
            }
            else {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Schedules"    
                $ReturnData = $ReturnData | Sort-Object name, purpose, nextStartAt
            }
    
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}



Function Remove-HPECOMSchedule {
    <#
    .SYNOPSIS
    Remove a schedule resource from a region.

    .DESCRIPTION
    This Cmdlet can be used to delete a schedule resource and its associated history in a region using its name property.     
        
    .PARAMETER Name 
    Name of the schedule resource to remove. 
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where to remove a schedule resource. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMSchedule -Region eu-central -Name "ESXi_group_ServerFirmwareUpdate_Schedule_663933" 
    
    Remove the schedule named "ESXi_group_ServerFirmwareUpdate_Schedule_663933" from the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -Name 'ESXi_group_ServerFirmwareUpdate_Schedule_663933' | Remove-HPECOMSchedule

    Remove schedule 'ESXi_group_ServerFirmwareUpdate_Schedule_663933' from the central EU region using 'Get-HPECOMSchedule' as a pipeline input. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -ShowPendingSchedules | Remove-HPECOMSchedule

    Remove all pending schedules from the central EU region using 'Get-HPECOMSchedule' as a pipeline input.

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central | Where-Object name -match "Inventory_Report_Schedule" | Remove-HPECOMSchedule 

    Remove all schedules with names that match 'Inventory_Report_Schedule' from the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central | Remove-HPECOMSchedule 

    Remove all schedules from the central EU region. 

    .INPUTS
    System.Collections.ArrayList
        List of schedule(s) from 'Get-HPECOMSchedule'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the schedule attempted to be removed
        * Region - Name of the region where the schedule is removed
        * Status - Status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

     
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveScheduleStatus = [System.Collections.ArrayList]::new()
        
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        try {
            $ScheduleResource = Get-HPECOMSchedule -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $ScheduleID = $ScheduleResource.id

        
        if (-not $ScheduleID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Schedule '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Schedule cannot be found in the region!"

            }

        }
        else {
            
            $Uri = $COMSchedulesUri + "/" + $ScheduleID

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Schedule removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Schedule '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Schedule successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Schedule cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveScheduleStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveScheduleStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more schedules has failed!"


          
            }
            
            $RemoveScheduleStatus = Invoke-RepackageObjectWithType -RawObject $RemoveScheduleStatus -ObjectName "COM.objStatus.NSDE"    

            Return $RemoveScheduleStatus
        }
    }
}



Function Set-HPECOMSchedule {
    <#
    .SYNOPSIS
    Update a schedule resource in a region.

    .DESCRIPTION   
    This Cmdlet can be used to modify the basic settings of a schedule resource in a region. Basic settings include name, description, and schedule.
    To modify advanced settings, such as the schedule operations or the associated resource, it's necessary to remove the existing schedule (using 'Remove-HPECOMSchedule') and re-create it using 
    one of the Register cmdlets (such as 'Register-HPECOMGroupFirmwareUpdateSchedule', 'Register-HPECOMServerFirmwareUpdateSchedule', etc.).
        
    .PARAMETER Name 
    Name of the schedule to update. 

    .PARAMETER ID
    ID of the schedule to update.

    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the schedule is located.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    New name for the schedule.

    .PARAMETER NewScheduleTime  
    New time for the scheduled operation's execution.

    .PARAMETER NewInterval
    Specifies the new execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)
        
    .PARAMETER NewDescription 
    New description for the schedule.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSchedule -Region us-west -Name ServerFirmwareUpdate_Schedule -NewName CZ12312312_ServerFirmwareUpdate_Schedule 
   
    Change the name of the schedule named 'ServerFirmwareUpdate_Schedule' to 'CZ12312312_ServerFirmwareUpdate_Schedule' in the western US region.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewDescription "This is my new description"  

    Change the description of the schedule named 'ServerFirmwareUpdate_Schedule' to 'This is my new description' in the central EU region.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewScheduleTime (Get-Date).AddMonths(6)

    Change the schedule time of the schedule named 'ServerFirmwareUpdate_Schedule' to six months from the current date. 

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewInterval P2M 

    Change the interval time of the schedule named 'ServerFirmwareUpdate_Schedule' to an interval of two months.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewScheduleTime (Get-Date).AddMonths(6) -NewInterval P2M 

    Change both the schedule time and the interval time of the schedule named 'ServerFirmwareUpdate_Schedule' in the eu-central region. Set the schedule time to six months from the current date and the interval to recur every two months.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewName CZ12312312_ServerFirmwareUpdate_Schedule -NewScheduleTime ((Get-Date).AddMonths(6)) -NewDescription "My new description" 

    Change the name, the schedule time and description of the schedule named 'ServerFirmwareUpdate_Schedule' in the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central | Set-HPECOMSchedule -NewScheduleTime  (Get-Date).AddDays(7)

    Change the schedule time of all schedules found in the central EU region to 7 days from the current date.

    .INPUTS
    System.Collections.ArrayList
        List of schedule(s) from 'Get-HPECOMSchedule'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the schedule attempted to be updated
        * Region - Name of the region where the schedule is updated
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Name')]
        [String]$Name,
                       
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'ID')]
        [String]$ID,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,

        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$NewScheduleTime,   

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [String]$NewInterval, 

        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 10000 })]
        [alias('description')]
        [String]$NewDescription,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetScheduleStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($Name) {

                $ParamUsed = $Name
                
                $SchedulesResources = Get-HPECOMSchedule -Region $Region -Name $Name
                
                if ($SchedulesResources.length -gt 1) {

                    $ErrorMessage = "More than one schedule uses the name '{0}' in the '{1}' region!" -f $Name, $Region
                    Write-warning $ErrorMessage
                    break
                    
                }
                else {

                    $ScheduleID = $SchedulesResources.id
                    
                }
            }
            else {
                
                $ParamUsed = $ID

                $SchedulesResources = Get-HPECOMSchedule -Region $Region 

                $ScheduleID = $SchedulesResources | Where-Object id -eq $ID

                
            }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $ParamUsed
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        "[{0}] Schedule ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ScheduleID | Write-Verbose
       
        if (-not $ScheduleID) {

            # Must return a message if not found
            if ($WhatIf) {

                $ErrorMessage = "Schedule '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
                $ErrorRecord = New-ErrorRecord ScheduleNotFoundInCOM ObjectNotFound -TargetObject 'Schedule' -Message $ErrorMessage -TargetType $ParamUsed.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)   
              
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Schedule cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $_Schedule = Get-HPECOMSchedule -Region $Region -ID $ScheduleID
            
            $Uri = $COMSchedulesUri + "/" + $ScheduleID
            
            $Payload = @{}

            # Conditionally add properties
            if ($NewName) {
                $Payload.name = $NewName
            }
            else {
                $Payload.name = $Name
                
            }

            if (-not $PSBoundParameters.ContainsKey('NewDescription')) {
	
                if ($_Schedule.description) {
                    $Payload.description = $_Schedule.description
                }
                else {
                    $Payload.description = $Null
                }
            }
            else {
                $Payload.description = $NewDescription
            }
   

            if ($NewScheduleTime -and -not $NewInterval) {
                $Payload.schedule = @{
                    startAt  = $NewScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                    interval = $_Schedule.schedule.interval
                }
            }
            elseif ($NewScheduleTime -and $NewInterval) {
                $Payload.schedule = @{
                    startAt  = $NewScheduleTime.ToString("o")  # Convert to ISO 8601 format as $ScheduleTime alone is convert by PS5.1 to '/Date(...)\/ notation'
                    interval = $NewInterval
                }
            }
            elseif (-not $NewScheduleTime -and $NewInterval) {
                $Payload.schedule = @{
                    startAt  = $_Schedule.schedule.startAt
                    interval = $NewInterval
                }
            }
            else {
                $Payload.schedule = @{
                    startAt  = $_Schedule.schedule.startAt
                    interval = $_Schedule.schedule.interval
                }
            }

            $Payload.purpose = $_Schedule.purpose
            $Payload.associatedResourceUri = $_Schedule.associatedResourceUri

            # Convert the hashtable to JSON
            $jsonPayload = $Payload | ConvertTo-Json


            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $jsonPayload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Schedule update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Schedule '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Schedule successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Schedule cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $SetScheduleStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetScheduleStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Schedule failed the update attempt!"
          
            }
            
            $RemoveScheduleStatus = Invoke-RepackageObjectWithType -RawObject $RemoveScheduleStatus -ObjectName "COM.objStatus.NSDE"    

            Return $SetScheduleStatus
        }


    }
}

#EndRegion


#Region --- SETTINGS ---

Function Get-HPECOMSetting {
    <#
    .SYNOPSIS
    Retrieve the list of settings.

    .DESCRIPTION
    This Cmdlet returns a collection of settings that are available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name 
    Optional parameter that can be used to specify the name of a setting to display.

    .PARAMETER Category 
    Optional parameter that can be used to specify a category of server settings to display.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMSetting -Region us-west

    Return all server settings resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name 'DLV24-ESX8.0-Installation'
   
    Return the server settings resource named 'DLV24-ESX8.0-Installation' located in the central EU region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category Os
   
    Return the server settings resources for the OS category located in the Central EU region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name RAID-FOR_AI -ShowVolumes

    Return the volumes associated with the server internal storage setting named 'RAID-FOR_AI' located in the central EU region.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

   #>
    [CmdletBinding(DefaultParameterSetName = 'default')]
    Param( 
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter(ParameterSetName = 'default')]
        [Parameter(Mandatory, ParameterSetName = 'ShowVolumes')]
        [String]$Name,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $categories = @('Bios', 'Os', 'Firmware', 'ExternalStorage', 'IloSettings', 'Storage')
                
                $filteredCategories = $categories | Where-Object { $_ -like "$wordToComplete*" }

                return $filteredCategories | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }

            })]
        [ValidateScript({
                $validOptions = @('Bios', 'Os', 'Firmware', 'ExternalStorage', 'IloSettings', 'Storage')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]    
        [String]$Category,

        [Parameter(ParameterSetName = 'ShowVolumes')]
        [Switch]$ShowVolumes,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command
  
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_bundles = Get-HPECOMFirmwareBundle -Region $Region 

    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
           
        if ($Name) {
            $Uri = $COMSettingsUri + "?filter=name eq '$name'"

        }
        elseif ($Category) {

            switch ($Category) {
                Bios { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'BIOS'"
                }
                Os { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'OS'"
                }                
                Firmware { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'FIRMWARE'"
                }                
                ExternalStorage { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'EXTERNAL_STORAGE'"
                }                
                IloSettings { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'ILO_SETTINGS'"
                }                
                Storage { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'STORAGE'"
                }

            }
        }
        else {
            $Uri = $COMSettingsUri   

        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction Stop
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            
            if ($Name) {
                $CollectionList = $CollectionList | Where-Object name -eq $Name
            }

            $allFirmware = $allbios = $allstorage = $allos = $allIlosettings = $allExternalStorage = $true

            foreach ($setting in $CollectionList) {
                
                $_settings = $setting.settings

                # When firmware category
                if ($_settings.DEFAULT) {
                    # if ($setting.category -eq "FIRMWARE") {

                    foreach ($Item in $_settings.DEFAULT) {
                        
                        foreach ($property in $item.PSObject.Properties) {

                            $setting | Add-Member -type NoteProperty -name $property.Name -value $property.Value

                        } 
                    }                                 
                
                }
                # When other categories
                else {

                    $_Gens = ($setting.settings | Get-Member -MemberType NoteProperty).name  # it's where GEN10, GEN11 are usually provided for firmware server settings

                    foreach ($Gen in $_Gens) {

                        $_settings = $setting.settings.$($Gen)
                        
                        foreach ($property in $setting.settings.$($Gen)) {
                                
                            $_bundleName = $_bundles | Where-Object id -eq $property.id | ForEach-Object displayName

                            $_propertyName = $Gen + "FirmwareBundle"

                            $setting | Add-Member -type NoteProperty -name $_propertyName -value $_bundleName
                                
                        } 
                    }                   
                }   
                
                # Detect object type for object repackage 
                if ("FIRMWARE" -ne $setting.Category) {
                    $allFirmware = $false
                }
                
                if ("BIOS" -ne $setting.Category) {
                    $allbios = $false                   
                }
                
                if ("STORAGE" -ne $setting.Category) {
                    $allstorage = $false
                }

                if ("OS" -ne $setting.Category) {
                    $allos = $false
                }

                if ("ILO_SETTINGS" -ne $setting.Category) {
                    $allIlosettings = $false
                }

                if ("EXTERNAL_STORAGE" -ne $setting.Category) {
                    $allExternalStorage = $false
                }
            }         


            if ($allstorage) { 
                    
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.STORAGE"   
            } 
            elseif ($allos) {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.OS"   
            }
            elseif ($allExternalStorage) {
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.EXTERNAL_STORAGE"   
            }
            elseif ($allIlosettings) {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.ILO_SETTINGS"   
            }
            elseif ($allbios) {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.BIOS"   
            }   
            elseif ($allFirmware) {
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.FIRMWARE"    
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings"    
                
            }

            if ($ShowVolumes) {
                
                $CollectionList = $CollectionList.volumes | Sort-Object { $_.raidType }    
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.STORAGE.volumes"
                
            }

            $ReturnData = $ReturnData | Sort-Object { $_.name }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function New-HPECOMSettingServerBios {
    <#
    .SYNOPSIS
    Configure a bios server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new bios server setting set either with a workload profile or a customized one with provided parameters.
    Bios settings enable you to apply a consistent bios configuration to servers in a group.

    For a detailed description of all iLO BIOS attributes parameters:
    - For iLO6, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo6/ilo6_159/ilo6_bios_resourcedefns159/
    - For iLO5, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo5/ilo5_304/ilo5_bios_resourcedefns304/

    Note: If a parameter is incompatible with your iLO generation or server platform, 'Invoke-HPECOMGroupBiosConfiguration' will return an error message stating "Apply BIOS settings failed".
          To get more detailed information about the parameters that caused these errors, access the iLO Redfish API using a GET request to /redfish/v1/Systems/1/Bios/ and inspect the @Redfish.Settings.Messages property.
    
    Note: If one or several unsupported parameters are selected, the other BIOS settings will still be applied successfully. Unsupported parameters will be ignored without affecting the application of the other settings.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the bios server setting to set.

    .PARAMETER Description
    Specifies a description of the bios server setting.

    .PARAMETER WorkloadProfileName
    Name of a pre-defined workload profile:
        - Decision Support
        - General Peak Frequency Compute
        - General Power Efficient Compute
        - General Throughput Compute
        - Graphic Processing
        - High Performance Compute (HPC)
        - I/O Throughput
        - Low Latency
        - Mission Critical
        - My-Bios-For-AI
        - Transactional Application Processing
        - Virtual Radio Access Network (vRAN)
        - Virtualization - Max Performance
        - Virtualization - Power Efficient

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance"

    This example shows how to create a new BIOS setting named "Custom-Bios-For-ESX" in the eu-central region. It sets a description and uses the "Virtualization - Max Performance" workload profile.

    .EXAMPLE
    New-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance" `
      -AdminName Albert -AdminEmail "alb@domain.com" -AsrTimeoutMinutes Timeout10 -AutoPowerOn AlwaysPowerOn -CoreBoosting:$true -F11BootMenu:$False -ThermalConfig OptimalCooling 

    This example sets a customized BIOS configuration for "Custom-Bios-For-ESX" in the eu-central region. In addition to the settings from Example 1, it includes admin details (AdminName and AdminEmail), various BIOS feature configurations such as ASR timeout, auto power on, core boosting, F11 boot menu, and thermal configuration for optimal cooling.

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the bios server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ilo6')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Decision Support', 'General Peak Frequency Compute', 'General Power Efficient Compute', 'General Throughput Compute', 'Graphic Processing', 'High Performance Compute (HPC)', 'I/O Throughput', 'Low Latency', 'Mission Critical', 'Transactional Application Processing', 'Virtual Radio Access Network (vRAN)', 'Virtualization - Max Performance', 'Virtualization - Power Efficient')
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Decision Support', 'General Peak Frequency Compute', 'General Power Efficient Compute', 'General Throughput Compute', 'Graphic Processing', 'High Performance Compute (HPC)', 'I/O Throughput', 'Low Latency', 'Mission Critical', 'Transactional Application Processing', 'Virtual Radio Access Network (vRAN)', 'Virtualization - Max Performance', 'Virtualization - Power Efficient')]

        [String]$WorkloadProfileName,
        
        [bool]$AccessControlService,
        [bool]$AcpiHpet,
        [bool]$AcpiRootBridgePxm,
        [bool]$AcpiSlit,
        [bool]$AdjSecPrefetch,
        [string]$AdminEmail,
        [String]$AdminName,
        [string]$AdminOtherInfo,
        # Name of the server administrator
        [string]$AdminPhone,

        [bool]$AdvCrashDumpMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')]
        [String]$AdvancedMemProtection,

        [bool]$AllowLoginWithIlo,
        [bool]$Amd5LevelPage,
        [bool]$AmdCdma,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('800us', '18us')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('800us', '18us')]
        [String]$AmdCstC2Latency,

        [bool]$AmdDmaRemapping,
        [bool]$AmdL1Prefetcher,
        [bool]$AmdL2Prefetcher,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [String]$AmdMemPStates,
        
        [bool]$AmdMemoryBurstRefresh,
        [bool]$AmdPeriodicDirectoryRinse,
        [bool]$AmdSecureMemoryEncryption,
        [bool]$AmdSecureNestedPaging,
        [bool]$AmdVirtualDrtmDevice,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32' )
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32')]
        [String]$AmdXGMILinkSpeed,

        [bool]$ApplicationPowerBoost,

        # Use this option to configure the Automatic Server Recovery option, which enables the system to automatically reboot if the server locks up.
        [bool]$AsrStatus,

        # When Automatic Server Recovery is enabled, you can use this option to set the time to wait before rebooting the server in the event of an operating system crash or server lockup.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')]
        [string]$AsrTimeoutMinutes,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Locked', 'Unlocked')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Locked', 'Unlocked')]
        [String]$AssetTagProtection,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')]
        [String]$AutoPowerOn,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')]
        [string]$BootOrderPolicy,

        [bool]$ChannelInterleaving,
        [bool]$CollabPowerControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('LomsAndSlots', 'LomsOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('LomsAndSlots', 'LomsOnly', 'Disabled')]
        [string]$ConsistentDevNaming,

        [bool]$CoreBoosting,

        # Enter a message to be displayed on POST screen during system startup. This feature limits POST screen messaging to 62 characters, special characters are also accepted.
        [ValidateScript({
                if ($_.Length -le 62) {
                    $True
                }
                if ($_ -match '^[a-zA-Z0-9]+$') {
                    $true
                } 
                elseif ($_.Length -gt 62) {
                    throw "The POST screen message cannot have more than 62 characters!"

                }
                elseif ($_ -notmatch '^[a-zA-Z0-9]+$') {
                    throw "The POST screen message cannot contain special characters!"
                }
            })]
        [string]$CustomPostMessage,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Manual')]
        [string]$CustomPstate0,
            
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceEnabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'ForceEnabled', 'Disabled')]
        [string]$DataFabricCStateEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')]
        [string]$DaylightSavingsTime,
         
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DeterminismCtrlAuto', 'DeterminismCtrlManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DeterminismCtrlAuto', 'DeterminismCtrlManual')]            
        [string]$DeterminismControl,        

        [bool]$DcuIpPrefetcher,
        [bool]$DcuStreamPrefetcher,
        [bool]$Dhcpv4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]
        [string]$DirectToUpi,

        [bool]$DramControllerPowerDown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]            
        [string]$DynamicPowerCapping,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AspmL1Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AspmL1Enabled', 'Disabled')]            
        [string]$EmbNicAspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]            
        [string]$EmbNicEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1')]
        [string]$EmbNicLinkSpeed,
        
        [bool]$EmbNicPCIeOptionROM,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$EmbSas1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AllTargets', 'TwentyFourTargets', 'NoTargets')]
        [string]$EmbSas1Boot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSas1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$EmbSas1LinkSpeed,
        
        [bool]$EmbSas1PcieOptionROM,
        [bool]$EmbSata1Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata1Enable,
        
        [bool]$EmbSata1PCIeOptionROM,
        [bool]$EmbSata2Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata2Enable,
        
        [bool]$EmbSata2PCIeOptionROM,

        [bool]$EmbSata3Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata3Enable,
        
        [bool]$EmbSata3PCIeOptionROM,
        [bool]$EmbSata4Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata4Enable,
        
        [bool]$EmbSata4PCIeOptionROM,
               
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AlwaysDisabled', 'AlwaysEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AlwaysDisabled', 'AlwaysEnabled')]
        [string]$EmbVideoConnection,
        
        [bool]$EmbeddedDiagnostics,
        [bool]$EmbeddedIpxe,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')]
        [string]$EmbeddedSata,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$EmbeddedSerialPort,
        
        [bool]$EmbeddedUefiShell,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Physical', 'Virtual')]
        [string]$EmsConsole,
        
        # This attribute is a problem because in iLO5, value is an integer
        [Parameter (ParameterSetName = 'ilo6')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')]
        [string]$EnabledCoresPerProcIlo6,

        [Parameter (ParameterSetName = 'ilo5')]
        [int]$EnabledCoresPerProcIlo5,

        [bool]$EnergyEfficientTurbo,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')]
        [string]$EnergyPerfBias,

        [bool]$EnhancedProcPerf,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ASHRAE3', 'ASHRAE4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ASHRAE3', 'ASHRAE4')]
        [string]$ExtendedAmbientTemp,

        [bool]$ExtendedMemTest,
        [bool]$F11BootMenu,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'CardConfig')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'CardConfig')]
        [string]$FCScanPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Shutdown', 'Allow')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Shutdown', 'Allow')]
        [string]$FanFailPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EnableMessaging', 'DisableMessaging')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EnableMessaging', 'DisableMessaging')]
        [string]$FanInstallReq,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$FlexLom1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$FlexLom1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$FlexLom1LinkSpeed,

        [bool]$FlexLom1PCIeOptionROM,
         

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('12Hours', '24Hours')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('12Hours', '24Hours')]
        [string]$HourFormat,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')]
        [string]$HttpSupport,

        [bool]$HwPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('P0', 'P1', 'P2', 'P3', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('P0', 'P1', 'P2', 'P3', 'Auto')]
        [string]$InfinityFabricPstate,
        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DmiGen1', 'DmiGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DmiGen1', 'DmiGen2')]            
        [string]$IntelDmiLinkFreq,
        
        [bool]$IntelNicDmaChannels,
        [bool]$IntelPerfMonitoring,
        [bool]$IntelProcVtd,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Base', 'Config1', 'Config2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Base', 'Config1', 'Config2')]
        [string]$IntelSpeedSelect,

        [bool]$IntelTxt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MinUpiSpeed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MinUpiSpeed')]
        [string]$IntelUpiFreq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'SingleLink')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'SingleLink')]
        [string]$IntelUpiLinkEn,

        [bool]$IntelUpiPowerManagement,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('VmdDirectAssignEnabledAll', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('VmdDirectAssignEnabledAll', 'Disabled')]
        [string]$IntelVmdDirectAssign,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')]
        [string]$IntelVmdSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'Standard', 'Premium')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'Standard', 'Premium')]
        [string]$IntelVrocSupport,
                
        [bool]$IntelligentProvisioning,
        [bool]$InternalSDCardSlot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PowerCycle', 'PowerDown', 'WarmBoot')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PowerCycle', 'PowerDown', 'WarmBoot')]
        [string]$IpmiWatchdogTimerAction,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')]
        [string]$IpmiWatchdogTimerStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')]
        [string]$IpmiWatchdogTimerTimeout,
        
        [string]$Ipv4Address,
        [string]$Ipv4Gateway,
        [string]$Ipv4PrimaryDNS,
        [string]$Ipv4SubnetMask,
        [string]$Ipv6Address,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Automatic', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Automatic', 'Manual')]
        [string]$Ipv6ConfigPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DuidLlt', 'DUID-LLT')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DuidLlt', 'DUID-LLT')]
        [string]$Ipv6Duid,

        [string]$Ipv6Gateway,
        [string]$Ipv6PrimaryDNS,
        [string]$Ipv6SecondaryDNS,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$IpxeAutoStartScriptLocation,
        
        
        [bool]$IpxeBootOrder,
        [bool]$IpxeScriptAutoStart,
        [bool]$IpxeScriptVerification,
        [string]$IpxeStartupUrl,
        [bool]$LastLevelCacheAsNUMANode,
        

        [bool]$LLCDeadLineAllocation,
        [bool]$LlcPrefetch,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Low', 'Medium', 'High', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Low', 'Medium', 'High', 'Disabled')]
        [string]$LocalRemoteThreshold,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')]
        [string]$MaxMemBusFreqMHz,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')]
        [string]$MaxPcieSpeed,

        [bool]$MemClearWarmReset,
        [bool]$MemFastTraining,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')]
        [string]$MemMirrorMode,
        
        [bool]$MemPatrolScrubbing,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Refreshx1', 'Refreshx2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Refreshx1', 'Refreshx2')]
        [string]$MemRefreshRate,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$MemoryControllerInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'AllMemory')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'AllMemory')]
        [string]$MemoryRemap,

        [bool]$MicrosoftSecuredCoreSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6Retention', 'C6NonRetention', 'NoState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6Retention', 'C6NonRetention', 'NoState')]
        [string]$MinProcIdlePkgState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6', 'C1E', 'NoCStates')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6', 'C1E', 'NoCStates')]
        [string]$MinProcIdlePower,

        [int]$MinimumSevAsid,

        [bool]$MixedPowerSupplyReporting,
        [bool]$NetworkBootRetry,
        [int]$NetworkBootRetryCount,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot5,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot6,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot7,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot8,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot9,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot10,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot11,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot12,

        [bool]$NodeInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Flat', 'Clustered')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Flat', 'Clustered')]
        [string]$NumaGroupSizeOpt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')]
        [string]$NumaMemoryDomainsPerSocket,
        
        [bool]$NvDimmNMemFunctionality,
        [bool]$NvDimmNMemInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')]
        [string]$NvDimmNSanitizePolicy,

        [bool]$NvdimmLabelSupport,
        [bool]$NvmeOptionRom,
        [bool]$Ocp1AuxiliaryPower,
        [bool]$Ocp2AuxiliaryPower,
        [bool]$OmitBootDeviceEvent,
        [bool]$OpportunisticSelfRefresh,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Manual')]
        [string]$PackagePowerLimitControlMode,

        [int]$PackagePowerLimitValue,
        [int]$PatrolScrubDuration,

        [bool]$PciPeerToPeerSerialization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Medium', 'High')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Medium', 'High')]
        [string]$PciResourcePadding,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot20Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot20Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot20Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot20LinkSpeed,

        [bool]$PciSlot20OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot19Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot19Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot19Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot19LinkSpeed,

        [bool]$PciSlot19OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot18Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot18Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot18Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot18LinkSpeed,

        [bool]$PciSlot18OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot17Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot17Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot17Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot17LinkSpeed,

        [bool]$PciSlot17OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot16Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot16Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot16Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot16LinkSpeed,

        [bool]$PciSlot16OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot15Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot15Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot15Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot15LinkSpeed,

        [bool]$PciSlot15OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot14Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot14Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot14Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot14LinkSpeed,

        [bool]$PciSlot14OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot13Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot13Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot13Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot13LinkSpeed,

        [bool]$PciSlot13OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot12Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot12Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot12Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot12LinkSpeed,

        [bool]$PciSlot12OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot11Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot11Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot11Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot11LinkSpeed,

        [bool]$PciSlot11OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot10Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot10Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot10Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot10LinkSpeed,

        [bool]$PciSlot10OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot9Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot9Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot9Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot9LinkSpeed,

        [bool]$PciSlot9OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot8Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot8Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot8Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot8LinkSpeed,

        [bool]$PciSlot8OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot7Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot7Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot7Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot7LinkSpeed,

        [bool]$PciSlot7OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot6Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot6Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot6Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot6LinkSpeed,

        [bool]$PciSlot6OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot5Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot5Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot5Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot5LinkSpeed,

        [bool]$PciSlot5OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot4Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot4Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot4Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot4LinkSpeed,

        [bool]$PciSlot4OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot3Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot3Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot3Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot3LinkSpeed,

        [bool]$PciSlot3OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot2Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot2Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot2Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot2LinkSpeed,

        [bool]$PciSlot2OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot1Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot1LinkSpeed,
        
        [bool]$PciSlot1OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerformanceDeterministic', 'PowerDeterministic')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerformanceDeterministic', 'PowerDeterministic')]
        [string]$PerformanceDeterminism,
        
        [bool]$PersistentMemAddressRangeScrub,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')]
        [string]$PersistentMemBackupPowerPolicy,

        [bool]$PersistentMemScanMem,
        [bool]$PlatformCertificate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FirmwareFirst', 'OSFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('FirmwareFirst', 'OSFirst')]
        [string]$PlatformRASPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PostAsrOff', 'PostAsrOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PostAsrOff', 'PostAsrOn')]
        [string]$PostAsr,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')]
        [string]$PostAsrDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Serial', 'All')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Serial', 'All')]
        [string]$PostBootProgress,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')]
        [string]$PostDiscoveryMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delayed20Sec', 'Delayed2Sec', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Delayed20Sec', 'Delayed2Sec', 'Disabled')]
        [string]$PostF1Prompt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('QuietMode', 'VerboseMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('QuietMode', 'VerboseMode')]
        [string]$PostScreenMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DisplayAll', 'DisplayEmbeddedOnly')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DisplayAll', 'DisplayEmbeddedOnly')]
        [string]$PostVideoSupport,
        
        [bool]$PowerButton,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')]
        [string]$PowerOnDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')]
        [string]$PowerRegulator,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                        'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                        'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                        'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                        'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort2', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')]
        [string]$PreBootNetwork,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'IPv4', 'IPv6')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'IPv4', 'IPv6')]
        [string]$PrebootNetworkEnvPolicy,
        
        [string]$PrebootNetworkProxy,
        [bool]$ProcAes,
        [bool]$ProcAMDBoost,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')]
        [string]$ProcAMDBoostControl,
        
        [int]$ProcAmdFmax,
        [bool]$ProcAmdIoVt,
        [bool]$ProcHyperthreading,
        [bool]$ProcSMT,
        [bool]$ProcTurbo,
        [bool]$ProcVirtualization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Enabled', 'ForceEnabled', 'Disabled', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Enabled', 'ForceEnabled', 'Disabled', 'Auto')]
        [string]$ProcX2Apic,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Level1', 'Level2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Level1', 'Level2')]
        [string]$ProcessorConfigTDPLevel,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Auto-tuned', 'Manual-tuned')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Auto-tuned', 'Manual-tuned')]
        [string]$ProcessorJitterControl,
        
        [int]$ProcessorJitterControlFrequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')]
        [string]$ProcessorJitterControlOptimization,

        [string]$Pstate0Frequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupply,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplyGpuDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplySystemDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')]
        [string]$RemovableFlashBootSeq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CurrentRom', 'BackupRom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CurrentRom', 'BackupRom')]
        [string]$RomSelection,

        [bool]$SanitizeAllNvDimmN,
        [bool]$SataSanitize,
        [bool]$SataSecureErase,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Ghesv1Support', 'Ghesv2Support')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Ghesv1Support', 'Ghesv2Support')]
        [string]$SciRasSupport,

        [bool]$SecStartBackupImage,
        [bool]$SecureBootStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')]
        [string]$SerialConsoleBaudRate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')]
        [string]$SerialConsoleEmulation,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'Physical', 'Virtual')]
        [string]$SerialConsolePort,
        
        [string]$ServerAssetTag,
        [bool]$ServerConfigLockStatus,
        [string]$ServerOtherInfo,
        [string]$ServerPrimaryOs,
        [string]$ServiceEmail,
        [string]$ServiceName,
        [string]$ServiceOtherInfo,
        [string]$ServicePhone,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('GUI', 'Text', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('GUI', 'Text', 'Auto')]
        [string]$SetupBrowserSelection,     

        [bool]$Slot1MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot4,

        [bool]$Slot2MctpBroadcastSupport,        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot4,

        [bool]$Slot3MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot4,

        [bool]$Slot4MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot4,

        [bool]$Slot5MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot4,

        [bool]$Slot6MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot4,
 
        [bool]$Slot7MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot4,

        [bool]$Slot8MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot4,
            
        [bool]$Slot9MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot4,

        [bool]$Slot10MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]    
        [string]$Slot10NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
  
        [string]$Slot10NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]     
        [string]$Slot10NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]      
        [string]$Slot10NicBoot4,

        [bool]$Slot11MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot4,


        [bool]$Slot12MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot4,


        [bool]$Slot13MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot4,


        [bool]$Slot14MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot4,


        [bool]$Slot15MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot4,


        [bool]$Slot16MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot4,

        [bool]$Slot17MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot4,

        [bool]$Slot18MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot4,

        [bool]$Slot19MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot4,

        [bool]$Slot20MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot1StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot2StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot3StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot4StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot5StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot6StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot7StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot8StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot9StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot10StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot11StorageBoot,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot12StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot13StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot14StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot15StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot16StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot17StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot18StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot19StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot20StorageBoot,

        [bool]$SpeculativeLockScheduling,
        [bool]$Sriov,


        [bool]$StaleAtoS,
        # When enabled, Sub-NUMA Clustering divides the processor's cores, cache, and memory into multiple NUMA domains. Enabling this feature can increase performance for workloads that are NUMA aware and optimized. Note: When this option is enabled, up to 1GB of system memory may become unavailable.
        
        [bool]$SubNumaClustering,

        [bool]$TPM2EndorsementDisable,
        [bool]$TPM2StorageDisable,

        # Use this option to select the fan cooling solution for the system. Optimal Cooling provides the most efficient solution by configuring fan speeds to the minimum required speed to provide adequate cooling. Increased Cooling runs fans at higher speeds to provide additional cooling. Select Increased Cooling when third-party storage controllers are cabled to the embedded hard drive cage, or if the system is experiencing thermal issues that cannot be resolved. Maximum cooling provides the maximum cooling available on this platform. Enhanced CPU Cooling runs the fans at a higher speed to provide additional cooling to the processors. Selecting Enhanced CPU Cooling may improve system performance with certain processor intensive workloads.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')]
        [string]$ThermalConfig,

        [bool]$ThermalShutdown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Utc', 'Local')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Utc', 'Local')]
        [string]$TimeFormat,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')]
        [string]$TimeZone,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceStatus,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Clear')]
        [string]$Tpm2Operation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')]
        [string]$TpmActivePcrs,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')]
        [string]$TpmChipId,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'NonFipsMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'NonFipsMode', 'FipsMode')]
        [string]$TpmFips,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'RegularMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'RegularMode', 'FipsMode')]
        [string]$TpmFipsModeSwitch,
                        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Tpm12', 'Tpm20')]
        [string]$TpmModeSwitchOperation,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Enable', 'Disable', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Enable', 'Disable', 'Clear')]
        [string]$TpmOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotPresent', 'PresentDisabled', 'PresentEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotPresent', 'PresentDisabled', 'PresentEnabled')]
        [string]$TpmState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoTpm', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoTpm', 'Tpm12', 'Tpm20')]
        [string]$TpmType,
        
        [bool]$TpmUefiOpromMeasuring,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Hidden', 'Visible')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Hidden', 'Visible')]
        [string]$TpmVisibility,

        [bool]$TransparentSecureMemoryEncryption,
        [bool]$UefiOptimizedBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')]
        [string]$UefiSerialDebugLevel,

        [bool]$UefiShellBootOrder,
        [bool]$UefiShellPhysicalPresenceKeystroke,
        [bool]$UefiShellScriptVerification,
        [bool]$UefiShellStartup,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$UefiShellStartupLocation,
        
        [string]$UefiShellStartupUrl,
        [bool]$UefiShellStartupUrlFromDhcp,
        [bool]$UefiVariableAccessFwControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Maximum', 'Minimum')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Maximum', 'Minimum')]
        [string]$UncoreFreqScaling,

        [bool]$UpiPrefetcher,
        [string]$UrlBootFile,
        [string]$UrlBootFile2,
        [bool]$UsbBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')]
        [string]$UsbControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('English', 'Japanese', 'Chinese')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('English', 'Japanese', 'Chinese')]
        [string]$UtilityLang,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptionalVideoOnly', 'BothVideoEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptionalVideoOnly', 'BothVideoEnabled')]
        [string]$VideoOptions,

        [bool]$VirtualInstallDisk,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$VirtualSerialPort,
        
        
        [bool]$VlanControl,
        [int]$VlanId,
        [int]$VlanPriority,
        [bool]$WakeOnLan,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Enabled', 'Disabled')]
        [string]$XptPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIForceLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIMaxLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('SoftwareInitiator', 'AdapterInitiator')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('SoftwareInitiator', 'AdapterInitiator')]
        [string]$iSCSIPolicy,

        [bool]$iSCSISoftwareInitiator,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewBiosSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Bios

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {

            "[{0}] Setting '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Setting '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Setting already exists in the region! No action needed."
            }

        }
        else {

            # Build payload
    
            
            if ($WorkloadProfileName) {
    
                if ($WorkloadProfileName -eq "Virtual Radio Access Network (vRAN)") {
                    $WorkloadProfileName = "vRAN"
                }
                
            }
            
            $Attributes = @{ 
    
                WorkloadProfile = $WorkloadProfileName
                
            }
    
    
    
            #Region Booleaan parameters   
    
            $boolParametersList = @(
                'AccessControlService',
                'AcpiHpet',
                'AcpiRootBridgePxm',
                'AcpiSlit',
                'AdjSecPrefetch',
                'AdvCrashDumpMode',
                'AllowLoginWithIlo',
                'Amd5LevelPage',
                'AmdCdma',
                'AmdDmaRemapping',
                'AmdL1Prefetcher',
                'AmdL2Prefetcher',
                'AmdMemoryBurstRefresh',
                'AmdPeriodicDirectoryRinse',
                'AmdSecureMemoryEncryption',
                'AmdSecureNestedPaging',
                'AmdVirtualDrtmDevice',
                'ApplicationPowerBoost',
                'AsrStatus',
                'ChannelInterleaving',
                'CollabPowerControl',
                'CoreBoosting',
                'DcuIpPrefetcher',
                'DcuStreamPrefetcher',
                'Dhcpv4',
                'DramControllerPowerDown',
                'EmbNicPCIeOptionROM',
                'EmbSas1PcieOptionROM',
                'EmbSata1Aspm',
                'EmbSata1PCIeOptionROM',
                'EmbSata2Aspm',
                'EmbSata2PCIeOptionROM',
                'EmbSata3Aspm',
                'EmbSata3PCIeOptionROM',
                'EmbSata4Aspm',
                'EmbSata4PCIeOptionROM',
                'EmbeddedDiagnostics',
                'EmbeddedIpxe',
                'EmbeddedUefiShell',
                'EnergyEfficientTurbo',
                'EnhancedProcPerf',
                'ExtendedMemTest',
                'F11BootMenu',
                'FlexLom1PCIeOptionROM',
                'HwPrefetcher',
                'IntelNicDmaChannels',
                'IntelPerfMonitoring',
                'IntelProcVtd',
                'IntelTxt',
                'IntelUpiPowerManagement',
                'IntelligentProvisioning',
                'InternalSDCardSlot',
                'IpxeBootOrder',
                'IpxeScriptAutoStart',
                'IpxeScriptVerification',
                'LastLevelCacheAsNUMANode',
                'LLCDeadLineAllocation',
                'LlcPrefetch',
                'MemClearWarmReset',
                'MemFastTraining',
                'MemPatrolScrubbing',
                'MicrosoftSecuredCoreSupport',
                'MixedPowerSupplyReporting',
                'NetworkBootRetry',
                'NodeInterleaving',
                'NvDimmNMemFunctionality',
                'NvDimmNMemInterleaving',
                'NvdimmLabelSupport',
                'NvmeOptionRom',
                'Ocp1AuxiliaryPower',
                'Ocp2AuxiliaryPower',
                'OmitBootDeviceEvent',
                'OpportunisticSelfRefresh',
                'PciPeerToPeerSerialization',
                'PciSlot20OptionROM',
                'PciSlot19OptionROM',
                'PciSlot18OptionROM',
                'PciSlot17OptionROM',
                'PciSlot16OptionROM',
                'PciSlot15OptionROM',
                'PciSlot14OptionROM',
                'PciSlot13OptionROM',
                'PciSlot12OptionROM',
                'PciSlot11OptionROM',
                'PciSlot10OptionROM',
                'PciSlot9OptionROM',
                'PciSlot8OptionROM',
                'PciSlot7OptionROM',
                'PciSlot6OptionROM',
                'PciSlot5OptionROM',
                'PciSlot4OptionROM',
                'PciSlot3OptionROM',
                'PciSlot2OptionROM',
                'PciSlot1OptionROM',
                'PersistentMemAddressRangeScrub',
                'PersistentMemScanMem',
                'PlatformCertificate',
                'PowerButton',
                'ProcAes',
                'ProcAMDBoost',
                'ProcAmdIoVt',
                'ProcHyperthreading',
                'ProcSMT',
                'ProcTurbo',
                'ProcVirtualization',
                'SanitizeAllNvDimmN',
                'SataSanitize',
                'SataSecureErase',
                'SecStartBackupImage',
                'SecureBootStatus',
                'ServerConfigLockStatus',
                'Slot1MctpBroadcastSupport',
                'Slot2MctpBroadcastSupport',
                'Slot3MctpBroadcastSupport',
                'Slot4MctpBroadcastSupport',
                'Slot5MctpBroadcastSupport',
                'Slot6MctpBroadcastSupport',
                'Slot7MctpBroadcastSupport',
                'Slot8MctpBroadcastSupport',
                'Slot9MctpBroadcastSupport',
                'Slot10MctpBroadcastSupport',
                'Slot11MctpBroadcastSupport',
                'Slot12MctpBroadcastSupport',
                'Slot13MctpBroadcastSupport',
                'Slot14MctpBroadcastSupport',
                'Slot15MctpBroadcastSupport',
                'Slot16MctpBroadcastSupport',
                'Slot17MctpBroadcastSupport',
                'Slot18MctpBroadcastSupport',
                'Slot19MctpBroadcastSupport',
                'Slot20MctpBroadcastSupport',
                'SpeculativeLockScheduling',
                'Sriov',
                'StaleAtoS',
                'SubNumaClustering',
                'TPM2EndorsementDisable',
                'TPM2StorageDisable',
                'ThermalShutdown',
                'TpmUefiOpromMeasuring',
                'TransparentSecureMemoryEncryption',
                'UefiOptimizedBoot',
                'UefiShellBootOrder',
                'UefiShellPhysicalPresenceKeystroke',
                'UefiShellScriptVerification',
                'UefiShellStartup',
                'UefiShellStartupUrlFromDhcp',
                'UefiVariableAccessFwControl',
                'UpiPrefetcher',
                'UsbBoot',
                'VirtualInstallDisk',
                'VlanControl',
                'WakeOnLan',
                'iSCSISoftwareInitiator'
    
            )
           
            $RequireCustomProfile = $False
    
            foreach ($boolparameter in $boolParametersList) {
            
                if ($PSBoundParameters.ContainsKey($boolparameter)) {
        
                    $RequireCustomProfile = $True
        
                    if ($PSBoundParameters[$boolparameter] -eq $True) {
            
                        $Attributes."$boolparameter" = "Enabled"
            
                    }
                    else {
                        $Attributes."$boolparameter" = "Disabled"
            
                    }
                }        
            }
    
            #EndRegion
    
    
            #Region String + Integer parameters
    
            $stringparametersList = @(
                'AdminEmail',
                'AdminName',
                'AdminOtherInfo',
                'AdminPhone',
                'AdvancedMemProtection',
                'AmdCstC2Latency',
                'AmdMemPStates',
                'AmdXGMILinkSpeed',
                'AsrTimeoutMinutes',
                'AssetTagProtection',
                'AutoPowerOn',
                'BootOrderPolicy',
                'ConsistentDevNaming',
                'CustomPostMessage',
                'CustomPstate0',
                'DataFabricCStateEnable',
                'DaylightSavingsTime',
                'DeterminismControl',
                'DirectToUpi',
                'DynamicPowerCapping',
                'EmbNicAspm',
                'EmbNicEnable',
                'EmbNicLinkSpeed',
                'EmbSas1Aspm',
                'EmbSas1Boot',
                'EmbSas1Enable',
                'EmbSas1LinkSpeed',
                'EmbSata1Enable',
                'EmbSata2Enable',
                'EmbSata3Enable',
                'EmbSata4Enable',
                'EmbVideoConnection',
                'EmbeddedSata',
                'EmbeddedSerialPort',
                'EmsConsole',
                # 'EnabledCoresPerProcIlo6', # Removed as iLO5 and 6 do not use the same value types
                # 'EnabledCoresPerProcIlo5',
                'EnergyPerfBias',
                'ExtendedAmbientTemp',
                'FCScanPolicy',
                'FanFailPolicy',
                'FanInstallReq',
                'FlexLom1Aspm',
                'FlexLom1Enable',
                'FlexLom1LinkSpeed',
                'HourFormat',
                'HttpSupport',
                'InfinityFabricPstate',
                'IntelDmiLinkFreq',
                'IntelSpeedSelect',
                'IntelUpiFreq',
                'IntelUpiLinkEn',
                'IntelVmdDirectAssign',
                'IntelVmdSupport',
                'IntelVrocSupport',
                'IpmiWatchdogTimerAction',
                'IpmiWatchdogTimerStatus',
                'IpmiWatchdogTimerTimeout',
                'Ipv4Address',
                'Ipv4Gateway',
                'Ipv4PrimaryDNS',
                'Ipv4SubnetMask',
                'Ipv6Address',
                'Ipv6ConfigPolicy',
                'Ipv6Duid',
                'Ipv6Gateway',
                'Ipv6PrimaryDNS',
                'Ipv6SecondaryDNS',
                'IpxeAutoStartScriptLocation',
                'IpxeStartupUrl',
                'LocalRemoteThreshold',
                'MaxMemBusFreqMHz',
                'MaxPcieSpeed',
                'MemMirrorMode',
                'MemRefreshRate',
                'MemoryControllerInterleaving',
                'MemoryRemap',
                'MinProcIdlePkgState',
                'MinProcIdlePower',
                'MinimumSevAsid',
                'NetworkBootRetryCount',
                'NicBoot1',
                'NicBoot2',
                'NicBoot3',
                'NicBoot4',
                'NicBoot5',
                'NicBoot6',
                'NicBoot7',
                'NicBoot8',
                'NicBoot9',
                'NicBoot10',
                'NicBoot11',
                'NicBoot12',
                'NumaGroupSizeOpt',
                'NumaMemoryDomainsPerSocket',
                'NvDimmNSanitizePolicy',
                'PackagePowerLimitControlMode',
                'PackagePowerLimitValue',
                'PatrolScrubDuration',
                'PciResourcePadding',
                'PciSlot20Aspm',
                'PciSlot20Bifurcation',
                'PciSlot20Enable',
                'PciSlot20LinkSpeed',
                'PciSlot19Aspm',
                'PciSlot19Bifurcation',
                'PciSlot19Enable',
                'PciSlot19LinkSpeed',
                'PciSlot18Aspm',
                'PciSlot18Bifurcation',
                'PciSlot18Enable',
                'PciSlot18LinkSpeed',
                'PciSlot17Aspm',
                'PciSlot17Bifurcation',
                'PciSlot17Enable',
                'PciSlot17LinkSpeed',
                'PciSlot16Aspm',
                'PciSlot16Bifurcation',
                'PciSlot16Enable',
                'PciSlot16LinkSpeed',
                'PciSlot15Aspm',
                'PciSlot15Bifurcation',
                'PciSlot15Enable',
                'PciSlot15LinkSpeed',
                'PciSlot14Aspm',
                'PciSlot14Bifurcation',
                'PciSlot14Enable',
                'PciSlot14LinkSpeed',
                'PciSlot13Aspm',
                'PciSlot13Bifurcation',
                'PciSlot13Enable',
                'PciSlot13LinkSpeed',
                'PciSlot12Aspm',
                'PciSlot12Bifurcation',
                'PciSlot12Enable',
                'PciSlot12LinkSpeed',
                'PciSlot11Aspm',
                'PciSlot11Bifurcation',
                'PciSlot11Enable',
                'PciSlot11LinkSpeed',
                'PciSlot10Aspm',
                'PciSlot10Bifurcation',
                'PciSlot10Enable',
                'PciSlot10LinkSpeed',
                'PciSlot9Aspm',
                'PciSlot9Bifurcation',
                'PciSlot9Enable',
                'PciSlot9LinkSpeed',
                'PciSlot8Aspm',
                'PciSlot8Bifurcation',
                'PciSlot8Enable',
                'PciSlot8LinkSpeed',
                'PciSlot7Aspm',
                'PciSlot7Bifurcation',
                'PciSlot7Enable',
                'PciSlot7LinkSpeed',
                'PciSlot6Aspm',
                'PciSlot6Bifurcation',
                'PciSlot6Enable',
                'PciSlot6LinkSpeed',
                'PciSlot5Aspm',
                'PciSlot5Bifurcation',
                'PciSlot5Enable',
                'PciSlot5LinkSpeed',
                'PciSlot4Aspm',
                'PciSlot4Bifurcation',
                'PciSlot4Enable',
                'PciSlot4LinkSpeed',
                'PciSlot3Aspm',
                'PciSlot3Bifurcation',
                'PciSlot3Enable',
                'PciSlot3LinkSpeed',
                'PciSlot2Aspm',
                'PciSlot2Bifurcation',
                'PciSlot2Enable',
                'PciSlot2LinkSpeed',
                'PciSlot1Aspm',
                'PciSlot1Bifurcation',
                'PciSlot1Enable',
                'PciSlot1LinkSpeed',
                'PerformanceDeterminism',
                'PersistentMemBackupPowerPolicy',
                'PlatformRASPolicy',
                'PostAsr',
                'PostAsrDelay',
                'PostBootProgress',
                'PostDiscoveryMode',
                'PostF1Prompt',
                'PostScreenMode',
                'PostVideoSupport',
                'PowerOnDelay',
                'PowerRegulator',
                'PreBootNetwork',
                'PrebootNetworkEnvPolicy',
                'PrebootNetworkProxy',
                'ProcAMDBoostControl',
                'ProcAmdFmax',
                'ProcX2Apic',
                'ProcessorConfigTDPLevel',
                'ProcessorJitterControl',
                'ProcessorJitterControlFrequency',
                'ProcessorJitterControlOptimization',
                'Pstate0Frequency',
                'RedundantPowerSupply',
                'RedundantPowerSupplyGpuDomain',
                'RedundantPowerSupplySystemDomain',
                'RemovableFlashBootSeq',
                'RomSelection',
                'SciRasSupport',
                'SerialConsoleBaudRate',
                'SerialConsoleEmulation',
                'SerialConsolePort',
                'ServerAssetTag',
                'ServerOtherInfo',
                'ServerPrimaryOs',
                'ServiceEmail',
                'ServiceName',
                'ServiceOtherInfo',
                'ServicePhone',
                'SetupBrowserSelection',
                'Slot1NicBoot1',
                'Slot1NicBoot2',
                'Slot1NicBoot3',
                'Slot1NicBoot4',
                'Slot2NicBoot1',
                'Slot2NicBoot2',
                'Slot2NicBoot3',
                'Slot2NicBoot4',
                'Slot3NicBoot1',
                'Slot3NicBoot2',
                'Slot3NicBoot3',
                'Slot3NicBoot4',
                'Slot4NicBoot1',
                'Slot4NicBoot2',
                'Slot4NicBoot3',
                'Slot4NicBoot4',
                'Slot5NicBoot1',
                'Slot5NicBoot2',
                'Slot5NicBoot3',
                'Slot5NicBoot4',
                'Slot6NicBoot1',
                'Slot6NicBoot2',
                'Slot6NicBoot3',
                'Slot6NicBoot4',
                'Slot7NicBoot1',
                'Slot7NicBoot2',
                'Slot7NicBoot3',
                'Slot7NicBoot4',
                'Slot8NicBoot1',
                'Slot8NicBoot2',
                'Slot8NicBoot3',
                'Slot8NicBoot4',
                'Slot9NicBoot1',
                'Slot9NicBoot2',
                'Slot9NicBoot3',
                'Slot9NicBoot4',
                'Slot10NicBoot1',
                'Slot10NicBoot2',
                'Slot10NicBoot3',
                'Slot10NicBoot4',
                'Slot11NicBoot1',
                'Slot11NicBoot2',
                'Slot11NicBoot3',
                'Slot11NicBoot4',
                'Slot12NicBoot1',
                'Slot12NicBoot2',
                'Slot12NicBoot3',
                'Slot12NicBoot4',
                'Slot13NicBoot1',
                'Slot13NicBoot2',
                'Slot13NicBoot3',
                'Slot13NicBoot4',
                'Slot14NicBoot1',
                'Slot14NicBoot2',
                'Slot14NicBoot3',
                'Slot14NicBoot4',
                'Slot15NicBoot1',
                'Slot15NicBoot2',
                'Slot15NicBoot3',
                'Slot15NicBoot4',
                'Slot16NicBoot1',
                'Slot16NicBoot2',
                'Slot16NicBoot3',
                'Slot16NicBoot4',
                'Slot17NicBoot1',
                'Slot17NicBoot2',
                'Slot17NicBoot3',
                'Slot17NicBoot4',
                'Slot18NicBoot1',
                'Slot18NicBoot2',
                'Slot18NicBoot3',
                'Slot18NicBoot4',
                'Slot19NicBoot1',
                'Slot19NicBoot2',
                'Slot19NicBoot3',
                'Slot19NicBoot4',
                'Slot20NicBoot1',
                'Slot20NicBoot2',
                'Slot20NicBoot3',
                'Slot20NicBoot4',
                'Slot1StorageBoot',
                'Slot2StorageBoot',
                'Slot3StorageBoot',
                'Slot4StorageBoot',
                'Slot5StorageBoot',
                'Slot6StorageBoot',
                'Slot7StorageBoot',
                'Slot8StorageBoot',
                'Slot9StorageBoot',
                'Slot10StorageBoot',
                'Slot11StorageBoot',
                'Slot12StorageBoot',
                'Slot13StorageBoot',
                'Slot14StorageBoot',
                'Slot15StorageBoot',
                'Slot16StorageBoot',
                'Slot17StorageBoot',
                'Slot18StorageBoot',
                'Slot19StorageBoot',
                'Slot20StorageBoot',
                'ThermalConfig',
                'TimeFormat',
                'TimeZone',
                'Tpm20SoftwareInterfaceOperation',
                'Tpm20SoftwareInterfaceStatus',
                'Tpm2Operation',
                'TpmActivePcrs',
                'TpmChipId',
                'TpmFips',
                'TpmFipsModeSwitch',
                'TpmModeSwitchOperation',
                'TpmOperation',
                'TpmState',
                'TpmType',
                'TpmVisibility',
                'UefiSerialDebugLevel',
                'UefiShellStartupLocation',
                'UefiShellStartupUrl',
                'UncoreFreqScaling',
                'UrlBootFile',
                'UrlBootFile2',
                'UsbControl',
                'UtilityLang',
                'VideoOptions',
                'VirtualSerialPort',
                'VlanId',
                'VlanPriority',
                'XptPrefetcher',
                'XGMIForceLinkWidth',
                'XGMIMaxLinkWidth',
                'iSCSIPolicy'
            )
    
            foreach ($stringparameter in $stringparametersList) {
                
                if ($PSBoundParameters.ContainsKey($stringparameter)) {
                    
                    $RequireCustomProfile = $True
    
                    $param1Value = $PSBoundParameters[$stringparameter]
    
                    $Attributes."$stringparameter" = $param1Value
                }
            }
    
    
            if ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo6')) {
    
                $RequireCustomProfile = $True
    
                $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo6
            } 
            elseif ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo5')) {
    
                $RequireCustomProfile = $True
    
                $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo5
                
            }
    
    
    
            if ($AsrTimeoutMinutes) {
                $Attributes.AsrStatus = "Enabled"
    
            }
    
    
            if ($SubNumaClustering) {
                # Options that must be enabled when Sub-Numa Clustering (SNC) is enabled:
                $Attributes.XptPrefetcher = "Enabled"
                $Attributes.UpiPrefetcher = "Enabled"
            }
    
            #EndRegion
    
               
    
            # Build paylaod
    
            if ($RequireCustomProfile) {
                
                $Default = @{ 
                    redfishData                 = @{
                        Attributes = $Attributes
                    }
                    enableCustomWorkloadProfile = $True
                }
            }
            else {
                
                $Default = @{ 
                    redfishData = @{
                        Attributes = $Attributes
                    }
                }
    
            }
    
            $Settings = @{ 
                DEFAULT = $Default
            }
    
            $payload = @{ 
                name           = $Name
                category       = "BIOS"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }
    
            $payload = ConvertTo-Json $payload -Depth 10 
    
            try {
    
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
    
                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    "[{0}] Bios server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Bios server setting successfully created in $Region region"
    
    
                }
            }
            catch {
    
                if (-not $WhatIf) {
    
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Bios server setting cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
    
                }
            } 
        }

        [void] $NewBiosSettingStatus.add($objStatus)

    
    }
    
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewBiosSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more bios server settings failed the creation attempt!"
          
            }
            
            $NewBiosSettingStatus = Invoke-RepackageObjectWithType -RawObject $NewBiosSettingStatus -ObjectName "COM.objStatus.NSDE"    
            Return $NewBiosSettingStatus
        
        }

    }
}


Function Set-HPECOMSettingServerBios {
    <#
    .SYNOPSIS
    Update a bios server setting resource in a specified region.
    
    .DESCRIPTION
    This Cmdlet modifies a bios server setting resource in a given region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.
    
    For a detailed description of all iLO BIOS attributes parameters:
    - For iLO6, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo6/ilo6_159/ilo6_bios_resourcedefns159/
    - For iLO5, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo5/ilo5_304/ilo5_bios_resourcedefns304/

    Note: If a parameter is incompatible with your iLO generation or server platform, 'Invoke-HPECOMGroupBiosConfiguration' will return an error message stating "Apply BIOS settings failed".
          To get more detailed information about the parameters that caused these errors, access the iLO Redfish API using a GET request to /redfish/v1/Systems/1/Bios/ and inspect the @Redfish.Settings.Messages property.

    Note: If one or several unsupported parameters are selected, the other BIOS settings will still be applied successfully. Unsupported parameters will be ignored without affecting the application of the other settings.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the bios server setting to set.

    .PARAMETER Description
    Specifies a description of the bios server setting.

    .PARAMETER WorkloadProfileName
    Name of a pre-defined workload profile:
        - Decision Support
        - General Peak Frequency Compute
        - General Power Efficient Compute
        - General Throughput Compute
        - Graphic Processing
        - High Performance Compute (HPC)
        - I/O Throughput
        - Low Latency
        - Mission Critical
        - My-Bios-For-AI
        - Transactional Application Processing
        - Virtual Radio Access Network (vRAN)
        - Virtualization - Max Performance
        - Virtualization - Power Efficient

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance"

    This example shows how to modify a BIOS setting named "Custom-Bios-For-ESX" in the eu-central region. The command updates the description and sets the workload profile to "Virtualization - Max Performance" while preserving all other existing settings.

    .EXAMPLE
    Set-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance" `
      -AdminName Albert -AdminEmail "alb@domain.com" -AsrTimeoutMinutes Timeout10 -AutoPowerOn AlwaysPowerOn -CoreBoosting:$true -F11BootMenu:$False -ThermalConfig OptimalCooling 

    This example modifies a customized BIOS configuration for "Custom-Bios-For-ESX" in the eu-central region. it sets new admin details (AdminName and AdminEmail), various new BIOS feature configurations such as ASR timeout, auto power on, core boosting, F11 boot menu, and thermal configuration for optimal cooling.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name Custom-Bios-For-ESX | Set-HPECOMSettingServerBios -NewName "Custom-Bios-For-ESX8" -FanFailPolicy Shutdown -PowerRegulator DynamicPowerSavings

    This example retrieves an existing BIOS setting named 'Custom-Bios-For-ESX' in the eu-central region and updates it. The command renames it to 'Custom-Bios-For-ESX8', sets the fan fail policy to Shutdown, and adjusts the power regulator to DynamicPowerSavings while preserving all other existing settings.
    
    .INPUTS
    System.Collections.ArrayList
        List of bios server settings from 'Get-HPECOMSetting -Category Bios'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the bios server setting attempted to be updated
        * Region - The name of the region
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ilo6')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Decision Support', 'General Peak Frequency Compute', 'General Power Efficient Compute', 'General Throughput Compute', 'Graphic Processing', 'High Performance Compute (HPC)', 'I/O Throughput', 'Low Latency', 'Mission Critical', 'Transactional Application Processing', 'Virtual Radio Access Network (vRAN)', 'Virtualization - Max Performance', 'Virtualization - Power Efficient')
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$WorkloadProfileName,
        
        [bool]$AccessControlService,
        [bool]$AcpiHpet,
        [bool]$AcpiRootBridgePxm,
        [bool]$AcpiSlit,
        [bool]$AdjSecPrefetch,
        [string]$AdminEmail,
        [String]$AdminName,
        [string]$AdminOtherInfo,
        # Name of the server administrator
        [string]$AdminPhone,

        [bool]$AdvCrashDumpMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')]
        [String]$AdvancedMemProtection,

        [bool]$AllowLoginWithIlo,
        [bool]$Amd5LevelPage,
        [bool]$AmdCdma,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('800us', '18us')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('800us', '18us')]
        [String]$AmdCstC2Latency,

        [bool]$AmdDmaRemapping,
        [bool]$AmdL1Prefetcher,
        [bool]$AmdL2Prefetcher,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [String]$AmdMemPStates,
        
        [bool]$AmdMemoryBurstRefresh,
        [bool]$AmdPeriodicDirectoryRinse,
        [bool]$AmdSecureMemoryEncryption,
        [bool]$AmdSecureNestedPaging,
        [bool]$AmdVirtualDrtmDevice,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32' )
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32')]
        [String]$AmdXGMILinkSpeed,

        [bool]$ApplicationPowerBoost,

        # Use this option to configure the Automatic Server Recovery option, which enables the system to automatically reboot if the server locks up.
        [bool]$AsrStatus,

        # When Automatic Server Recovery is enabled, you can use this option to set the time to wait before rebooting the server in the event of an operating system crash or server lockup.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')]
        [string]$AsrTimeoutMinutes,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Locked', 'Unlocked')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Locked', 'Unlocked')]
        [String]$AssetTagProtection,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')]
        [String]$AutoPowerOn,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')]
        [string]$BootOrderPolicy,

        [bool]$ChannelInterleaving,
        [bool]$CollabPowerControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('LomsAndSlots', 'LomsOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('LomsAndSlots', 'LomsOnly', 'Disabled')]
        [string]$ConsistentDevNaming,

        [bool]$CoreBoosting,

        # Enter a message to be displayed on POST screen during system startup. This feature limits POST screen messaging to 62 characters, special characters are also accepted.
        [ValidateScript({
                if ($_.Length -le 62) {
                    $True
                }
                if ($_ -match '^[a-zA-Z0-9]+$') {
                    $true
                } 
                elseif ($_.Length -gt 62) {
                    throw "The POST screen message cannot have more than 62 characters!"

                }
                elseif ($_ -notmatch '^[a-zA-Z0-9]+$') {
                    throw "The POST screen message cannot contain special characters!"
                }
            })]
        [string]$CustomPostMessage,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Manual')]
        [string]$CustomPstate0,
            
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceEnabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'ForceEnabled', 'Disabled')]
        [string]$DataFabricCStateEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')]
        [string]$DaylightSavingsTime,
         
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DeterminismCtrlAuto', 'DeterminismCtrlManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DeterminismCtrlAuto', 'DeterminismCtrlManual')]            
        [string]$DeterminismControl,        

        [bool]$DcuIpPrefetcher,
        [bool]$DcuStreamPrefetcher,
        [bool]$Dhcpv4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]
        [string]$DirectToUpi,

        [bool]$DramControllerPowerDown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]            
        [string]$DynamicPowerCapping,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AspmL1Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AspmL1Enabled', 'Disabled')]            
        [string]$EmbNicAspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]            
        [string]$EmbNicEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1')]
        [string]$EmbNicLinkSpeed,
        
        [bool]$EmbNicPCIeOptionROM,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$EmbSas1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AllTargets', 'TwentyFourTargets', 'NoTargets')]
        [string]$EmbSas1Boot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSas1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$EmbSas1LinkSpeed,
        
        [bool]$EmbSas1PcieOptionROM,
        [bool]$EmbSata1Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata1Enable,
        
        [bool]$EmbSata1PCIeOptionROM,
        [bool]$EmbSata2Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata2Enable,
        
        [bool]$EmbSata2PCIeOptionROM,

        [bool]$EmbSata3Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata3Enable,
        
        [bool]$EmbSata3PCIeOptionROM,
        [bool]$EmbSata4Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata4Enable,
        
        [bool]$EmbSata4PCIeOptionROM,
               
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AlwaysDisabled', 'AlwaysEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AlwaysDisabled', 'AlwaysEnabled')]
        [string]$EmbVideoConnection,
        
        [bool]$EmbeddedDiagnostics,
        [bool]$EmbeddedIpxe,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')]
        [string]$EmbeddedSata,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$EmbeddedSerialPort,
        
        [bool]$EmbeddedUefiShell,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Physical', 'Virtual')]
        [string]$EmsConsole,
        
        # This attribute is a problem because in iLO5, value is an integer
        [Parameter (ParameterSetName = 'ilo6')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')]
        [string]$EnabledCoresPerProcIlo6,

        [Parameter (ParameterSetName = 'ilo5')]
        [int]$EnabledCoresPerProcIlo5,

        [bool]$EnergyEfficientTurbo,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')]
        [string]$EnergyPerfBias,

        [bool]$EnhancedProcPerf,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ASHRAE3', 'ASHRAE4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ASHRAE3', 'ASHRAE4')]
        [string]$ExtendedAmbientTemp,

        [bool]$ExtendedMemTest,
        [bool]$F11BootMenu,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'CardConfig')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'CardConfig')]
        [string]$FCScanPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Shutdown', 'Allow')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Shutdown', 'Allow')]
        [string]$FanFailPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EnableMessaging', 'DisableMessaging')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EnableMessaging', 'DisableMessaging')]
        [string]$FanInstallReq,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$FlexLom1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$FlexLom1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$FlexLom1LinkSpeed,

        [bool]$FlexLom1PCIeOptionROM,
         

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('12Hours', '24Hours')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('12Hours', '24Hours')]
        [string]$HourFormat,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')]
        [string]$HttpSupport,

        [bool]$HwPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('P0', 'P1', 'P2', 'P3', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('P0', 'P1', 'P2', 'P3', 'Auto')]
        [string]$InfinityFabricPstate,
        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DmiGen1', 'DmiGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DmiGen1', 'DmiGen2')]            
        [string]$IntelDmiLinkFreq,
        
        [bool]$IntelNicDmaChannels,
        [bool]$IntelPerfMonitoring,
        [bool]$IntelProcVtd,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Base', 'Config1', 'Config2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Base', 'Config1', 'Config2')]
        [string]$IntelSpeedSelect,

        [bool]$IntelTxt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MinUpiSpeed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MinUpiSpeed')]
        [string]$IntelUpiFreq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'SingleLink')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'SingleLink')]
        [string]$IntelUpiLinkEn,

        [bool]$IntelUpiPowerManagement,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('VmdDirectAssignEnabledAll', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('VmdDirectAssignEnabledAll', 'Disabled')]
        [string]$IntelVmdDirectAssign,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')]
        [string]$IntelVmdSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'Standard', 'Premium')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'Standard', 'Premium')]
        [string]$IntelVrocSupport,
                
        [bool]$IntelligentProvisioning,
        [bool]$InternalSDCardSlot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PowerCycle', 'PowerDown', 'WarmBoot')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PowerCycle', 'PowerDown', 'WarmBoot')]
        [string]$IpmiWatchdogTimerAction,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')]
        [string]$IpmiWatchdogTimerStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')]
        [string]$IpmiWatchdogTimerTimeout,
        
        [string]$Ipv4Address,
        [string]$Ipv4Gateway,
        [string]$Ipv4PrimaryDNS,
        [string]$Ipv4SubnetMask,
        [string]$Ipv6Address,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Automatic', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Automatic', 'Manual')]
        [string]$Ipv6ConfigPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DuidLlt', 'DUID-LLT')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DuidLlt', 'DUID-LLT')]
        [string]$Ipv6Duid,

        [string]$Ipv6Gateway,
        [string]$Ipv6PrimaryDNS,
        [string]$Ipv6SecondaryDNS,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$IpxeAutoStartScriptLocation,
        
        
        [bool]$IpxeBootOrder,
        [bool]$IpxeScriptAutoStart,
        [bool]$IpxeScriptVerification,
        [string]$IpxeStartupUrl,
        [bool]$LastLevelCacheAsNUMANode,
        

        [bool]$LLCDeadLineAllocation,
        [bool]$LlcPrefetch,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Low', 'Medium', 'High', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Low', 'Medium', 'High', 'Disabled')]
        [string]$LocalRemoteThreshold,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')]
        [string]$MaxMemBusFreqMHz,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')]
        [string]$MaxPcieSpeed,

        [bool]$MemClearWarmReset,
        [bool]$MemFastTraining,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')]
        [string]$MemMirrorMode,
        
        [bool]$MemPatrolScrubbing,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Refreshx1', 'Refreshx2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Refreshx1', 'Refreshx2')]
        [string]$MemRefreshRate,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$MemoryControllerInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'AllMemory')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'AllMemory')]
        [string]$MemoryRemap,

        [bool]$MicrosoftSecuredCoreSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6Retention', 'C6NonRetention', 'NoState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6Retention', 'C6NonRetention', 'NoState')]
        [string]$MinProcIdlePkgState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6', 'C1E', 'NoCStates')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6', 'C1E', 'NoCStates')]
        [string]$MinProcIdlePower,

        [int]$MinimumSevAsid,

        [bool]$MixedPowerSupplyReporting,
        [bool]$NetworkBootRetry,
        [int]$NetworkBootRetryCount,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot5,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot6,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot7,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot8,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot9,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot10,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot11,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot12,

        [bool]$NodeInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Flat', 'Clustered')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Flat', 'Clustered')]
        [string]$NumaGroupSizeOpt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')]
        [string]$NumaMemoryDomainsPerSocket,
        
        [bool]$NvDimmNMemFunctionality,
        [bool]$NvDimmNMemInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')]
        [string]$NvDimmNSanitizePolicy,

        [bool]$NvdimmLabelSupport,
        [bool]$NvmeOptionRom,
        [bool]$Ocp1AuxiliaryPower,
        [bool]$Ocp2AuxiliaryPower,
        [bool]$OmitBootDeviceEvent,
        [bool]$OpportunisticSelfRefresh,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Manual')]
        [string]$PackagePowerLimitControlMode,

        [int]$PackagePowerLimitValue,
        [int]$PatrolScrubDuration,

        [bool]$PciPeerToPeerSerialization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Medium', 'High')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Medium', 'High')]
        [string]$PciResourcePadding,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot20Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot20Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot20Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot20LinkSpeed,

        [bool]$PciSlot20OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot19Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot19Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot19Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot19LinkSpeed,

        [bool]$PciSlot19OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot18Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot18Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot18Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot18LinkSpeed,

        [bool]$PciSlot18OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot17Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot17Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot17Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot17LinkSpeed,

        [bool]$PciSlot17OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot16Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot16Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot16Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot16LinkSpeed,

        [bool]$PciSlot16OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot15Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot15Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot15Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot15LinkSpeed,

        [bool]$PciSlot15OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot14Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot14Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot14Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot14LinkSpeed,

        [bool]$PciSlot14OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot13Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot13Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot13Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot13LinkSpeed,

        [bool]$PciSlot13OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot12Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot12Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot12Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot12LinkSpeed,

        [bool]$PciSlot12OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot11Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot11Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot11Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot11LinkSpeed,

        [bool]$PciSlot11OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot10Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot10Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot10Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot10LinkSpeed,

        [bool]$PciSlot10OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot9Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot9Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot9Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot9LinkSpeed,

        [bool]$PciSlot9OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot8Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot8Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot8Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot8LinkSpeed,

        [bool]$PciSlot8OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot7Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot7Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot7Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot7LinkSpeed,

        [bool]$PciSlot7OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot6Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot6Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot6Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot6LinkSpeed,

        [bool]$PciSlot6OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot5Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot5Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot5Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot5LinkSpeed,

        [bool]$PciSlot5OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot4Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot4Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot4Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot4LinkSpeed,

        [bool]$PciSlot4OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot3Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot3Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot3Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot3LinkSpeed,

        [bool]$PciSlot3OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot2Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot2Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot2Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot2LinkSpeed,

        [bool]$PciSlot2OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot1Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot1LinkSpeed,
        
        [bool]$PciSlot1OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerformanceDeterministic', 'PowerDeterministic')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerformanceDeterministic', 'PowerDeterministic')]
        [string]$PerformanceDeterminism,
        
        [bool]$PersistentMemAddressRangeScrub,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')]
        [string]$PersistentMemBackupPowerPolicy,

        [bool]$PersistentMemScanMem,
        [bool]$PlatformCertificate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FirmwareFirst', 'OSFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('FirmwareFirst', 'OSFirst')]
        [string]$PlatformRASPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PostAsrOff', 'PostAsrOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PostAsrOff', 'PostAsrOn')]
        [string]$PostAsr,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')]
        [string]$PostAsrDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Serial', 'All')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Serial', 'All')]
        [string]$PostBootProgress,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')]
        [string]$PostDiscoveryMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delayed20Sec', 'Delayed2Sec', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Delayed20Sec', 'Delayed2Sec', 'Disabled')]
        [string]$PostF1Prompt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('QuietMode', 'VerboseMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('QuietMode', 'VerboseMode')]
        [string]$PostScreenMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DisplayAll', 'DisplayEmbeddedOnly')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DisplayAll', 'DisplayEmbeddedOnly')]
        [string]$PostVideoSupport,
        
        [bool]$PowerButton,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')]
        [string]$PowerOnDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')]
        [string]$PowerRegulator,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                        'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                        'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                        'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                        'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort2', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')]
        [string]$PreBootNetwork,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'IPv4', 'IPv6')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'IPv4', 'IPv6')]
        [string]$PrebootNetworkEnvPolicy,
        
        [string]$PrebootNetworkProxy,
        [bool]$ProcAes,
        [bool]$ProcAMDBoost,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')]
        [string]$ProcAMDBoostControl,
        
        [int]$ProcAmdFmax,
        [bool]$ProcAmdIoVt,
        [bool]$ProcHyperthreading,
        [bool]$ProcSMT,
        [bool]$ProcTurbo,
        [bool]$ProcVirtualization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Enabled', 'ForceEnabled', 'Disabled', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Enabled', 'ForceEnabled', 'Disabled', 'Auto')]
        [string]$ProcX2Apic,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Level1', 'Level2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Level1', 'Level2')]
        [string]$ProcessorConfigTDPLevel,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Auto-tuned', 'Manual-tuned')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Auto-tuned', 'Manual-tuned')]
        [string]$ProcessorJitterControl,
        
        [int]$ProcessorJitterControlFrequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')]
        [string]$ProcessorJitterControlOptimization,

        [string]$Pstate0Frequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupply,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplyGpuDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplySystemDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')]
        [string]$RemovableFlashBootSeq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CurrentRom', 'BackupRom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CurrentRom', 'BackupRom')]
        [string]$RomSelection,

        [bool]$SanitizeAllNvDimmN,
        [bool]$SataSanitize,
        [bool]$SataSecureErase,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Ghesv1Support', 'Ghesv2Support')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Ghesv1Support', 'Ghesv2Support')]
        [string]$SciRasSupport,

        [bool]$SecStartBackupImage,
        [bool]$SecureBootStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')]
        [string]$SerialConsoleBaudRate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')]
        [string]$SerialConsoleEmulation,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'Physical', 'Virtual')]
        [string]$SerialConsolePort,
        
        [string]$ServerAssetTag,
        [bool]$ServerConfigLockStatus,
        [string]$ServerOtherInfo,
        [string]$ServerPrimaryOs,
        [string]$ServiceEmail,
        [string]$ServiceName,
        [string]$ServiceOtherInfo,
        [string]$ServicePhone,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('GUI', 'Text', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('GUI', 'Text', 'Auto')]
        [string]$SetupBrowserSelection,     

        [bool]$Slot1MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot4,

        [bool]$Slot2MctpBroadcastSupport,        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot4,

        [bool]$Slot3MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot4,

        [bool]$Slot4MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot4,

        [bool]$Slot5MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot4,

        [bool]$Slot6MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot4,
 
        [bool]$Slot7MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot4,

        [bool]$Slot8MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot4,
            
        [bool]$Slot9MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot4,

        [bool]$Slot10MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]    
        [string]$Slot10NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
  
        [string]$Slot10NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]     
        [string]$Slot10NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]      
        [string]$Slot10NicBoot4,

        [bool]$Slot11MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot4,


        [bool]$Slot12MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot4,


        [bool]$Slot13MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot4,


        [bool]$Slot14MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot4,


        [bool]$Slot15MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot4,


        [bool]$Slot16MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot4,

        [bool]$Slot17MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot4,

        [bool]$Slot18MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot4,

        [bool]$Slot19MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot4,

        [bool]$Slot20MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot1StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot2StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot3StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot4StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot5StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot6StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot7StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot8StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot9StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot10StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot11StorageBoot,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot12StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot13StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot14StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot15StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot16StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot17StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot18StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot19StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot20StorageBoot,

        [bool]$SpeculativeLockScheduling,
        [bool]$Sriov,


        [bool]$StaleAtoS,
        # When enabled, Sub-NUMA Clustering divides the processor's cores, cache, and memory into multiple NUMA domains. Enabling this feature can increase performance for workloads that are NUMA aware and optimized. Note: When this option is enabled, up to 1GB of system memory may become unavailable.
        
        [bool]$SubNumaClustering,

        [bool]$TPM2EndorsementDisable,
        [bool]$TPM2StorageDisable,

        # Use this option to select the fan cooling solution for the system. Optimal Cooling provides the most efficient solution by configuring fan speeds to the minimum required speed to provide adequate cooling. Increased Cooling runs fans at higher speeds to provide additional cooling. Select Increased Cooling when third-party storage controllers are cabled to the embedded hard drive cage, or if the system is experiencing thermal issues that cannot be resolved. Maximum cooling provides the maximum cooling available on this platform. Enhanced CPU Cooling runs the fans at a higher speed to provide additional cooling to the processors. Selecting Enhanced CPU Cooling may improve system performance with certain processor intensive workloads.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')]
        [string]$ThermalConfig,

        [bool]$ThermalShutdown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Utc', 'Local')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Utc', 'Local')]
        [string]$TimeFormat,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')]
        [string]$TimeZone,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceStatus,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Clear')]
        [string]$Tpm2Operation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')]
        [string]$TpmActivePcrs,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')]
        [string]$TpmChipId,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'NonFipsMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'NonFipsMode', 'FipsMode')]
        [string]$TpmFips,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'RegularMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'RegularMode', 'FipsMode')]
        [string]$TpmFipsModeSwitch,
                        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Tpm12', 'Tpm20')]
        [string]$TpmModeSwitchOperation,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Enable', 'Disable', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Enable', 'Disable', 'Clear')]
        [string]$TpmOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotPresent', 'PresentDisabled', 'PresentEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotPresent', 'PresentDisabled', 'PresentEnabled')]
        [string]$TpmState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoTpm', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoTpm', 'Tpm12', 'Tpm20')]
        [string]$TpmType,
        
        [bool]$TpmUefiOpromMeasuring,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Hidden', 'Visible')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Hidden', 'Visible')]
        [string]$TpmVisibility,

        [bool]$TransparentSecureMemoryEncryption,
        [bool]$UefiOptimizedBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')]
        [string]$UefiSerialDebugLevel,

        [bool]$UefiShellBootOrder,
        [bool]$UefiShellPhysicalPresenceKeystroke,
        [bool]$UefiShellScriptVerification,
        [bool]$UefiShellStartup,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$UefiShellStartupLocation,
        
        [string]$UefiShellStartupUrl,
        [bool]$UefiShellStartupUrlFromDhcp,
        [bool]$UefiVariableAccessFwControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Maximum', 'Minimum')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Maximum', 'Minimum')]
        [string]$UncoreFreqScaling,

        [bool]$UpiPrefetcher,
        [string]$UrlBootFile,
        [string]$UrlBootFile2,
        [bool]$UsbBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')]
        [string]$UsbControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('English', 'Japanese', 'Chinese')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('English', 'Japanese', 'Chinese')]
        [string]$UtilityLang,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptionalVideoOnly', 'BothVideoEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptionalVideoOnly', 'BothVideoEnabled')]
        [string]$VideoOptions,

        [bool]$VirtualInstallDisk,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$VirtualSerialPort,
        
        
        [bool]$VlanControl,
        [int]$VlanId,
        [int]$VlanPriority,
        [bool]$WakeOnLan,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Enabled', 'Disabled')]
        [string]$XptPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIForceLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIMaxLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('SoftwareInitiator', 'AdapterInitiator')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('SoftwareInitiator', 'AdapterInitiator')]
        [string]$iSCSIPolicy,

        [bool]$iSCSISoftwareInitiator,

        [Switch]$WhatIf
      
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingBiosStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Bios
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the region!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID


            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
        
                if ($SettingResource.description) {
                            
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }       

        
            if (-not $PSBoundParameters.ContainsKey('WorkloadProfileName')) {
        
                if ($SettingResource.redfishData.Attributes.WorkloadProfile) {
                            
                    $WorkloadProfileName = $SettingResource.redfishData.Attributes.WorkloadProfile
                }

            }
            elseif ($WorkloadProfileName) {

                if ($WorkloadProfileName -eq "Virtual Radio Access Network (vRAN)") {
                    $WorkloadProfileName = "vRAN"
                }
            }


          
        
            $Attributes = @{ 

                WorkloadProfile = $WorkloadProfileName
                
            }



            #Region Booleaan parameters   

            $boolParametersList = @(
                'AccessControlService',
                'AcpiHpet',
                'AcpiRootBridgePxm',
                'AcpiSlit',
                'AdjSecPrefetch',
                'AdvCrashDumpMode',
                'AllowLoginWithIlo',
                'Amd5LevelPage',
                'AmdCdma',
                'AmdDmaRemapping',
                'AmdL1Prefetcher',
                'AmdL2Prefetcher',
                'AmdMemoryBurstRefresh',
                'AmdPeriodicDirectoryRinse',
                'AmdSecureMemoryEncryption',
                'AmdSecureNestedPaging',
                'AmdVirtualDrtmDevice',
                'ApplicationPowerBoost',
                'AsrStatus',
                'ChannelInterleaving',
                'CollabPowerControl',
                'CoreBoosting',
                'DcuIpPrefetcher',
                'DcuStreamPrefetcher',
                'Dhcpv4',
                'DramControllerPowerDown',
                'EmbNicPCIeOptionROM',
                'EmbSas1PcieOptionROM',
                'EmbSata1Aspm',
                'EmbSata1PCIeOptionROM',
                'EmbSata2Aspm',
                'EmbSata2PCIeOptionROM',
                'EmbSata3Aspm',
                'EmbSata3PCIeOptionROM',
                'EmbSata4Aspm',
                'EmbSata4PCIeOptionROM',
                'EmbeddedDiagnostics',
                'EmbeddedIpxe',
                'EmbeddedUefiShell',
                'EnergyEfficientTurbo',
                'EnhancedProcPerf',
                'ExtendedMemTest',
                'F11BootMenu',
                'FlexLom1PCIeOptionROM',
                'HwPrefetcher',
                'IntelNicDmaChannels',
                'IntelPerfMonitoring',
                'IntelProcVtd',
                'IntelTxt',
                'IntelUpiPowerManagement',
                'IntelligentProvisioning',
                'InternalSDCardSlot',
                'IpxeBootOrder',
                'IpxeScriptAutoStart',
                'IpxeScriptVerification',
                'LastLevelCacheAsNUMANode',
                'LLCDeadLineAllocation',
                'LlcPrefetch',
                'MemClearWarmReset',
                'MemFastTraining',
                'MemPatrolScrubbing',
                'MicrosoftSecuredCoreSupport',
                'MixedPowerSupplyReporting',
                'NetworkBootRetry',
                'NodeInterleaving',
                'NvDimmNMemFunctionality',
                'NvDimmNMemInterleaving',
                'NvdimmLabelSupport',
                'NvmeOptionRom',
                'Ocp1AuxiliaryPower',
                'Ocp2AuxiliaryPower',
                'OmitBootDeviceEvent',
                'OpportunisticSelfRefresh',
                'PciPeerToPeerSerialization',
                'PciSlot20OptionROM',
                'PciSlot19OptionROM',
                'PciSlot18OptionROM',
                'PciSlot17OptionROM',
                'PciSlot16OptionROM',
                'PciSlot15OptionROM',
                'PciSlot14OptionROM',
                'PciSlot13OptionROM',
                'PciSlot12OptionROM',
                'PciSlot11OptionROM',
                'PciSlot10OptionROM',
                'PciSlot9OptionROM',
                'PciSlot8OptionROM',
                'PciSlot7OptionROM',
                'PciSlot6OptionROM',
                'PciSlot5OptionROM',
                'PciSlot4OptionROM',
                'PciSlot3OptionROM',
                'PciSlot2OptionROM',
                'PciSlot1OptionROM',
                'PersistentMemAddressRangeScrub',
                'PersistentMemScanMem',
                'PlatformCertificate',
                'PowerButton',
                'ProcAes',
                'ProcAMDBoost',
                'ProcAmdIoVt',
                'ProcHyperthreading',
                'ProcSMT',
                'ProcTurbo',
                'ProcVirtualization',
                'SanitizeAllNvDimmN',
                'SataSanitize',
                'SataSecureErase',
                'SecStartBackupImage',
                'SecureBootStatus',
                'ServerConfigLockStatus',
                'Slot1MctpBroadcastSupport',
                'Slot2MctpBroadcastSupport',
                'Slot3MctpBroadcastSupport',
                'Slot4MctpBroadcastSupport',
                'Slot5MctpBroadcastSupport',
                'Slot6MctpBroadcastSupport',
                'Slot7MctpBroadcastSupport',
                'Slot8MctpBroadcastSupport',
                'Slot9MctpBroadcastSupport',
                'Slot10MctpBroadcastSupport',
                'Slot11MctpBroadcastSupport',
                'Slot12MctpBroadcastSupport',
                'Slot13MctpBroadcastSupport',
                'Slot14MctpBroadcastSupport',
                'Slot15MctpBroadcastSupport',
                'Slot16MctpBroadcastSupport',
                'Slot17MctpBroadcastSupport',
                'Slot18MctpBroadcastSupport',
                'Slot19MctpBroadcastSupport',
                'Slot20MctpBroadcastSupport',
                'SpeculativeLockScheduling',
                'Sriov',
                'StaleAtoS',
                'SubNumaClustering',
                'TPM2EndorsementDisable',
                'TPM2StorageDisable',
                'ThermalShutdown',
                'TpmUefiOpromMeasuring',
                'TransparentSecureMemoryEncryption',
                'UefiOptimizedBoot',
                'UefiShellBootOrder',
                'UefiShellPhysicalPresenceKeystroke',
                'UefiShellScriptVerification',
                'UefiShellStartup',
                'UefiShellStartupUrlFromDhcp',
                'UefiVariableAccessFwControl',
                'UpiPrefetcher',
                'UsbBoot',
                'VirtualInstallDisk',
                'VlanControl',
                'WakeOnLan',
                'iSCSISoftwareInitiator'

            )
        


            foreach ($boolparameter in $boolParametersList) {
            
                if ($PSBoundParameters.ContainsKey($boolparameter)) {
               
                    if ($PSBoundParameters[$boolparameter] -eq $True) {
            
                        $Attributes."$boolparameter" = "Enabled"
            
                    }
                    else {
                        $Attributes."$boolparameter" = "Disabled"
            
                    }
                }     
                elseif (-not $PSBoundParameters.ContainsKey($boolparameter)) {
                    
                    if ($SettingResource.redfishData.Attributes."$boolparameter") {
                            
                        $Attributes."$boolparameter" = $SettingResource.redfishData.Attributes."$boolparameter"
                    }

                }   
            }

            #EndRegion


            #Region String + Integer parameters

            $stringparametersList = @(
                'AdminEmail',
                'AdminName',
                'AdminOtherInfo',
                'AdminPhone',
                'AdvancedMemProtection',
                'AmdCstC2Latency',
                'AmdMemPStates',
                'AmdXGMILinkSpeed',
                'AsrTimeoutMinutes',
                'AssetTagProtection',
                'AutoPowerOn',
                'BootOrderPolicy',
                'ConsistentDevNaming',
                'CustomPostMessage',
                'CustomPstate0',
                'DataFabricCStateEnable',
                'DaylightSavingsTime',
                'DeterminismControl',
                'DirectToUpi',
                'DynamicPowerCapping',
                'EmbNicAspm',
                'EmbNicEnable',
                'EmbNicLinkSpeed',
                'EmbSas1Aspm',
                'EmbSas1Boot',
                'EmbSas1Enable',
                'EmbSas1LinkSpeed',
                'EmbSata1Enable',
                'EmbSata2Enable',
                'EmbSata3Enable',
                'EmbSata4Enable',
                'EmbVideoConnection',
                'EmbeddedSata',
                'EmbeddedSerialPort',
                'EmsConsole',
                # 'EnabledCoresPerProcIlo6', # Removed as iLO5 and 6 do not use the same value types
                # 'EnabledCoresPerProcIlo5',
                'EnergyPerfBias',
                'ExtendedAmbientTemp',
                'FCScanPolicy',
                'FanFailPolicy',
                'FanInstallReq',
                'FlexLom1Aspm',
                'FlexLom1Enable',
                'FlexLom1LinkSpeed',
                'HourFormat',
                'HttpSupport',
                'InfinityFabricPstate',
                'IntelDmiLinkFreq',
                'IntelSpeedSelect',
                'IntelUpiFreq',
                'IntelUpiLinkEn',
                'IntelVmdDirectAssign',
                'IntelVmdSupport',
                'IntelVrocSupport',
                'IpmiWatchdogTimerAction',
                'IpmiWatchdogTimerStatus',
                'IpmiWatchdogTimerTimeout',
                'Ipv4Address',
                'Ipv4Gateway',
                'Ipv4PrimaryDNS',
                'Ipv4SubnetMask',
                'Ipv6Address',
                'Ipv6ConfigPolicy',
                'Ipv6Duid',
                'Ipv6Gateway',
                'Ipv6PrimaryDNS',
                'Ipv6SecondaryDNS',
                'IpxeAutoStartScriptLocation',
                'IpxeStartupUrl',
                'LocalRemoteThreshold',
                'MaxMemBusFreqMHz',
                'MaxPcieSpeed',
                'MemMirrorMode',
                'MemRefreshRate',
                'MemoryControllerInterleaving',
                'MemoryRemap',
                'MinProcIdlePkgState',
                'MinProcIdlePower',
                'MinimumSevAsid',
                'NetworkBootRetryCount',
                'NicBoot1',
                'NicBoot2',
                'NicBoot3',
                'NicBoot4',
                'NicBoot5',
                'NicBoot6',
                'NicBoot7',
                'NicBoot8',
                'NicBoot9',
                'NicBoot10',
                'NicBoot11',
                'NicBoot12',
                'NumaGroupSizeOpt',
                'NumaMemoryDomainsPerSocket',
                'NvDimmNSanitizePolicy',
                'PackagePowerLimitControlMode',
                'PackagePowerLimitValue',
                'PatrolScrubDuration',
                'PciResourcePadding',
                'PciSlot20Aspm',
                'PciSlot20Bifurcation',
                'PciSlot20Enable',
                'PciSlot20LinkSpeed',
                'PciSlot19Aspm',
                'PciSlot19Bifurcation',
                'PciSlot19Enable',
                'PciSlot19LinkSpeed',
                'PciSlot18Aspm',
                'PciSlot18Bifurcation',
                'PciSlot18Enable',
                'PciSlot18LinkSpeed',
                'PciSlot17Aspm',
                'PciSlot17Bifurcation',
                'PciSlot17Enable',
                'PciSlot17LinkSpeed',
                'PciSlot16Aspm',
                'PciSlot16Bifurcation',
                'PciSlot16Enable',
                'PciSlot16LinkSpeed',
                'PciSlot15Aspm',
                'PciSlot15Bifurcation',
                'PciSlot15Enable',
                'PciSlot15LinkSpeed',
                'PciSlot14Aspm',
                'PciSlot14Bifurcation',
                'PciSlot14Enable',
                'PciSlot14LinkSpeed',
                'PciSlot13Aspm',
                'PciSlot13Bifurcation',
                'PciSlot13Enable',
                'PciSlot13LinkSpeed',
                'PciSlot12Aspm',
                'PciSlot12Bifurcation',
                'PciSlot12Enable',
                'PciSlot12LinkSpeed',
                'PciSlot11Aspm',
                'PciSlot11Bifurcation',
                'PciSlot11Enable',
                'PciSlot11LinkSpeed',
                'PciSlot10Aspm',
                'PciSlot10Bifurcation',
                'PciSlot10Enable',
                'PciSlot10LinkSpeed',
                'PciSlot9Aspm',
                'PciSlot9Bifurcation',
                'PciSlot9Enable',
                'PciSlot9LinkSpeed',
                'PciSlot8Aspm',
                'PciSlot8Bifurcation',
                'PciSlot8Enable',
                'PciSlot8LinkSpeed',
                'PciSlot7Aspm',
                'PciSlot7Bifurcation',
                'PciSlot7Enable',
                'PciSlot7LinkSpeed',
                'PciSlot6Aspm',
                'PciSlot6Bifurcation',
                'PciSlot6Enable',
                'PciSlot6LinkSpeed',
                'PciSlot5Aspm',
                'PciSlot5Bifurcation',
                'PciSlot5Enable',
                'PciSlot5LinkSpeed',
                'PciSlot4Aspm',
                'PciSlot4Bifurcation',
                'PciSlot4Enable',
                'PciSlot4LinkSpeed',
                'PciSlot3Aspm',
                'PciSlot3Bifurcation',
                'PciSlot3Enable',
                'PciSlot3LinkSpeed',
                'PciSlot2Aspm',
                'PciSlot2Bifurcation',
                'PciSlot2Enable',
                'PciSlot2LinkSpeed',
                'PciSlot1Aspm',
                'PciSlot1Bifurcation',
                'PciSlot1Enable',
                'PciSlot1LinkSpeed',
                'PerformanceDeterminism',
                'PersistentMemBackupPowerPolicy',
                'PlatformRASPolicy',
                'PostAsr',
                'PostAsrDelay',
                'PostBootProgress',
                'PostDiscoveryMode',
                'PostF1Prompt',
                'PostScreenMode',
                'PostVideoSupport',
                'PowerOnDelay',
                'PowerRegulator',
                'PreBootNetwork',
                'PrebootNetworkEnvPolicy',
                'PrebootNetworkProxy',
                'ProcAMDBoostControl',
                'ProcAmdFmax',
                'ProcX2Apic',
                'ProcessorConfigTDPLevel',
                'ProcessorJitterControl',
                'ProcessorJitterControlFrequency',
                'ProcessorJitterControlOptimization',
                'Pstate0Frequency',
                'RedundantPowerSupply',
                'RedundantPowerSupplyGpuDomain',
                'RedundantPowerSupplySystemDomain',
                'RemovableFlashBootSeq',
                'RomSelection',
                'SciRasSupport',
                'SerialConsoleBaudRate',
                'SerialConsoleEmulation',
                'SerialConsolePort',
                'ServerAssetTag',
                'ServerOtherInfo',
                'ServerPrimaryOs',
                'ServiceEmail',
                'ServiceName',
                'ServiceOtherInfo',
                'ServicePhone',
                'SetupBrowserSelection',
                'Slot1NicBoot1',
                'Slot1NicBoot2',
                'Slot1NicBoot3',
                'Slot1NicBoot4',
                'Slot2NicBoot1',
                'Slot2NicBoot2',
                'Slot2NicBoot3',
                'Slot2NicBoot4',
                'Slot3NicBoot1',
                'Slot3NicBoot2',
                'Slot3NicBoot3',
                'Slot3NicBoot4',
                'Slot4NicBoot1',
                'Slot4NicBoot2',
                'Slot4NicBoot3',
                'Slot4NicBoot4',
                'Slot5NicBoot1',
                'Slot5NicBoot2',
                'Slot5NicBoot3',
                'Slot5NicBoot4',
                'Slot6NicBoot1',
                'Slot6NicBoot2',
                'Slot6NicBoot3',
                'Slot6NicBoot4',
                'Slot7NicBoot1',
                'Slot7NicBoot2',
                'Slot7NicBoot3',
                'Slot7NicBoot4',
                'Slot8NicBoot1',
                'Slot8NicBoot2',
                'Slot8NicBoot3',
                'Slot8NicBoot4',
                'Slot9NicBoot1',
                'Slot9NicBoot2',
                'Slot9NicBoot3',
                'Slot9NicBoot4',
                'Slot10NicBoot1',
                'Slot10NicBoot2',
                'Slot10NicBoot3',
                'Slot10NicBoot4',
                'Slot11NicBoot1',
                'Slot11NicBoot2',
                'Slot11NicBoot3',
                'Slot11NicBoot4',
                'Slot12NicBoot1',
                'Slot12NicBoot2',
                'Slot12NicBoot3',
                'Slot12NicBoot4',
                'Slot13NicBoot1',
                'Slot13NicBoot2',
                'Slot13NicBoot3',
                'Slot13NicBoot4',
                'Slot14NicBoot1',
                'Slot14NicBoot2',
                'Slot14NicBoot3',
                'Slot14NicBoot4',
                'Slot15NicBoot1',
                'Slot15NicBoot2',
                'Slot15NicBoot3',
                'Slot15NicBoot4',
                'Slot16NicBoot1',
                'Slot16NicBoot2',
                'Slot16NicBoot3',
                'Slot16NicBoot4',
                'Slot17NicBoot1',
                'Slot17NicBoot2',
                'Slot17NicBoot3',
                'Slot17NicBoot4',
                'Slot18NicBoot1',
                'Slot18NicBoot2',
                'Slot18NicBoot3',
                'Slot18NicBoot4',
                'Slot19NicBoot1',
                'Slot19NicBoot2',
                'Slot19NicBoot3',
                'Slot19NicBoot4',
                'Slot20NicBoot1',
                'Slot20NicBoot2',
                'Slot20NicBoot3',
                'Slot20NicBoot4',
                'Slot1StorageBoot',
                'Slot2StorageBoot',
                'Slot3StorageBoot',
                'Slot4StorageBoot',
                'Slot5StorageBoot',
                'Slot6StorageBoot',
                'Slot7StorageBoot',
                'Slot8StorageBoot',
                'Slot9StorageBoot',
                'Slot10StorageBoot',
                'Slot11StorageBoot',
                'Slot12StorageBoot',
                'Slot13StorageBoot',
                'Slot14StorageBoot',
                'Slot15StorageBoot',
                'Slot16StorageBoot',
                'Slot17StorageBoot',
                'Slot18StorageBoot',
                'Slot19StorageBoot',
                'Slot20StorageBoot',
                'ThermalConfig',
                'TimeFormat',
                'TimeZone',
                'Tpm20SoftwareInterfaceOperation',
                'Tpm20SoftwareInterfaceStatus',
                'Tpm2Operation',
                'TpmActivePcrs',
                'TpmChipId',
                'TpmFips',
                'TpmFipsModeSwitch',
                'TpmModeSwitchOperation',
                'TpmOperation',
                'TpmState',
                'TpmType',
                'TpmVisibility',
                'UefiSerialDebugLevel',
                'UefiShellStartupLocation',
                'UefiShellStartupUrl',
                'UncoreFreqScaling',
                'UrlBootFile',
                'UrlBootFile2',
                'UsbControl',
                'UtilityLang',
                'VideoOptions',
                'VirtualSerialPort',
                'VlanId',
                'VlanPriority',
                'XptPrefetcher',
                'XGMIForceLinkWidth',
                'XGMIMaxLinkWidth',
                'iSCSIPolicy'
            )

            foreach ($stringparameter in $stringparametersList) {
                
                if ($PSBoundParameters.ContainsKey($stringparameter)) {
                    
                    $param1Value = $PSBoundParameters[$stringparameter]

                    $Attributes."$stringparameter" = $param1Value
                }
                elseif (-not $PSBoundParameters.ContainsKey($stringparameter)) {

                    if ($SettingResource.redfishData.Attributes."$stringparameter") {
                            
                        $Attributes."$stringparameter" = $SettingResource.redfishData.Attributes."$stringparameter"
                    }

                }

            }


            if ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo6')) {

                $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo6
            } 
            elseif ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo5')) {

                $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo5
                
            }
            elseif (-not $PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo5') -and -not $PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo6')) {

                if ($SettingResource.redfishData.Attributes.EnabledCoresPerProc) {
                    
                    $Attributes.EnabledCoresPerProc = $SettingResource.redfishData.Attributes.EnabledCoresPerProc
                }

            }



            if ($AsrTimeoutMinutes) {
                $Attributes.AsrStatus = "Enabled"

            }


            if ($SubNumaClustering) {
                # Options that must be enabled when Sub-Numa Clustering (SNC) is enabled:
                $Attributes.XptPrefetcher = "Enabled"
                $Attributes.UpiPrefetcher = "Enabled"
            }

            #EndRegion

            

            # Build paylaod

            if ($Attributes.length -gt 1) {
                
                $RequireCustomProfile = $True #$SettingResource.enableCustomWorkloadProfile
            }

            if ($RequireCustomProfile) {
                
                $Default = @{ 
                    redfishData                 = @{
                        Attributes = $Attributes
                    }
                    enableCustomWorkloadProfile = $True
                }
            }
            else {
                
                $Default = @{ 
                    redfishData = @{
                        Attributes = $Attributes
                    }
                }

            }

            $Settings = @{ 
                DEFAULT = $Default
            }

            $payload = @{ 
                name           = $Name
                category       = "BIOS"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Bios server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Bios server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Bios server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingBiosStatus.add($objStatus)
    
    }
    
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingBiosStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more bios server settings failed the modification attempt!"
          
            }
            
            $SetServerSettingBiosStatus = Invoke-RepackageObjectWithType -RawObject $SetServerSettingBiosStatus -ObjectName "COM.objStatus.NSDE"    
            Return $SetServerSettingBiosStatus
        
        }

    }
}


Function New-HPECOMSettingServerInternalStorageVolume {
    <#
    .SYNOPSIS
    Create volumes to be used with Set-HPECOMSettingServerInternalStorage to create a server internal storage setting. 

    .DESCRIPTION
    This Cmdlet creates a volume object that is required to create a server internal storage setting using Set-HPECOMSettingServerInternalStorage.

    .PARAMETER RAID
    Specifies the RAID type:
        - RAID0: Uses disk striping. Optimized for I/O speed and efficient use of physical disk capacity, but provides no data redundancy.
          Requires a minimum of 1 drive. You can add drives in increments of 1 up to 32 drives.

        - RAID1: Uses disk mirroring. Optimized for data redundancy and I/O speed, but uses more physical disk drives.
          Requires 2 drives.

        - RAID10: Combines RAID0 and RAID1. Optimized for performance and fault tolerance.
          Requires a minimum of 4 drives. You can add drives in increments of 2 up to 32 drives.

        - RAID1Triple: Uses disk mirroring with three copies of data. Optimized for data redundancy and I/O speed.
          Requires 3 drives.

        - RAID10Triple: Combines RAID0 and RAID1 with three copies of data. Optimized for performance and fault tolerance.
          Requires a minimum of 6 drives. You can add drives in increments of 3 up to 30 drives.

        - RAID5: Uses disk striping with parity. Optimized for performance and fault tolerance.
          Requires a minimum of 3 drives. You can add drives in increments of 1 up to 32 drives.

        - RAID50: Combines RAID0 and RAID1 with parity. Optimized for performance and fault tolerance. 
          Requires a minimum of 6 drives. You can add drives in increments of 2 up to 32 drives.

        - RAID6: Uses disk striping with parity. Optimized for performance and fault tolerance.
          Requires a minimum of 4 drives. You can add drives in increments of 1 up to 32 drives.

        - RAID60: Combines RAID0 and RAID1 with parity. Optimized for performance and fault tolerance.
          Requires a minimum of 8 drives. You can add drives in increments of 2 up to 32 drives.

    .PARAMETER DrivesNumber
    Specifies the number of drives to be used. The default value is the minimum number of drives required for the selected RAID type.

    .PARAMETER DriveTechnology
    Specifies the drive technology. Selecting a drive technology value helps you to prepare volumes for future use. 
    For example, you might want to use SAS SSD drives to create a volume for OS installation, or use a SATA HDD drive for a long-term data storage solution. 
    Supported values: SAS HDD, SAS SSD, SATA HDD, SATA SDD, NVMe SSD

    .PARAMETER SpareDriveNumber
    Specifies the number of spare drives to be added to the volume. The default value is 0. 
    This option is not supported with RAID 0. Spare drives will not be accessible to other volumes defined within the same server setting.

    .PARAMETER SizeinGB
    Creates a volume using the full drive capacity of the selected drives.
    When not used, a volume using the full drive capacity of the selected drives is created.

    .PARAMETER IOPerformanceMode   
    Specifies the I/O performance mode for the internal storage server setting.
    I/O performance mode is an intelligent I/O passthrough mechanism for SSD arrays. This feature can boost storage subsystem and application performance, especially for applications that use high random read/write operation workloads.

    By default, this feature is set to 'Not managed', which means that Compute Ops Management does not set any value for the feature. When this feature is not managed through Compute Ops Management, the default value set by the controller is used.

    .PARAMETER ReadCachePolicy   
    Specifies the read cache policy for the internal storage server setting.
    Read cache policy controls the behavior when a server reads from a volume. When read caching is enabled, I/O performance is improved by satisfying read requests from the controller memory instead of from physical disks.

    By default, this feature is set to 'Not managed', which means that Compute Ops Management does not set any value for the feature. When this feature is not managed through Compute Ops Management, the default value set by the controller is used.

    .PARAMETER WriteCachePolicy   
    Specifies the write cache policy for the internal storage server setting.
    Write cache policy controls the behavior when a server writes to a volume. Data can be written to the cache and storage at the same time, or it can be written to the cache first, and then written to the storage later.

    By default, this feature is set to 'Not managed', which means that Compute Ops Management does not set any value for the feature. When this feature is not managed through Compute Ops Management, the default value set by the controller is used.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    $volume1 = New-HPECOMSettingServerInternalStorageVolume -RAID RAID5 -DriveTechnology NVME_SSD -IOPerformanceMode -ReadCachePolicy OFF -WriteCachePolicy WRITE_THROUGH -SizeinGB 100 -DrivesNumber 3 -SpareDriveNumber 2
    $volume2 = New-HPECOMSettingServerInternalStorageVolume -RAID RAID1 -DriveTechnology SAS_HDD
    New-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID_CONF_FOR_AI_SERVERS" -Description "My server setting for the AI servers" -Volume $volume1,$volume2 

    This example demonstrates how to create two internal storage volumes. The first volume is a RAID5 configuration with NVMe SSD drives, I/O performance mode enabled, and a size of 100GB. 
    The second volume is a RAID1 configuration with SAS HDD drives. Finally, the volumes are used to create a server setting named 'RAID_CONF_FOR_AI_SERVERS' in the central European region. 
    This server setting is created using the 'New-HPECOMSettingServerInternalStorage' Cmdlet, which allows for the configuration of internal storage settings for servers.  

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    [PSCustomObject]@{
        raidType           = $RAID
        capacityInGiB      = $SizeinGB
        driveCount         = $DrivesNumber
        spareDriveCount    = $SpareDriveNumber
        driveTechnology    = $DriveTechnology
        ioPerfModeEnabled  = $IOPerformanceMode
        readCachePolicy    = $ReadCachePolicy
        writeCachePolicy   = $WriteCachePolicy
    }
        
        

    #>

    [CmdletBinding()]
    Param(        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $RAIDs = @('RAID0', 'RAID1', 'RAID1_TRIPLE', 'RAID10', 'RAID10_TRIPLE', 'RAID5', 'RAID50', 'RAID6', 'RAID60')
                $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredRAIDs | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RAID0', 'RAID1', 'RAID1_TRIPLE', 'RAID10', 'RAID10_TRIPLE', 'RAID5', 'RAID50', 'RAID6', 'RAID60')]
        [String]$RAID,

        [Int]$DrivesNumber,

        [ArgumentCompleter({
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
            $RAIDs = @('SAS_HDD', 'SAS_SSD', 'SATA_HDD', 'SATA_SSD', 'NVME_SSD')
            $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
            return $filteredRAIDs | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        })]
        [ValidateSet ('SAS_HDD', 'SAS_SSD', 'SATA_HDD', 'SATA_SSD', 'NVME_SSD')]
        [String]$DriveTechnology,

        [Int]$SpareDriveNumber,

        [Int]$SizeinGB,

        [ArgumentCompleter({
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
            $RAIDs = @('ENABLED', 'DISABLED')
            $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
            return $filteredRAIDs | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        })]
        [ValidateSet ('ENABLED', 'DISABLED')]
        [String]$IOPerformanceMode,

        [ArgumentCompleter({
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
            $RAIDs = @('READ_AHEAD', 'ADAPTIVE_READ_AHEAD', 'OFF')
            $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
            return $filteredRAIDs | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        })]
        [ValidateSet ('PROTECTED_WRITE_BACK', 'UNPROTECTED_WRITE_BACK', 'WRITE_THROUGH', 'OFF')]
        [String]$ReadCachePolicy,

        [ArgumentCompleter({
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
            $RAIDs = @('PROTECTED_WRITE_BACK', 'UNPROTECTED_WRITE_BACK', 'WRITE_THROUGH', 'OFF')
            $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
            return $filteredRAIDs | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        })]
        [ValidateSet ('PROTECTED_WRITE_BACK', 'UNPROTECTED_WRITE_BACK', 'WRITE_THROUGH', 'OFF')]
        [String]$WriteCachePolicy,

        [Switch]$WhatIf
       
    ) 
    Begin {
        # Initialize the volume object
        $volume = [PSCustomObject]@{
            raidType           = $RAID
            capacityInGiB      = $null
            driveCount         = $null
            spareDriveCount    = $null
            driveTechnology    = $null
            ioPerfModeEnabled  = $null
            readCachePolicy    = $null
            writeCachePolicy   = $null
        }
    }

    Process {

        if ($RAID -eq "RAID0" -and $SpareDriveNumber -gt 0) {
            Write-Error "RAID0 does not support spare drives!"
            return
        }

        if ($PSBoundParameters.ContainsKey('SizeinGB')) {
            $volume.capacityInGiB = $SizeinGB
        }
       
        if ($PSBoundParameters.ContainsKey('DrivesNumber')) {
            $volume.driveCount = $DrivesNumber
        }
        else {
            if ($RAID -eq "RAID0") {
                $volume.driveCount = 1
            }
            elseif ($RAID -eq "RAID1") {
                $volume.driveCount = 2
            }
            elseif ($RAID -eq "RAID10") {
                $volume.driveCount = 4
            }
            elseif ($RAID -eq "RAID1Triple") {
                $volume.driveCount = 3
            }
            elseif ($RAID -eq "RAID10Triple") {
                $volume.driveCount = 6
            }
            elseif ($RAID -eq "RAID5") {
                $volume.driveCount = 3
            }
            elseif ($RAID -eq "RAID50") {
                $volume.driveCount = 6
            }   
            elseif ($RAID -eq "RAID6") {
                $volume.driveCount = 4
            }
            elseif ($RAID -eq "RAID60") {
                $volume.driveCount = 8
            } 
        }

        if ($PSBoundParameters.ContainsKey('SpareDriveNumber')) {
            $volume.spareDriveCount = $SpareDriveNumber
        }

        if ($PSBoundParameters.ContainsKey('DriveTechnology')) {
            $volume.driveTechnology = $DriveTechnology
        }

        if ($PSBoundParameters.ContainsKey('IOPerformanceMode')) {
            
            if ($IOPerformanceMode -eq "ENABLED") {
                $IOPerformanceModeBoolean = $true
            }
            elseif ($IOPerformanceMode -eq "DISABLED") {
                $IOPerformanceModeBoolean = $false
            }

            $volume.ioPerfModeEnabled = $IOPerformanceModeBoolean
        }

        if ($PSBoundParameters.ContainsKey('ReadCachePolicy')) {
            $volume.readCachePolicy = $ReadCachePolicy
        }
        
        if ($PSBoundParameters.ContainsKey('WriteCachePolicy')) {
            $volume.writeCachePolicy = $WriteCachePolicy
        }

        if ($WhatIf) {
            Write-Host "WhatIf: Would create volume object with properties:"
            $volume | Format-List
            return
        }

        # Output the volume object
        $volume
    }

    End {
        # No cleanup needed
    }
}


Function New-HPECOMSettingServerInternalStorage {
    <#
    .SYNOPSIS
    Configures an internal storage server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new internal storage server setting with specified RAID type and size.
    Internal storage server settings enable consistent storage configurations across servers in a group.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the internal storage server setting.

    .PARAMETER Description
    Provides a description for the internal storage server setting.

   .PARAMETER Volumes
    Specifies the volumes to be included in the internal storage server setting. 
    This parameter accepts an array of volume objects created using the 'New-HPECOMSettingServerInternalStorageVolume' cmdlet.
     
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    $volume1 = New-HPECOMSettingServerInternalStorageVolume -RAID RAID5 -DriveTechnology NVME_SSD -IOPerformanceMode -ReadCachePolicy OFF -WriteCachePolicy WRITE_THROUGH -SizeinGB 100 -DrivesNumber 3 -SpareDriveNumber 2 
    $volume2 = New-HPECOMSettingServerInternalStorageVolume -RAID RAID1 -DriveTechnology SAS_HDD 
    New-HPECOMSettingServerInternalStorage -Region "eu-central" -Name "MyStorage" -Description "My storage description" -Volumes $volume1, $volume2 

    Creates a new internal storage server setting named "MyStorage" in the "eu-central" region with the specified description and volumes.
    The volumes are created using the 'New-HPECOMSettingServerInternalStorageVolume' cmdlet.    

    .EXAMPLE
    New-HPECOMSettingServerInternalStorageVolume -RAID RAID1 -DriveTechnology SAS_HDD | New-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID-FOR_AI" -Description MyDescription 

    Creates a new internal storage server setting named "RAID-FOR_AI" in the "eu-central" region using the specified volume provided through the pipeline, along with a description.
    The volume is created using the 'New-HPECOMSettingServerInternalStorageVolume' cmdlet.

    .EXAMPLE
    $volume1, $Volume2 | New-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID-FOR_AI"

    Creates a new internal storage server setting named "RAID-FOR_AI" in the "eu-central" region using the specified volumes provided through the pipeline.

    .INPUTS
    Pipeline input is supported. The input must be an array of volume objects created using the 'New-HPECOMSettingServerInternalStorageVolume' cmdlet.
    The input can be passed directly to the 'Volumes' parameter.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the internal storage server setting attempted to be created.
        * Region - The name of the region.
        * Status - The creation attempt's status (Failed for HTTP error return; Complete if successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
        
    #>


    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory, ValueFromPipeline)]
        [Object]$Volumes,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri

        $VolumesObject = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        [void] $VolumesObject.add($Volumes)

    
    }
    
    End {

          # Build object for the output
          $objStatus = [pscustomobject]@{
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Storage

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {

            "[{0}] Setting '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Setting '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                Return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Setting already exists in the region! No action needed."
            }
        }
        else {
            # Setting resource is not present, proceed to create it
            "[{0}] Setting '{1}' is not present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose

            # Build payload

            $Settings = @{ 
                DEFAULT = @{
                    volumes = @($VolumesObject | ForEach-Object { $_ })
                }
            }

            $payload = @{ 
                name           = $Name
                category       = "STORAGE"
                description    = $Description
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Internal storage server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Internal storage server setting successfully created in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Internal storage server setting cannot be created!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        if (-not $WhatIf ) {

            if ($objStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Failed to create the internal storage server setting. Please review the details for further information."
          
            }
            
            $NewServerSettingInternalStorageStatus = Invoke-RepackageObjectWithType -RawObject $objStatus -ObjectName "COM.objStatus.NSDE"    
            Return $NewServerSettingInternalStorageStatus
        
        }
    }
}


Function Set-HPECOMSettingServerInternalStorage {
    <#
    .SYNOPSIS
    Update an internal storage server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies an internal storage server setting resource in a given region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.

    .PARAMETER Name
    Specifies the name of the internal storage server setting to update.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    Specifies the new name for the internal storage server setting.

    .PARAMETER Description
    Specifies a new description of the internal storage server setting.
    
    .PARAMETER Volumes   
    Specifies the volumes to be associated with the internal storage server setting. This parameter allows for detailed configuration of storage volumes, including RAID type and size.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID1" -NewName "RAID-1"

    This example updates the name of the internal storage server setting from "RAID1" to "RAID-1" in the "eu-central" region.

    .EXAMPLE
    Set-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID1" -Description "Local storage settings using RAID1 and entire disk for OS"
    
    This example updates the description of the internal storage server setting "RAID1" in the "eu-central" region, describing it as "Local storage settings using RAID1 and entire disk for OS".

    .EXAMPLE
    $volume1 = New-HPECOMSettingServerInternalStorageVolume -RAID RAID5 -DriveTechnology NVME_SSD -IOPerformanceMode -ReadCachePolicy OFF -WriteCachePolicy WRITE_THROUGH -SizeinGB 100 -DrivesNumber 3 -SpareDriveNumber 2 
    $volume2 = New-HPECOMSettingServerInternalStorageVolume -RAID RAID1 -DriveTechnology SAS_HDD 
    Set-HPECOMSettingServerInternalStorage -Region eu-central -Name "AI_SERVER_RAID1&5" -Volumes $volume1, $volume2 

    This example changes the volumes configuration of the internal storage server setting named "AI_SERVER_RAID1&5" in the "eu-central" region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category Storage | Set-HPECOMSettingServerInternalStorage -EntireDisk 
    
    This example retrieves all storage settings from the "eu-central" region and pipes them to update the internal storage server setting to use the entire disk.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category Storage -Name 'AI_SERVER_RAID1' | Set-HPECOMSettingServerInternalStorage -Volumes $volume1 

    This example retrieves the internal storage server setting named "AI_SERVER_RAID1" from the "eu-central" region and updates its volumes configuration to use the specified volume object created using the 'New-HPECOMSettingServerInternalStorageVolume' cmdlet.

    .INPUTS
    System.Collections.ArrayList
        List of internal storage server settings from 'Get-HPECOMSetting -Category Storage'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the internal storage server setting attempted to be updated
        * Region - The name of the region
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
                
        [Object]$Volumes,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingInternalStorageStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Storage
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the region!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $Volumes){
                $Volumes = $SettingResource.volumes
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }            


            # Build payload

            $Settings = @{ 
                DEFAULT = @{
                    volumes = @($Volumes)
                }
            }

            $payload = @{ 
                name           = $Name
                category       = "STORAGE"
                description    = $Description
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Internal storage server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Internal storage server setting successfully updated in $Region region"

                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Internal storage server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingInternalStorageStatus.add($objStatus)

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingInternalStorageStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more internal storage server settings failed the modification attempt!"
          
            }
            
            $SetServerSettingInternalStorageStatus = Invoke-RepackageObjectWithType -RawObject $SetServerSettingInternalStorageStatus -ObjectName "COM.objStatus.NSDE"    
            Return $SetServerSettingInternalStorageStatus
        
        }

    }
}


Function New-HPECOMSettingServerOSImage {
    <#
    .SYNOPSIS
    Configure an OS image configuration server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new operating system image configuration server setting.
    OS image configurations enable consistent OS installations across servers in a group.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the OS image configuration server setting.

    .PARAMETER Description
    Provides a description for the OS image configuration server setting.

    .PARAMETER OperatingSystem
    Specifies the operating system:
        - VMware ESXi
        - Microsoft Windows
        - Red Hat Enterprise Linux
        - Suse Linux
        - Ubuntu Linux

    Note: Compute Ops Management can detect completion of operating system install via HPE Agentless Management Service. 
          Ensure that the operating system image includes HPE Agentless Management Service utility.
    
    .PARAMETER OSImageURL
    Specifies the full URL location of the OS image.

    Example: https://hostname.domain.com/ImageName.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. 
          Ensure that iLO can access the virtual media URL and that there are no connectivity issues

    .PARAMETER UnattendedInstallationFileImageUrl
    Specifies the full URL location of the ISO file for the unattended installation file image.

    Example: https://hostname.domain.com/kickstart.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. 
          Ensure that iLO can access the virtual media URL and that there are no connectivity issues

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region  us-west -Name OS-ESX -Description "My ESX OS image SS" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx.iso" 

    This command creates a new OS image configuration server setting named 'OS-ESX' using a single image containing OS and unattended installation file from the URL 'https://domain.com/esx8.iso' in the 'us-west' region.

    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region us-west -Name OS-ESX -Description "My ESX 8 OS image configuration" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx8.iso" -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso" 
    
    This command creates a new OS image configuration server setting named 'OS-ESX' using a separate image for OS from the URL 'https://domain.com/esx8.iso' and for the unattended file from the URL 'https://domain.com/esx_ks.iso'.

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the OS image configuration server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

     
    
   #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX', 'CUSTOM')
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX', 'UBUNTU_LINUX', 'CUSTOM')]
        [String]$OperatingSystem,
        
        [Parameter (Mandatory, ParameterSetName = 'SingleImage')]
        [Parameter (Mandatory, ParameterSetName = 'SeparateImages')]
        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$OSImageURL,

        [Parameter (Mandatory, ParameterSetName = 'SeparateImages')]
        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$UnattendedInstallationFileImageUrl,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingOSImageConfigurationStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Os

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {

            "[{0}] Setting '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Setting '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Setting already exists in the region! No action needed."
            }

        }
        else {

            # Build payload
    
            if ($UnattendedInstallationFileImageUrl) {
    
                $Settings = @{ 
                    DEFAULT = @{
                        osType                        = $OperatingSystem
                        mediaUrl                      = $OSImageURL
                        unattendedInstallationFileUrl = $UnattendedInstallationFileImageUrl
    
                    }
                }
            }
            else {
                
                $Settings = @{ 
                    DEFAULT = @{
                        osType   = $OperatingSystem
                        mediaUrl = $OSImageURL
                    }
                }
            }
    
    
            $payload = @{ 
                name           = $Name
                category       = "OS"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }
    
            $payload = ConvertTo-Json $payload -Depth 10 
    
            try {
    
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
    
                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    "[{0}] OS image configuration server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "OS image configuration server setting successfully created in $Region region"
    
    
                }
            }
            catch {
    
                if (-not $WhatIf) {
    
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "OS image configuration server setting cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
    
                }
            } 
        }
        

        [void] $NewServerSettingOSImageConfigurationStatus.add($objStatus)

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingOSImageConfigurationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more OS image configuration server settings failed the creation attempt!"
          
            }
            
            $NewServerSettingOSImageConfigurationStatus = Invoke-RepackageObjectWithType -RawObject $NewServerSettingOSImageConfigurationStatus -ObjectName "COM.objStatus.NSDE"    
            Return $NewServerSettingOSImageConfigurationStatus
        
        }

    }
}


Function Set-HPECOMSettingServerOSImage {
    <#
    .SYNOPSIS
    Update the configuration of an OS image server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies an OS image configuration server setting resource in a designated Compute Ops Management (COM) region. If certain parameters are not specified, the cmdlet retains their existing settings and only updates those that are provided.

    .PARAMETER Name
    Specifies the name of the OS image configuration server setting to update.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    Specifies the new name for the OS image configuration server setting.

    .PARAMETER Description
    Specifies a new description for the OS image configuration server setting.

    .PARAMETER OperatingSystem
    Specifies the new operating system:
        - VMware ESXi
        - Microsoft Windows
        - Red Hat Enterprise Linux
        - SUSE Linux

    Note: Compute Ops Management can detect the completion of an operating system install via HPE Agentless Management Service. Ensure that the OS image includes this utility.

    .PARAMETER OSImageURL
    Specifies the new full URL location of the OS image.

    Example: https://hostname.domain.com/ImageName.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. Ensure that iLO can access the virtual media URL without any connectivity issues.

    .PARAMETER UnattendedInstallationFileImageUrl
    Specifies the new full URL location of the ISO file for the unattended installation file image.

    Example: https://hostname.domain.com/kickstart.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. Ensure that iLO can access the virtual media URL without any connectivity issues.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSettingServerOSImage -Region eu-central -Name OS_ESXi -NewName ESXi_800

    This command updates the name of the OS image configuration server setting from 'OS_ESXi' to 'ESXi_800' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerOSImage -Region eu-central -Name OS_ESXi -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso"
    
    This command updates the URL for the unattended installation file image to "https://domain.com/esx_ks.iso" for the OS image configuration named 'OS_ESXi' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerOSImage -Region eu-central -Name OS_ESXi -Description "OS Image for ESXi 8.00" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.lab/deployment/esxi80u2/VMware-ESXi-8.0.2-22380479-HPE-802.0.0.11.4.0.14-Sep2023.iso" -UnattendedInstallationFileImageUrl ""
    
    This command updates multiple parameters for the OS image configuration named 'OS_ESXi':
     - Sets the description to "OS Image for ESXi 8.00"
     - Specifies the operating system as 'VMware ESXi'
     - Updates the OS image URL to the provided link
     - Clears the unattended installation file image URL
    This modification is applied in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category OS | Set-HPECOMSettingServerOSImage -Description "My new description"
    
    This command first retrieves all OS image configuration settings in the 'eu-central' region using 'Get-HPECOMSetting'.
    It then pipes the retrieved settings into 'Set-HPECOMSettingServerOSImage' to update the description of each setting to "My new description".

    .INPUTS
    System.Collections.ArrayList
        List of internal OS image configuration settings from 'Get-HPECOMSetting -Category OS'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the OS image configuration server setting attempted to be updated.
        * Region - The name of the region.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information regarding any exceptions generated during the operation.

    #>

    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $RAIDs = @('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX', 'CUSTOM')
                $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredRAIDs | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX', 'CUSTOM')]
        [String]$OperatingSystem,
        
        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$OSImageURL,

        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                elseif ($_ -eq "") { 
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$UnattendedInstallationFileImageUrl,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Os
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the region!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }            

          
            if (-not $OperatingSystem) {
                $OperatingSystem = $SettingResource.settings.default.osType
            }

            #  -UnattendedInstallationFileImageUrl "" must work as the unattended file is not mandatory so it should remove the UnattendedInstallationFileImageUrl if present
            if (-not $PSBoundParameters.ContainsKey('UnattendedInstallationFileImageUrl') ) {

                if ($SettingResource.settings.default.unattendedInstallationFileUrl) {

                    $UnattendedInstallationFileImageUrl = $SettingResource.settings.default.unattendedInstallationFileUrl
                }

            }

            if (-not $OSImageURL) {
                $OSImageURL = $SettingResource.settings.default.mediaUrl
            }

        
            if ($UnattendedInstallationFileImageUrl) {

                $Settings = @{ 
                    DEFAULT = @{
                        osType                        = $OperatingSystem
                        mediaUrl                      = $OSImageURL
                        unattendedInstallationFileUrl = $UnattendedInstallationFileImageUrl

                    }
                }
            }
            else {
            
                $Settings = @{ 
                    DEFAULT = @{
                        osType   = $OperatingSystem
                        mediaUrl = $OSImageURL
                    }
                }
            }


            $payload = @{ 
                name           = $Name
                category       = "OS"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] OS Image server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "OS Image server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "OS Image server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingStatus.add($objStatus)

        
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more OS Image server settings failed the modification attempt!"
          
            }
            
            $SetServerSettingStatus = Invoke-RepackageObjectWithType -RawObject $SetServerSettingStatus -ObjectName "COM.objStatus.NSDE"    
            Return $SetServerSettingStatus
        
        }

    }
}


Function New-HPECOMSettingServerFirmware {
    <#
    .SYNOPSIS
    Configure a firmware server setting.

    .DESCRIPTION
    This Cmdlet creates a new firmware baseline server setting with baseline and hotfix or patch settings.
    Firmware server settings enable you to apply consistent firmware configurations to servers in a group. 
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the firmware server setting.

    .PARAMETER Description
    Specifies a description for the firmware server setting.

    .PARAMETER Gen10FirmwareBundleReleaseVersion
    Specifies the name of a baseline SPP or hotfix/patch bundle for Gen10/Gen10+ servers. 
    
    .PARAMETER Gen11FirmwareBundleReleaseVersion
    Specifies the name of a baseline SPP or hotfix/patch bundle for Gen11 servers. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM. 
   
    .EXAMPLE
    $Gen10_Firmware_Bundle = Get-HPECOMFirmwareBundle -Region eu-central -Generation 10 | Select-Object -first 1 | ForEach-Object releaseversion
    $Gen11_Firmware_Bundle = Get-HPECOMFirmwareBundle -Region eu-central -Generation 11 | Select-Object -first 1 | ForEach-Object releaseversion

    New-HPECOMSettingServerFirmware -Region eu-central -Name Latest_Firmware_Bundle -Description "Server setting to update servers to latest firmware bundle" -Gen10FirmwareBundleReleaseVersion $Gen10_Firmware_Bundle -Gen11FirmwareBundleReleaseVersion $Gen11_Firmware_Bundle

    Create a new firmware server setting using dynamically retrieved firmware bundle release versions for Gen10/Gen10+ and Gen11 servers.

    .EXAMPLE
    New-HPECOMSettingServerFirmware -Region us-west -Name SPP-2024.04.00.01 -Description "Server setting to update servers to 2024-04-00-01 firmware bundle" -Gen10FirmwareBundleReleaseVersion 2024.04.00.01 -Gen11FirmwareBundleReleaseVersion 2024.04.00.01 

    Create a new firmware server setting using specified firmware bundle release versions for Gen10 and Gen11 servers.
       
    .INPUTS
    Pipeline input is not supported.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the firmware server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.


    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Together')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory, ParameterSetName = 'Gen10Baseline')]
        [Parameter (ParameterSetName = 'Together')]
        [String]$Gen10FirmwareBundleReleaseVersion,

        [Parameter (Mandatory, ParameterSetName = 'Gen11Baseline')]
        [Parameter (ParameterSetName = 'Together')]
        [String]$Gen11FirmwareBundleReleaseVersion,
        
        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingFirmwareStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Firmware

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {

            "[{0}] Setting '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Setting '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Setting already exists in the region! No action needed."
            }

        }
        else {

            # Build payload

            if ($Gen10FirmwareBundleReleaseVersion -and -not $Gen11FirmwareBundleReleaseVersion) {

                try {
                    $Gen10FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen10FirmwareBundleReleaseVersion -Generation 10).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }

                if (-not $Gen10FirmwareBundleID) {

                    # Must return a message if SN/Name not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
                else {
                    
                    $Settings = @{ 
                        GEN10 = @{
                            id = $Gen10FirmwareBundleID
        
                        }
                    }
                }

            }
            elseif ($Gen10FirmwareBundleReleaseVersion -and $Gen11FirmwareBundleReleaseVersion) {

                try {
                    $Gen10FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen10FirmwareBundleReleaseVersion -Generation 10).id
                    $Gen11FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen11FirmwareBundleReleaseVersion -Generation 11).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }

                if (-not $Gen10FirmwareBundleID) {

                    # Must return a message if not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
                elseif (-not $Gen10FirmwareBundleID -and -not $Gen11FirmwareBundleID) {
                    
                    # Must return a message if not found
                    
                    $ErrorMessage = "Firmware bundles '{0}' and '{1}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion, $Gen11FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)                

                }
                elseif (-not $Gen11FirmwareBundleID) {

                    # Must return a message if not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen11FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundlesNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen11FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
                else {
                
                    $Settings = @{ 
                        GEN10 = @{
                            id = $Gen10FirmwareBundleID

                        }
                        GEN11 = @{
                            id = $Gen11FirmwareBundleID

                        }
                    }
                }
            }
            elseif ($Gen11FirmwareBundleReleaseVersion -and -not $Gen10FirmwareBundleReleaseVersion ) {

                try {
                    $Gen11FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen11FirmwareBundleReleaseVersion -Generation 11).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }

                if (-not $Gen11FirmwareBundleID) {

                    # Must return a message if SN/Name not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen11FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen11FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
                else {
                
                    $Settings = @{ 
                        GEN11 = @{
                            id = $Gen11FirmwareBundleID

                        }
                    }
                }
            }

            $payload = @{ 
                name           = $Name
                category       = "FIRMWARE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Firmware server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Firmware server setting successfully created in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Firmware server setting cannot be created!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 

        }
                

        [void] $NewServerSettingFirmwareStatus.add($objStatus)

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingFirmwareStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Firmware server settings failed the creation attempt!"
          
            }
            
            $NewServerSettingFirmwareStatus = Invoke-RepackageObjectWithType -RawObject $NewServerSettingFirmwareStatus -ObjectName "COM.objStatus.NSDE"
            Return $NewServerSettingFirmwareStatus
        
        }

    }
}


Function Set-HPECOMSettingServerFirmware {
    <#
    .SYNOPSIS
    Updates the configuration of a firmware server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies a firmware server setting resource within a designated Compute Ops Management (COM) region. If certain parameters are not specified, the cmdlet retains their existing settings and only updates those that are provided.

    .PARAMETER Name
    Specifies the name of the firmware server setting to update.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    Specifies the new name for the firmware server setting.

    .PARAMETER Description
    Provides a new description for the firmware server setting.

    .PARAMETER Gen10FirmwareBundleReleaseVersion
    Specifies the release version of the new baseline SPP or hotfix/patch bundle for Gen10/Gen10+ servers. 

    .PARAMETER Gen11FirmwareBundleReleaseVersion
    Specifies the release version of the new baseline SPP or hotfix/patch bundle for Gen11 servers. 

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the native REST API calls utilized by COM.

    .EXAMPLE
    Set-HPECOMSettingServerFirmware -Region eu-central -Name ESXi_firmware_baseline_24_04_Gen10 -NewName ESXi_firmware_baseline

    This example updates the name of the firmware server setting from 'ESXi_firmware_baseline_24_04_Gen10' to 'ESXi_firmware_baseline' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerFirmware -Region eu-central -Name ESXi_firmware_baseline_24_04_Gen10 -Gen11FirmwareBundleReleaseVersion 2024.04.00.01

    This example updates the Gen11 firmware bundle release version of the server setting named 'ESXi_firmware_baseline_24_04_Gen10' to '2024.04.00.01' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerFirmware -Region eu-central -Name RHEL_firmware_baseline_2024_04_00_01 -Gen10FirmwareBundleReleaseVersion "2024.04.00.01" -Gen11FirmwareBundleReleaseVersion 2024.04.00.01 

    This example updates both the Gen10 and Gen11 firmware bundle release versions of the server setting named 'RHEL_firmware_baseline_2024_04_00_01' to '2024.04.00.01' in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category FIRMWARE -Name WIN_firmware_baseline | Set-HPECOMSettingServerFirmware -Description "FW server settings for 2024.04.00.02 Gen10 bundle" -Gen10FirmwareBundleReleaseVersion "2024.04.00.02"

    This example uses pipeline input to update the description and Gen10 firmware bundle release version of the server setting named 'WIN_firmware_baseline' retrieved from the 'eu-central' region.

    .INPUTS
    System.Collections.ArrayList
        List of firmware settings from 'Get-HPECOMSetting -Category FIRMWARE'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the firmware server setting attempted to be updated.
        * Region - The name of the region.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information regarding any exceptions generated during the operation.

    #>
    
    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [String]$Gen10FirmwareBundleReleaseVersion,

        [String]$Gen11FirmwareBundleReleaseVersion,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Firmware
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the region!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }     
            
            # Using containsKey to allow removing an already set parameter using -Gen10FirmwareBundleReleaseVersion ""
            if (-not $PSBoundParameters.ContainsKey('Gen10FirmwareBundleReleaseVersion') ) {
                
                if ($SettingResource.settings.GEN10.id) {

                    $Gen10FirmwareBundleID = $SettingResource.settings.GEN10.id
                    $Gen10FirmwareBundleReleaseVersion = $True
                }
            }
            elseif ($PSBoundParameters.ContainsKey('Gen10FirmwareBundleReleaseVersion')) {
                
                try {
                    $Gen10FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen10FirmwareBundleReleaseVersion -Generation 10).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }
    
                if (-not $Gen10FirmwareBundleID) {
    
                    # Must return a message if SN/Name not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
                
            }

            if (-not $PSBoundParameters.ContainsKey('Gen11FirmwareBundleReleaseVersion') ) {
                
                if ($SettingResource.settings.GEN11.id) {

                    $Gen11FirmwareBundleID = $SettingResource.settings.GEN11.id
                    $Gen11FirmwareBundleReleaseVersion = $True

                }
            }
            elseif ($PSBoundParameters.ContainsKey('Gen11FirmwareBundleReleaseVersion')) {

                try {
                    $Gen11FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen11FirmwareBundleReleaseVersion -Generation 11).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }
    
                if (-not $Gen11FirmwareBundleID) {
    
                    # Must return a message if SN/Name not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen11FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen11FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
            }


            if ($Gen10FirmwareBundleReleaseVersion -and -not $Gen11FirmwareBundleReleaseVersion) {

                $Settings = @{ 
                    GEN10 = @{
                        id = $Gen10FirmwareBundleID
    
                    }
                }
            }

            elseif ($Gen10FirmwareBundleReleaseVersion -and $Gen11FirmwareBundleReleaseVersion) {
                
                $Settings = @{ 
                    GEN10 = @{
                        id = $Gen10FirmwareBundleID
    
                    }
                    GEN11 = @{
                        id = $Gen11FirmwareBundleID
    
                    }
                }
            }

            elseif ($Gen11FirmwareBundleReleaseVersion -and -not $Gen10FirmwareBundleReleaseVersion ) {
                
                $Settings = @{ 
                    GEN11 = @{
                        id = $Gen11FirmwareBundleID
    
                    }
                }

            }  


            $payload = @{ 
                name           = $Name
                category       = "FIRMWARE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Firmware server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Firmware server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Firmware server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more firmware server settings failed the modification attempt!"
          
            }
            
            $SetServerSettingStatus = Invoke-RepackageObjectWithType -RawObject $SetServerSettingStatus -ObjectName "COM.objStatus.NSDE"
            Return $SetServerSettingStatus
        
        }

    }
}


Function New-HPECOMSettingServerExternalStorage {
    <#
    .SYNOPSIS
    Configures an external storage server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new external storage server setting to utilize an external storage resource managed within Data Ops Manager.
    External storage server settings enable you to apply a consistent external storage configuration to servers in a group.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the external storage server setting.

    .PARAMETER Description
    Provides a description for the external storage server setting.

    .PARAMETER HostOSType
    Specifies the OS installed on the server:
        - UNKNOWN
        - AIX
        - APPLE
        - CITRIX_HYPERVISOR
        - HP_UX
        - IBM_VIO_SERVER
        - INFORM
        - NETAPP
        - OE_LINUX_UEK
        - OPENVMS
        - ORACLE_VM
        - RHE_LINUX
        - RHE_VIRTUALIZATION
        - SOLARIS
        - SUSE_LINUX
        - SUSE_VIRTUALIZATION
        - UBUNTU
        - VMWARE_ESXI
        - WINDOWS_SERVER
   
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region  us-west -Name OS-ESX -Description "My ESX OS image SS" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx.iso" 

    This command creates a new OS image configuration server setting named 'OS-ESX' using a single image containing OS and unattended installation file from the URL 'https://domain.com/esx8.iso' in the 'us-west' region.

    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region us-west -Name OS-ESX -Description "My ESX 8 OS image configuration" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx8.iso" -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso" 
    
    This command creates a new OS image configuration server setting named 'OS-ESX' using a separate image for OS from the URL 'https://domain.com/esx8.iso' and for the unattended file from the URL 'https://domain.com/esx_ks.iso'.

    .INPUTS
    Pipeline input is not supported.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the external storage server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Together')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER"
                )
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER")]
        [String]$HostOSType,

        
        [Switch]$WhatIf
       
    ) 
    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingFirmwareStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category ExternalStorage

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {

            "[{0}] Setting '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Setting '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Setting already exists in the region! No action needed."
            }

        }
        else {

            # Build payload
            $Settings = @{ 
                DEFAULT = @{
                    externalStorageHostOs = $HostOSType
    
                }
            }
    
            $payload = @{ 
                name           = $Name
                category       = "EXTERNAL_STORAGE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }
    
            $payload = ConvertTo-Json $payload -Depth 10 
    
            try {
    
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
    
                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    "[{0}] Firmware server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Firmware server setting successfully created in $Region region"
    
    
                }
            }
            catch {
    
                if (-not $WhatIf) {
    
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Firmware server setting cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
    
                }
            } 
        }
        

        [void] $NewServerSettingFirmwareStatus.add($objStatus)

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingFirmwareStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Firmware server settings failed the creation attempt!"
          
            }
            
            $NewServerSettingFirmwareStatus = Invoke-RepackageObjectWithType -RawObject $NewServerSettingFirmwareStatus -ObjectName "COM.objStatus.NSDE"
            Return $NewServerSettingFirmwareStatus
        
        }

    }
}


Function Set-HPECOMSettingServerExternalStorage {
    <#
    .SYNOPSIS
    Updates the configuration of an external storage server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies an external storage server setting resource within a designated Compute Ops Management (COM) region. If certain parameters are not specified, the cmdlet retains their existing settings and only updates those that are provided.

    .PARAMETER Name
    Specifies the name of the external storage server setting to update.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER NewName 
    Specifies the new name for the external storage server setting.

    .PARAMETER Description
    Provides a new description for the external storage server setting.

    .PARAMETER HostOSType
    Specifies the OS installed on the server. 

    "UNKNOWN" "AIX" "APPLE" "CITRIX_HYPERVISOR" "HP_UX" "IBM_VIO_SERVER" "INFORM" "NETAPP" "OE_LINUX_UEK" "OPENVMS" "ORACLE_VM" "RHE_LINUX" "RHE_VIRTUALIZATION" "SOLARIS" "SUSE_LINUX" "SUSE_VIRTUALIZATION" "UBUNTU" "VMWARE_ESXI" "WINDOWS_SERVER"
        
    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the native REST API calls utilized by COM.

    .EXAMPLE
    Set-HPECOMSettingServerExternalStorage -Region eu-central -Name AI -NewName AI-External-Storage

    This example updates the name of the external storage server setting from 'AI' to 'AI-External-Storage' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerExternalStorage -Region eu-central -Name AI-External-Storage -Description "External storage for AI hosts" -HostOSType RHE_LINUX    

    This example updates the description to 'External storage for AI hosts' and sets the host OS type to 'RHE_LINUX' for the external storage server setting named 'AI-External-Storage' in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name AI -Category ExternalStorage | Set-HPECOMSettingServerExternalStorage -Description "External storage for VMware hosts" -NewName "WMWARE-External-Storage"

    This example uses pipeline input to update the description to 'External storage for VMware hosts' and the name to 'WMWARE-External-Storage' for the external storage server setting named 'AI' retrieved from the 'eu-central' region.

    .INPUTS
    System.Collections.ArrayList
        List of external storage settings from 'Get-HPECOMSetting -Category ExternalStorage'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the external storage server setting attempted to be updated.
        * Region - The name of the region.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information regarding any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER"
                )
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER")]
        [String]$HostOSType,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category ExternalStorage
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the region!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }     
            
            if (-not $PSBoundParameters.ContainsKey('HostOSType') ) {
                
                if ($SettingResource.settings.default.externalStorageHostOs) {

                    $HostOSType = $SettingResource.settings.default.externalStorageHostOs
                }
            }
         

            # Build payload
            $Settings = @{ 
                DEFAULT = @{
                    externalStorageHostOs = $HostOSType
                }
            }

            $payload = @{ 
                name           = $Name
                category       = "EXTERNAL_STORAGE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] External storage server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External storage server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External storage server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more external storage server settings failed the modification attempt!"
          
            }
            
            $SetServerSettingStatus = Invoke-RepackageObjectWithType -RawObject $SetServerSettingStatus -ObjectName "COM.objStatus.NSDE"
            Return $SetServerSettingStatus
        
        }

    }
}

# NOT IMPLEMENTED YET
# Function New-HPECOMSettingOneViewApplianceSettings {
#     <#
#     .SYNOPSIS
#     Configure a OneView appliance settings.

#     .DESCRIPTION
#     This Cmdlet creates a new setting for OneView appliances settings
    
#     Appliance settings allow you to create a set of common configuration preferences that you can easily apply to one or more appliances in a Compute Ops Management group.
    
#     .PARAMETER Region 
#     Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
#     This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

#     Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

#     .PARAMETER Name
#     Specifies the name of the external storage server setting.

#     .PARAMETER Description
#     Specifies a description of the external storage server setting.

#     .PARAMETER HostOSType
#     Specifies the OS installed on the server. 

#     "UNKNOWN" "AIX" "APPLE" "CITRIX_HYPERVISOR" "HP_UX" "IBM_VIO_SERVER" "INFORM" "NETAPP" "OE_LINUX_UEK" "OPENVMS" "ORACLE_VM" "RHE_LINUX" "RHE_VIRTUALIZATION" "SOLARIS" "SUSE_LINUX" "SUSE_VIRTUALIZATION" "UBUNTU" "VMWARE_ESXI" "WINDOWS_SERVER"
    
#     .PARAMETER WhatIf 
#     Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
#     .EXAMPLE
#     New-HPECOMSettingServerOSImage -Region  us-west -Name OS-ESX -Description "My ESX OS image SS" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx.iso" 

#     This command creates a new OS image configuration server setting named 'OS-ESX' using a single image containing OS and unattended installation file from the URL 'https://domain.com/esx8.iso' in the 'us-west' region.

#     .EXAMPLE
#     New-HPECOMSettingServerOSImage -Region us-west -Name OS-ESX -Description "My ESX 8 OS image configuration" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx8.iso" -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso" 
    
#     This command creates a new OS image configuration server setting named 'OS-ESX' using a separate image for OS from the URL 'https://domain.com/esx8.iso' and for the unattended file from the URL 'https://domain.com/esx_ks.iso'.

#     .INPUTS
#     Pipeline input is not supported.
    
#     .OUTPUTS
#     System.Collections.ArrayList
#         A custom status object or array of objects containing the following PsCustomObject keys:
#         * Name - The name of the external storage server setting attempted to be created
#         * Region - The name of the region
#         * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
#         * Details - More information about the status 
#         * Exception: Information about any exceptions generated during the operation.

    
#    #>
#     [CmdletBinding(DefaultParameterSetName = 'Together')]
#     Param( 
#         [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
#         [ArgumentCompleter({
#                 param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
#                 # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
#                 $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
#                     [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
#                 }
#             })]
#         [String]$Region,

#         [Parameter (Mandatory)]
#         [ValidateScript({ $_.Length -le 100 })]
#         [String]$Name,  
        
#         [ValidateScript({ $_.Length -le 1000 })]
#         [String]$Description,    
        

        
#         [Switch]$WhatIf
       
#     ) 
#     Begin {
        
#         $Caller = (Get-PSCallStack)[1].Command

#         "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

#         $Uri = $COMSettingsUri
#         $NewServerSettingFirmwareStatus = [System.Collections.ArrayList]::new()
        
#     }
    
#     Process {
        
#         "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

#         # Build object for the output
#         $objStatus = [pscustomobject]@{
  
#             Name      = $Name
#             Region    = $Region                            
#             Status    = $Null
#             Details   = $Null
#             Exception = $Null
#         }
    
        
#         # Build payload
#         $Settings = @{ 
#             DEFAULT = @{
#                 externalStorageHostOs = $HostOSType

#             }
#         }

#         $payload = @{ 
#             name           = $Name
#             category       = "EXTERNAL_STORAGE"
#             description    = $Description
#             platformFamily = "ANY"
#             settings       = $Settings                  
#         }

#         $payload = ConvertTo-Json $payload -Depth 10 

#         try {

#             $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

#             if (-not $WhatIf ) {
    
#                 "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

#                 "[{0}] Firmware server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
#                 $objStatus.Status = "Complete"
#                 $objStatus.Details = "Firmware server setting successfully created in $Region region"


#             }
#         }
#         catch {

#             if (-not $WhatIf) {

#                 $objStatus.Status = "Failed"
#                 $objStatus.Details = "Firmware server setting cannot be created!"
#                 $objStatus.Exception = $_.Exception.message 

#             }
#         } 

#         [void] $NewServerSettingFirmwareStatus.add($objStatus)

        

    
#     }
    
#     End {
       

#         if (-not $WhatIf ) {

#             if ($NewServerSettingFirmwareStatus | Where-Object { $_.Status -eq "Failed" }) {
  
#                 write-error "One or more Firmware server settings failed the creation attempt!"
          
#             }
            
#             Return $NewServerSettingFirmwareStatus
        
#         }

#     }
# }



Function Remove-HPECOMSetting {
    <#
    .SYNOPSIS
    Remove a server setting from a region.

    .DESCRIPTION
    This Cmdlet can be used to remove a server setting resource from a region using its name property.       
        
    .PARAMETER Name 
    Name of the server setting to remove. 
    
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where to remove a server setting. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Force
    Switch parameter to force the removal. 
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMSetting -Region eu-central -Name 'RAID1' 
    
    Remove the server setting named 'RAID1' from the central EU region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name RAID-1 | Remove-HPECOMSetting 

    Remove server setting 'RAID-1' from the western central EU region. 

    .EXAMPLE 
    Get-HPECOMSetting -Region us-west | Where-Object {$_.name -eq 'RAID1' -or $_.name -eq 'RAID5'} | Remove-HPECOMSetting
    
    Remove server setting 'RAID1' and 'RAID5' from the western US region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central | Remove-HPECOMSetting -Force

    Remove all server settings from the central EU region using the force removal. 

    .INPUTS
    System.Collections.ArrayList
        List of server settings from 'Get-HPECOMSetting'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the server setting attempted to be removed
        * Region - Name of the region
        * Status - Status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveSettingstatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
                
        try {
            $settingResource = Get-HPECOMSetting -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $settingID = $settingResource.id

        
        if (-not $settingID) {

            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Server setting '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
       
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Server setting cannot be found in the region!"

            }
        }
        elseif ($settingID -match "00000000-0000-0000-0000") {

            if ($WhatIf) {

                $ErrorMessage = "Server setting '{0}': This resource is an HPE pre-defined setting and cannot be removed from the Compute Ops Management instance!" -f $Name       
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "This server setting is an HPE pre-defined setting that cannot be removed from the Compute Ops Management instance!"
            }
        }
        else {
            
            if ($Force) {

                $Uri = $COMSettingsUri + "/" + $settingID + "?Force=true"
            }
            else {
                
                $Uri = $COMSettingsUri + "/" + $settingID
            }

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {
                    
                    "[{0}] Server setting removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Server setting '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Server setting successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Server setting cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveSettingstatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveSettingstatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more settings has failed!"

          
            }
            
            $RemoveSettingstatus = Invoke-RepackageObjectWithType -RawObject $RemoveSettingstatus -ObjectName "COM.objStatus.NSDE"
            Return $RemoveSettingstatus
        }


    }
}






#EndRegion


#Region --- SERVERS ---

Function Get-HPECOMServer {
    <#
    .SYNOPSIS
    Retrieve the list of servers.
    
    .DESCRIPTION
    This Cmdlet returns a collection of server resources in the specified region. Switch parameters can be used to retrieve specific data such as alerts, external storage details, notification status, security parameters, adapter to switch port mapping, and to check the presence of storage volume for OS installation.
    
    For server inventory data, you must use 'Get-HPECOMServerInventory'.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER Name 
    Specifies the name or serial number of the server to display. 
    
    .PARAMETER Model 
    Optional parameter that can be used to display a specific server model only, such as 'ProLiant DL380 Gen11', 'ProLiant DL365 Gen11', etc. 
    Partial model names are not supported.
    
    .PARAMETER ConnectionType
    Optional parameter that can be used to display servers based on the connection type (Direct, OneView managed or Secure gateway).
    
    .PARAMETER ConnectedState
    A Boolean value (True or False). When set to True, only servers that are connected to HPE GreenLake will be displayed. When set to False, only servers that are not connected will be displayed.
    
    .PARAMETER PowerState
    A value of ON or OFF. When set to ON, only servers that are powered on will be displayed. When set to OFF, only servers that are powered off will be displayed.

    .PARAMETER Limit 
    This parameter allows you to define a limit on the number of servers to be displayed. 
    
    .PARAMETER ShowGroupMembership 
    Optional parameter that can be used to get the server group membership.

    .PARAMETER ShowGroupFirmwareCompliance
    Optional parameter that can be used when a server is a member of a group to get the group firmware compliance. 
    This parameter allows you to check if the server is compliant with the group's firmware baseline (if any).
      
    .PARAMETER ShowGroupFirmwareDeviation
    Optional parameter that can be used when a server is member of a group to get the group firmware deviation.
    This parameter can be useful for identifying deviations from the group's firmware baseline (if any), ensuring that the server is up to date and compliant with the group (if any).

    .PARAMETER ShowLocation 
    Optional parameter that can be used to get the server location.
    
    .PARAMETER ShowAlerts 
    Optional parameter that can be used to get the server alerts. 

    .PARAMETER ShowServersWithRecentSupportCases
    Optional parameter that can be used to get the servers with recent support cases.
    This parameter can be useful for identifying servers that have had recent issues or support cases opened, allowing for proactive management and resolution of potential problems.

    .PARAMETER ShowSupportCases
    Optional parameter to retrieve HPE support cases automatically generated by Compute Ops Management for issues related to the specified server. 
    If no support cases are found for the specified server, the cmdlet returns no output.
    
    .PARAMETER ShowNotificationStatus 
    Optional parameter that can be used to get the server notification status. 
    
    .PARAMETER ShowSecurityParameters 
    Optional parameter that can be used to get the server security parameters. 

    .PARAMETER ShowSecurityParametersDetails 
    Optional parameter that can be used to get the server security parameter details. 
    
    .PARAMETER ShowAdapterToSwitchPortMappings 
    Optional parameter that can be used to get the network connectivity of the adapter port to the connected switch port of the server. 
    
    .PARAMETER ShowAutoiLOFirmwareUpdateStatus
    Optional parameter that can be used to get the status of the automatic iLO firmware update configuration.

    .PARAMETER ShowExternalStorageDetails 
    Optional parameter that can be used to get the server external storage details. 
   
    .PARAMETER CheckifserverHasStorageVolume 
    Optional parameter that can be used to validate the presence of a storage volume for the server 
    specified for operating system installation. The response returned is a boolean.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central

    Returns data for all servers located in the Central European region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Limit 50

    Returns the first 50 servers located in the Central European region. 
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name sles15sp4

    Returns the server data for the server named 'sles15sp4' located in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name TWA22525A6 

    Returns the server data for the server with the serial number 'TWA22525A6'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowGroupMembership

    This command returns the group membership of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMserver -Region eu-central -Name ESX-1 -ShowGroupFirmwareCompliance 

    This command returns the group firmware compliance report of the server with name 'ESX-1' if it is a member of a group with a compatible firmware baseline.

    .EXAMPLE
    Get-HPECOMserver -Region eu-central -Name ESX-1 -ShowGroupFirmwareDeviation 

    This command returns the firmware components of the server with name 'ESX-1' that have deviations from the group's firmware baseline if it is a member of a group with a compatible firmware baseline.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowAlerts

    This command returns the alerts of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType Direct

    This command returns the servers that are directly connected to HPE GreenLake in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType 'OneView managed'

    This command returns the servers that are managed by OneView in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType 'Secure gateway'

    This command returns the servers that are connected to HPE GreenLake through a secure gateway in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ShowLocation

    This command returns the location of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowLocation

    This command returns the location of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowNotificationStatus

    This command returns the notification status of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ShowSecurityParameters

    This command returns the security parameters of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowSecurityParameters

    This command returns the security parameters of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowSecurityParametersDetails

    This command returns the security parameters details of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowAdapterToSwitchPortMappings

    This command returns the adapter to switch port mappings of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ShowAutoiLOFirmwareUpdateStatus

    This command returns the auto iLO firmware update status of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowAutoiLOFirmwareUpdateStatus

    This command returns the auto iLO firmware update status of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowExternalStorageDetails

    This command returns the external storage details of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectedState False
    
    Lists all servers that are not connected to Compute Ops Management.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectedState True -PowerState ON

    Lists all servers that are powered on and connected to Compute Ops Management.
    
    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model "ProLiant DL325 Gen10 Plus" -PowerState ON 

    Lists all ProLiant DL325 Gen10 Plus servers that are powered on.
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -CheckIfServerHasStorageVolume

    This command returns a True or False to indicate if the server with name 'ESX-1.domain.lab' has a storage volume for OS installation.

    .EXAMPLE
    "ESX-1", "ESX-2" | Get-HPECOMServer -Region eu-central

    Returns all servers that match the names given in the pipeline.

    .EXAMPLE
    "ESX-1", "ESX-2" | Get-HPECOMServer -Region eu-central -ShowSecurityParameters

    Retrieves server security parameters for the two servers with the specified names in the pipeline.

    .EXAMPLE
    Get-HPECOMServer -Limit 2 | Get-HPECOMServer -Region eu-central -ShowNotificationStatus 
    
    Gets the first two servers in HPE GreenLake and passes their names into the pipeline to retrieve their server notification status.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's names.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

#>

    [CmdletBinding(DefaultParameterSetName = 'ByName')]
    Param( 
    
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ByName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'CheckifserverHasStorageVolumeWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ExternalStorageDetailsWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupMembershipWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupFirmwareComplianceWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'LocationWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'NotificationStatusWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SecurityParametersWithNameForbidFilters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AlertsName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ShowSupportCasesName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupFirmwareDeviationName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SecurityParametersDetailsName')]
        [String]$Name,
        
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithoutName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithoutName')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithoutName')]
        [Parameter (ParameterSetName = 'GroupMembershipWithoutName')]
        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithoutName')]
        [Parameter (ParameterSetName = 'LocationWithoutName')]
        [Parameter (ParameterSetName = 'NotificationStatusWithoutName')]
        [Parameter (ParameterSetName = 'SecurityParametersWithoutName')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Direct', 'OneView managed', 'Secure gateway')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Direct', 'OneView managed', 'Secure gateway')]
        [String]$ConnectionType,

        
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithoutName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithoutName')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithoutName')]
        [Parameter (ParameterSetName = 'GroupMembershipWithoutName')]
        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithoutName')]
        [Parameter (ParameterSetName = 'LocationWithoutName')]
        [Parameter (ParameterSetName = 'NotificationStatusWithoutName')]
        [Parameter (ParameterSetName = 'SecurityParametersWithoutName')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('True', 'False')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('True', 'False')]
        [String]$ConnectedState,
    
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithoutName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithoutName')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithoutName')]
        [Parameter (ParameterSetName = 'GroupMembershipWithoutName')]
        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithoutName')]
        [Parameter (ParameterSetName = 'LocationWithoutName')]
        [Parameter (ParameterSetName = 'NotificationStatusWithoutName')]
        [Parameter (ParameterSetName = 'SecurityParametersWithoutName')]
        [String]$Model,
        
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithoutName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithoutName')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithoutName')]
        [Parameter (ParameterSetName = 'GroupMembershipWithoutName')]
        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithoutName')]
        [Parameter (ParameterSetName = 'LocationWithoutName')]
        [Parameter (ParameterSetName = 'NotificationStatusWithoutName')]
        [Parameter (ParameterSetName = 'SecurityParametersWithoutName')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('ON', 'OFF')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('ON', 'OFF')]
        [String]$PowerState,
        
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithoutName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithNameForbidFilters')]
        [Switch]$CheckIfServerHasStorageVolume,
        
        [Parameter (ParameterSetName = 'AlertsName')]
        [Switch]$ShowAlerts,

        [Parameter (ParameterSetName = 'ShowServersWithRecentSupportCases')]
        [Switch]$ShowServersWithRecentSupportCases,

        [Parameter (ParameterSetName = 'ShowSupportCasesName')]
        [Switch]$ShowSupportCases,
        
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Switch]$ShowAdapterToSwitchPortMappings,
        
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithoutName')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithNameForbidFilters')]
        [Switch]$ShowAutoiLOFirmwareUpdateStatus,
        
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithoutName')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithNameForbidFilters')]
        [Switch]$ShowExternalStorageDetails,

        [Parameter (ParameterSetName = 'GroupMembershipWithoutName')]
        [Parameter (ParameterSetName = 'GroupMembershipWithNameForbidFilters')]
        [Switch]$ShowGroupMembership,

        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithoutName')]
        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithNameForbidFilters')]
        [Switch]$ShowGroupFirmwareCompliance,
    
        [Parameter (ParameterSetName = 'GroupFirmwareDeviationName')]
        [Switch]$ShowGroupFirmwareDeviation,

        [Parameter (ParameterSetName = 'LocationWithoutName')]
        [Parameter (ParameterSetName = 'LocationWithNameForbidFilters')]
        [Switch]$ShowLocation,    
    
        [Parameter (ParameterSetName = 'NotificationStatusWithoutName')]
        [Parameter (ParameterSetName = 'NotificationStatusWithNameForbidFilters')]
        [Switch]$ShowNotificationStatus,
        
        [Parameter (ParameterSetName = 'SecurityParametersWithoutName')]
        [Parameter (ParameterSetName = 'SecurityParametersWithNameForbidFilters')]
        [Switch]$ShowSecurityParameters,
        
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Switch]$ShowSecurityParametersDetails,
            
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatusWithoutName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeWithoutName')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsWithoutName')]
        [Parameter (ParameterSetName = 'GroupMembershipWithoutName')]
        [Parameter (ParameterSetName = 'GroupFirmwareComplianceWithoutName')]
        [Parameter (ParameterSetName = 'LocationWithoutName')]
        [Parameter (ParameterSetName = 'NotificationStatusWithoutName')]
        [Parameter (ParameterSetName = 'SecurityParametersWithoutName')]
        [Parameter (ParameterSetName = 'ShowServersWithRecentSupportCases')]
        [ValidateScript({ $_ -le 100 })]
        [int]$Limit,

        [Switch]$WhatIf
        
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMServersUri 
   
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($Name) {       

            # $Uri = $COMServersUri + "?filter=name eq '$Name'"   # Filter that supports only serial numbers
            $Uri = $COMServersUri + "?filter=host/hostname eq '$Name' or name eq '$Name'"   # Filter that supports both serial numbers and server names
        }
        else {
            
            $Uri = $COMServersUri 

        }       
        


           
        if ($PSBoundParameters.ContainsKey('Model')) {

            if ($Uri -match "\?filter=" ) {
                
                $Uri = $Uri + " and hardware/model eq '$Model'"

            }
            else {

                $Uri = $Uri + "?filter=hardware/model eq '$Model'"

            }
        }
       
        if ($PSBoundParameters.ContainsKey('ConnectedState')) {

            if ($ConnectedState -eq 'True') {	
    
                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and state/connected eq true"

                }
                else {
                    $Uri = $Uri + "?filter=state/connected eq true"

                }
            }
            else {

                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and state/connected eq false"

                }
                else {
                    $Uri = $Uri + "?filter=state/connected eq false"

                }
            }
        }

        if ($PSBoundParameters.ContainsKey('PowerState')) {

            if ($PowerState -eq 'ON') {    

                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and hardware/powerState eq 'ON'"

                }
                else {
                    $Uri = $Uri + "?filter=hardware/powerState eq 'ON'"

                }               
            }
            else {

                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and hardware/powerState eq 'OFF'"

                }
                else {
                    $Uri = $Uri + "?filter=hardware/powerState eq 'OFF'"

                }   
            }
        }

        if ($PSBoundParameters.ContainsKey('Limit')) {
            
            if ($Uri -match "\?") {
                
                $Uri = $Uri + "&limit=$Limit"

            }
            else {
            
                $Uri = $Uri + "?limit=$Limit"

            }

        }


        # Set $Uri
        if (       
            $ShowAlerts `
                -or $ShowSupportCases `
                -or ($ShowExternalStorageDetails -and $Name) `
                -or ($ShowNotificationStatus -and $Name) `
                -or $ShowSecurityParametersDetails `
                -or $ShowAdapterToSwitchPortMappings `
                -or ($CheckifserverHasStorageVolume -and $Name) `
        ) {
                

            try {
                [Array]$Server = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region               

                if ($Null -eq $Server) { 
                
                    Return
           
                }
                elseif ($server.count -gt 1) {
                    throw "Multiple servers found with the name '$Name'. Please refine your query to return only one server or use the serial number to retrieve the server details."
                }
                else {
                    
                    $ServerID = $Server.id
                        
                    "[{0}] ID found for server name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $ServerID | Write-Verbose                  
                        
                }
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
       
        
        
      
        # NOT SUPPORTED FILTER
        #   if ($PSBoundParameters.ContainsKey('ConnectionType')) {

        #     if ($ConnectionType -eq 'Direct') {	
        #         # If $Uri contains a query parameter            
        #         if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "&filter=connectionType eq 'DIRECT'"
        #         }
        #         elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {

        #             $Uri = $Uri + "?filter=connectionType eq 'DIRECT'"

        #         }
        #         else {

        #             $Uri = $Uri + " and connectionType eq 'DIRECT'"

        #         }
        #     }
        #     else {
        #         # If $Uri contains a query parameter            
        #         if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "&filter=connectionType eq 'ONEVIEW'"
        #         }
        #         elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "?filter=connectionType eq 'ONEVIEW'"
                
        #         }
        #         else {
                
        #             $Uri = $Uri + " and connectionType eq 'ONEVIEW'"
                
        #         }
        #     }
        # }

     
        # Requests using $ServerID in URI    
        if ($ShowAlerts) {

            $Uri = $COMServersUri + "/" + $ServerID + "/alerts"

            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

        }
        elseif ($ShowSupportCases) {

            # Get server info
            $Uri = $COMServersUIDoorwayUri + "/" + $ServerID 

            # Invoke the web request using the UI Doorway URL - Needed to get support case information
            "[{0}] Invoke web request using the UI Doorway URL to get support case information: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose
            
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

            # Get server alerts
            $Uri = $COMServersUIDoorwayUri + "/" + $ServerID + "/alerts?offset=0&limit=800"

            # Invoke the web request using the UI Doorway URL - Needed to get support case information
            "[{0}] Invoke web request using the UI Doorway URL to get support case information: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose
            
            try {
                [Array]$AlertsCollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf              

                $ListofCases = [System.Collections.ArrayList]::new()

                foreach ($alert in $AlertsCollectionList) {

                    $Object = [PSCustomObject]@{
                        name = $CollectionList.name
                        serialnumber = $CollectionList.hardware.serialNumber
                        model = $CollectionList.hardware.model
                        iloIpAddress = $CollectionList.hardware.bmc.ip
                        description = $Null
                        resolution = $Null
                        message = $Null
                        caseId  = $Null
                        caseState = $Null
                        caseURL = $Null
                        createdAt = $Null
                    }

                    if ($null -ne $alert.case_.Id) {

                        $Object.description = $alert.description
                        $Object.resolution = $alert.resolution
                        $Object.message = $alert.message
                        $Object.caseId = $alert.case_.caseId
                        $Object.caseState = $alert.case_.caseState
                        $Object.caseURL = $alert.case_.caseURL
                        $Object.createdAt = $alert.createdAt
                        
                        [void]$ListofCases.Add($Object)                     
                    }
                }
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

        }
        elseif ($ShowExternalStorageDetails -and $Name) {

            $Uri = $COMServersUri + "/" + $ServerID + "/external-storage-details"

            
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction SilentlyContinue
            }

            catch {    
                return
            }
        }
        elseif ($ShowNotificationStatus -and $Name) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/notifications"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        elseif ($ShowSecurityParametersDetails) {

            if ($server.connectionType -eq "ONEVIEW") {

                Write-Error "The iLO security settings are not supported on server '$Name'."
                Return
    
            }
            else {
                
                $Uri = $COMServersUri + "/" + $ServerID + "/security-parameters"
                
                try {
                    [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                    
                }
                catch {
                    
                    Write-Error "Unable to retrieve iLO security parameters details for '$Name'. Please check the iLO event logs for more details."
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                    
            }
                    
        }
        elseif ($ShowAdapterToSwitchPortMappings) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/tor-port-mappings"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        # Requests with no $ServerID in URI
        elseif ($ShowServersWithRecentSupportCases){
            try {

                # Get server with recent created cases
                # $uri = $COMServersUri + "?limit=100&sort=hardware/health/summary desc&filter=(supportCaseCount_ gt 0)" # Not supported
                $uri = "/ui-doorway/compute/v2/servers?limit=100&sort=hardware/health/summary desc&filter=(supportCaseCount_ gt 0)"

                $FilterList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

                $CollectionList = $FilterList.items
                "[{0}] List of server names with recent support cases: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($CollectionList.name) | Write-Verbose
                
                # Convert to PSCustomObject array
                $structuredArray = $CollectionList | ForEach-Object {
                    if ($_ -is [hashtable]) {
                        [PSCustomObject]$_
                    } else {
                        [PSCustomObject]@{ Name = $_; Value = $null }
                    }
                }

                $CollectionList = $structuredArray

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
               
            }

        }
        else {

            try {
                [Array]$AllCollection = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
               
            }


            if ($Null -ne $AllCollection) {     
                            
                $CollectionList = $AllCollection
        
            }

        }

        $ReturnData = @()
               
        # Format response with Repackage Object With Type
        if ($Null -ne $CollectionList) {     
            
            # Add region, serverName and iLOIPAddress to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serverName -value $_.name }
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name iLOIPAddress -value $_.hardware.bmc.ip}

            if ($ConnectionType) {
                   
                switch ($ConnectionType) {
                    'Secure gateway' { $_ConnectionType = 'GATEWAY' }
                    'OneView managed' { $_ConnectionType = 'ONEVIEW' }
                    'Direct' { $_ConnectionType = 'DIRECT' }
                }

                $CollectionList = $CollectionList | where-Object ConnectionType -eq $_ConnectionType

                "[{0}] --------------------------- Final content of `$CollectionList - Number of items : {1} ------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($CollectionList.count) | Write-Verbose
                "[{0}] --------------------------- Final content of `$CollectionList ------------------------------------------------------------------------`n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($CollectionList | Out-String) | Write-Verbose
                "[{0}] ---------------------------------------------------------------------------------------------------------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                
            }
                                       
            if ($ShowAlerts) {

                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServer -Region $Region -Name  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1] }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.Alert"    
                
            }
            elseif ($ShowServersWithRecentSupportCases) {

                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.Id -split '\+')[1] }
                # $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1] }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.WithSupportCases"    
                # $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers"    

            }
            elseif ($ShowSupportCases) {

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ListofCases -ObjectName "COM.Servers.Support"    
                
            }
            elseif ($ShowExternalStorageDetails) {

                if ($Name) {
                    # Add serial number, servername, model and connectionType to object
                    $_Server = (Get-HPECOMServer -Region $Region -Name  ($CollectionList.serverId -split '\+')[1])
                    $CollectionList | Add-Member -type NoteProperty -name serverName -value $_Server.name -Force
                    $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1] }
                    $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name model -value $_Server.hardware.model }
                    $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name connectionType -value $_Server.connectionType }
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.ExternalStorageDetails"    
                    
                }
                else {

                    $NewCollectionList = [System.Collections.ArrayList]::new()

                    foreach ($Item in $CollectionList) {

                        $Uri = $COMServersUri + "/" + $Item.ID + "/external-storage-details"

                        try {
                                 
                            $ServerExternalStorageDetails = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction SilentlyContinue

                            if ($ServerExternalStorageDetails ) {

                                $_ServerExternalStorageDetails = [PSCustomObject]@{
                                    model          = $Item.hardware.model
                                    serverId       = $Item.id
                                    serverName     = $Item.name   
                                    serialNumber   = $Item.hardware.serialNumber 
                                    connectionType = $Item.connectionType
                                    volumeDetails  = $ServerExternalStorageDetails.VolumeDetails
                                    HostName       = $ServerExternalStorageDetails.HostName
                                    HostGroups     = $ServerExternalStorageDetails.HostGroups
                                    HostOS         = $ServerExternalStorageDetails.HostOS
                                    region         = $Region
                                }
                                    

                                "[{0}] _ServerExternalStorageDetails object built content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_ServerExternalStorageDetails | Out-String) | Write-Verbose

                                [void]$NewCollectionList.add($_ServerExternalStorageDetails)

                                "----------------------------------------- Item added to collection:--------------------------------------------------- `n{0}" -f ($_ServerExternalStorageDetails | out-String ) | Write-Verbose
                            }
                            
                        }
                        catch {

                            "[{0}] ServerExternalStorageDetails content not available" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            Continue
                        }

                    }

                    $NewCollectionList = $NewCollectionList | Sort-Object -Property serverName, serialNumber
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.ExternalStorageDetails" 
                }   
            }
            elseif ($ShowNotificationStatus) {

                if ($Name) {

                    # Add serial number, servername, model and connectionType to object
                    $_Server = (Get-HPECOMServer -Region $Region -Name  ($CollectionList.serverId -split '\+')[1])
                    $CollectionList | Add-Member -type NoteProperty -name serverName -value $_Server.name -Force
                    $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1] }
                    $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name model -value $_Server.hardware.model }
                    $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name connectionType -value $_Server.connectionType }
    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.NotificationStatus"    

                }
                else {

                    $NewCollectionList = [System.Collections.ArrayList]::new()

                    foreach ($Item in $CollectionList) {

                        # Not using COM API 
                        # $Uri = $COMServersUri + "/" + $Item.ID + "/security-parameters"
                        # Using /ui-doorway/compute/v2/servers/<serverID>
                        $Uri = $COMServersUIDoorwayUri + "/" + $Item.ID 

                        try {
                                
                            # $_ServerSecurityParameters = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            $_Server = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

                            "[{0}] Response type: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Server.GetType().FullName | Write-Verbose

                            if ($Null -ne $_Server.notifications_ ) {

                                "[{0}] notifications_ content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_Server.notifications_ | Out-String) | Write-Verbose

                                $_ServerNotifications = [PSCustomObject]@{
                                    model                          = $_Server.hardware.model
                                    serverId                       = $_Server.id
                                    serverName                     = $_Server.name   
                                    serialNumber                   = $_Server.hardware.serialNumber 
                                    connectionType                 = $_Server.connectionType_
                                    healthNotification             = $_Server.notifications_.healthNotification
                                    healthNotificationUsersCount   = $_Server.notifications_.healthNotificationUsersCount_
                                    criticalNotification           = $_Server.notifications_.criticalNotification
                                    criticalNotificationUsersCount = $_Server.notifications_.criticalNotificationUsersCount_
                                    criticalNonServiceNotification = $_Server.notifications_.criticalNonServiceNotification
                                    warningNotification            = $_Server.notifications_.warningNotification
                                    serverNotificationUsersCount   = $_Server.notifications_.serverNotificationUsersCount_
                                    region                         = $Region
                                }
                                    

                                "[{0}] _ServerNotifications object built content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_ServerNotifications | Out-String) | Write-Verbose

                            }
                            else {

                                "[{0}] notifications_ content not available" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                               
                            }

                            [void]$NewCollectionList.add($_ServerNotifications)

                            "----------------------------------------- item added to collection:--------------------------------------------------- `n{0}" -f ($_ServerNotifications | out-String ) | Write-Verbose
    

                        }
                        catch {

                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                    }

                    $NewCollectionList = $NewCollectionList | Sort-Object -Property serverName, serialNumber
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.NotificationStatus"  

                }                
            }
            elseif ($ShowSecurityParameters) {

                $NewCollectionList = [System.Collections.ArrayList]::new()

                foreach ($Item in $CollectionList) {

                    # Not using COM API as there is an issue with OneView servers at the moment (Error 404 with OneView servers, case 5385212183 )
                    # $Uri = $COMServersUri + "/" + $Item.ID + "/security-parameters"
                    # So retrieved from /ui-doorway/compute/v2/servers/<serverID>
                    $Uri = $COMServersUIDoorwayUri + "/" + $Item.ID 

                    try {
                            
                        # $_ServerSecurityParameters = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                        $_Server = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

                        "[{0}] Response: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Server | Write-Verbose

                        "[{0}] Response type: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Server.GetType().FullName | Write-Verbose

                        # Due to convert response from json exception returned by this request sometimes, object generated is a PSObject with name/value that breaks the .add() later, so it needs to be converted to PSCustomObject
                        if ($Null -ne $_Server.iloSecurity_ ) {

                            "[{0}] Response detected with iloSecurity_ content" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Server.GetType().FullName | Write-Verbose
                                                            
                            $_ServerSecurityParameters = [PSCustomObject]@{
                                iLOVersion            = $_Server.iloSecurity_.iLOVersion 
                                overallSecurityStatus = $_Server.iloSecurity_.overallSecurityStatus
                                iLOGeneration         = $_Server.iloSecurity_.iLOGeneration 
                                id                    = $_Server.iloSecurity_.id
                                IloSecurityParams     = $_Server.iloSecurity_.iloSecurityParams      
                            }
                                

                            "[{0}] iloSecurity_ content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_ServerSecurityParameters | Out-String) | Write-Verbose

                        }
                        else {

                            "[{0}] iloSecurity_ content not available, creating object..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            # If server is connected
                            if ($Item.state.connected -eq $True) {

                                if ($_Server.iloFirmwareVersion_ -eq "UNKNOWN") {

                                    $iLOVersion = "UNKNOWN"
                                    $iLOGeneration = "UNKNOWN"


                                }
                                else {
                                    $iLOVersion = $_Server.iloFirmwareVersion_.substring(5)
                                    $iLOGeneration = $_Server.iloFirmwareVersion_.substring(0, 4)
                                }
                               
                                $_ServerSecurityParameters = [PSCustomObject]@{
                                    iLOVersion            = $iLOVersion
                                    overallSecurityStatus = "Not available"
                                    iLOGeneration         = $iLOGeneration
                                    id                    = $Item.id
                                    IloSecurityParams     = @()
                                }

                            }
                            else {

                                $_ServerSecurityParameters = [PSCustomObject]@{
                                    iLOVersion            = $Item.iloFirmwareVersion_
                                    overallSecurityStatus = "Not available"
                                    iLOGeneration         = $Item.iloFirmwareVersion_
                                    id                    = $Item.id
                                    IloSecurityParams     = @()
                                }

                            }
                        }



                        # Add serial number, servername, model and connectionType to object
                        # $_ServerName = (Get-HPECOMServer -Region $Region -Name  ($Item.id -split '\+')[1]).name
                        # $_ServerSecurityParameters | Add-Member -type NoteProperty -name serverName -value $_ServerName 
                            
                        $_ServerSecurityParameters | Add-Member -type NoteProperty -name serverName -value $_Server.Name 
                        # $_ServerSecurityParameters | Add-Member -type NoteProperty -name serialNumber -value ($Item.id -split '\+')[1]
                            
                        $_ServerSecurityParameters | Add-Member -type NoteProperty -name serialNumber -value $_Server.hardware.serialNumber 

                        $_ServerSecurityParameters | Add-Member -type NoteProperty -name model -value $_Server.hardware.model 
                        $_ServerSecurityParameters | Add-Member -type NoteProperty -name connectionType -value $_Server.connectionType_ 


                        [void]$NewCollectionList.add($_ServerSecurityParameters)

                        "----------------------------------------- item added to collection:--------------------------------------------------- `n{0}" -f ($_ServerSecurityParameters | out-String ) | Write-Verbose

                    }
                    catch {

                        $PSCmdlet.ThrowTerminatingError($_)
                        
                    }
                }

                # "-------------- Content of final object: `n{0}" -f   ($NewCollectionList|Out-String )| Write-Verbose

                $NewCollectionList = $NewCollectionList | Sort-Object -Property serverName, serialNumber
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters"  

            }   
            elseif ($ShowSecurityParametersDetails) {
       
                $NewCollectionList = [System.Collections.ArrayList]::new()

                $_ServerName = (Get-HPECOMServer -Region $Region -Name  ($CollectionList.Id -split '\+')[1]).name

                if ($CollectionList.IloSecurityParams) {

                    foreach ($IloSecurityParam in $CollectionList.IloSecurityParams) {
                        # Add serial number and region to object
                        $IloSecurityParam | Add-Member -type NoteProperty -name serialNumber -value ($CollectionList.Id -split '\+')[1]  
                        $IloSecurityParam | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                        $IloSecurityParam | Add-Member -type NoteProperty -name region -value $Region
                        
                        [void]$NewCollectionList.add($IloSecurityParam)
                    }
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters.Details"    
                }    
                else {
                    Return
                } 
                
            }                       
            elseif ($ShowAdapterToSwitchPortMappings) {
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServer -Region $Region -Name  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1] }        
         
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.AdapterToSwitchPortMappings"    
                
            } 
            elseif ($ShowGroupMembership) {

                $NewCollectionList = [System.Collections.ArrayList]::new()

                # Get Groups with members
                $_Groups = Get-HPECOMGroup -Region $Region | Where-Object { $_.devices.count -gt 0 }

                foreach ($Item in $CollectionList) {

                    if ($_Groups) {

                        $GroupName = ($_Groups | Where-Object { $_.devices.serial -eq $Item.hardware.serialNumber }).name
                        
                        # Groups are not supported with OneView servers
                        if (-not $GroupName -and $Item.connectionType -eq "ONEVIEW") {   
                            
                            $GroupName = "Unsupported"
                            
                        }
                        elseif (-Not $GroupName) {
                            $GroupName = ""
                            # $GroupName = "No group"
                        }

                        
                        # Add group name to object
                        $Item | Add-Member -type NoteProperty -name associatedGroupname -value $GroupName

                        [void]$NewCollectionList.add($Item)
                        
                    }
                }                
                
                $NewCollectionList = $NewCollectionList | Sort-Object -Property name, { $_.hardware.serialnumber }
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.GroupMembership"    

            }       
            elseif ($ShowLocation) {

                $NewCollectionList = [System.Collections.ArrayList]::new()

                try {

                    $_Devices = Get-HPEGLDevice 
                    
                    # As OneView servers are not available in GLP, location must be retrieved from /ui-doorway/compute/v2/servers
                    $_Servers = Invoke-HPECOMWebRequest -Method Get -Uri $COMServersUIDoorwayUri -Region $Region -WhatIfBoolean $WhatIf 
                    
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                        
                }

                foreach ($Item in $CollectionList) {

                    # Add serial number to object
                    $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.Id -split '\+')[1]  

                    if ($_Devices) {

                        $LocationName = ($_Devices | Where-Object serial_number -eq $Item.serialNumber).location_name
                        $LocationID = ($_Devices | Where-Object serial_number -eq $Item.serialNumber).location_id

                        if (-not $LocationName) {
                            # The case for OneView servers
                            
                            $LocationName = ($_Servers.items | Where-Object { $_.hardware.serialNumber -eq $Item.serialNumber }).locationInfo_.name
                            $LocationID = ($_Servers.items | Where-Object { $_.hardware.serialNumber -eq $Item.serialNumber }).locationInfo_.locationId
                            
                        }
                                            
                        # Add location name and id to object
                        $Item | Add-Member -type NoteProperty -name Location -value $LocationName
                        $Item | Add-Member -type NoteProperty -name LocationId -value $LocationID
                        
                        [void]$NewCollectionList.add($Item)
                        
                    }
                }     
                
                $NewCollectionList = $NewCollectionList | Sort-Object -Property name, { $_.hardware.serialnumber }
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.Location"    
                
            } 
            elseif ($CheckifserverHasStorageVolume) {

                $NewCollectionList = [System.Collections.ArrayList]::new()

                foreach ($Item in $CollectionList) {

                    $Uri = $COMServersUri + "/" + $Item.ID + "/analyze-os-install"
                    $Payload = @{id = $Item.ID } | ConvertTo-Json

                    try {
                        [Array]$_ServerAnalyseOSInstall = Invoke-HPECOMWebRequest -Method POST -Uri $Uri -Body $payload -Region $Region -WhatIfBoolean $WhatIf -ErrorAction SilentlyContinue
                        
                        # if ($_ServerAnalyseOSInstall.serverHasStorageVolume) {
                        $Item | Add-Member -type NoteProperty -name serverHasStorageVolume -value $_ServerAnalyseOSInstall.serverHasStorageVolume
                        [void]$NewCollectionList.add($Item)
                        # }
                    }
                    catch [System.Net.Http.HttpRequestException] {
                        continue
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                            
                    }
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.OSInstallAnalysis"    

            }
            elseif ($ShowGroupFirmwareCompliance) {

                $NewCollectionList = [System.Collections.ArrayList]::new()

                $_GroupMemberships = (Get-HPECOMServer -Region $Region -ShowGroupMembership )

                foreach ($Item in $CollectionList) {

                    "[{0}] Item: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Item | Write-Verbose

                    try {

                        $_GroupName = $_GroupMemberships | Where-Object { $_.hardware.serialNumber -eq $Item.hardware.serialNumber } | Select-Object -ExpandProperty associatedGroupname

                        "[{0}] `$_Groupname found: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_GroupName | Write-Verbose
                        
                        if ($_GroupName -ne "No group" -and $_GroupName -ne "Unsupported") {

                            $_Resp = Get-HPECOMGroupFirmwareCompliance -Region $Region -GroupName $_GroupName -ServerSerialNumber $Item.hardware.serialNumber
                            
                            [void]$NewCollectionList.add($_Resp)
                            
                        }
                        else {
                            "[{0}] No group found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        }

                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                            
                    }
                }

                $ReturnData = $NewCollectionList

            }
            elseif ($ShowGroupFirmwareDeviation) {

                $NewCollectionList = [System.Collections.ArrayList]::new()

                $_GroupMemberships = (Get-HPECOMServer -Region $Region -ShowGroupMembership )

                foreach ($Item in $CollectionList) {

                    "[{0}] Item: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Item | Write-Verbose

                    try {
                        
                        $_GroupName = $_GroupMemberships | Where-Object { $_.hardware.serialNumber -eq $Item.hardware.serialNumber } | Select-Object -ExpandProperty associatedGroupname

                        "[{0}] `$_Groupname found: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_GroupName | Write-Verbose
                       
                        if ($_GroupName -ne "No group" -and $_GroupName -ne "Unsupported") {
                            
                            $_Resp = Get-HPECOMGroupFirmwareCompliance -Region $Region -GroupName $_GroupName -ServerSerialNumber $Item.hardware.serialNumber -Deviations
                            
                            # # Add serial number and servername to object
                            $_Resp | Add-Member -type NoteProperty -name serialNumber -value $Item.serialNumber
                            $_Resp | Add-Member -type NoteProperty -name serverName -value $Item.ServerName 
                            
                            [void]$NewCollectionList.add($_Resp)
                            
                        }
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                            
                    }
                }

                $ReturnData = $NewCollectionList

            }
            else {

                $NewCollectionList = [System.Collections.ArrayList]::new()
                
                foreach ($Item in $CollectionList) {

                    # "[{0}] Item: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Item | Write-Verbose
                    
                    # Add serial number and part number to object
                    $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.Id -split '\+')[1]  
                    $Item | Add-Member -type NoteProperty -name partNumber -value $Item.hardware.productId  

                    # "[{0}] added SN: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Item.Id -split '\+')[1]   | Write-Verbose

                    [void]$NewCollectionList.add($Item)

                }      
               

                if ($ShowAutoiLOFirmwareUpdateStatus ) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.autoIloFwUpdateStatus"    
                    $ReturnData = $ReturnData | Sort-Object name, serialNumber 
   
                }
                elseif ($ShowGroupFirmwareDeviation) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Groups.Compliance.Deviations"   

                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                elseif (-not $ShowGroupFirmwareCompliance) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers"   
                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                else {
                    $ReturnData = $NewCollectionList
                }
            }

            if (-not $WhatIf) {
                
                return $ReturnData 

            }
           
        }
        else {

            return
                
        }         
    }
}


Function Get-HPECOMServeriLOSSO {
    <#
    .DESCRIPTION
    Obtain an iLO SSO Token URL or iLO session object to authenticate to an iLO.

    The generated SSO token or session object can be used with other HPE libraries that support iLO session tokens, such as the HPEiLOCmdlets module. 
    This allows for seamless integration and interaction with iLOs, enabling tasks such as running native iLO API RedFish calls or using the HPEiLOCmdlets module for various iLO operations.

    Important note: SSO is not currently supported on servers managed by HPE OneView.

    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER SerialNumber
    The serial number of the server for which the iLO SSO token will be generated.

    .PARAMETER GenerateXAuthToken 
    Generates an iLO session object that can be used later to configure the iLO via native RedFish calls (compliant with the X-Auth-Token header) or via the HPEiLOCmdlets (compliant with the XAuthToken parameter of Connect-HPEiLO).

    .PARAMETER RemoteConsoleOnly
    Generates an SSO URL Token for accessing the Remote Console.

    .PARAMETER SkipCertificateValidation
    Optional parameter that can be used to skip certificate validation checks, including all validations such as expiration, revocation, trusted root authority, etc.

    [WARNING]: Using this parameter is not secure and is not recommended. This switch is only intended to be used against known hosts using a self-signed certificate for testing purposes. Use at your own risk.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    # Get server information
    $server = Get-HPECOMServer -Region eu-central -Name ESX-Gen10P-1.lj.lab

    # Get iLO IP
    $iLO_IP = $server.hardware.bmc.ip

    # Generate an iLO SSO Object that can then be used with the HPEiLOCmdlets module.
    $SSOObject = $server | Get-HPECOMServeriLOSSO -GenerateXAuthToken  -SkipCertificateValidation

    # Get iLO SSO Token
    $iLOSessionKey = $SSOObject."X-Auth-Token"

    # Connect to iLO using HPEiLOCmdlets module and the iLO SSO Token
    $connection = Connect-HPEiLO -Address $iLO_IP -XAuthToken $SSOObject."X-Auth-Token" -DisableCertificateAuthentication

    # Get iLO User Information
    (Get-HPEiLOUser -Connection $connection).userinformation

    This example shows how to generate an iLO SSO Object that can then be used with the HPEiLOCmdlets module to connect to an iLO and retrieve user information.

    .EXAMPLE
    Get-HPECOMServeriLOSSO -Region eu-central -SerialNumber "CZ2311004H" -GenerateXAuthToken  -SkipCertificateValidation

    Generate an iLO SSO Object that can then be used with the HPEiLOCmdlets module, skipping certificate validation.
    [WARNING]: Using this parameter is not secure and is not recommended. This switch is only intended to be used against known hosts using a self-signed certificate for testing purposes. Use at your own risk.

    .EXAMPLE
    $SSOObject = Get-HPECOMServer -Region eu-central -Name ESX-Gen10P-1.lj.lab | Get-HPECOMServeriLOSSO

    Generate an iLO SSO Object for the server named 'ESX-Gen10P-1.lj.lab' located in the Central European region.

    .EXAMPLE
    $SSOObject = Get-HPECOMServer -Region eu-central -Name CZ1234567 | Get-HPECOMServeriLOSSO -GenerateXAuthToken 

    Generate an iLO SSO Object that can then be used with the HPEiLOCmdlets module.

    .EXAMPLE
    $SSOObjects = Get-HPECOMServer -Region eu-central | Get-HPECOMServeriLOSSO

    Generate iLO SSO Objects for all servers located in the Central European region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's names.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Management.Automation.PSCustomObject
        SSO URL Object

    System.Array
        Multiple SSO URL objects.

    System.Management.Automation.PSCustomObject
        The session object generated for the iLO
    #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumberGenerateXAuthToken ')]
    Param( 
    
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumberGenerateXAuthToken ')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumberRemoteConsoleOnly')]
        [alias('serial')]
        [String]$SerialNumber,
        
        [Parameter (ParameterSetName = 'SerialNumberGenerateXAuthToken ')]
        [Switch]$GenerateXAuthToken ,

        [Parameter (ParameterSetName = 'SerialNumberRemoteConsoleOnly')]
        [Switch]$RemoteConsoleOnly,

        [Switch]$SkipCertificateValidation,
        
        [Switch]$WhatIf
        
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GetSSOUrl'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $Uri = $COMJobsUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
   
    }
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $objStatus = [pscustomobject]@{               
            associatedResource = $SerialNumber
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)
       
    }

    End {
        
        "[{0}] ObjectStatusList content '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | out-string) | Write-Verbose

        try {
            
            $Servers = Get-HPECOMServer -Region $Region
       
        }
        catch {

            $PSCmdlet.ThrowTerminatingError($_)
            
        }
         
        foreach ($Resource in $ObjectStatusList) {
            
            $Server = $Servers | Where-Object serialNumber -eq $Resource.associatedResource
            
            if (-not $Server) {
                
                Throw "Server with serial number '$($Resource.associatedResource)' not found in the region '$Region'."

            } 
            else {     
                
                $_serverResourceUri = $Server.resourceUri
                $_serverIloIpAddress = $Server.hardware.bmc.ip
                
                # Test network connectivity with iLO
                $IsILOAccessible = (New-Object System.Net.NetworkInformation.Ping).Send($_serverIloIpAddress, 4000) 

                "[{0}] PING iLO '{1}' test result: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverIloIpAddress, $IsILOAccessible.status | Write-Verbose
    
                if ($Server.connectionType -eq "ONEVIEW") {

                    Throw "iLO SSO is currently not supported on servers managed by HPE OneView."
                }
                elseif ($server.state.connected -ne $True) {

                    Throw "The server's iLO is not connected to COM. Please connect your iLO to Compute Ops Management first."
                }
                elseif ($IsILOAccessible.Status -ne "Success") {
                    
                    throw "The server's iLO IP address '$($_serverIloIpAddress)' is not reachable. Please ensure your are connected to the iLO network."
                }

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_serverResourceUri
                    data           = @{
                        iloTargetUrl = $_serverIloIpAddress
                    }
                }

                $payload = ConvertTo-Json $payload -Depth 10 

                try {
        
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -Method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf
                    
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
            
                    if (-not $Whatif) {

                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 20 
                        
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
                        
                        $ssoResourceUri = $_resp.statusDetails.sso_resource_uri
                        
                        "[{0}] ssoResourceUri returned: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ssoResourceUri | Write-Verbose
                        
                        $ssoUrlContent = Invoke-HPECOMWebRequest -Region $Region -Uri $ssoResourceUri -Method GET 
                        
                        $ssoUrl = $ssoUrlContent.sso_url

                        "[{0}] SSO URL returned: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ssoUrl | Write-Verbose
                       
                        if ($GenerateXAuthToken  -or $RemoteConsoleOnly) {
                            
                            # Make an HTTP request to the SSO URL
                            "[{0}] About to run GET with the SSO URL..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose  

                            if ($SkipCertificateValidation) {

                                "[{0}] SkipCertificateValidation parameter detected." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose  
                                
                                $response = Invoke-WebRequest -Uri $ssoUrl -Method Get -SessionVariable session -SkipCertificateCheck -ErrorAction Stop
                                                            
                            }
                            else {

                                "[{0}] SkipCertificateValidation parameter not detected." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose  
                
                                $response = Invoke-WebRequest -Uri $ssoUrl -Method Get -SessionVariable session -ErrorAction Stop
                            }

                            "[{0}] Received status code response: {1} - Description: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $response.StatusDescription | Write-verbose           
        
                            $cookies = $session.Cookies.GetCookies($ssoUrl)
        
                            "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                            foreach ($cookie in $cookies) { 
                                
                                "[{0}] {1} = {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookie.name, $cookie.value | Write-Verbose
                                
                                # Extract the 'sessionKey' cookie value
                                if ($cookie.name -match 'sessionKey') {
                                    
                                    $sessionKey = $cookie.Value 
                                    
                                    "[{0}] `$sessionKey = {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $sessionKey | Write-Verbose
                                    
                                }
                            }       
                        }
                    
                        if ($GenerateXAuthToken ) {
                        
                            # Extract the base URL using regex
                            $baseUrl = $ssoUrl -replace "^(https://[^/]+).*", '$1/'

                            "[{0}] X-Auth-Token extracted from SSO URL: {1} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $baseUrl | Write-Verbose

                            $rootUri = $baseUrl + "/rest/v1"
                            
                            $object = [PSCustomObject]@{
                                rootUri        = $rootUri
                                'X-Auth-Token' = $sessionKey
                            }

                            return $object

                        }
                        elseif ($RemoteConsoleOnly) {
                            
                            # Extract the IP address using regex
                            $ipAddress = $ssoUrl -replace "https://([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+).*", '$1'

                            $RemoteConsoleUrl = "hplocons://addr=" + $ipAddress + "&sessionkey=" + $sessionKey
        
                            $object = [PSCustomObject]@{
                                remoteConsoleUrl = $RemoteConsoleUrl                            
                            }
                            
                            return $object

                        }
                        else {
                            
                            $object = [PSCustomObject]@{
                                iloSsoUrl = $ssoUrl                            
                            }
                            
                            return $object
                        }   
                    }                                                        
                }                    
                catch {
                    
                    $PSCmdlet.ThrowTerminatingError($_)
                }
            }
        }
    }
}



Function Enable-HPECOMServerAutoiLOFirmwareUpdate {
    <#
    .SYNOPSIS
    Enable the automatic iLO firmware update.

    .DESCRIPTION
    This Cmdlet can be used to enable the iLO automatic firmware update for a specified server in a region.    

    The iLO automatic firmware update status can be checked using 'Get-HPECOMServer -Region eu-central -ShowAutoiLOFirmwareUpdateStatus -Name <nameserver>' 
        
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where to enable the automatic iLO firmware update
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER SerialNumber
    Serial number of the server on which the iLO automatic firmware update preference will be enabled.
    
    .PARAMETER Name
    Name of the server on which the iLO automatic firmware update preference will be enabled.   

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
  
    .EXAMPLE
    Enable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central -SerialNumber 2M240400JN 

    This command enables the automatic iLO firmware update for the server with the serial number "2M240400JN" located in the "eu-central" region. 

    .EXAMPLE 
    Enable-HPECOMServerAutoiLOFirmwareUpdate -Region us-west -Name  'HOL45' 

    This command enables the automatic iLO firmware update for the server with the name "HOL45" located in the "us-west" region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west | Enable-HPECOMServerAutoiLOFirmwareUpdate 

    This command enables the automatic iLO firmware update for all servers located in the "us-west" region. 

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Enable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central 

    This command enables the automatic iLO firmware update for the servers with the serial numbers "CZ12312312" and "DZ12312312" located in the "eu-central" region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the server where to enable the automatic iLO firmware update
        * Region - Name of the region 
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [alias('serial_number')]
        [String]$SerialNumber,
        
        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {
              
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $EnableServerAutoiLOFirmwareUpdatetatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($SerialNumber) {

                $ParamUsed = $SerialNumber
                $_server = Get-HPECOMServer -Region $Region -Name $SerialNumber

            } 
            elseif ($Name) {

                $ParamUsed = $Name
                $_server = Get-HPECOMServer -Region $Region -Name $Name

            }
      

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $ParamUsed
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
        
        if (-not $_server) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $ParamUsed, $Region
                Write-Warning $ErrorMessage
                return

            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Server cannot be found in the region!"
            }              

        }
        else {

            # ID uses a '+' sign, it needs to be replaced with '%2B' to avoid 404 resource not found error (URL encoding not working: $encodedServerID = [System.Web.HttpUtility]::UrlEncode($_serverId) )
            $ServerID = $_server.id.replace('+', '%2B') 
            "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID | Write-Verbose
            
            $Uri = $COMServersUri + "?id=" + $ServerID 
            "[{0}] URI: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                autoIloFwUpdate = $true    
            }          
          
            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Server auto iLO firmware enable raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Server auto iLO firmware '{1}' successfully enabled in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Server auto iLO firmware successfully enabled in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Server auto iLO firmware cannot be enabled!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $EnableServerAutoiLOFirmwareUpdatetatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($EnableServerAutoiLOFirmwareUpdatetatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed the Auto iLO firmware enable attempt!"
          
            }
            
            $EnableServerAutoiLOFirmwareUpdatetatus = Invoke-RepackageObjectWithType -RawObject $EnableServerAutoiLOFirmwareUpdatetatus -ObjectName "COM.objStatus.NSDE"
            Return $EnableServerAutoiLOFirmwareUpdatetatus
        }


    }
}


Function Disable-HPECOMServerAutoiLOFirmwareUpdate {
    <#
    .SYNOPSIS
    Disable the automatic iLO firmware update.

    .DESCRIPTION
    This Cmdlet can be used to disable the iLO automatic firmware update for a specified server in a region.    

    The iLO automatic firmware update status can be checked using 'Get-HPECOMServer -Region eu-central -ShowAutoiLOFirmwareUpdateStatus -Name <nameserver>' 
        
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where to disable the automatic iLO firmware update.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER SerialNumber
    Serial number of the server on which the iLO automatic firmware update preference will be disabled.
    
    .PARAMETER Name
    Name of the server on which the iLO automatic firmware update preference will be disabled.   

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
  
    .EXAMPLE
    Disable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central -SerialNumber 2M240400JN 

    This command disables the automatic iLO firmware update for the server with the serial number "2M240400JN" located in the "eu-central" region. 

    .EXAMPLE
    Disable-HPECOMServerAutoiLOFirmwareUpdate -Region us-west -Name 'HOL45' 

    This command disables the automatic iLO firmware update for the server with the name "HOL45" located in the "us-west" region. 

    .EXAMPLE
    Get-HPECOMServer -Region us-west | Disable-HPECOMServerAutoiLOFirmwareUpdate

    This command disables the automatic iLO firmware update for all servers in the "us-west" region. 

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Disable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central 

    This command disables the automatic iLO firmware update for the servers with the serial numbers "CZ12312312" and "DZ12312312" located in the "eu-central" region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the server where to disable the automatic iLO firmware update
        * Region - Name of the region 
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [alias('serial')]
        [String]$SerialNumber,
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Name')]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
              
        $EnableServerAutoiLOFirmwareUpdatetatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($SerialNumber) {

                $ParamUsed = $SerialNumber
                $_server = Get-HPECOMServer -Region $Region -Name $SerialNumber

            } 
            elseif ($Name) {

                $ParamUsed = $Name
                $_server = Get-HPECOMServer -Region $Region -Name $Name

            }
      

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $ParamUsed
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
        
        if (-not $_server) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $ParamUsed, $Region
                Write-Warning $ErrorMessage
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Server cannot be found in the region!"
            }              

        }
        else {

            # ID uses a '+' sign, it needs to be replaced with '%2B' to avoid 404 resource not found error (URL encoding not working: $encodedServerID = [System.Web.HttpUtility]::UrlEncode($_serverId) )
            $ServerID = $_server.id.replace('+', '%2B') 
            "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID | Write-Verbose
            
            $Uri = $COMServersUri + "?id=" + $ServerID 
            "[{0}] URI: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                autoIloFwUpdate = $false    
            }          
          
            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {
                    
                    "[{0}] Server auto iLO firmware disable raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Server auto iLO firmware '{1}' successfully disabled in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Server auto iLO firmware successfully disabled in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Server auto iLO firmware cannot be disabled!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $EnableServerAutoiLOFirmwareUpdatetatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($EnableServerAutoiLOFirmwareUpdatetatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed the Auto iLO firmware disable attempt!"
          
            }
            
            $EnableServerAutoiLOFirmwareUpdatetatus = Invoke-RepackageObjectWithType -RawObject $EnableServerAutoiLOFirmwareUpdatetatus -ObjectName "COM.objStatus.NSDE"
            Return $EnableServerAutoiLOFirmwareUpdatetatus
        }


    }
}


Function Get-HPECOMServerActivationKey {
    <#
    .SYNOPSIS
    Retrieve server activation keys.

    .DESCRIPTION   
    This Cmdlet returns a collection of activation keys for adding servers to a Compute Ops Management service instance. The keys will be removed from the collection on expiry.
    
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server will be added.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMServerActivationKey -Region eu-central

    This command retrieves the activation keys required to add servers to a Compute Ops Management service instance in the "eu-central" region.
        
    #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $Uri = $COMActivationKeysUri
       
        try {
            [Array]$Collection = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf


        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }     

        if ($Collection) {

            # Add region to objects
            $Collection | ForEach-Object { $_ | Add-Member -type NoteProperty -name region -value $Region }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "COM.Servers.ActivationKeys"   
            $ReturnData = $ReturnData | Sort-Object activationKey

            return $ReturnData
        }
        else {
            return
        }

    }   
}


Function New-HPECOMServerActivationKey {
    <#
    .SYNOPSIS
    Generate a activation key required to connect servers to a Compute Ops Management service instance.
    
    .DESCRIPTION   
    This cmdlet generates an activation key necessary for connecting servers to a Compute Ops Management service instance using the 'Connect-HPEGLDeviceComputeiLOtoCOM -ActivationKey' command.

    The activation key is valid for a duration specified by the ExpirationInHours parameter.

    Note that a maximum of 10 server activation keys per user per region is allowed. The generated activation key will consist of 9 alphanumeric characters.

    Note that iLO must be updated to the following minimum versions prior to support activation keys:
    - iLO 5: v3.09 or later
    - iLO 6: v1.64 or later
    
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server will be added.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER SecureGateway
    Specifies the name of the Compute Ops Management secure gateway to use for the activation key. The name can be retrieved using 'Get-HPECOMAppliance'.
    When this parameter is used, servers connect to Compute Ops Management through the secure gateway present in the network infrastructure, rather than directly.

    .PARAMETER SubscriptionKey
    Optional parameter that specifies a new or an existing device subscription key to assign to the server. 
    This parameter is not required if the automatic subscription status of Compute device is enabled (see Get-HPEGLDeviceAutoSubscription and Set-HPEGLDeviceAutoSubscription).
    An existing key can be retrieved using 'Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -FilterBySubscriptionType Server'.

    .PARAMETER ExpirationInHours
    Specifies the expiration time of the activation key in hours. The default value is 1 hour. The valid range is from 0.5 hours (30 minutes) to 168 hours (7 days).

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    $Activation_Key = New-HPECOMServerActivationKey -Region eu-central -ExpirationInHours 2

    This command generates an activation key required to add servers to a Compute Ops Management service instance in the "eu-central" region. 
    The activation key will expire in 2 hours and can then be used with 'Connect-HPEGLDeviceComputeiLOtoCOM -iLOCredential $iLO_credential -IloIP $iLO_IP -ActivationKeyfromCOM $Activation_Key'. 
    This command requires that the automatic subscription status of the Compute device is enabled and that a valid subscription key with available quantity is available, as no subscription key was provided.

    .EXAMPLE
    $Activation_Key = New-HPECOMServerActivationKey -Region eu-central -SubscriptionKey "123456789" -ExpirationInHours 24

    This command generates an activation key required to add servers to a Compute Ops Management service instance in the "eu-central" region using the new subscription key "123456789" that will be added to the workspace.
    The activation key will expire in 24 hours and can then be used with 'Connect-HPEGLDeviceComputeiLOtoCOM'.

    .EXAMPLE
    $Subscription_Key = Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -FilterBySubscriptionType Server | select -First 1 -ExpandProperty key
        
    $Activation_Key = New-HPECOMServerActivationKey -Region eu-central -SubscriptionKey $Subscription_Key 
   
    The first command retrieves the first available server subscription key that is valid and with available quantity.
    The second command retrieves the activation key required to add servers to a Compute Ops Management service instance in the "eu-central" region using the subscription key retrieved in the first command.
    The activation key will expire in 1 hour and can then be used with 'Connect-HPEGLDeviceComputeiLOtoCOM'
    
    .EXAMPLE
    $Activation_Key = New-HPECOMServerActivationKey -Region eu-central -ExpirationInHours 2 -SecureGateway "sg01.domain.lab"
    
    This command generates an activation key required to add servers to a Compute Ops Management service instance in the "eu-central" region using the secure gateway "sg01.domain.labm". 
    The activation key will expire in 2 hours and can then be used with 'Connect-HPEGLDeviceComputeiLOtoCOM'.
    
    .EXAMPLE
    Get-HPECOMAppliance -Region eu-central -Type SecureGateway -Name sg01.domain.lab | New-HPECOMServerActivationKey

    This command retrieves the secure gateway "sg01.domain.lab" and generates an activation key required to add servers via secure gateway to a Compute Ops Management service instance in the "eu-central" region.
    The activation key will expire in 1 hour and can then be used with 'Connect-HPEGLDeviceComputeiLOtoCOM'.

    .INPUTS
    HPEGreenLake.COM.Appliances
        A Secure Gateway object from 'Get-HPECOMAppliance -Region $Region -Type SecureGateway'.

    .OUTPUTS
    System.String
        A string object representing the activation key generated for adding servers to a Compute Ops Management service instance.
    
    #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipelineByPropertyName, ValueFromPipeline)] 
        [alias('name')]
        [object]$SecureGateway,

        [String]$SubscriptionKey,

        [ValidateScript({
                if ($_ -ge 0.5 -and $_ -le 168) {
                    $true
                }
                else {
                    Throw "ExpirationInHours must be between 0.5 and 168."
                }
            })]
        [Int]$ExpirationInHours = 1,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if (-not $SubscriptionKey) {

            $SubscriptionKey = ""
        }

        if ($SecureGateway) {

            try {
                # Check $SecureGateway object type 
                if ($SecureGateway -is [string]) {
                    "[{0}] SecureGateway parameter is a string" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    $SecureGatewayResource = Get-HPECOMAppliance -Region $Region -Type SecureGateway -Name $SecureGateway
                    $SecureGatewayResourceUri = $SecureGatewayResource.resourceUri
                    $SecureGatewayName = $SecureGatewayResource.name
                }
                else {
                    "[{0}] SecureGateway parameter is a PSCustomObject." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    $SecureGatewayResourceUri = $SecureGateway.resourceUri
                    "[{0}] Secure Gateway URI: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SecureGatewayResourceUri | Write-Verbose
                    $SecureGatewayName = $SecureGateway.name
                    "[{0}] Secure Gateway name: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SecureGatewayName | Write-Verbose
                }
           
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }

            If (-not $SecureGatewayResourceUri) {

                # Must return a message if secure gateway not found
                "[{0}] Secure Gateway '{1}' cannot be found in the Compute Ops Management instance" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SecureGatewayName | Write-Verbose
    
                $ErrorMessage = "Secure Gateway '{0}' cannot be found in the Compute Ops Management instance!" -f $SecureGatewayName
                Write-warning $ErrorMessage
                return               
            }
            else {
        
                $Uri = $COMActivationKeysUri

                $body = @{
                    expirationInHours   = $ExpirationInHours
                    subscriptionKey     = $SubscriptionKey   
                    applianceUri        = $SecureGatewayResourceUri      
                    targetDevice     = 'ILO'
                } | ConvertTo-Json
        
            }
        }
        else {

            $Uri = $COMActivationKeysUri

            $body = @{
                expirationInHours = $ExpirationInHours
                subscriptionKey   = $SubscriptionKey       
                targetDevice      = 'ILO'  
            } | ConvertTo-Json

        }

       
        try {
            [Array]$Collection = Invoke-HPECOMWebRequest -Method POST -Uri $Uri -Region $Region -Body $body -WhatIfBoolean $WhatIf

            $ReturnData = $Collection.activationKey     
            return $ReturnData

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }     

    }   
}


Function Remove-HPECOMServerActivationKey {
    <#
    .SYNOPSIS
    Delete an activation key.
    
    .DESCRIPTION   
    This cmdlet deletes a generated activation key necessary for connecting servers to a Compute Ops Management service instance.

    
    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the server will be added.  
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER ActivationKey
    Specifies the activation key to be deleted from the Compute Ops Management service instance. The key can be retrieved using 'Get-HPECOMServerActivationKey'.
   
    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMServerActivationKey -Region eu-central -ActivationKey 123456789    

    .EXAMPLE
    Get-HPECOMServerActivationKey -Region eu-central | Remove-HPECOMServerActivationKey 

    This command deletes all activation keys for the Compute Ops Management service instance in the "eu-central" region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the activation keys.
    System.Collections.ArrayList
        List of keys retrieved using 'Get-HPECOMServerActivationKey'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * ActivationKey - Name of the activation key to be removed from the region
        * Region - Name of the region 
        * Status - The status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - Additional information about the status.
        * Exception: Information about any exceptions generated during the operation.

       
    #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$ActivationKey,
            
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveKeyStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            ActivationKey = $ActivationKey
            Region        = $Region   
            Status        = $Null
            Details       = $Null
            Exception     = $Null
        }


        try {
    
            $_ActivationKey = Get-HPECOMServerActivationKey -Region $Region | Where-Object activationKey -eq $ActivationKey
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        

        if (-not $_ActivationKey) {
                
            "[{0}] Activation key '{1}' cannot be found in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ActivationKey, $Region | Write-Verbose

            if ($WhatIf) {

                $ErrorMessage = "Activation key '{0}': Resource cannot be found in the '{1}' region!" -f $ActivationKey, $Region
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Activation key cannot be found in the region!"
              
            }

        }
        else {   

            $Uri = $COMActivationKeysUri + '/' + $_ActivationKey.activationKey

            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 
                        
                if (-not $WhatIf) {

                    "[{0}] Remove activation key call response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                    "[{0}] Activation key '{1}' successfully removed from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ActivationKey, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Activation key successfully removed from $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Activation key cannot be removed from $Region region!"
                    $objStatus.Exception = $_.Exception.message 
    
                }
            }   
            
        }

        [void] $RemoveKeyStatus.add($objStatus)

    }   
    end {

        if (-not $WhatIf) {

            if ($RemoveKeyStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more activation keys failed to be removed from $Region!"
          
            }
            
            $RemoveKeyStatus = Invoke-RepackageObjectWithType -RawObject $RemoveKeyStatus -ObjectName "COM.Servers.ActivationKeys.ASDE"
            Return $RemoveKeyStatus
        }
    }
}

#EndRegion


#Region --- SERVER LOCATIONS ---

# Get-HPECOMServerLocation is an alias of Get-HPEGLLocation
Set-Alias -Name Get-HPECOMServerLocation -Value Get-HPEGLLocation


Function Set-HPECOMOneViewServerLocation {
    <#
    .SYNOPSIS
    Configure the server location for HPE OneView managed servers.

    .DESCRIPTION
    This Cmdlet assigns an a location that exists in HPE GreenLake to HPE OneView managed servers. 
    
    Assigning a location enhances the data visible in Compute Ops Management sustainability reports and the HPE Sustainability Insight Center.

    For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.)
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER LocationName
    Specifies the name of the location to assign to the server.
    
    .PARAMETER ServerName
    Specifies the name of the server.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMOneViewServerLocation -Region eu-central -LocationName "Mougins" -ServerSerialNumber CN12312312

    Assign the location named 'Mougins' to the server with the serial number 'CN12312312' in the central EU region.

    .EXAMPLE
    Set-HPECOMOneViewServerLocation -Region eu-central -LocationName "Mougins" -ServerName RHEL-1
    
    Assign the location named 'Mougins' to the server named 'RHEL-1' in the central EU region.

    .EXAMPLE
    'CN12312312', 'CN12312313', 'CN12312314' |  Set-HPECOMOneViewServerLocation -Region eu-central  -LocationName "Mougins" 

    Assign the location named 'Mougins' to the servers with the serial numbers 'CN12312312', 'CN12312313', and 'CN12312314' in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType 'OneView managed' | Set-HPECOMOneViewServerLocation -LocationName "Mougins" 
    
    Assign the location named 'Mougins' to all HPE OneView managed servers in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Model 'Synergy 480 Gen11' | Set-HPECOMOneViewServerLocation -LocationName "Mougins"

    Assign the location named 'Mougins' to all HPE OneView managed servers with the model 'Synergy 480 Gen11' in the central EU region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.    
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Server - Serial number or name of the server
        * Region - Name of the region where the server is located
        * Location - Name of the location assigned to the server
        * Status - Status of the assignment attempt (Failed for http error return; Complete if assignment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [String]$LocationName,

        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$ServerName,
    
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Alias('serialNumber')]
        [String]$ServerSerialNumber,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

        try {
            $Location = Get-HPEGLLocation -Name $LocationName
            $Uri = $COMServerLocationsUri + "/" + $Location.ID + "/servers"
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $Location) {

            $ErrorMessage = "Location '{0}': Resource cannot be found in the '{1}' region!" -f $LocationName, $Region
            throw $ErrorMessage

        }
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        # Build object for the output
        $objStatus = [pscustomobject]@{

            Server    = if ($ServerSerialNumber) { $ServerSerialNumber } else { $ServerName }
            Region    = $Region     
            Location  = $LocationName                       
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        [void] $ObjectStatusList.add($objStatus)
    
    }
    
    End {


        try {
            if ($Region) {
                $Servers = Get-HPECOMServer -Region $Region 

            }
            else {
                return
            }
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of servers to add to location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose


        foreach ($Object in $ObjectStatusList) {

            $Server = $Servers | Where-Object serialNumber -eq $Object.server
            
            if (-not $Server) {
                $Server = $Servers | Where-Object serverName -eq $Object.server
            }
            
            #  Condition when serverName is used and when multiple servers use the same serverName 
            if ( $server -and $Server.id.count -gt 1) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource."

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource." -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ( $server -and $Server.connectionType -ne "OneView") {

                # Must return a message if device not OneView server
                $Object.Status = "Failed"
                $Object.Details = "Server is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $Server) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server cannot be found in the region!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}': Resource cannot be found in the '{1}' region!" -f $Object.server, $Region
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            else {       
            
                $ServerLocation = Get-HPECOMServer -Region $Region -Name $server.serialnumber -ShowLocation

                if ($ServerLocation.location) {   
                    # Must return a message if server already member of a location
                    $Object.Status = "Warning"
                    $Object.Details = "Server is already assigned to the '$($ServerLocation.location)' location!"

                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}': Resource is already assigned to the '{1}' location!" -f $Object.server, $ServerLocation.location
                        Write-warning $ErrorMessage
                        continue
                    }

                }
                else {

                    # Build DeviceInfo object for tracking
                    $DeviceInfo = [PSCustomObject]@{
                        serialnumber = $server.serialNumber
                        servername   = $server.serverName
                        
                    }
                    
                    Write-Verbose "Server serialNumber: $($server.serialNumber)"
                    Write-Verbose "Server ID: $($server.id)"
                    
                    # Building the list of devices object for payload
                    [void]$DevicesList.Add($($Server.id))
    
                    # Building the list of devices object for tracking
                    [void]$DevicesTrackingList.Add($DeviceInfo)

                }
            }
        }


        if ($DevicesList) {

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                servers = $DevicesList
            } 

        
            # Add Devices to location  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully assigned to server"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be assigned to server!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf ) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more server locations failed to assign successfully!"
                
          
            }
            
            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Location.SLSDE"
            Return $ObjectStatusList
        
        }

    }
}



Function Remove-HPECOMOneViewServerLocation {
    <#
    .SYNOPSIS
    Remove location of one or more servers managed by HPE OneView.

    .DESCRIPTION
    This Cmdlet unassigns an HPE GreenLake location from HPE OneView managed server(s). 

    For non-HPE OneView servers, use `Remove-HPEGLDeviceLocation`.
    
    .PARAMETER Region     
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.)
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.
    
    .PARAMETER ServerName
    Specifies the name of the server.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    Remove-HPECOMOneViewServerLocation -Region eu-central -ServerSerialNumber CN12312312
    
    Remove the location of the server with the serial number 'CN12312312' in the central EU region.

    .EXAMPLE
    Remove-HPECOMOneViewServerLocation -Region eu-central -ServerName RHEL-1

    Remove the location of the server named 'RHEL-1' in the central EU region.

    .EXAMPLE
    'CN12312312', 'CN12312313', 'CN12312314' |  Remove-HPECOMOneViewServerLocation -Region eu-central

    Remove the location of the servers with the serial numbers 'CN12312312', 'CN12312313', and 'CN12312314' in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType 'OneView managed' | Remove-HPECOMOneViewServerLocation

    Remove the location of all HPE OneView managed servers in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Model 'Synergy 480 Gen11' | Remove-HPECOMOneViewServerLocation

    Remove the location of all HPE OneView managed servers with the model 'Synergy 480 Gen11' in the central EU region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer'.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Server - Serial number or name of the server
        * Region - Name of the region where the server is located
        * Location - Name of the location assigned to the server
        * Status - Status of the assignment attempt (Failed for http error return; Complete if assignment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

   
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$ServerName,
    
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Alias('serialNumber')]
        [String]$ServerSerialNumber,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

                
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        # Build object for the output
        $objStatus = [pscustomobject]@{

            Server    = if ($ServerSerialNumber) { $ServerSerialNumber } else { $ServerName }
            Region    = $Region     
            Location  = $Null                       
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        [void] $ObjectStatusList.add($objStatus)
    
    }
    
    End {

        try {
            if ($Region) {
            
                $Servers = Get-HPECOMServer -Region $Region 
            }
            else {
                Return
            }
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of servers where to remove the location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose


        foreach ($Object in $ObjectStatusList) {

            $Server = $Servers | Where-Object serialNumber -eq $Object.server
            
            if (-not $Server) {
                $Server = $Servers | Where-Object serverName -eq $Object.server
            }
            

            #  Condition when serverName is used and when multiple servers use the same serverName 
            if ( $server -and $Server.id.count -gt 1) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource."

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource." -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ( $server -and $Server.connectionType -ne "OneView") {

                # Must return a message if device not OneView server
                $Object.Status = "Failed"
                $Object.Details = "Server is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $Server) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server cannot be found in the Compute Ops Management instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            else {       
            
                $ServerLocation = Get-HPECOMServer -Region $Region -Name $server.serialnumber -ShowLocation

                if (-not $ServerLocation.location) {   
                    # Must return a message if server is not member of the location
                    $Object.Status = "Warning"
                    $Object.Details = "Server is not assigned to a location!"

                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}': Resource not assigned to a location" -f $Object.server
                        Write-warning $ErrorMessage
                        continue
                    }

                }
                else {

                    $Object.Location = $ServerLocation.name 

                    # Build DeviceInfo object for tracking
                    $DeviceInfo = [PSCustomObject]@{
                        serialnumber = $server.serialNumber
                        servername   = $server.serverName
                        
                    }
                    
                    Write-Verbose "Server serialNumber: $($server.serialNumber)"
                    Write-Verbose "Server ID: $($server.id)"
                    
                    # Building the list of devices object for payload
                    [void]$DevicesList.Add($($Server.id))
    
                    # Building the list of devices object for tracking
                    [void]$DevicesTrackingList.Add($DeviceInfo)

                }
            }
        }


        if ($DevicesList) {

            "[{0}] List of IDs to add to query: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($DevicesList | out-string) | Write-Verbose


            # Build the query string
            $queryString = ($DevicesList | ForEach-Object { "id=$_" }) -join "&"
            $queryString = "?$queryString"

            # ID uses a '+' sign, it needs to be replaced with '%2B' to avoid 404 resource not found error 
            # (URL encoding not working: $encodedQueryString = [System.Web.HttpUtility]::UrlEncode($queryString) )
            $encodedQueryString = $queryString.replace('+', '%2B')

            $Uri = $COMServerLocationsUri + "/" + $ServerLocation.locationId + "/servers" + $encodedQueryString
       
            # Remove Devices to location  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully unassigned from server"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be unassigned from server!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf ) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more server locations failed to unassign successfully!"

          
            }
            
            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Location.SLSDE"
            Return $ObjectStatusList
        
        }

    }
}




#EndRegion


#Region --- WEBHOOKS ---

Function Get-HPECOMWebhook {
    <#
    .SYNOPSIS
    Retrieve webhook resources in the specified region.

    .DESCRIPTION
    This Cmdlet retrieves a collection of webhooks available in the specified region.
    
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.).
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name 
    An optional parameter to specify the name of a webhook to display.

    .PARAMETER Deliveries
    An optional switch parameter to retrieve details of the most recent deliveries attempted. 
    Compute Ops Management stores the ten most recent deliveries and the five most recent failures.
    
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west 

    Returns a collection of webhooks available in the western US region.

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west -Name 'Webhook event for server shutdown'

    Returns the webhook resource named 'Webhook event for server shutdown' located in the western US region. 

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west -Name 'Webhook event for server shutdown' -Deliveries
    
    Returns the most recent deliveries attempted by the webhook named 'Webhook event for server shutdown'.
    
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.


    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Region')]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'Region')]
        [Parameter (Mandatory, ParameterSetName = 'Deliveries')]
        [String]$Name,

        [Parameter (ParameterSetName = 'Deliveries')]
        [Switch]$Deliveries,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        if ($Name -and -not $Deliveries) {
            $Uri = $COMWebhooksUri + "?filter=name eq '$Name'"
            
        }
        elseif ($Deliveries) {
            
            $Uri = $COMWebhooksUri + "?filter=name eq '$Name'"
            
            try {
                [Array]$Webhook = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
                
                $WebhookID = $Webhook.id
                
                "[{0}] ID found for Webhook name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $WebhookID | Write-Verbose
                
                if ($Null -eq $WebhookID) { Throw "Webhook with this name cannot be found!" }
                
                $Uri = $COMWebhooksUri + "/" + $WebhookID + "/deliveries"
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
            
        }
        else {

            $Uri = $COMWebhooksUri     
            
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction Stop
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
                        
            if ($Deliveries) {

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Webhooks.Deliveries"    
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Webhooks"    
                $ReturnData = $ReturnData | Sort-Object name
            }   
        
            return $ReturnData 
                
        }
        else {

            return
                
        }         
    }
}


Function New-HPECOMWebhook {
    <#
    .SYNOPSIS
    Creates a new webhook in a specified region.

    .DESCRIPTION
    This Cmdlet can be used to create a new webhook with a destination endpoint and an OData configuration for event filtering.
        
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the webhook will be created.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace. 

    .PARAMETER Name 
    Specifies the name of the webhook to create. 
    
    .PARAMETER EventFilter  
    Specifies the OData configuration for events to receive.
    
    Filters use OData style filters as described in https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/guide/#filtering 

    The general syntax for an OData filter looks like 'property op value' with:
     - 'property' refers to the field or property to filter on in the entity.
     - 'op' is the operator, such as eq (equals), ne (not equal), gt (greater than), ge (greater or equal), lt (less than), le (less or equal), etc.
     - 'value' is the value to compare against the property.

    Filtering examples:

    - To receive webhooks for group and server events only:         
        type eq 'compute-ops/group' or type eq 'compute-ops/server'
    - To receive webhooks for all servers that are shut down:       
        type eq 'compute-ops/server' and old/hardware/powerState eq 'ON' and changed/hardware/powerState eq True
    - To receive webhooks for all servers that get disconnect from COM:
        type eq 'compute-ops/server' and old/state/connected eq True and changed/state/connected eq True
    -To receive webhooks for all jobs that run a server firmware update:
        type eq 'compute-ops/job' and contains(name, 'FirmwareUpdate.New') and new/state eq 'RUNNING'
    - To receive webhooks for all servers that transition to an unhealthy status:
        type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True
    - To receive webhooks for all events within a specified group:
        type eq 'compute-ops/group' and contains(name, 'Production')
    - To receive webhooks for all new firmware bundles that are available:
        type eq 'compute-ops/firmware-bundle' and operation eq 'Created'
    - To receive webhooks for all servers added to COM that require activation:
        type eq 'compute-ops/server' and operation eq 'Created'
    - To receive webhooks for all new servers added and connected to COM:
        type eq 'compute-ops/server' and old/state/connected eq False and changed/state/connected eq True
   
    For more information about COM webhooks, see https://jullienl.github.io/Implementing-webhooks-with-COM/ 

    .PARAMETER Destination 
    Specifies the HTTPS webhook endpoint capable of receiving HTTP GET and POST requests.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMWebhook -Region eu-central -Name "Webhook for servers that disconnect" `
    -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
    -EventFilter "type eq 'compute-ops/alert' and old/hardware/powerState eq 'ON' and changed/hardware/powerState eq True"

    This example creates a webhook named "Webhook for servers that disconnect" in the `eu-central` region. 
    The webhook will send events to the specified destination URL when a server's hardware power state changes from 'ON'. 
    The filter criteria are defined using OData syntax.

    .EXAMPLE
    New-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" `
    -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
    -EventFilter "type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True"

    This example creates a webhook named "Webhook for servers that become unhealthy" in the `eu-central` region. 
    The webhook will trigger when servers transition from a healthy state (`OK`) to an unhealthy state. 
    The events will be sent to the specified destination URL, filtered according to the provided OData criteria.

    .EXAMPLE
    New-HPECOMWebhook -Region eu-central -Name "Webhook for new activated servers" `
    -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
    -EventFilter "type eq 'compute-ops/server' and old/state/connected eq False and changed/state/connected eq True"

    This example creates a webhook named "Webhook for new activated servers" in the `eu-central` region. 
    This webhook will send notifications to the given destination URL whenever new servers are activated and connected to COM. 
    The filter ensures that the event captures the change in connection state from `False` to `True`.

    .INPUTS
    Pipeline input is not supported

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the webhook attempted to be created
        * Region - Name of the region where to create the webhook
        * Status - Status of the creation attempt (Failed for http error return; Complete if creation is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                # Regex pattern to validate OData filter strings with multiple 'and'/'or' conditions
                if ($_ -match "^\s*([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false))(\s+(and|or)\s+([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false)))*\s*$") {
                    return $true
                }
                else {
                    throw "The filter string '$_' is not a valid OData filter."
                }
            })]
        [String]$EventFilter,
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($_ -match '^https?:\/\/[a-zA-Z0-9-\.]+\.[a-z]{2,4}(/\S*)?$') {
                    return $true
                }
                else {
                    throw "The URL '$_' is not a valid HTTP/HTTPS URL."
                }
            })]
        [String]$Destination,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $CreateWebhookStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $Uri = $COMWebhooksUri

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($WebhookResource) {
            
            "[{0}] Webhook '{1}' is already present in the '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
    
            if ($WhatIf) {
                $ErrorMessage = "Webhook '{0}': Resource is already present in the '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Webhook already exists in the region! No action needed."
            }

        }
        else {

            # Build payload
            $payload = ConvertTo-Json @{
                name        = $Name
                destination = $Destination
                state       = "ENABLED"
                eventFilter = $EventFilter
                headers     = @{}
            }
                
    
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 
    
                
                if (-not $WhatIf) {
    
                    "[{0}] Webhook creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                    "[{0}] Webhook '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook successfully created in $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Webhook cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

                     
        [void] $CreateWebhookStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($CreateWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more webhooks failed the creation attempt!"
          
            }
            
            $CreateWebhookStatus = Invoke-RepackageObjectWithType -RawObject $CreateWebhookStatus -ObjectName "COM.objStatus.NSDE"    
            Return $CreateWebhookStatus
        }


    }
}


Function Set-HPECOMWebhook {
    <#
    .SYNOPSIS
    Update an existing webhook in a specified region.

    .DESCRIPTION
    This Cmdlet is used to update an existing webhook to modify its destination, its OData filtering configuration, or to re-initiate the verification handshake. 
    If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.
        
    .PARAMETER Region
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the webhook to be updated is located.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name
    Specifies the name of the webhook to update.

    .PARAMETER NewName
    Specifies the new name for the webhook.

    .PARAMETER EventFilter
    Specifies the new OData filter configuration for events to receive.

    Filters use OData style filters as described in [HPE Developer Documentation](https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/guide/#filtering).

    The general syntax for an OData filter is 'property op value', where:
    - `property` refers to the field or property to filter on within the entity.
    - `op` is the operator, such as eq (equals), ne (not equal), gt (greater than), ge (greater or equal), lt (less than), le (less or equal), etc.
    - `value` is the value to compare against the property.

    Filtering examples:

    - To receive webhooks for group and server events only:         
        type eq 'compute-ops/group' or type eq 'compute-ops/server'
    - To receive webhooks for all servers that are shut down:       
        type eq 'compute-ops/server' and old/hardware/powerState eq 'ON' and changed/hardware/powerState eq True
    - To receive webhooks for all servers that get disconnect from COM:
        type eq 'compute-ops/server' and old/state/connected eq True and changed/state/connected eq True
    -To receive webhooks for all jobs that run a server firmware update:
        type eq 'compute-ops/job' and contains(name, 'FirmwareUpdate.New') and new/state eq 'RUNNING'
    - To receive webhooks for all servers that transition to an unhealthy status:
        type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True
    - To receive webhooks for all events within a specified group:
        type eq 'compute-ops/group' and contains(name, 'Production')
    - To receive webhooks for all new firmware bundles that are available:
        type eq 'compute-ops/firmware-bundle' and operation eq 'Created'
    - To receive webhooks for all servers added to COM that require activation:
        type eq 'compute-ops/server' and operation eq 'Created'
    - To receive webhooks for all new servers added and connected to COM:
        type eq 'compute-ops/server' and old/state/connected eq False and changed/state/connected eq True
   
    For more information about COM webhooks, see https://jullienl.github.io/Implementing-webhooks-with-COM/ 

    .PARAMETER Destination
    Specifies the new HTTPS webhook endpoint that is able to receive HTTP GET and POST requests.

    .PARAMETER RetryWebhookHandshake
    Re-initiates the webhook verification handshake.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "New_webhook" -NewName "Webhook for servers that become unhealthy" `
     -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
     -EventFilter "type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True"

    This example updates an existing webhook named "New_webhook" to a new name "Webhook for servers that become unhealthy" in the `eu-central` region. 
    The webhook will send events to the specified destination URL when a server's health summary transitions from `OK` to unhealthy (`True`), using the specified OData filter.

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" -RetryWebhookHandshake

    This example re-initiates the verification handshake for the webhook named "Webhook for servers that become unhealthy" in the `eu-central` region.

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" -Destination "https://hook.us1.make.com/wwedws2fa0f8be4d546445c98253392058"

    This example updates the destination URL for the webhook named "Webhook for servers that become unhealthy" in the `eu-central` region. 

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" -EventFilter "type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True"

    This example updates the OData filter configuration for the webhook named "Webhook for servers that become unhealthy" in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMWebhook -Region eu-central | Set-HPECOMWebhook  -RetryWebhookHandshake 

    This example re-initiates the verification handshake for all webhooks in the `eu-central` region.

    .EXAMPLE
    "POSH_webhook_Alert", "POSH_webhook_firmwarebundle" | Set-HPECOMWebhook -Region eu-central  -RetryWebhookHandshake 

    This example re-initiates the verification handshake for the webhooks named "POSH_webhook_Alert" and "POSH_webhook_firmwarebundle" in the `eu-central` region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the webhooks's names.

    System.Collections.ArrayList
        List of webhooks from 'Get-HPECOMWebhook'.

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object or array of objects containing the following properties:
        * Name - Name of the webhook attempted to be set.
        * Region - Name of the region where the webhook is updated.
        * Status - Status of the modification attempt (Failed if an HTTP error occurs; Complete if successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.

      
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [ValidateScript({ $_.Length -lt 256 })]
        [String]$NewName,
        
        [ValidateScript({
                # Regex pattern to validate OData filter strings with multiple 'and'/'or' conditions
                if ($_ -match "^\s*([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false))(\s+(and|or)\s+([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false)))*\s*$") {
                    return $true
                }
                else {
                    throw "The filter string '$_' is not a valid OData filter."
                }
            })]
        [String]$EventFilter,
        
        [ValidateScript({
                if ($_ -match '^https?:\/\/[a-zA-Z0-9-\.]+\.[a-z]{2,4}(/\S*)?$') {
                    return $true
                }
                else {
                    throw "The URL '$_' is not a valid HTTP/HTTPS URL."
                }
            })]
        [String]$Destination,

        [Switch]$RetryWebhookHandshake,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetWebhookStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name
            $WebhookID = $WebhookResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        "[{0}] Webhook ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $WebhookID | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        if (-not $WebhookID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Webhook '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be found in the region!"
            }
        }
        else {

            $Uri = $COMWebhooksUri + "/" + $WebhookID

            $Payload = @{}

            # Conditionally add properties
            if ($NewName) {
                $Payload.name = $NewName
            }
            else {
                $Payload.name = $Name
               
            }

            if ($Destination) {
                $Payload.destination = $Destination
            }
            else {
                $Payload.destination = $WebhookResource.destination
            }

            if ($RetryWebhookHandshake) {
                $Payload.state = "ENABLED"
            }
            else {
                $Payload.state = $WebhookResource.state
            }

            if ($EventFilter) {
                $Payload.eventFilter = $EventFilter
            }
            else {
                $Payload.eventFilter = $WebhookResource.eventFilter
            }

            # Convert the hashtable to JSON
            $jsonPayload = $Payload | ConvertTo-Json
           
            try {
               
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $jsonPayload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 
                              
                if (-not $WhatIf) {
                   
                    "[{0}] Webhook update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                   
                    "[{0}] Webhook '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                   
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook successfully updated in $Region region"
                   
                }
                
            }
            catch {
                
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Webhook cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }


        [void] $SetWebhookStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more webhooks failed the updated attempt!"
          
            }
            
            $SetWebhookStatus = Invoke-RepackageObjectWithType -RawObject $SetWebhookStatus -ObjectName "COM.objStatus.NSDE"    
            Return $SetWebhookStatus
        }


    }
}


Function Send-HPECOMWebhookTest {
    <#
   
    .SYNOPSIS
    Simulate a webhook by sending a typical resource object to its configured endpoint URL.

    .DESCRIPTION
    This Cmdlet can simulate a webhook by sending a resource object that matches the filtering configuration of an existing webhook to its configured endpoint URL.

    This test is useful for validating communication between COM and the webhook destination endpoint. It also helps capture data content and test the flow of your automation process.

    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the webhook is located. 
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER Name 
    The name of the webhook to be used for the sending test. 
   
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Send-HPECOMWebhookTest -Region eu-central -Name "Webhook event for servers that are disconnected"

    Sends a typical resource object that matches the filtering configuration (i.e. a server resource object in this case) of the existing webhook named 'Webhook event for servers that are disconnected' located in the 'eu-central' region to the destination endpoint.
    
    .EXAMPLE
    Get-HPECOMWebhook -Region eu-central | Send-HPECOMWebhookTest

    Sends a typical resource object that matches the filtering configuration of all existing webhooks in the 'eu-central' region to their respective destination endpoints.

    .EXAMPLE
    "Webhook event for servers that are disconnected", "Webhook event for servers that are unhealthy" | Send-HPECOMWebhookTest -Region eu-central

    Sends a typical resource object that matches the filtering configuration of the webhooks named 'Webhook event for servers that are disconnected' and 'Webhook event for servers that are unhealthy' located in the 'eu-central' region to their respective destination endpoints.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the webhooks's names.

    System.Collections.ArrayList
        List of webhooks from 'Get-HPECOMWebhook'.

   .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - The name of the webhook used for the sending test.
        * Region - The name of the region where the webhook is located.
        * Status - The status of the send test attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed). 
        * Details - Additional information about the status. 
        * Exception - Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SendWebhookTestStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name
            $WebhookID = $WebhookResource.id


        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        "[{0}] Webhook ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $WebhookID | Write-Verbose

        if (-not $WebhookID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Webhook '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-Warning $ErrorMessage
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $EventFilter = $WebhookResource.eventFilter
            $Destination = $WebhookResource.destination


            # Define the regex pattern to match the resource type of webhook filter
            $pattern = "type eq '([^']*)'"

            # Use the -match operator to apply the pattern and capture the webhook resource type value
            if ($EventFilter -match $pattern) {
                
                # Extract the full type value (e.g. 'compute-ops/server')
                $fullTypeValue = $matches[1]

                # Extract the part after the last slash (e.g. 'server')
                $typeValue = $fullTypeValue -split '/' | Select-Object -Last 1

                "[{0}] Extracted webhook resource type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $typeValue | Write-Verbose

            }
            else {
                throw "The webhook test cannot be sent as the webhook resource type cannot be extracted from the webhook filter definition."
            }

            # Object to send creation
            switch ($typeValue) {
                server { 
                    $Object = Get-HPECOMServer -Region $Region | Select-Object -First 1
                }
                alert { 
                    $_SerialNumber = Get-HPECOMServer -Region $Region | Select-Object -First 1 | ForEach-Object serialNumber
                    $Object = Get-HPECOMServer -Region $Region -Name $_SerialNumber -ShowAlerts | Select-Object -First 1

                }                
                group { 
                    $Object = Get-HPECOMGroup -Region $Region | Where-Object { $_.devices.count -gt 1 } | Select-Object -first 1

                }                
                server-setting { 
                    $Object = Get-HPECOMSetting -Region $Region -Category Firmware | Select-Object -First 1

                }                
                job { 
                    $Object = Get-HPECOMJob -Region $Region | Select-Object -First 1

                }                
                compliance { 
                    $_name = Get-HPECOMGroup -Region $Region | Where-Object { $_.devices.count -gt 1 } | Select-Object -first 1 | ForEach-Object name
                    $Object = Get-HPECOMGroup -Region $Region -Name $_name -ShowCompliance | Select-Object -First 1

                }
                firmware-bundle { 
                    $Object = Get-HPECOMFirmwareBundle -Region $Region | Select-Object -First 1

                }

            }
         
            $jsonPayload = ConvertTo-Json -Depth 20 -InputObject $Object

            "[{0}] Webhook test object that will be sent: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jsonPayload | Write-Verbose

            
           
            try {

                if ($WhatIf) {

                    Invoke-RestMethodWhatIf -Uri $Destination -Method POST -Body $jsonPayload -ContentType "application/json" -Cmdlet Invoke-RestMethod


                } 
                else {

                    $Response = Invoke-RestMethod -Uri $Destination -method POST -body $jsonPayload -ContentType "application/json" 
                }
               
                              
                if (-not $WhatIf) {
                   
                    "[{0}] Webhook test raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                   
                    "[{0}] Webhook '{1}' test successfully send to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Destination | Write-Verbose
                   
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook test successfully sent to '$Destination' using a resource object of type '$typeValue'."
                   
                }
                
            }
            catch {

                $errorResponse = $_.Exception.Response
                
                if ($errorResponse) {
                
                    $statusCode = $errorResponse.StatusCode
                
                    if (-not $WhatIf -and $statusCode -eq 410) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Error: The destination webhook '$Destination' is no longer available!"
                        $objStatus.Exception = $_.Exception.message 

                    } 
                    elseif (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Webhook test sent to '$Destination' using a resource object of type '$typeValue' was not accepted!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }                  
            }


            [void] $SendWebhookTestStatus.add($objStatus)

        }
    }


    end {

        if (-not $WhatIf) {

            if ($SendWebhookTestStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more webhooks test failed the test attempt!"
          
            }
            
            $SendWebhookTestStatus = Invoke-RepackageObjectWithType -RawObject $SendWebhookTestStatus -ObjectName "COM.objStatus.NSDE"    
            Return $SendWebhookTestStatus
        }


    }
}


Function Remove-HPECOMWebhook {
    <#
    .SYNOPSIS
    Removes a webhook resource from a specified region.

    .DESCRIPTION
    This Cmdlet removes a webhook resource from a specific region using its name property.

    .PARAMETER Name 
    The name of the webhook to remove. 

    .PARAMETER Region 
    Specifies the region code of a Compute Ops Management instance provisioned in the workspace (e.g., 'us-west', 'eu-central', etc.) where the webhook should be removed.
    This mandatory parameter can be retrieved using 'Get-HPEGLService -Name "Compute Ops Management" -ShowProvisioned' or 'Get-HPEGLRegion -ShowProvisioned'.

    Auto-completion (Tab key) is supported for this parameter, providing a list of region codes provisioned in your workspace.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of executing the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" 
    
    Removes the webhook named 'Webhook for servers that become unhealthy' from the central EU region.

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west -Name "Webhook for servers that become unhealthy" | Remove-HPECOMWebhook 

    Removes the webhook named 'Webhook for servers that become unhealthy' from the western US region.

    .EXAMPLE
    Get-HPECOMWebhook -Region eu-central | Remove-HPECOMWebhook 

    Removes all webhooks from the central EU region.

    .EXAMPLE
    "POSH_webhook_Alert", "POSH_webhook_firmwarebundle" | Remove-HPECOMWebhook -Region eu-central 
    
    Removes the webhooks named 'POSH_webhook_Alert' and 'POSH_webhook_firmwarebundle' from the central EU region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the webhooks's names.

    System.Collections.ArrayList
        A list of webhooks retrieved from 'Get-HPECOMWebhook'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following properties:  
        * Name - The name of the webhook attempted to be removed.
        * Region - The name of the region where the webhook was removed.
        * Status - The status of the removal attempt (Failed for HTTP error; Complete if removal is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace! Please specify a valid region code (e.g., 'us-west', 'eu-central'). `nYou can retrieve the region code using: Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned. `nYou can also use the Tab key for auto-completion to see the list of provisioned region codes."
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveWebhookStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
              
        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
        
        $WebhookID = $WebhookResource.id

        
        if (-not $WebhookID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Webhook '{0}': Resource cannot be found in the '{1}' region!" -f $Name, $Region
                Write-warning $ErrorMessage
                return

            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be found in the region!"

            }

        }
        else {
            
            $Uri = $COMWebhooksUri + "/" + $WebhookID

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                if (-not $WhatIf) {

                    "[{0}] Webhook removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Webhook '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Webhook cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveWebhookStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more webhooks has failed!"

          
            }

            $RemoveWebhookStatus = Invoke-RepackageObjectWithType -RawObject $RemoveWebhookStatus -ObjectName "COM.objStatus.NSDE"    
            Return $RemoveWebhookStatus
        }


    }
}

#EndRegion




#EndRegion



#Region ------------------- GLP -----------------------------------------------------------------------------------------------------------------------------------------------


#Region --- DEVICE ---

Function Get-HPEGLDevice {
    <#
    .SYNOPSIS
    Retrieve device resource(s).

    .DESCRIPTION
    This Cmdlet returns a collection of device resources, individual device statistics, or specific devices with specified parameters such as serial numbers. 

    .PARAMETER PartNumber
    Specifies the part number associated with the resources.

    .PARAMETER SerialNumber
    Specifies the serial number associated with the resources.

    .PARAMETER ShowRequireAssignment
    Optional parameter to display devices that lack a service assignment.

    .PARAMETER ShowRequireSubscription
    Optional parameter to display devices that do not have a subscription tier.

    .PARAMETER ShowComputeReadyForCOMIloConnection
    Optional parameter to display devices that are ready for an iLO connection to a Compute Ops Management instance.

    .PARAMETER ShowArchived
    Optional parameter to display only archived devices.

    .PARAMETER ShowNotArchived 
    Optional parameter to hide archived devices.

    .PARAMETER SearchString
    Specifies a case-insensitive search string for device searches. The SearchString value can be either a full or partial match of the property. 
    Supported properties for the search include: serial number, model, and MAC address.

    .PARAMETER FilterByDeviceType
    Specifies the device type, such as STORAGE, COMPUTE, or SWITCH.

    .PARAMETER Location
    Specifies the location name.

    .PARAMETER ContactName
    Specifies the service delivery contact name.

    .PARAMETER ShowTags
    Optional parameter to display device tags.

    .PARAMETER Limit
    Defines the number of devices to be displayed.

    .PARAMETER ShowStats
    Optional parameter to display device statistics.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls.

    .EXAMPLE
    Get-HPEGLdevice

    Return all device resources.

    .EXAMPLE
    Get-HPEGLdevice -Limit 200

    Return the first 200 device resources.

    .EXAMPLE
    Get-HPEGLdevice -SerialNumber CN70490RXP

    Return the device resource with the serial number "CN70490RXP".

    .EXAMPLE
    Get-HPEGLdevice -PartNumber "P38471-B21"

    Return all device resources with the part number "P38471-B21".

    .EXAMPLE
    Get-HPEGLdevice -ShowStats

    Return device statistics.

    .EXAMPLE
    Get-HPEGLdevice | Where-Object { $_.part_number -eq "HF20" }

    Return a device resource with the part number "HF20".

    .EXAMPLE
    Get-HPEGLdevice -FilterByDeviceType STORAGE

    Return all device resources with the device type "STORAGE".

    .EXAMPLE
    Get-HPEGLdevice -Location "Houston-Datacenter"

    Return all device resources assigned to the "Houston-Datacenter" location.

    .EXAMPLE
    Get-HPEGLdevice -ShowRequireAssignment -SearchString DL360

    Return all DL360 device resources that require a service assignment.

    .EXAMPLE
    Get-HPEGLDevice -ShowComputeReadyForCOMIloConnection

    Return all compute device resources that are ready to connect to a Compute Ops Management instance using 'Connect-HPEGLDeviceComputeiLOtoCOM'.

    .EXAMPLE
    Get-HPEGLdevice -ShowRequireSubscription -ShowRequireAssignment

    Return all device resources that require both a subscription and a service assignment.

    .EXAMPLE
    Get-HPEGLdevice -ShowTags

    Return all device resources with tag information.

    .EXAMPLE
    Get-HPEGLDevice -ShowArchived

    Return all archived devices.

    .EXAMPLE
    "J12345605X", "J13134413T", "J21233335W", "J2123333S" | Get-HPEGLdevice

    Return all devices matching the given serial numbers from the pipeline.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectionType Direct | Get-HPEGLdevice -ShowTags
    
    Retrieve a list of HPE COM servers from the 'us-west' region with a direct connection type (not OneView) and then get the corresponding devices, displaying their tags.
    This example demonstrates how to chain the output of 'Get-HPECOMServer' to 'Get-HPEGLdevice'. The -ShowTags parameter is used to display the tags associated with each device.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the device's serial numbers.
    System.Collections.ArrayList
        List of device(s) from 'Get-HPECOMServer'.

    #>

    [CmdletBinding(DefaultParameterSetName = "NotArchived")]
    Param( 
        
        [Parameter (ParameterSetName = 'Archived', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (ParameterSetName = 'NotArchived', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,  

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$PartNumber, 

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowRequireAssignment,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowRequireSubscription,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowComputeReadyForCOMIloConnection,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowTags,

        [Parameter (ParameterSetName = 'Archived')]
        [Switch]$ShowArchived,

        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowNotArchived,

        [Parameter(ParameterSetName = 'Stats')]
        [Switch]$ShowStats,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$SearchString,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('ACCESS POINT', 'GATEWAY', 'SERVER', 'STORAGE', 'SWITCH')]
        [String]$FilterByDeviceType,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$Location,
        
        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$ContactName,
        
        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [int]$Limit,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        $SerialNumbersList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        if ($SerialNumber) {
            
            # Add serial number to the serial numbers list
            [void]$SerialNumbersList.Add($SerialNumber)
        
        }

    }
    End {
        
        if ($limit) {

            if ($SearchString) {
                $Uri = $DevicesUri + "?search_string=$SearchString&limit=$Limit"

            }
            else {
                $Uri = $DevicesUri + "?limit=$Limit"
            }



            try {
                [Array]$AllCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -WhatIfBoolean $WhatIf
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

        }
        else {            

            $Uri = $DevicesUri + "/filter"
            # $Uri = $DevicesUri 

            if ($SearchString) {

                $body = @{
                    unassigned_only    = $false
                    archive_visibility = "ALL"
                    search_string      = $SearchString
                } | ConvertTo-Json

            }
            else {
                
                $body = @{
                    unassigned_only    = $false
                    archive_visibility = "ALL"
                } | ConvertTo-Json 
    
            }
            

            try {

                [Array]$AllCollection = Invoke-HPEGLWebRequest -Method POST -Uri $Uri -Body $Body -WhatIfBoolean $WhatIf 
                # [Array]$AllCollection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf 
                
            }
            catch {
           
                $PSCmdlet.ThrowTerminatingError($_)
               
            }
           
        }           


        $ReturnData = @()
       
        if ($ShowStats) {
            
            $Uri = $DevicesStatsUri
            
            try {
                [Array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -WhatIfBoolean $WhatIf
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Device.stat"         
                return $ReturnData 

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
                       
        }
       
        else {        

            if ($Null -ne $AllCollection.devices) {     

                $CollectionList = $AllCollection.devices 

                If ($SerialNumbersList) {
    
                    "[{0}] Serial numbers list: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($SerialNumbersList | out-string) | Write-Verbose

                    # Filter devices based on serial numbers
                    $CollectionList = $CollectionList | Where-Object { $SerialNumbersList -contains $_.Serial_Number }
        
                }

                if ($PartNumber) {

                    $CollectionList = $CollectionList | Where-Object part_number -eq $PartNumber

                }   

                if ($ShowRequireAssignment) {

                    $CollectionList = $CollectionList | Where-Object { -not $_.application_instance_id }

                }   

                if ($ShowRequireSubscription) {

                    $CollectionList = $CollectionList | Where-Object { -not $_.subscription_key }

                }   

                if ($ShowComputeReadyForCOMIloConnection) {

                    $CollectionList = $CollectionList | Where-Object { $_.application_name -eq "Compute Ops Management" -and $_.subscription_key -and $_.application_instance_id }

                }                   

                if ($ShowArchived) {

                    $CollectionList = $CollectionList | Where-Object { $_.archived }

                }   

                if ($ShowNotArchived) {

                    $CollectionList = $CollectionList | Where-Object { -not $_.archived }

                }   
          
                if ($Location) {

                    $CollectionList = $CollectionList | Where-Object location_name -eq $Location

                }   

                if ($ContactName) {

                    $CollectionList = $CollectionList | Where-Object contact_name -eq $ContactName

                }   


                if ($FilterByDeviceType) {

                    switch ($FilterByDeviceType) {
                        "ACCESS POINT" { $_DeviceType = "AP" }
                        "GATEWAY" { $_DeviceType = "GATEWAY" }
                        "SERVER" { $_DeviceType = "COMPUTE" }
                        "STORAGE" { $_DeviceType = "STORAGE" }
                        "SWITCH" { $_DeviceType = "SWITCH" }
                    }

                    $CollectionList = $CollectionList | Where-Object device_type -match $_DeviceType

                }

                if ($ShowTags) {
       
                    $CollectionList = $CollectionList | Where-Object tags
       
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Device.Tag"         
                    $ReturnData = $ReturnData | Sort-Object { $_.serial_number }

                    return $ReturnData 
            
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Device"    
    
                $ReturnData = $ReturnData | Sort-Object { $_.serial_number }
        
                return $ReturnData 
                
            }
            else {

                return
                
            }     

        }
    
    }
}


Function Add-HPEGLDeviceCompute {
    <#
    .SYNOPSIS
    Add compute device(s) to HPE GreenLake.

    .DESCRIPTION
    This Cmdlet adds compute device(s) to the currently connected HPE GreenLake workspace. It can optionally add tags during the onboarding process. 
    
    Note: Devices to be added must be on the Compute Ops Management supported servers list. For more details, refer to the [supported servers list](https://support.hpe.com/hpesc/public/docDisplay?docId=sd00001293en_us&page=GUID-BC7D1D1B-AE36-4F00-A1FB-C1B9E01DF101).

    .PARAMETER SerialNumber
    Specifies the serial number of the device to be added. This value can be retrieved from the HPE iLO RedFish API.

    .PARAMETER PartNumber
    Specifies the part number of the device to be added. This value can be retrieved from the HPE iLO RedFish API.

    .PARAMETER Tags
    Optional parameter to add tags to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

    Supported tags example:
        - "Country=US"
        - "Country=US,State=TX,App=Grafana" 
        - "Country=US, State =TX ,App= Grafana "
            -> Produces the same result as the previous example.
        - "Private note=this is my tag note value,Email=Chris@email.com,City=New York" 
        - "Private note = this is my tag note value , Email = Chris@email.com , City=New York "
            -> Produces the same result as the previous example.   

    Refer to HPE GreenLake tagging specifications:
    https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
        - Resources that support tagging can have up to 25 tags per resource.
        - Tag keys and values are case-insensitive.
        - There can be only one value for a particular tag key for a given resource.
        - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
        - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
        - Tag keys must have 1-128 characters.
        - Tag values can have a maximum of 256 characters.
        - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceCompute -SerialNumber "123456789012" -PartNumber "879991-B21" -Tags "Country=US, Hypersior App=ESXi, City=New York"
    
    Adds a compute device to the currently connected HPE GreenLake workspace using a serial number and part number and assigns three tags.

    .EXAMPLE
    Import-Csv Compute_Devices.csv | Add-HPEGLDeviceCompute -Tags "Location=Houston"
    
    Adds all compute devices listed in a `Compute_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns the same location tag to all devices.

    The content of the CSV file must use the following format:
        SerialNumber, PartNumber
        WGX2380BLC, P55181-B21
        DZ12312312, P55182-B21
        CZ12312312, P54277-B21
      
    .EXAMPLE
    Import-Csv .\Compute_Devices_Tags.csv -Delimiter ";"  | Add-HPEGLDeviceCompute  
    
    Adds all compute devices listed in a `Compute_Devices_Tags.csv` file to the currently connected HPE GreenLake workspace and assigns tags as defined in the 'Tags' column of the CSV file.

    The content of the CSV file must use the following format:
        SerialNumber; PartNumber; Tags
        WGX2380BLC; P55181-B21; Country=US, State=CA, App=RH
        EZ12312312; P55182-B21; State=TX, Role=Production
        CZ12312312; P54277-B21
        7LKY2323233LM; P54277-B21; City=New York

        Note that for `CZ12312312`, no tags are assigned in this example.

    .EXAMPLE
    # Example when you don't have the serial numbers and part numbers but only the iLO IP addresses and credentials.

    $iLO_collection = import-csv Private\iLOs.csv -Delimiter ";"  
    Import-Module HPEiLOCmdlets 

    $ComputeDevicesToAdd = @()

    ForEach ($iLO in $iLO_Collection) {
        try {
            $session = Connect-HPEiLO -Address $iLO.IP -username $iLO.Username -password $iLO.Password -DisableCertificateAuthentication -ErrorAction Stop
            $HPEiLOSystemInfo = Get-HPEiLOSystemInfo -Connection $session 

            $SerialNumber = $HPEiLOSystemInfo.SerialNumber
            $PartNumber = $HPEiLOSystemInfo.sku
            $Tags = $iLO.Tags
            
            $ComputeDevicesToAdd += [PSCustomObject]@{SerialNumber = $SerialNumber; PartNumber = $PartNumber; Tags = $Tags }

            Disconnect-HPEiLO -Connection $session
        }
        catch {
            "iLO {0} cannot be added ! Check your IP or credentials !" -f $iLO.IP
            continue
        }
    }

    $ComputeDevicesToAdd  | Add-HPEGLDeviceCompute 

    Sample script to add all compute devices listed in an `iLOs.csv` file to the currently connected HPE GreenLake workspace. Device information (part number and serial number) is retrieved using the HPEiLOCmdlets module with the IP and credentials provided in the CSV file. Optionally, tags can also be provided.

    The content of the iLOs.csv file must use the following format:
        IP; Username; Password; Tags
        192.168.1.44; demo; password; Country=FR, State=PACA, App=RH
        192.168.0.40; Administrator; P@ssw0rd; State=Texas, Role=production
        192.168.3.194; Admin; Password!    
        
        Note that for `192.168.3.194`, no tags are assigned in this example.

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = '123456789012'; PartNumber = 'P55181-B21'},
        [PSCustomObject]@{SerialNumber = '123432356789'; PartNumber = 'P54277-B21'}
    )

    $devices | Add-HPEGLDeviceCompute -Tags "Country=US, Department=Marketing"
    
    Adds all compute devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them two identical tags.

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = '123456789012'; PartNumber = 'P55181-B21'; Tags = 'Country=US, State=PACA, App=RH' },
        [PSCustomObject]@{SerialNumber = '123432356789'; PartNumber = 'P54277-B21'; Tags = 'State=Texas, Role=production' }
    )

    $devices | Add-HPEGLDeviceCompute 
    
    Adds all compute devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them different tags.

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber, partnumber and tags properties. 

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be added
        * PartNumber - Part number of the device attempted to be added
        * TagsAdded - List of tags to assign to the device (if any)
        * Status - Status of the device onboarding attempt (Failed for HTTP error return; Complete if onboarding is successful; Warning if no action is needed) 
        * Details - More information about the onboarding status of the device, which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - Error - More information on a warning or failed status error.
        * Exception - Information about any exceptions generated during the operation.

    #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('part_number')]
        [String]$PartNumber,

        [Parameter (ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesAddUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesToAddList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            PartNumber   = $PartNumber
            TagsAdded    = $Tags
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        
        foreach ($DeviceToAdd in $ObjectStatusList) {
            
            
            $ErrorFoundInTags = $False

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAdd.SerialNumber
            
            
            if ( $Device) {

                $DeviceToAdd.Status = "Warning"
                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device already present in the workspace!" }
                $DeviceToAdd.TagsAdded = $Null
                
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource already present in the workspace!" -f $DeviceToAdd.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {
                
                if ($DeviceToAdd.TagsAdded) {
                    
                    "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber, $DeviceToAdd.TagsAdded | Write-Verbose

                    $splittedtags = $DeviceToAdd.TagsAdded.split(",")

                    if ($splittedtags.Length -gt 25) {
                        
                        $DeviceToAdd.Status = "Failed"
                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }
                        $DeviceToAdd.TagsAdded = $Null
                        $ErrorFoundInTags = $True


                        if ($WhatIf) {
                            $ErrorMessage = "Device '{0}': Resource is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAdd.SerialNumber
                            Write-warning $ErrorMessage
                            continue
                        }
                    }
                    else {

                        # Object for the tracking object
                        $TagsList = [System.Collections.ArrayList]::new()
                        # Object for the payload
                        $TagsArray = @{}
                                
                        foreach ($tag in $splittedtags) {
    
                            # Check tag format, if format is not <tagname>=<value>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                                
                                $splittedtagName = $tag.TrimEnd().TrimStart()
    
                                $DeviceToAdd.Status = "Failed"
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }
                                $DeviceToAdd.TagsAdded = $Null
                                $ErrorFoundInTags = $True
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}': Tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAdd.SerialNumber, $splittedtagName
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
    
                                $tagname = $tag.split('=')[0]
        
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tagname.TrimEnd().TrimStart()
        
                                if ($tagname.Length -gt 128) {
        
                                    $DeviceToAdd.Status = "Failed"
                                    $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }
                                    $DeviceToAdd.TagsAdded = $Null
                                    $ErrorFoundInTags = $True
        
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}': Tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAdd.SerialNumber, $tagname
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {
                                    
                                    $tagvalue = $tag.split('=')[1]
                                    
                                    # Remove space at the begining and at the end of the string if any
                                    $tagvalue = $tagvalue.TrimEnd().TrimStart()
            
                                    if ($tagvalue.Length -gt 256) {
            
                                        $DeviceToAdd.Status = "Failed"
                                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }
                                        $DeviceToAdd.TagsAdded = $Null
                                        $ErrorFoundInTags = $True
            
                                        if ($WhatIf) {
                                            $ErrorMessage = "Device '{0}': Tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAdd.SerialNumber, $tagvalue
                                            Write-warning $ErrorMessage
                                            break
                                        }
                                    }
                                    else {
    
                                        $TagsArray.$tagname = $tagvalue 
                
                                        $TagsList += [PSCustomObject]@{
                                            name  = $tagname
                                            value = $tagvalue 
                                        }
                                    }
                                }
                            }
                        } 
                    }


                    if ($TagsList -and -not $ErrorFoundInTags) {
                        
                        $DeviceToAdd.TagsAdded = $TagsList
                    }
    
                }
                else {
    
                    "[{0}] {1}: No tags to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber | Write-Verbose
    
                }
                
                

                # Build DeviceList object

                if (-not $ErrorFoundInTags) {

                    # If tags
                    if ($DeviceToAdd.TagsAdded) {
                    
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            tags         = $TagsArray 
                        }
                    }
                    # If no tags
                    else {
                        
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            
                        }
                    }
    
                    [void]$DevicesToAddList.Add($DeviceList)
                }

            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        if ($DevicesToAddList) {

            # Build payload
            $payload = [PSCustomObject]@{
                compute = $DevicesToAddList 
                network = @()
                storage = @()
            } | ConvertTo-Json -Depth 5
            

            # Add device
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Complete"

                            if ($DeviceToAdd.TagsAdded) {
                                
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = $DeviceToAdd.TagsAdded.count; Error = $Null }
                            }
                            else {
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = $Null }

                            }

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Failed"
                            $DeviceToAdd.TagsAdded = $Null
                            $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device cannot be added to the HPE GreenLake workspace!" }
                            $DeviceToAdd.Exception = $_.Exception.message 

                        }
                    }
                }
            }      
        }
    
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the onboarding attempt!"
            
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Device.Add.SPTSDE"    
            Return $ObjectStatusList
        }

    }
}
        

Function Connect-HPEGLDeviceComputeiLOtoCOM {
    <#
    .SYNOPSIS
    Connect an iLO of a compute device to a Compute Ops Management instance.

    .DESCRIPTION

    By default (i.e., when the 'ActivationKeyFromCOM' parameter is not used), this Cmdlet connects the iLO of a compute device to the assigned Compute Ops Management instance.

      - Requirement: The compute device must first be added to the workspace using 'Add-HPEGLDeviceCompute', then assigned to a Compute Ops Management instance using 'Add-HPEGLDeviceToService', and finally attached to a valid subscription key using Add-HPEGLSubscriptionToDevice.

      - You can use 'Get-HPEGLDevice -ShowComputeReadyForCOMIloConnection' to retrieve all compute devices ready to be connected to a Compute Ops Management instance.
        

    When the 'ActivationKeyFromCOM' parameter is used, the following steps take place:

       1- The compute device is added to the HPE GreenLake workspace.

       2- The compute device is attached to the Compute Ops Management instance from which the provided activation key was generated.

       3- The compute device is assigned to the Compute Ops Management subscription key set by 'New-HPECOMServerActivationKey' or by the auto subscription policy using 'Set-HPEGLDeviceAutoSubscription'.

       4- The iLO of the compute device is connected to the Compute Ops Management instance from which the provided activation key was generated.
       
    Requirement: An activation key is required and can be generated using 'New-HPECOMServerActivationKey'. The COM activation key is not supported for iLO5 versions lower than v3.09 and iLO6 versions lower than v1.64.
       
       - You can use 'Get-HPECOMServerActivationKey' to retrieve all generated and valid activation keys for the different Compute Ops Management instances where you want the compute device to be connected.
       

    .PARAMETER SerialNumber
    Specifies the serial number of the device to be connected to Compute Ops Management.

    .PARAMETER IloIP
    Specifies the iLO IP address or hostname of the device to be connected to Compute Ops Management.
    
    .PARAMETER IloCredential
    A PSCredential object comprising the username and password associated with the iLO of the device that is being added.
    
    .PARAMETER ActivationKeyFromCOM
    (Optional) Specifies the Compute Ops Management activation key to be used for the connection. This activation key is retrieved using 'Get-HPECOMServerActivationKey'. 
    If not provided, the workspace account ID is used, and in this case, ensure the server is attached to a valid subscription key.

    .PARAMETER SkipCertificateValidation
    Skips certificate validation checks that include all validations such as expiration, revocation, trusted root authority, etc.

    [WARNING]:  Using this parameter is not secure and is not recommended. This switch is only intended to be used against known hosts using a self-signed certificate for testing purposes. Use at your own risk.

    .PARAMETER IloProxyServer
    (Optional) Enables iLO web proxy. Specifies the hostname or IP address of the web proxy server.
    
    .PARAMETER IloProxyPort
    (Optional) Specifies the iLO web proxy port number. The range of valid port values in iLO is from 1 to 65535.
    
    .PARAMETER IloProxyUserName
    (Optional) Specifies the iLO web proxy username, if applicable.
    
    .PARAMETER IloProxyPassword
    (Optional) Specifies the iLO web proxy password, if applicable, as a SecureString.

    .PARAMETER DisconnectiLOfromOneView
    If present, this switch parameter disconnects a system managed by HPE OneView in order to connect it to Compute Ops Management. If absent, the connection to Compute Ops Management will fail if the system is already managed by HPE OneView.
    
    .EXAMPLE
    $iLO_credential = Get-Credential 
    Connect-HPEGLDeviceComputeiLOtoCOM -SerialNumber "123456789012" -IloIP "192.168.0.21" -IloCredential $iLO_credential -SkipCertificateValidation
    
    Connect the iLO at 192.168.0.21 of compute device "123456789012" to the currently assigned Compute Ops Management instance. Certificate validation checks are skipped.
    
    .EXAMPLE
    Connect-HPEGLDeviceComputeiLOtoCOM -SerialNumber "123456789012" -IloIP "192.168.1.151" -IloCredential $iLO_credential -IloProxyServer "web-proxy.domain.com" -IloProxyPort 8080

    Connect the iLO at 192.168.1.151 of compute device "123456789012" to the currently assigned Compute Ops Management instance through a web proxy.

    .EXAMPLE
    $iLO_secureString_Proxy_Password = Read-Host -Prompt "Enter the proxy password" -AsSecureString
    Connect-HPEGLDeviceComputeiLOtoCOM -SerialNumber "123456789012" -IloIP "192.168.0.21" -IloCredential $iLO_credential -IloProxyServer "web-proxy.domain.com" -IloProxyPort 8080 -IloProxyUserName "admin" -IloProxyPassword $iLO_secureString_Proxy_Password

    Connect the iLO at 192.168.0.21 of compute device "123456789012" to the currently assigned Compute Ops Management instance through a web proxy using a username and password.

    .EXAMPLE
    $iLO_credential = Get-Credential 
    Import-Csv .\iLOs-List-To-Connect-To-COM.csv | Connect-HPEGLDeviceComputeiLOtoCOM -IloCredential $iLO_credential

    Connect all compute device iLOs listed in the `iLOs-List-To-Connect-To-COM.csv` file to the Compute Ops Management instance assigned to them.

    The content of the CSV file must use the following format:
        SerialNumber, IP
        DZ12312312, 192.188.2.151
        CZ12312312, 192.188.2.152

    .EXAMPLE
    $iLOs =  .\iLOs-List-To-Connect-To-COM.csv -Delimiter ","

    # Retrieve the first available Compute Ops Management subscription key that is valid and with available quantitiy 
    $Subscription_Key = Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -FilterBySubscriptionType Server | Select-Object -First 1 -ExpandProperty key

    # Generate an activation key for the Compute Ops Management in the central european region 
    $COM_Activation_Key = New-HPECOMServerActivationKey -Region eu-central -SubscriptionKey $Subscription_Key 
    
    ForEach ($iLO in $iLOs) {
      try {
        $iLO_SecurePassword = ConvertTo-SecureString $ILO.Password -AsPlainText -Force
        $iLO_credential = New-Object System.Management.Automation.PSCredential ($iLO.Username, $iLO_SecurePassword)
        Connect-HPEGLDeviceComputeiLOtoCOM -iLOCredential $iLO_credential -IloIP $iLO.IP -ActivationKeyfromCOM $COM_Activation_Key
      }
      catch {
        "iLO {0} cannot be connected to COM ! Check your network access, iLO IP or credentials !" -f $iLO.IP
        continue
      }          
    }

    The compute devices listed in the `iLOs-List-To-Connect-To-COM.csv` file are added to the HPE GreenLake workspace, 
    attached to the Compute Ops Management 'eu-central' instance from which the activation key was generated, 
    assigned to the Compute Ops Management subscription key retrieved by 'Get-HPEGLSubscription' 
    and connected directly to the Compute Ops Management instance without using a web proxy.

    The content of the CSV file must use the following format:
       IP, Username, Password
       192.168.0.1, admin, password
       192.168.0.2, Administrator, password
       192.168.0.3, demo, password

    .EXAMPLE
    $iLOs =  .\iLOs-List-To-Connect-To-COM.csv -Delimiter ","

    # Retrieve the first available Compute Ops Management subscription key that is valid and with available quantitiy 
    $Subscription_Key = Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -FilterBySubscriptionType Server | Select-Object -First 1 -ExpandProperty key

    # Generate an activation key for the Compute Ops Management in the central european region 
    $COM_Activation_Key = New-HPECOMServerActivationKey -Region eu-central -SubscriptionKey $Subscription_Key 
    
    ForEach ($iLO in $iLOs) {
      try {
        $iLO_SecurePassword = ConvertTo-SecureString $ILO.Password -AsPlainText -Force
        $iLO_credential = New-Object System.Management.Automation.PSCredential ($iLO.Username, $iLO_SecurePassword)
        Connect-HPEGLDeviceComputeiLOtoCOM -iLOCredential $iLO_credential -IloIP $iLO.IP -ActivationKeyfromCOM $COM_Activation_Key -IloProxyServer "web-proxy.domain.com" -IloProxyPort 8080
      }
      catch {
        "iLO {0} cannot be connected to COM ! Check your network access, iLO IP or credentials !" -f $iLO.IP
        continue
      }          
    }

    The compute devices listed in the `iLOs-List-To-Connect-To-COM.csv` file are added to the HPE GreenLake workspace, 
    attached to the Compute Ops Management 'eu-central' instance from which the activation key was generated, 
    assigned to the Compute Ops Management subscription key retrieved by 'Get-HPEGLSubscription' 
    and connected to the Compute Ops Management instance through a web proxy.

    The content of the CSV file must use the following format:
       IP, Username, Password
       192.168.0.1, admin, password
       192.168.0.2, Administrator, password
       192.168.0.3, demo, password

    .EXAMPLE
    $iLOs =  .\iLOs-List-To-Connect-To-COM.csv -Delimiter ","

    # Retrieve the name of the first available Compute Ops Management Secure Gateway in the central european region
    $SecureGatewayName = Get-HPECOMAppliance -Region eu-central -Type SecureGateway | select -first 1 -ExpandProperty name
    
    # Generate an activation key for the Compute Ops Management Secure Gateway in the central european region 
    $COM_Activation_Key = New-HPECOMServerActivationKey -Region eu-central -SecureGateway $SecureGatewayName  
    
    ForEach ($iLO in $iLOs) {
      try {
        $iLO_SecurePassword = ConvertTo-SecureString $ILO.Password -AsPlainText -Force
        $iLO_credential = New-Object System.Management.Automation.PSCredential ($iLO.Username, $iLO_SecurePassword)
        Connect-HPEGLDeviceComputeiLOtoCOM -iLOCredential $iLO_credential -IloIP $iLO.IP -ActivationKeyfromCOM $COM_Activation_Key -IloProxyServer $SecureGatewayName -IloProxyPort 8080 
      }
      catch {
        "iLO {0} cannot be connected to COM ! Check your network access, iLO IP or credentials !" -f $iLO.IP
        continue
      }          
    }

    The compute devices listed in the `iLOs-List-To-Connect-To-COM.csv` file are added to the HPE GreenLake workspace, 
    attached to the Compute Ops Management 'eu-central' instance from which the activation key was generated, 
    assigned to the Compute Ops Management subscription key retrieved by 'Get-HPEGLSubscription' 
    and connected to the Compute Ops Management instance through a Compute Ops Management Secure Gateway.

    The content of the CSV file must use the following format:
       IP, Username, Password
       192.168.0.1, admin, password
       192.168.0.2, Administrator, password
       192.168.0.3, demo, password

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber and IP properties (iLO IP address).

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * iLO - iLO IP address of the device to connect to Compute Ops Management.
        * SerialNumber - Serial number of the device.
        * Status - Status of the iLO connection and configuration attempt (Failed for error; Complete if successful; Warning if no action is needed or another condition was encountered).
        * Details - More information about the status.
        * iLOConnectionStatus - Status of the iLO connection attempt to Compute Ops Management (Failed for HTTP error return; Complete if successful, Warning if another condition was encountered).
        * iLOConnectionDetails - More information about the iLO connection attempt status.
        * ProxySettingsStatus - Status of the iLO Proxy configuration attempt (Failed for HTTP error return; Complete if successful).
        * ProxySettingsDetails - More information about the iLO Proxy configuration status.
        * Exception - Information about any exceptions generated during the operation.
#>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or
                $_ -match [Net.IPAddress]$_ })]
        [Alias ('IP')]
        [IPAddress]$IloIP,
  
        [Parameter (Mandatory)]
        [ValidateNotNullOrEmpty()]
        [PSCredential]$iLOCredential,

        [Parameter (Mandatory, ParameterSetName = 'ActivationKey')]
        [string]$ActivationKeyfromCOM,

        [Switch]$SkipCertificateValidation,

        [String]$IloProxyServer,
  
        [Int]$IloProxyPort,
  
        [String]$IloProxyUserName,
  
        [System.Security.SecureString]$IloProxyPassword,

        [Switch]$DisconnectiLOfromOneView

  
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $iLOConnectionStatus = [System.Collections.ArrayList]::new()

        try {
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Create object for the output
        $objStatus = [pscustomobject]@{
  
            iLO                  = $IloIP
            SerialNumber         = $Null
            Status               = $Null
            Details              = $Null
            iLOConnectionStatus  = $Null
            iLOConnectionDetails = $Null
            ProxySettingsStatus  = $Null
            ProxySettingsDetails = $Null
            Exception            = $Null
        }

        if ($SerialNumber ) {

            $objStatus.SerialNumber = $SerialNumber 
                        
            # Test if device present
            $device = $devices | Where-Object serial_number -eq $SerialNumber
            
            if ( -not $device) {
                # Must return a message if device is not found
                $objStatus.Status = "Failed"
                $objStatus.Details = "Device cannot be found in the HPE GreenLake workspace"
                [void] $iLOConnectionStatus.add($objStatus)
                return
                
            }
            elseif (-not $device.ccs_region) {
                # Must return a message if device is not assigned to COM
                $objStatus.Status = "Failed"
                $objStatus.Details = "Device is not assigned to any service instance!"
                [void] $iLOConnectionStatus.add($objStatus)
                return
                
            }
            elseif (-not $device.subscription_key) {
                # Must return a message if device has no subscription
                $objStatus.Status = "Failed"
                $objStatus.Details = "Device has not been attached to any subscription!"
                [void] $iLOConnectionStatus.add($objStatus)
                return
                
            }
        }
         

        #Region----------------------------------------------------------- Create iLO session -----------------------------------------------------------    
      
        # Test network connectivity with iLO
        $IsILOAccessible = (New-Object System.Net.NetworkInformation.Ping).Send($IloIP, 4000) 

        "[{0}] PING iLO '{1}' test result: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $IsILOAccessible.status | Write-Verbose

        if ($IsILOAccessible.Status -ne "Success") {
            $objStatus.Status = "Failed"
            $objStatus.Details = "iLO is not reachable. Please ensure your are connected to the iLO network."
            [void] $iLOConnectionStatus.add($objStatus)
            return       
        }


        $iLOBaseURL = "https://$IloIP"
            
        $AddURI = "/redfish/v1/SessionService/Sessions/"
            
        $url = $iLOBaseURL + $AddURI

        $IloUsername = $iLOCredential.UserName
        $IlodecryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($iLOCredential.Password))
            
        $Body = [System.Collections.Hashtable]@{
            UserName = $IloUserName
            Password = $IlodecryptPassword
        } | ConvertTo-Json 
            
        "[{0}] '{1}' -- Attempting an iLO session creation!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
        "[{0}] '{1}' -- Method: POST - URI: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $url | Write-Verbose
        "[{0}] '{1}' -- Body content: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $Body | Write-Verbose

        try {

            if ($SkipCertificateValidation) {
                $response = Invoke-WebRequest -Method POST -Uri $url -Body $Body -ContentType "Application/json" -SkipCertificateCheck -ErrorAction Stop
            }
            else {
                $response = Invoke-WebRequest -Method POST -Uri $url -Body $Body -ContentType "Application/json" -ErrorAction Stop
            }
            
            $XAuthToken = (($response.RawContent -split "[`r`n]" | select-string -Pattern 'X-Auth-Token' ) -split " ")[1]
            
            "[{0}] '{1}' -- Received status code response: '{2}' - Description: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose              
            "[{0}] '{1}' -- Raw response: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $response | Write-Verbose

            "[{0}] '{1}' -- iLO session created successfully!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose

        }
        catch {

            # Check if the exception message contains invalid certificate error
            if ($_.Exception.InnerException.Message -match "remote certificate is invalid") {
                    
                $objStatus.iLOConnectionStatus = "Failed"
                $objStatus.iLOConnectionDetails = "Failed to create iLO session due to certificate validation error. To bypass certificate validation checks, including expiration, revocation, and trusted root authority, use the -SkipCertificateValidation switch. Warning: This is not recommended as it is insecure because it exposes the connection to potential man-in-the-middle attacks and other security risks."
                $objStatus.Exception = $_.Exception.InnerException.Message 
                
                "[{0}] '{1}' -- Attempt to create iLO session failed due to certificate validation error!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose

            }
            else {               
                
                $objStatus.iLOConnectionStatus = "Failed"
                $objStatus.iLOConnectionDetails = "iLO connection error! Verify the iLO IP address, credentials, and ensure you have an active connection to the iLO network, then try again."
                $objStatus.Exception = $_.Exception.message 
                
                "[{0}] '{1}' -- iLO session cannot be created!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
            }

            $objStatus.Status = "Failed"
            [void] $iLOConnectionStatus.add($objStatus)
            return
        }
        
        #endregion

        #Region----------------------------------------------------------- Get System information -----------------------------------------------------------
                
        $Headers = [System.Collections.Hashtable]@{
            'X-Auth-Token'  = $XAuthToken
            'Content-Type'  = 'application/json'
            'OData-Version' = '4.0'    
        }

        "[{0}] '{1}' -- Getting iLO generation " -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
            
        $AddURI = "/redfish/v1/Managers/1/"

        try {

            if ($SkipCertificateValidation) {
                $Manager = Invoke-RestMethod -Method GET -Uri ($iLObaseURL + $AddURI) -Headers $Headers -SkipCertificateCheck
            }
            else {
                $Manager = Invoke-RestMethod -Method GET -Uri ($iLObaseURL + $AddURI) -Headers $Headers
            }            
        }
        catch {
            
            $objStatus.iLOConnectionStatus = "Failed"
            $objStatus.iLOConnectionDetails = "iLO communication error!"
            $objStatus.Exception = $_.Exception.message 

            "[{0}] '{1}' -- iLO communication error!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
            $objStatus.Status = "Failed"
            [void] $iLOConnectionStatus.add($objStatus)
            return
        }
            
        $iLOGeneration = $Manager.model
        $iLOFWVersion = ($Manager.firmwareVersion.split(" "))[2].TrimStart('v')  # "FirmwareVersion": "iLO 5 v3.06" or "iLO 6 v1.62"

        "[{0}] '{1}' - iLO generation: {2} - Version: {3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $iLOGeneration, $iLOFWVersion | Write-Verbose
        
        #EndRegion
        #Region----------------------------------------------------------- iLO Firmware validation with COM activation key -----------------------------------------------------------
        # Check if the iLO firmware version is compatible with the COM activation key
        # Servers running earlier versions of iLO 5 and iLO 6 can be activated by using the HPE GreenLake workspace ID.
        # COM activation key is not supported if iLO5 lower than v3.09 and if iLO6 lower than v1.64.
        
        if ($ActivationKeyfromCOM) {
            
            # Need to retrieve serial number for $objStatus
            $AddURI = "/redfish/v1/Systems/1/"

            try {

                if ($SkipCertificateValidation) {
                    $System = Invoke-RestMethod -Method GET -Uri ($iLObaseURL + $AddURI) -Headers $Headers -SkipCertificateCheck
                }
                else {
                    $System = Invoke-RestMethod -Method GET -Uri ($iLObaseURL + $AddURI) -Headers $Headers
                }             
                
            }
            catch {
                
                $objStatus.iLOConnectionStatus = "Failed"
                $objStatus.iLOConnectionDetails = "iLO communication error!"
                $objStatus.Exception = $_.Exception.message 
    
                "[{0}] '{1}' -- iLO communication error!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
                $objStatus.Status = "Failed"
                [void] $iLOConnectionStatus.add($objStatus)
                return
                
            }

            $SerialNumber = $System.serialnumber 
            
            $objStatus.SerialNumber = $SerialNumber

            if ($iLOGeneration -eq "iLO 5" -and [decimal]$iLOFWVersion -lt [decimal]3.09) {

                
                $objStatus.iLOConnectionStatus = "Failed"
                $objStatus.iLOConnectionDetails = "Server cannot be connected to COM using a COM activation key because the iLO firmware version is lower than v3.09. Please run the cmdlet without the 'ActivationKeyfromCOM' parameter."
                
                "[{0}] '{1}' -- iLO '{2}' - The iLO {3} firmware version {4} is NOT compatible with the COM activation key ! iLO cannot be connected to COM using a COM activation key because the iLO firmware version is lower than v3.09" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $iLOGeneration, $iLOFWVersion | Write-Verbose
                
                $objStatus.Status = "Failed"
                [void]$iLOConnectionStatus.add($objStatus) 
                return

            }
            elseif ($iLOGeneration -eq "iLO 6" -and [decimal]$iLOFWVersion -lt [decimal]1.64) {

                
                $objStatus.iLOConnectionStatus = "Failed"
                $objStatus.iLOConnectionDetails = "Server cannot be connected to COM using a COM activation key because the iLO firmware version is lower than v1.64. Please run the cmdlet without the 'ActivationKeyfromCOM' parameter."

                "[{0}] '{1}' -- iLO '{2}' - The iLO {3} firmware version {4} is NOT compatible with the COM activation key ! iLO cannot be connected to COM using a COM activation key because the iLO firmware version is lower than v1.64" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $iLOGeneration, $iLOFWVersion | Write-Verbose
                
                $objStatus.Status = "Failed"
                [void]$iLOConnectionStatus.add($objStatus)
                return
            }
            else {
                
                "[{0}] '{1}' -- iLO '{2}' - The iLO {3} firmware version {4} is compatible with the COM activation key" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $iLOGeneration, $iLOFWVersion | Write-Verbose
            }
            
        }
        
        
        #EndRegion
                
        #Region----------------------------------------------------------- Enable iLO proxy settings or secure gateway if needed -----------------------------------------------------------------------------

        if ($iLOGeneration -eq "iLO 5" -or $iLOGeneration -eq "iLO 6") {       

            if ($IloProxyServer) {

                "[{0}] '{1}' -- iLO '{2}' attempting iLO proxy server settings" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose

                $AddURI = "/redfish/v1/Managers/1/NetworkProtocol/"

                $url = ( $iLObaseURL + $AddURI)


                if ($IloProxyUserName -and $IloProxyPassword) {
                    
                    $Ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($IloProxyPassword)
                    $IloProxyPasswordPlainText = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($Ptr)

                    $Body = [System.Collections.Hashtable]@{
                        Oem = @{
                            Hpe = @{
                                WebProxyConfiguration = @{
                                    ProxyServer   = $IloProxyServer
                                    ProxyPort     = $IloProxyPort
                                    ProxyUserName = $IloProxyUserName
                                    ProxyPassword = $IloProxyPasswordPlainText
                                }
                            }
                        }
                    } | ConvertTo-Json -d 9

                }
                else {

                    $Body = [System.Collections.Hashtable]@{
                        Oem = @{
                            Hpe = @{
                                WebProxyConfiguration = @{
                                    ProxyServer = $IloProxyServer
                                    ProxyPort   = $IloProxyPort
                                }
                            }
                        }
                    } | ConvertTo-Json -d 9

                }

                "[{0}] '{1}' -- iLO '{2}' - Method: POST - URI: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $url | Write-Verbose
                "[{0}] '{1}' -- iLO '{2}' - Hearders content: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($Headers | Out-String) | Write-Verbose
                "[{0}] '{1}' -- iLO '{2}' - Body content: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $Body | Write-Verbose

                try {
                    
                    if ($SkipCertificateValidation) {
                        $Response = Invoke-RestMethod -Method PATCH -Uri $url -Headers $Headers -Body $Body -ErrorAction Stop -SkipCertificateCheck
                    }                        
                    else {
                        $Response = Invoke-RestMethod -Method PATCH -Uri $url -Headers $Headers -Body $Body -ErrorAction Stop
                    }

    
                    "[{0}] '{1}' -- iLO '{2}' - Raw response: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($Response | Out-String) | Write-Verbose

                    $msg = $response.error.'@Message.ExtendedInfo'.MessageId
                
                    "[{0}] '{1}' -- iLO '{2}' - Response: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $msg | Write-Verbose
    
                    if ($msg -match "Success") {
                        "[{0}] '{1}' -- iLO '{2}' proxy server settings modified successfully!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.ProxySettingsStatus = "Complete"
                        $objStatus.ProxySettingsDetails = "iLO proxy server settings modified successfully!"
                    }
                    else {
                        "[{0}] '{1}' -- iLO '{2}' proxy server settings modification error!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.ProxySettingsStatus = "Failed"
                        $objStatus.ProxySettingsDetails = $msg                        
                    }                

                }
                catch {

                    "[{0}] '{1}' -- iLO '{2}' proxy server settings cannot be configured! Error: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $_ | Write-Verbose

                    $objStatus.ProxySettingsStatus = "Failed"
                    $objStatus.ProxySettingsDetails = $_.Exception.message 
                    [void] $iLOConnectionStatus.add($objStatus)
                    return

                }
            }

            #EndRegion
            
            #Region----------------------------------------------------------- Connect iLO to Compute Ops Management -----------------------------------------------------------------------------

            "{0} -- Attempting to connect iLO '{1}' to the Compute Ops Management instance..." -f $SerialNumber, $IloIP | Write-Verbose
        
            # If -DisconnectiLOfromOneView switch used: disconnect iLO from Oneview
            if ($DisconnectiLOfromOneView) { 
                $OverrideManager = $True 
            } 
            else {
                $OverrideManager = $False
            }

            if ($ActivationKeyfromCOM) {
                $ActivationKey = $ActivationKeyfromCOM
            }
            else {
                $ActivationKey = $HPEGreenLakeSession.workspaceId
            }

            $Body = [System.Collections.Hashtable]@{
                ActivationKey   = $ActivationKey
                OverrideManager = $OverrideManager
            } | ConvertTo-Json 
                    
                    
            $AddURI = "/redfish/v1/Managers/1/Actions/Oem/Hpe/HpeiLO.EnableCloudConnect"

            $url = ( $iLObaseURL + $AddURI)    
        
            "[{0}] '{1}' -- iLO '{2}' - Method: POST - URI: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $url | Write-Verbose
            "[{0}] '{1}' -- iLO '{2}' - Hearders content: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($Headers | Out-String) | Write-Verbose
            "[{0}] '{1}' -- iLO '{2}' - Body content: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $Body | Write-Verbose
    
            $currentDate = Get-Date 
                        
            $counter = 1

            # Define the spinning cursor characters
            $spinner = @('|', '/', '-', '\')
            
            # Get the current width of the terminal window                
            $terminalWidth = (Get-Host).UI.RawUI.WindowSize.Width                    
            
            # Create a clear line string based on the terminal width to ensure the entire line is overwritten
            if (-not $psISE) {
                $clearLine = " " * ($terminalWidth - 1)
            }

            if ($SkipCertificateValidation) {
                $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers -SkipCertificateCheck).Oem.Hpe.CloudConnect.CloudConnectStatus
            }
            else {
                $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers).Oem.Hpe.CloudConnect.CloudConnectStatus
            }

            "[{0}] '{1}' -- iLO '{2}' - Status of the iLO connection to COM: {3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $CloudConnectStatus | Write-Verbose


            if ($CloudConnectStatus -ne "Connected") {

                do {
                    
                    try {
                        
                        "[{0}] '{1}' -- iLO '{2}' - About to run POST {3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $url | Write-Verbose

                        if ($SkipCertificateValidation) {
                            $iLOConnectiontoCOMResponse = Invoke-RestMethod -Method POST -Uri $url -Body $Body -Headers $Headers -SkipCertificateCheck -ErrorAction SilentlyContinue
                        }
                        else {
                            $iLOConnectiontoCOMResponse = Invoke-RestMethod -Method POST -Uri $url -Body $Body -Headers $Headers -ErrorAction SilentlyContinue
                        }

                        $subcounter = 0
                        
                        do {                            
                            
                            "[{0}] '{1}' -- iLO '{2}' - About to run GET {3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ( $iLObaseURL + "/redfish/v1/Managers/1/") | Write-Verbose

                            if ($SkipCertificateValidation) {
                                $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers -SkipCertificateCheck).Oem.Hpe.CloudConnect.CloudConnectStatus
                            }
                            else {
                                $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers).Oem.Hpe.CloudConnect.CloudConnectStatus
                            }
 
                            "[{0}] '{1}' -- iLO '{2}' - Connection to COM status: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $CloudConnectStatus | Write-Verbose
                            
                            # Calculate the current spinner character
                            $spinnerChar = $spinner[$subcounter % $spinner.Length]
                            
                            # Display the spinner character, replacing the previous content
                            $output = "[{0}] -- iLO '{1}' - Connection to COM status: '{2}'  {3}" -f $SerialNumber, $IloIP, $CloudConnectStatus, $spinnerChar
                            if (-not $psISE) {
                                Write-Host "`r$clearLine`r$output" -NoNewline -ForegroundColor Yellow
                            }
                            else {
                                Write-Host "$output" -ForegroundColor Yellow
                            }
                            
                            $subcounter++
                            Start-Sleep -Seconds 2
                            
                        } while ($CloudConnectStatus -eq "ConnectionInProgress")
                        
                        # Increment counter
                        $counter++
                        Start-Sleep -Seconds 1

                    } 
                    catch {
                   
                        "[{0}] Catch triggered! {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose
                        
                        # Check if the error message indicates "Connection in progress"
                        if ($_ -match "Connection in progress") {
                            Write-Verbose "Connection in progress, retrying..."
                            Start-Sleep -Seconds 5
                        } 
                        else {
                            Write-Error "An error occurred: $_"
                            $objStatus.iLOConnectionStatus = "Failed"
                            $objStatus.iLOConnectionDetails = "iLO cannot be connected to Compute Ops Management! Check the iLO logs."
                            $objStatus.Exception = "Error: '{0}'" -f $_
                            $objStatus.Status = "Failed"
                            [void] $iLOConnectionStatus.add($objStatus)
                            break
                        }
                    }
                        
                } until ($CloudConnectStatus -eq "Connected" -or $counter -gt 10)       

                    
                if ($iLOConnectiontoCOMResponse) {
                    "[{0}] '{1}' -- iLO '{2}' - Response to the attempt to connect to COM: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($iLOConnectiontoCOMResponse | Out-String ) | Write-Verbose
                    
                    if ( $iLOConnectiontoCOMResponse.error.'@Message.ExtendedInfo'.MessageId ) {

                        $msg = $iLOConnectiontoCOMResponse.error.'@Message.ExtendedInfo'.MessageId
                        "[{0}] '{1}' -- iLO '{2}' - Response: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $msg | Write-Verbose

                        if ($iLOConnectiontoCOMResponse.error.'@Message.ExtendedInfo'.MessageId -notmatch "Success") {
                
                            "[{0}] '{1}' -- iLO '{2}' - Error to the attempt to connect to COM!: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($iLOConnectiontoCOMResponse.error.'@Message.ExtendedInfo'.MessageId ) | Write-Verbose
                            
                            $objStatus.iLOConnectionStatus = "Failed"
                            $objStatus.iLOConnectionDetails = "iLO cannot be connected to Compute Ops Management!"
                            $objStatus.Exception = "Error: {0}" -f ($iLOConnectiontoCOMResponse.error.'@Message.ExtendedInfo'.MessageId )
                            $objStatus.Status = "Failed"
                            [void] $iLOConnectionStatus.add($objStatus)
                            return                        
                        }
                    }
                }                
                else {
                    $msg = "AlreadyConnected"

                    "[{0}] '{1}' -- iLO '{2}' - iLO is already connected to a COM instance!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose

                }     
                
                if ($counter -gt 10) {

                    # Clear the message after do/until is complete
                    if (-not $psISE) {
                        "`r$clearLine`r" | Write-Host -NoNewline                    
                    }
                    
                    $objStatus.iLOConnectionStatus = "Failed"
                    $objStatus.iLOConnectionDetails = "iLO cannot be connected to Compute Ops Management! Check the iLO event log for more information."
                    $objStatus.Status = "Failed"

                }
                # Check if device is now present in the HPE GreenLake workspace
                else {

                    # Clear the message after do/until is complete
                    if (-not $psISE) {
                        "`r$clearLine`r" | Write-Host -NoNewline
                    }

                    $counter2 = 1

                    do {

                        # Calculate the current spinner character
                        $spinnerChar = $spinner[$counter2 % $spinner.Length]
                        
                        # Display the spinner character, replacing the previous content
                        $output = "[{0}] -- iLO '{1}' - Checking the availability of the device in the workspace... {2}" -f $SerialNumber, $IloIP, $spinnerChar
                        
                        if (-not $psISE) {
                            Write-Host "`r$clearLine`r$output" -NoNewline -ForegroundColor Yellow
                        }
                        else {
                            Write-Host "$output" -ForegroundColor Yellow
                        }

                        $DeviceFoundinGLP = Get-HPEGLdevice -SerialNumber $SerialNumber
                        Start-Sleep -Milliseconds 1000
                        $counter2++

                    }
                    until ($Null -ne $DeviceFoundinGLP -or $counter2 -gt 7)

                    # Clear the message after do/until is complete
                    if (-not $psISE) {
                        "`r$clearLine`r" | Write-Host -NoNewline
                    }

                    if ($DeviceFoundinGLP) {
                        "[{0}] '{1}' -- iLO '{2}' - Device found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                    }
                    else {
                        "[{0}] '{1}' -- iLO '{2}' - Device not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                    }

                    
                    if ($msg -match "Success" -and $DeviceFoundinGLP ) {
                  
                        "[{0}] '{1}' -- iLO '{2}' successfully connected to Compute Ops Management!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.iLOConnectionStatus = "Complete"
                        $objStatus.iLOConnectionDetails = "iLO successfully connected to the Compute Ops Management instance!"

                    }
                    elseif ($msg -eq "AlreadyConnected" -and $DeviceFoundinGLP) {

                        "[{0}] '{1}' -- iLO '{2}' already connected to Compute Ops Management!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.iLOConnectionStatus = "Complete"
                        $objStatus.iLOConnectionDetails = "iLO is already connected to the Compute Ops Management instance!"

                    }
                    elseif ($msg -eq "AlreadyConnected" -and $null -eq $DeviceFoundinGLP) {

                        "[{0}] '{1}' -- iLO '{2}' already connected to a Compute Ops Management instance - The device cannot be found in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.iLOConnectionStatus = "Warning"
                        $objStatus.iLOConnectionDetails = "iLO is already connected, but to a different Compute Ops Management instance!"

                    }
                    elseif ($msg -match "Success" -and $null -eq $DeviceFoundinGLP) {
                        
                        # Check the iLO event log to detect any error message 

                        if ($SkipCertificateValidation) {
                            $iLOEventLogs = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/LogServices/IEL/Entries/") -Headers $Headers -SkipCertificateCheck).Members
                        }
                        else {
                            $iLOEventLogs = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/LogServices/IEL/Entries/") -Headers $Headers).Members
                        }
                       
                        $iLOEventLogErrorMessages = $iLOEventLogs | Sort-Object -Property Created -Descending | Where-Object { [DateTime]::Parse($_.Created).ToLocalTime() -gt $currentDate -and $_.Message -match "(?i)Compute Ops Management.*failed|failed.*Compute Ops Management" }
                        # "Logs: `n{0}" -f $iLOEventLogErrorMessages | Write-Verbose
                        
                        $FormattediLOEventLogErrorMessages = ($iLOEventLogErrorMessages | Select-Object -ExpandProperty Message) -join "`n"
                        # "Logs: `n{0}" -f $FormattediLOEventLogErrorMessages | Write-Verbose
                        
                        $objStatus.iLOConnectionStatus = "Failed"
                        $objStatus.iLOConnectionDetails = $FormattediLOEventLogErrorMessages
                        $objStatus.Status = "Failed"
                        [void] $iLOConnectionStatus.add($objStatus)
                        return
                    }
                    else {
                        $objStatus.iLOConnectionStatus = "Complete"
                        $objStatus.iLOConnectionDetails = "iLO successfully connected to Compute Ops Management!"
                    }
                }   
            }
            else {
                "[{0}] '{1}' -- iLO '{2}' already connected to Compute Ops Management!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                $objStatus.iLOConnectionStatus = "Complete"
                $objStatus.iLOConnectionDetails = "iLO is already connected to the Compute Ops Management instance!"
            }                 
        }
        else {
            
            "[{0}] '{1}' -- iLO is not supported by HPE GreenLake! Skipping server..." -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
            
            $objStatus.OnboardingStatus = "Error" 
            $objStatus.OnboardingDetails = "Only iLO5 and iLO6 are supported by HPE GreenLake"
        }   
        
        if ($objStatus.PSobject.Properties.value -contains "Failed") {
            
            $objStatus.Status = "Failed"
            
        }
        else {
            $objStatus.Status = "Complete"
            
        }
        
        #EndRegion
        
        [void] $iLOConnectionStatus.add($objStatus)
      
    }

    end {

        if ($iLOConnectionStatus | Where-Object { $_.Status -eq "Failed" }) {

            write-error "One or more iLO failed to connect to Compute Ops Management!"
        
        }
        
        $iLOConnectionStatus = Invoke-RepackageObjectWithType -RawObject $iLOConnectionStatus -ObjectName "Device.Connect.iLO"    
        Return $iLOConnectionStatus
    }
        
}


Function Add-HPEGLDeviceStorage {
    <#
    .SYNOPSIS
    Add storage device(s) to HPE GreenLake. 

    .DESCRIPTION
    This Cmdlet adds storage device(s) to the currently connected HPE GreenLake workspace. It can optionally add tags during the onboarding process.  
    Devices must meet the requirements of the Data Services and be on the list of supported systems.    
   
    .PARAMETER SerialNumber
    Serial number of the storage device to be added. 
    The serial number can be found in the order confirmation email or in the email received after you activate the storage device software. 
    For Nimble devices, it can be retrieved from the Storage System UI or the pull-out tab.

    .PARAMETER PartNumber 
    Part number of the device to be added. 

   .PARAMETER Tags
    Optional parameter to add tags to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

    Supported tags example:
        - "Country=US"
        - "Country=US,State=TX,App=Grafana" 
        - "Country=US, State =TX ,App= Grafana "
            -> Produces the same result as the previous example.
        - "Private note=this is my tag note value,Email=Chris@email.com,City=New York" 
        - "Private note = this is my tag note value , Email = Chris@email.com , City=New York "
            -> Produces the same result as the previous example.  

    Refer to HPE GreenLake tagging specifications:
    https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
        - Resources that support tagging can have up to 25 tags per resource.
        - Tag keys and values are case-insensitive.
        - There can be only one value for a particular tag key for a given resource.
        - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
        - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
        - Tag keys must have 1-128 characters.
        - Tag values can have a maximum of 256 characters.
        - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceStorage -SerialNumber "123456789012" -PartNumber "879991-B21" -Tags "Country=US, Hypersior App=ESXi, City=New York"
    
    Adds a storage device to the currently connected HPE GreenLake workspace using a serial number and part number and assigns three tags.

    .EXAMPLE
    Import-Csv Storage_Devices.csv  | Add-HPEGLDeviceStorage -Tags "Location=Houston"

    Adds all storage devices listed in a `Storage_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns the same location tag to all devices.

    The content of the CSV file must use the following format:
        SerialNumber, PartNumber
        AF-23454852, Pxxxxx-B21
        AF-32331565, Pxxxxx-B21
        AF-32331597, Pxxxxx-B21
 
    .EXAMPLE
    Import-Csv Storage_Devices.csv -Delimiter ";"  | Add-HPEGLDeviceStorage 
    
    Adds all storage devices listed in a `Storage_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns tags as defined in the 'Tags' column of the CSV file.

    The content of the CSV file must use the following format:
        SerialNumber; PartNumber; Tags
        AF-23454852; Pxxxxx-B21; Country=US, State=PACA, App=RH
        AF-32331565; Pxxxxx-B21; State=Texas, Role=production
        AF-32331597; Pxxxxx-B21

        Note that for `AF-32331597`, no tags are assigned in this example.              

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = 'AF-23454852'; PartNumber = 'Pxxxxx-B21' },
        [PSCustomObject]@{SerialNumber = 'AF-32331565'; PartNumber = 'Pxxxxx-B21' }
    )

    $devices | Add-HPEGLDeviceStorage
    
    Add all storage devices (2) listed in $devices with the specified serial number and part number keys.
    
    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = '123456789012'; PartNumber = 'Pxxxxx-B21'; Tags = 'Country=US, State=PACA, App=RH' },
        [PSCustomObject]@{SerialNumber = '123432356789'; PartNumber = 'Pxxxxx-B21'; Tags = 'State=Texas, Role=production' }
    )

    $devices | Add-HPEGLDeviceStorage 
    
    Adds all storage devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them different tags.

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber, partnumber and tags properties. 

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be added
        * PartNumber - Part number of the device attempted to be added
        * TagsAdded - List of tags to assign to the device (if any)
        * Status - Status of the device onboarding attempt (Failed for HTTP error return; Complete if onboarding is successful; Warning if no action is needed) 
        * Details - More information about the onboarding status of the device, which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - Error - More information on a warning or failed status error.
        * Exception - Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('part_number')]
        [String]$PartNumber,

        [Parameter (ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesAddUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesToAddList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            PartNumber   = $PartNumber
            TagsAdded    = $Tags
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        
        foreach ($DeviceToAdd in $ObjectStatusList) {
            
            
            $ErrorFoundInTags = $False

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAdd.SerialNumber
            
            
            if ( $Device) {

                $DeviceToAdd.Status = "Warning"
                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device already present in the workspace!" }
                $DeviceToAdd.TagsAdded = $Null
                
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource already present in the workspace!" -f $DeviceToAdd.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {
                
                if ($DeviceToAdd.TagsAdded) {
                    
                    "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber, $DeviceToAdd.TagsAdded | Write-Verbose

                    $splittedtags = $DeviceToAdd.TagsAdded.split(",")

                    if ($splittedtags.Length -gt 25) {
                        
                        $DeviceToAdd.Status = "Failed"
                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }
                        $DeviceToAdd.TagsAdded = $Null
                        $ErrorFoundInTags = $True


                        if ($WhatIf) {
                            $ErrorMessage = "Device '{0}': Resource is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAdd.SerialNumber
                            Write-warning $ErrorMessage
                            continue
                        }
                    }
                    else {

                        # Object for the tracking object
                        $TagsList = [System.Collections.ArrayList]::new()
                        # Object for the payload
                        $TagsArray = @{}
                                
                        foreach ($tag in $splittedtags) {
    
                            # Check tag format, if format is not <tagname>=<value>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                                
                                $splittedtagName = $tag.TrimEnd().TrimStart()
    
                                $DeviceToAdd.Status = "Failed"
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }
                                $DeviceToAdd.TagsAdded = $Null
                                $ErrorFoundInTags = $True
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}': Tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAdd.SerialNumber, $splittedtagName                                   
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
    
                                $tagname = $tag.split('=')[0]
        
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tagname.TrimEnd().TrimStart()
        
                                if ($tagname.Length -gt 128) {
        
                                    $DeviceToAdd.Status = "Failed"
                                    $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }
                                    $DeviceToAdd.TagsAdded = $Null
                                    $ErrorFoundInTags = $True
                                    
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}': Tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAdd.SerialNumber, $tagname
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {
                                    
                                    $tagvalue = $tag.split('=')[1]
                                    
                                    # Remove space at the begining and at the end of the string if any
                                    $tagvalue = $tagvalue.TrimEnd().TrimStart()
            
                                    if ($tagvalue.Length -gt 256) {
            
                                        $DeviceToAdd.Status = "Failed"
                                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }
                                        $DeviceToAdd.TagsAdded = $Null
                                        $ErrorFoundInTags = $True
            
                                        if ($WhatIf) {
                                            $ErrorMessage = "Device '{0}': Tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAdd.SerialNumber, $tagvalue
                                            Write-warning $ErrorMessage
                                            break
                                        }
                                    }
                                    else {
    
                                        $TagsArray.$tagname = $tagvalue 
                
                                        $TagsList += [PSCustomObject]@{
                                            name  = $tagname
                                            value = $tagvalue 
                                        }
                                    }
                                }
                            }
                        } 
                    }


                    if ($TagsList -and -not $ErrorFoundInTags) {
                        
                        $DeviceToAdd.TagsAdded = $TagsList
                    }
    
                }
                else {
    
                    "[{0}] {1}: No tags to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber | Write-Verbose
    
                }
                
                

                # Build DeviceList object

                if (-not $ErrorFoundInTags) {

                    # If tags
                    if ($DeviceToAdd.TagsAdded) {
                    
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            tags         = $TagsArray 
                        }
                    }
                    # If no tags
                    else {
                        
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            
                        }
                    }
    
                    [void]$DevicesToAddList.Add($DeviceList)
                }

            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        if ($DevicesToAddList) {

            # Build payload
            $payload = [PSCustomObject]@{
                compute = @()
                network = @()
                storage = $DevicesToAddList 

            } | ConvertTo-Json -Depth 5
            

            # Add device
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Complete"

                            if ($DeviceToAdd.TagsAdded) {
                                
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = $DeviceToAdd.TagsAdded.count; Error = $Null }
                            }
                            else {
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = $Null }

                            }

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Failed"
                            $DeviceToAdd.TagsAdded = $Null
                            $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device cannot be added to the HPE GreenLake workspace!" }
                            $DeviceToAdd.Exception = $_.Exception.message 

                        }
                    }
                }
            }      
        }
    
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the onboarding attempt!"
            
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Device.Add.SPTSDE"    
            Return $ObjectStatusList
        }

    }
}


Function Add-HPEGLDeviceNetwork {
    <#
    .SYNOPSIS
    Add network device(s) to HPE GreenLake. 

    .DESCRIPTION
    This Cmdlet adds network device(s) to the currently connected HPE GreenLake workspace. It can optionally add tags during the onboarding process.  
    Devices must meet the requirements of the Data Services and be on the list of supported systems.    
   
    .PARAMETER SerialNumber
    Serial number of the network device to be added. 
    The serial number can be found in the order confirmation email or in the email received after you activate the network device software. 
    For Nimble devices, it can be retrieved from the network System UI or the pull-out tab.

    .PARAMETER MacAddress 
    Media access control (MAC) address of the device to be added. Most network devices have MAC address on the front or back of the hardware.

    .PARAMETER Tags
    Optional parameter to add tags to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

    Supported tags example:
        - "Country=US"
        - "Country=US,State=TX,App=Grafana" 
        - "Country=US, State =TX ,App= Grafana "
            -> Produces the same result as the previous example.
        - "Private note=this is my tag note value,Email=Chris@email.com,City=New York" 
        - "Private note = this is my tag note value , Email = Chris@email.com , City=New York "
            -> Produces the same result as the previous example.  

    Refer to HPE GreenLake tagging specifications:
    https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
        - Resources that support tagging can have up to 25 tags per resource.
        - Tag keys and values are case-insensitive.
        - There can be only one value for a particular tag key for a given resource.
        - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
        - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
        - Tag keys must have 1-128 characters.
        - Tag values can have a maximum of 256 characters.
        - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.
    
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceNetwork -SerialNumber "123456789012" -MACAddress "aa:bb:cc:dd:ee:ff"  -Tags "Country=US, Hypersior App=ESXi, City=New York"
    
    Adds a network device to the currently connected HPE GreenLake workspace using a serial number and part number and assigns three tags.

    .EXAMPLE
    Import-Csv Network_Devices.csv  | Add-HPEGLDeviceNetwork -Tags "Location=Houston"

    Adds all network devices listed in a `Network_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns the same location tag to all devices.

    The content of the CSV file must use the following format:
        SerialNumber, MACAddress
        A-23434324,	aa:bb:cc:dd:ee:ff
        A-53234730,	11:bb:22:dd:33:78
        A-58976464,	ff:bb:e3:d2:34:23
 
    .EXAMPLE
    Import-Csv Network_Devices.csv -Delimiter ";"  | Add-HPEGLDeviceNetwork 
    
    Adds all network devices listed in a `Network_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns tags as defined in the 'Tags' column of the CSV file.

    The content of the CSV file must use the following format:
        SerialNumber; MACAddress; Tags
        A-23434324;	aa:bb:cc:dd:ee:ff; Country=US, State=PACA, App=RH
        A-53234730;	11:bb:22:dd:33:78; State=Texas, Role=production
        A-58976464;	ff:bb:e3:d2:34:23

        Note that for `A-58976464`, no tags are assigned in this example.              

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = 'A-53234730'; MACAddress = 'aa:bb:cc:dd:ee:ff' },
        [PSCustomObject]@{SerialNumber = 'A-58976464'; MACAddress = '11:bb:22:dd:33:78' }
    )

    $devices | Add-HPEGLDeviceNetwork
    
    Add all network devices (2) listed in $devices with the specified serial number and part number keys.
    
    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = 'A-53234730'; MACAddress = 'aa:bb:cc:dd:ee:ff'; Tags = 'Country=US, State=PACA, App=RH' },
        [PSCustomObject]@{SerialNumber = 'A-58976464'; MACAddress = '11:bb:22:dd:33:78'; Tags = 'State=Texas, Role=production' }
    )

    $devices | Add-HPEGLDeviceNetwork 
    
    Adds all network devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them different tags.

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber, MACAddress and tags properties. 

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be added
        * PartNumber - Part number of the device attempted to be added
        * TagsAdded - List of tags to assign to the device (if any)
        * Status - Status of the device onboarding attempt (Failed for HTTP error return; Complete if onboarding is successful; Warning if no action is needed) 
        * Details - More information about the onboarding status of the device, which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - Error - More information on a warning or failed status error.
        * Exception - Information about any exceptions generated during the operation.

   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({
                if ( $_ -match "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$") {
                    $True
                } 
                else {
                    throw "Input '$_' is not in a valid MAC address format. Expected format is 'aa:bb:cc:dd:ee:ff'"
                }
            })]  
        [Alias ('mac_address')]
        [String]$MacAddress,

        [Parameter (ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesAddUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesToAddList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            MACAddress   = $MacAddress
            TagsAdded    = $Tags
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

            
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)



    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        
        foreach ($DeviceToAdd in $ObjectStatusList) {
            
            
            $ErrorFoundInTags = $False

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAdd.SerialNumber
            
            
            if ( $Device) {

                $DeviceToAdd.Status = "Warning"
                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device already present in the workspace!" }
                $DeviceToAdd.TagsAdded = $Null
                
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource already present in the workspace!" -f $DeviceToAdd.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {
                
                if ($DeviceToAdd.TagsAdded) {
                    
                    "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber, $DeviceToAdd.TagsAdded | Write-Verbose

                    $splittedtags = $DeviceToAdd.TagsAdded.split(",")

                    if ($splittedtags.Length -gt 25) {
                        
                        $DeviceToAdd.Status = "Failed"
                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }
                        $DeviceToAdd.TagsAdded = $Null
                        $ErrorFoundInTags = $True


                        if ($WhatIf) {
                            $ErrorMessage = "Device '{0}': Resource is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAdd.SerialNumber
                            Write-warning $ErrorMessage
                            continue
                        }
                    }
                    else {

                        # Object for the tracking object
                        $TagsList = [System.Collections.ArrayList]::new()
                        # Object for the payload
                        $TagsArray = @{}
                                
                        foreach ($tag in $splittedtags) {
    
                            # Check tag format, if format is not <tagname>=<value>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                                
                                $splittedtagName = $tag.TrimEnd().TrimStart()
    
                                $DeviceToAdd.Status = "Failed"
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }
                                $DeviceToAdd.TagsAdded = $Null
                                $ErrorFoundInTags = $True
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}': Tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAdd.SerialNumber, $splittedtagName
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
    
                                $tagname = $tag.split('=')[0]
        
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tagname.TrimEnd().TrimStart()
        
                                if ($tagname.Length -gt 128) {
        
                                    $DeviceToAdd.Status = "Failed"
                                    $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }
                                    $DeviceToAdd.TagsAdded = $Null
                                    $ErrorFoundInTags = $True
        
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}': Tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAdd.SerialNumber, $tagname
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {
                                    
                                    $tagvalue = $tag.split('=')[1]
                                    
                                    # Remove space at the begining and at the end of the string if any
                                    $tagvalue = $tagvalue.TrimEnd().TrimStart()
            
                                    if ($tagvalue.Length -gt 256) {
            
                                        $DeviceToAdd.Status = "Failed"
                                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }
                                        $DeviceToAdd.TagsAdded = $Null
                                        $ErrorFoundInTags = $True
            
                                        if ($WhatIf) {
                                            $ErrorMessage = "Device '{0}': Tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAdd.SerialNumber, $tagvalue
                                            Write-warning $ErrorMessage
                                            break
                                        }
                                    }
                                    else {
    
                                        $TagsArray.$tagname = $tagvalue 
                
                                        $TagsList += [PSCustomObject]@{
                                            name  = $tagname
                                            value = $tagvalue 
                                        }
                                    }
                                }
                            }
                        } 
                    }


                    if ($TagsList -and -not $ErrorFoundInTags) {
                        
                        $DeviceToAdd.TagsAdded = $TagsList
                    }
    
                }
                else {
    
                    "[{0}] {1}: No tags to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber | Write-Verbose
    
                }
                
                

                # Build DeviceList object

                if (-not $ErrorFoundInTags) {

                    # If tags
                    if ($DeviceToAdd.TagsAdded) {
                    
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            macAddress   = $DeviceToAdd.macAddress 
                            tags         = $TagsArray 
                        }
                    }
                    # If no tags
                    else {
                        
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            macAddress   = $DeviceToAdd.macAddress 
                            
                        }
                    }
    
                    [void]$DevicesToAddList.Add($DeviceList)
                }

            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        if ($DevicesToAddList) {

            # Build payload
            $payload = [PSCustomObject]@{
                compute = @()
                network = $DevicesToAddList 
                storage = @()

            } | ConvertTo-Json -Depth 5
            

            # Add device
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Complete"

                            if ($DeviceToAdd.TagsAdded) {
                                
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = $DeviceToAdd.TagsAdded.count; Error = $Null }
                            }
                            else {
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = $Null }

                            }

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Failed"
                            $DeviceToAdd.TagsAdded = $Null
                            $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device cannot be added to the HPE GreenLake workspace!" }
                            $DeviceToAdd.Exception = $_.Exception.message 

                        }
                    }
                }
            }      
        }
    
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the onboarding attempt!"
            
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Device.Add.SMTSDE"    
            Return $ObjectStatusList
        }

    }
} 


Function Disable-HPEGLDevice {
    <#
    .SYNOPSIS
    Archive device(s) in HPE GreenLake.

    .DESCRIPTION
    This Cmdlet archives device(s) in HPE GreenLake. Archiving devices will remove all service assignments and will remove them from your inventory list.

    .PARAMETER SerialNumber 
    Serial number of the device to be archived. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Disable-HPEGLDevice -SerialNumber CNX2380BLC

    Archive the device with the serial number 'CNX2380BLC'.

    .EXAMPLE
    Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString DL360 | Disable-HPEGLDevice -WhatIf

    Archive all DL360 server devices found in the HPE GreenLake workspace.

    .EXAMPLE
    'CNX2380BLC', '7CE244P9LM' | Disable-HPEGLDevice

    Archive the list of devices with serial numbers 'CNX2380BLC' and '7CE244P9LM' provided in the pipeline.

    .INPUTS
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be archived 
        * Status - Status of the archiving attempt (Failed for http error return; Complete if archiving is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesUri  

        $ArchivedDevicesStatus = [System.Collections.ArrayList]::new()
        $DevicesToArchivedList = [System.Collections.ArrayList]::new()



    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

                  
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
          
        }

      
        # Add tracking object to the list of object status list
        [void]$ArchivedDevicesStatus.Add($objStatus)     

   
    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] Devices to archive: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ArchivedDevicesStatus.SerialNumber | Write-Verbose

        foreach ($DeviceToArchive in $ArchivedDevicesStatus) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToArchive.SerialNumber

            if ( -not $Device) {
                
                $DeviceToArchive.Status = "Failed"
                $DeviceToArchive.Details = "Device cannot be found in the workspace!"
                
                # Must return a message if device not found
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the '{1}' region!" -f $DeviceToArchive.SerialNumber, $Region
                    Write-warning $ErrorMessage
                    continue
                }

            }
            elseif ( $Device.archived ) {
                # Must return a message if device already archived
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is already disabled (archived)!" -f $DeviceToArchive.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
                else {
                    
                    $DeviceToArchive.Status = "Warning"
                    $DeviceToArchive.Details = "Device already disabled (archived)!"
                

                }


            }
            else {

                # Create the device list object 
                if ($device.mac_address) {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $true
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                        mac_address   = $device.mac_address
                    }
                    [void]$DevicesToArchivedList.Add($DeviceList)

                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $true
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                    }
                    [void]$DevicesToArchivedList.Add($DeviceList)
                }
            }

        }

        if ($DevicesToArchivedList) {

            $payload = [PSCustomObject]@{
                devices = $DevicesToArchivedList
            } | ConvertTo-Json -Depth 5


            try {

                Invoke-HPEGLWebRequest -Uri $Uri -Method 'PATCH' -Body $payload -WhatIfBoolean $WhatIf | Out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToArchive in $ArchivedDevicesStatus) {
                    
                        $DeviceToArchive.Status = "Complete"
                        $DeviceToArchive.Details = "Device successfully disabled (archived)"
                    }
                }
            }
            catch {

                if (-not $WhatIf) {
                    
                    foreach ($DeviceToArchive in $ArchivedDevicesStatus) {

                        $DeviceToArchive.Status = "Failed"
                        $DeviceToArchive.Details = "Device could not be disabled (archived)!"
                        $DeviceToArchive.Exception = $_.Exception.message

                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($ArchivedDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the disabling attempt!"
          
            }

            $ArchivedDevicesStatus = Invoke-RepackageObjectWithType -RawObject $ArchivedDevicesStatus -ObjectName "ObjStatus.SSDE"  
            Return $ArchivedDevicesStatus
        }
    }
}


Function Enable-HPEGLDevice {
    <#
    .SYNOPSIS
    Unarchive device(s) in HPE GreenLake.

    .DESCRIPTION
    This Cmdlet unarchives device(s) in HPE GreenLake console. Unarchiving devices will make devices available for assignment and subscription.      

    .PARAMETER SerialNumber 
    Serial number of the device to be unarchived. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Enable-HPEGLDevice -SerialNumber "CNX2380BLC"

    Unarchive the device with the serial number CNX2380BLC.
    
    .EXAMPLE
    Get-HPEGLdevice -ShowArchived | Enable-HPEGLDevice

    Unarchive all archived devices found in the HPE GreenLake workspace.

    .EXAMPLE
    'CNX2380BLC', '7CE244P9LM' | Enable-HPEGLDevice

    Unarchive the list of devices with serial numbers 'CNX2380BLC' and '7CE244P9LM' provided in the pipeline.

    .INPUTS
    System.Collections.ArrayList
        List of archived devices from 'Get-HPEGLdevice -ShowArchived'. 
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers.        

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be unarchived 
        * Status - Status of the unarchiving attempt (Failed for http error return; Complete if unarchiving is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Uri = $DevicesUri  

        $UnarchivedDevicesStatus = [System.Collections.ArrayList]::new()
        $DevicesToUnarchivedList = [System.Collections.ArrayList]::new()

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
          
        }

      

        # Add tracking object to the list of object status list
        [void]$UnarchivedDevicesStatus.Add($objStatus)     



    }

    end {

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] Devices to unarchive: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($UnarchivedDevicesStatus.SerialNumber | out-string) | Write-Verbose

        foreach ($DeviceToUnarchive in $UnarchivedDevicesStatus) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToUnarchive.SerialNumber

            if ( -not $Device) {
                
                $DeviceToUnarchive.Status = "Failed"
                $DeviceToUnarchive.Details = "Device cannot be found in the workspace!"
                
                # Must return a message if device not found
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the '{1}' region!" -f $DeviceToUnarchive.SerialNumber, $Region
                    Write-warning $ErrorMessage
                    continue
                }
                 
            }
            elseif (-not $device.archived ) {
                # Must return a message if device is not archived
            
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is already enabled (unarchived)!" -f $DeviceToUnarchive.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
                else {
                    $DeviceToUnarchive.Status = "Warning"
                    $DeviceToUnarchive.Details = "Device is already enabled (unarchived)!"
                        
                }

            }
            else {
            
                # Create the device list object 
                if ($device.mac_address) {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $false
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                        mac_address   = $device.mac_address
                    }
                    [void]$DevicesToUnarchivedList.Add($DeviceList)

                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $false
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                    }
                    [void]$DevicesToUnarchivedList.Add($DeviceList)
                }
            }
        }

            
        if ($DevicesToUnarchivedList) {

            $payload = [PSCustomObject]@{
                devices = $DevicesToUnarchivedList
            } | ConvertTo-Json -Depth 5


            try {

                Invoke-HPEGLWebRequest -Uri $Uri -Method 'PATCH' -Body $payload -WhatIfBoolean $WhatIf | Out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToUnarchive in $UnarchivedDevicesStatus) {
                    
                        $DeviceToUnarchive.Status = "Complete"
                        $DeviceToUnarchive.Details = "Device successfully enabled (unarchived)"
                    }
                }
            }
            catch {

                if (-not $WhatIf) {
                    
                    foreach ($DeviceToUnarchive in $UnarchivedDevicesStatus) {

                        $DeviceToUnarchive.Status = "Failed"
                        $DeviceToUnarchive.Details = "Device could not be enabled (unarchived)!"
                        $DeviceToUnarchive.Exception = $_.Exception.message

                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($UnarchivedDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the enabling attempt!"
        
            }

            $UnarchivedDevicesStatus = Invoke-RepackageObjectWithType -RawObject $UnarchivedDevicesStatus -ObjectName "ObjStatus.SSDE"  
            Return $UnarchivedDevicesStatus
        }


    }
   
}


Function Add-HPEGLDeviceTagToDevice {
<#
.SYNOPSIS
Add tag(s) to a device.

.DESCRIPTION
This cmdlet adds one or more tags to a specified device available in the workspace. If a tag with the same name already exists on the device, the cmdlet deletes the existing tag and recreates it with the new value.

.PARAMETER SerialNumber
The serial number of the device to which tags must be added. This value can be retrieved using 'Get-HPEGLDevice'.

.PARAMETER Tags
Tags to be added to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

Supported tags example:
    - "Country=US"
    - "Country=US,State=TX,App=Grafana" 
    - "Country=US, State =TX ,App= Grafana "
        -> Produces the same result as the previous example.
    - "Note=this is my tag note value,Email=Chris@email.com,City=New York" 
    - "Note = this is my tag note value , Email = Chris@email.com , City=New York "
        -> Produces the same result as the previous example.  

Refer to HPE GreenLake tagging specifications:
https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
    - Resources that support tagging can have up to 25 tags per resource.
    - Tag keys and values are case-insensitive.
    - There can be only one value for a particular tag key for a given resource.
    - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
    - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
    - Tag keys must have 1-128 characters.
    - Tag values can have a maximum of 256 characters.
    - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.

.PARAMETER WhatIf
Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

.EXAMPLE
Add-HPEGLDeviceTagToDevice -SerialNumber CWERX2380BLC -Tags "Department=HR"

Adds the tag 'Department=HR' to the device with serial number 'CWERX2380BLC'. 

.EXAMPLE
Add-HPEGLDeviceTagToDevice -SerialNumber CWERX2380BLC -Tags "Country=US, App=VMware"

Adds the tags 'Country=US' and 'App=VMware' to the device with serial number 'CWERX2380BLC'.

.EXAMPLE
'CNX2380BLC', 'MXQ73200W1', 'EZ12312312' | Add-HPEGLDeviceTagToDevice -Tags "Department=HR, Apps=RHEL"

Adds the tags 'Department=HR' and 'Apps=RHEL' to the list of devices with the specified serial numbers defined in the pipeline.

.EXAMPLE
Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString DL360 | Add-HPEGLDeviceTagToDevice -Tags "Country=US, Apps=VMware ESX"

Adds the tags 'Country=US' and 'Apps=VMware ESX' to all DL360 server devices found in the workspace.

.EXAMPLE
Import-Csv Tests/Network_Devices.csv | Add-HPEGLDeviceTagToDevice -Tags "Country=US, City=New York"

Adds two tags to all devices listed in a "Network_Devices.csv" file containing at least a SerialNumber column.

.EXAMPLE
Import-Csv .\Compute_Devices_Tags.csv -Delimiter ";"  | Add-HPEGLDeviceTagToDevice 

Adds tags to all devices listed in a `Compute_Devices_Tags.csv` file containing at least two columns, SerialNumber and Tags.

The content of the CSV file must use the following format:
    SerialNumber; Tags
    7LKY2323233LM; Country=US, State=CA, App=RH
    CZ123QWE456; State=TX, Role=Production
    CZ122QWE533; City=New York

.INPUTS
System.Collections.ArrayList
    List of devices(s) from 'Get-HPEGLDevice'.
System.String, System.String[]
    A single string object or a list of string objects representing the device's serial numbers.

.OUTPUTS
System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
    * SerialNumber - The serial number of the device to which tags were attempted to be added.
    * PartNumber - The part number of the device.
    * DeviceType - The type of the device.
    * TagsAdded - List of tags that have been added.
    * TagsDeleted - List of tags that have been deleted.
    * TagsUnmodified - List of tags that have not been modified.
    * Status - The status of the tagging attempt (Failed for HTTP error return; Warning if tagging is incomplete; Complete if tagging is successful).
    * Details - More information about the status which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - TagsDeleted - The number of tags deleted.
          - TagsUnmodified - The number of tags that have not been modified.
          - Error - More information on a warning or failed status error.
    * Exception - Information about any exceptions generated during the operation.
#>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesATagsUri + "?only_validate=false"
        
        $AddTagsDevicesStatus = [System.Collections.ArrayList]::new()
        
        $DevicesWithTagsToAddList = [System.Collections.ArrayList]::new()
        $ObjectStatusList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
    
        # Build object for the output
        $objStatus = [pscustomobject]@{
          
            SerialNumber   = $SerialNumber
            PartNumber     = $Null
            DeviceType     = $Null
            TagsAdded      = $Tags
            TagsDeleted    = $Null
            TagsUnmodified = $Null
            Status         = $Null
            Details        = $Null
            Exception      = $Null
                  
        }
        
      
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] List of devices where to add tags: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ObjectStatusList.serialnumber | Write-Verbose

        foreach ($DeviceToAddTags in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAddTags.SerialNumber

            if ( -not $Device) {
                # Must return a message if device not found
                $DeviceToAddTags.Status = "Failed"
                $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Device cannot be found in the HPE GreenLake workspace!" }               

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $DeviceToAddTags.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {

                "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAddTags.serialnumber, $DeviceToAddTags.TagsAdded | Write-Verbose

                $splittedtags = $DeviceToAddTags.TagsAdded.split(",")

                if ($splittedtags.Length -gt 25) {
                    
                    $DeviceToAddTags.Status = "Failed"
                    $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }               

                    if ($WhatIf) {
                        $ErrorMessage = "Device '{0}': Resource is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAddTags.SerialNumber
                        Write-warning $ErrorMessage
                        continue
                    }
                }
                else {

                    # Object for the tracking object
                    $TagsList = [System.Collections.ArrayList]::new()
                    # Object for the payload
                    $TagsArray = @{}
                            
                    foreach ($tag in $splittedtags) {

                        # Check tag format, if format is not <tagname>=<value>, return error
                        if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                            
                            $splittedtagName = $tag.TrimEnd().TrimStart()

                            $DeviceToAddTags.Status = "Failed"
                            $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }               

                            if ($WhatIf) {
                                $ErrorMessage = "Device '{0}': Tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAddTags.SerialNumber, $splittedtagName
                                Write-warning $ErrorMessage
                                break
                            }
                        }
                        else {

                            $tagname = $tag.split('=')[0]
    
                            # Remove space at the begining and at the end of the string if any
                            $tagname = $tagname.TrimEnd().TrimStart()
    
                            if ($tagname.Length -gt 128) {
    
                                $DeviceToAddTags.Status = "Failed"
                                $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }               
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}': Tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAddTags.SerialNumber, $tagname
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
                                
                                $tagvalue = $tag.split('=')[1]
                                
                                # Remove space at the begining and at the end of the string if any
                                $tagvalue = $tagvalue.TrimEnd().TrimStart()
        
                                if ($tagvalue.Length -gt 256) {
        
                                    $DeviceToAddTags.Status = "Failed"
                                    $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }     

        
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}': Tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAddTags.SerialNumber, $tagvalue
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {

                                    $TagsList += [PSCustomObject]@{
                                        name  = $tagname
                                        value = $tagvalue 
                                    }
                                }
                            }
                        }
                    } 
                }

                # Remove all tags from the tracking object as we will create a new tag status based on device state
                $DeviceToAddTags.TagsAdded = $Null


                $DeviceToAddTags.PartNumber = $Device.Part_Number
                $DeviceToAddTags.DeviceType = $Device.Device_Type

                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
            
                }

                # Building the list of devices object where to add tags
                [void]$DevicesWithTagsToAddList.Add($DeviceList)

                # Capturing Tags that already exist
                $ExistingTags = $Device.tags

                if ($ExistingTags) {
                    "[{0}] {1}: Existing tags: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, ($ExistingTags | Out-String) | write-verbose
                }
                else {
                    "[{0}] {1}: No existing tag!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber | write-verbose

                }

                # Payload objects
                $TagsUnmodified = [System.Collections.ArrayList]::new()
                $TagsToBeCreated = [System.Collections.ArrayList]::new()
                $TagsToBeDeleted = [System.Collections.ArrayList]::new()
                        
                
                foreach ($_Tag in $TagsList) {                
                    
                    "[{0}] Tag requested to be added: {1}={2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name, $_Tag.value | write-verbose

                    if ($ExistingTags) {

                        # If tag name to add is equal to exisitng tag name
                        If ($ExistingTags | Where-Object name -eq $_tag.name) {

                            "[{0}] '{1}' tag is present" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name | write-verbose
                            
                            # If tag value to add is equal to existing tag value
                            if ($_tag.value -eq (($ExistingTags | Where-Object name -eq $_tag.name).value)) {
                                
                                "[{0}] Tag '{1}' value is equal to the one already set: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name, $_Tag.value | write-verbose

                                [void]$TagsUnmodified.Add($_Tag)

                                $DeviceToAddTags.TagsUnmodified = $TagsUnmodified    
                                $DeviceToAddTags.Status = "Warning"

                            }
                            else {

                                "[{0}] Tag '{1}' value is not equal to the one already set: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name, $_Tag.value | write-verbose

                                # A modification is a two steps process"
                                #  1- Delete the exisiting tag (must be added to the delete tag list)
                                #  2- Create a new tag using the same name but this time with the new value (must be added to the create tag list)
                                
                                #  1 
                                $_TagToDelete = [System.Collections.HashTable]@{
                                    name  = ($ExistingTags | Where-Object name -eq $_tag.name).name
                                    value = ($ExistingTags | Where-Object name -eq $_tag.name).value
                                }
                                
                                [void]$TagsToBeDeleted.Add($_TagToDelete)
                                
                                #  2
                                [void]$TagsToBeCreated.Add($_Tag)
                                
                                # Add tags to the tracking object
                                $DeviceToAddTags.TagsAdded = $TagsToBeCreated                       
                                $DeviceToAddTags.TagsDeleted = $TagsToBeDeleted                       



                            }
                        }
                        elseif ($ExistingTags | Where-Object name -ne $_tag.name) {

                            "[{0}] '{1}' tag cannot be found" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name | write-verbose

                            [void]$TagsToBeCreated.Add($_Tag)

                            # Add created tag to the tracking object
                            $DeviceToAddTags.TagsAdded = $TagsToBeCreated                       


                        }
                    }
                    else {

                        "[{0}] '{1}' tag to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name | write-verbose

                        [void]$TagsToBeCreated.Add($_Tag)

                        # Add created tag to the tracking object
                        $DeviceToAddTags.TagsAdded = $TagsToBeCreated                       

                    }
                }        
            }
        }

        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose
       
        
        # Removing objects where status is failed (condition when device is not found or tags are not supported)
        $ObjectStatusListForFoundDevices = $ObjectStatusList | Where-Object { $_.Status -ne "Failed" }
        
        "[{0}] List of objects where status is not failed in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListforFoundDevices | Out-String) | Write-Verbose
        
        "[{0}] Grouping objects based on identical TagsAdded / TagsDeleted property values" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        # Create a unique key for each object based on TagsDeleted
        $ObjectStatusListForFoundDevices | ForEach-Object {
            $TagsDeleteduniqueKey = ($_.TagsDeleted | Sort-Object name, value | ForEach-Object { "$($_.name)=$($_.value)" }) -join ";"
            $TagsAddeduniqueKey = ($_.TagsAdded | Sort-Object name, value | ForEach-Object { "$($_.name)=$($_.value)" }) -join ";"
            $uniqueKey = "$TagsDeleteduniqueKey;$TagsAddeduniqueKey"
            Add-Member -InputObject $_ -MemberType NoteProperty -Name UniqueKey -Value $uniqueKey
        }

        # Group objects based on the unique key
        $groupedObjects = $ObjectStatusListForFoundDevices | Group-Object -Property UniqueKey

        # Remove the UniqueKey property from each object in $groupedObjects
        $groupedObjects | ForEach-Object {
            $_.Group | ForEach-Object {
                $_ | ForEach-Object { $_.PSObject.Properties.Remove('UniqueKey') }

            }
        }
        
        "[{0}] List of object groups with devices found: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($groupedObjects | Out-String) | Write-Verbose

        foreach ($Group in $groupedObjects ) {
            
            "[{0}] Group being processed: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Group | Out-String) | Write-Verbose

            $ListOfDevicesWithMatchingTagsAddedAndModified = $DevicesWithTagsToAddList | Where-Object serial_number -in $Group.group.SerialNumber 

            if ($Group.Count -eq 1 ) {
                $ListOfDevicesWithMatchingTagsAddedAndModified = @($ListOfDevicesWithMatchingTagsAddedAndModified)
            }

            $TagsToBeCreated = $Group.group[0].TagsAdded
            
            if ($Group.group[0].TagsDeleted ) {
                $TagsToBeDeleted = $Group.group[0].TagsDeleted 
            }
            else {
                $TagsToBeDeleted = @()
            }
                
            # Build payload
            $payload = [PSCustomObject]@{
                devices     = $ListOfDevicesWithMatchingTagsAddedAndModified 
                create_tags = $TagsToBeCreated
                delete_tags = $TagsToBeDeleted
            } 
            

            # Add tags
            try {

                $SkipSubsequentRequestWithWhatIf = $False

                if ( $TagsToBeDeleted) {

                    $jsonPayload = $payload | ConvertTo-Json -Depth 5

                    if ($WhatIf) {
                        # This is to skip the subsequent CALL request during a tag modification when Whatif is used.
                        $SkipSubsequentRequestWithWhatIf = $True
                    }
                    
                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $jsonPayload -WhatIfBoolean $WhatIf  
                    
                    $payload = $payload | Select-Object -Property * -ExcludeProperty "delete_tags"

                                    
                }

                $jsonPayload = $payload | ConvertTo-Json -Depth 5

                if ($TagsToBeCreated -and -not $SkipSubsequentRequestWithWhatIf) {

                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $jsonPayload -WhatIfBoolean $WhatIf        
                                                
                    if (-not $WhatIf) {

                        foreach ($object in $Group.Group) {
                            $object.Status = "Complete"
                            $object.Details = [PSCustomObject]@{TagsAdded = $TagsToBeCreated.count; TagsDeleted = $TagsToBeDeleted.count; TagsUnmodified = $object.TagsUnmodified.count; Error = $Null }
                            [void] $AddTagsDevicesStatus.add($object)

                        }
                    }
                }
                else {

                    "[{0}] No action required, the same tag configuration already exists." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    if (-not $WhatIf) {

                        foreach ($object in $Group.Group) {
                            $object.Status = "Warning"
                            $object.Details = [PSCustomObject]@{TagsAdded = $TagsToBeCreated.count; TagsDeleted = $TagsToBeDeleted.count; TagsUnmodified = $object.TagsUnmodified.count; Error = "No action required, the same tag configuration already exists!" }
                            [void] $AddTagsDevicesStatus.add($object)

                        }
                    }
                    else {

                        foreach ($object in $Group.Group) {
                            Write-Warning "Device '$($object.SerialNumber)' has no action required, the tag configuration already exists."
                        }
                    }
                   
                }

            }
            catch {

                if (-not $WhatIf) {

                    foreach ($object in $Group.Group) {
                        $object.Status = "Failed"
                        $Object.TagsAdded = $Null
                        $object.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Device tagging error!" }
                        $object.Exception = $_.Exception.message 

                        [void] $AddTagsDevicesStatus.add($object)

                    }
                }
            }
        }
    
        # Getting objects where status is failed (condition when device is not found or tags are not supported )
        $ObjectStatusListOfDevicesNotFound = $ObjectStatusList | Where-Object { $_.Status -eq "Failed" } 


        "[{0}] List of objects with failed status: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListOfDevicesNotFound | Out-String) | Write-Verbose

        foreach ($Object in $ObjectStatusListOfDevicesNotFound) {

            if (-not $WhatIf) {
                $Object.TagsAdded = $Null
                [void] $AddTagsDevicesStatus.add($object)

            }
                
        }


        if (-not $WhatIf) {

            if ($AddTagsDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the tagging attempt!"
          
            }

            $AddTagsDevicesStatus = Invoke-RepackageObjectWithType -RawObject $AddTagsDevicesStatus -ObjectName "Device.Tag.STTTSDE"  
            Return $AddTagsDevicesStatus
        }
    }
}


Function Remove-HPEGLDeviceTagFromDevice {
    <#
.SYNOPSIS
Delete tag(s) from a device.

.DESCRIPTION
This Cmdlet deletes one or more tags from a specified device available in the workspace.

.PARAMETER SerialNumber
The serial number of the device from which tags must be deleted. This value can be retrieved using 'Get-HPEGLDevice'.

.PARAMETER Tags
Tags to be removed from the device. Tags must meet the following string format: <Name1>, <Name2>. For example, "Country" or "European location, timezone" or "Country, State, Grafana".

.PARAMETER WhatIf
Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

.EXAMPLE
Remove-HPEGLDeviceTagFromDevice -SerialNumber CWERX2380BLC -Tags "European location"

Removes the tag 'European location' from the device with serial number 'CWERX2380BLC'. 

.EXAMPLE
Remove-HPEGLDeviceTagFromDevice -SerialNumber CWERX2380BLC -Tags "Country, App"

Removes the tags 'Country' and 'App' from the device with serial number 'CWERX2380BLC'.

.EXAMPLE
'CNX2380BLC', 'MXQ73200W1', 'EZ12312312' | Remove-HPEGLDeviceTagFromDevice -Tags "Department, Apps"

Removes the tags 'Department' and 'Apps' from the list of devices with the specified serial numbers defined in the pipeline.

.EXAMPLE
Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString DL360 | Remove-HPEGLDeviceTagFromDevice -Tags "Country, State"

Removes the tags 'Country' and 'State' from all DL360 server devices found in the workspace.

.EXAMPLE
Import-Csv Tests/Network_Devices.csv | Remove-HPEGLDeviceTagFromDevice -Tags "Country, City, State"

Removes three tags from all devices listed in a CSV file containing at least a SerialNumber column.

.EXAMPLE
Get-HPEGLDevice -FilterByDeviceType SWITCH | Remove-HPEGLDeviceTagFromDevice -All

Removes all tags from all switch devices found in the workspace.

.EXAMPLE
Import-Csv .\Compute_Devices_Tags.csv -Delimiter ";"  | Remove-HPEGLDeviceTagFromDevice 

Removes tags from all devices listed in a `Compute_Devices_Tags.csv` file containing at least two columns, SerialNumber and Tags.

The content of the CSV file must use the following format:
    SerialNumber; Tags
    7LKY2323233LM; Country, State, App
    CZ123QWE456; State, Role
    CZ122QWE533; City

.INPUTS
System.Collections.ArrayList
    List of devices(s) from 'Get-HPEGLDevice'.
System.String, System.String[]
    A single string object or a list of string objects representing the device's serial numbers.

.OUTPUTS
System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
    * SerialNumber - The serial number of the device from which tags were attempted to be removed.
    * PartNumber - The part number of the device.
    * TagsDeleted - List of tags that have been deleted.
    * TagsNotFound - List of tags that were not found on the device.
    * Status - The status of the untagging attempt (Failed for HTTP error return; Warning if tagging is incomplete; Complete if tagging is successful).
    * Details - More information about the status which includes a PSCustomObject with:
          - TagsDeleted - The number of tags deleted.
          - TagsNotFound - The number of tags that could not be found on the device.
          - Error - More information on a warning or failed status error.
    * Exception - Information about any exceptions generated during the operation.
#>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumberAndTags')]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, ParameterSetName = "SerialNumberAndTags")]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, ParameterSetName = "SerialNumberAndAll")]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "SerialNumberAndTags")]
        [String]$Tags,

        [Parameter (ParameterSetName = "SerialNumberAndAll")]
        [Switch]$All,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesATagsUri + "?only_validate=false"
        
        $RemoveTagsDevicesStatus = [System.Collections.ArrayList]::new()
        
        $DevicesWithTagsToRemoveList = [System.Collections.ArrayList]::new()
        $ObjectStatusList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose               
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
          
            SerialNumber = $SerialNumber
            PartNumber   = $Null
            DeviceType   = $Null
            TagsDeleted  = $Tags
            TagsNotFound = $Null
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {


        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] List of devices where to remove tags: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ObjectStatusList.serialnumber | Write-Verbose

        foreach ($DeviceToRemoveTags in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToRemoveTags.SerialNumber

            if ( -not $Device) {
                # Must return a message if device not found
                $DeviceToRemoveTags.Status = "Failed"
                $DeviceToRemoveTags.TagsDeleted = $Null
                $DeviceToRemoveTags.Details = [PSCustomObject]@{TagsDeleted = 0; TagsNotFound = 0; Error = "Device cannot be found in the workspace!" }

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $DeviceToRemoveTags.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {

                $DeviceToRemoveTags.PartNumber = $Device.Part_Number
                $DeviceToRemoveTags.DeviceType = $Device.Device_Type
                    
                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                        
                }      
                "[{0}] `$DeviceList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($DeviceList | out-String) | write-verbose
                    
                # Building the list of devices object where to remove tags
                [void]$DevicesWithTagsToRemoveList.Add($DeviceList)
                    
                # Capturing Tags that already exist
                $ExistingTags = $device.tags

                if ($ExistingTags) {
                    "[{0}] {1}: Existing tags: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, ($ExistingTags | Out-String) | write-verbose
                }
                else {
                    "[{0}] {1}: No existing tag!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber | write-verbose
        
                }
    
                if ($ExistingTags) {
    
                    # Payload objects
                    $TagsToBeDeleted = [System.Collections.ArrayList]::new()
                    $TagsNotFoundList = [System.Collections.ArrayList]::new()
    
                    if ($All) {
    
                        foreach ($_Tag in $ExistingTags) {
            
                            [void]$TagsToBeDeleted.Add($_Tag)
    
                            $TagsNotfoundNumber = 0
            
                        }         
    
    
                    }                             
                    else {

                        $splittedtags = $DeviceToRemoveTags.TagsDeleted.split(",")

                        $TagsList = [System.Collections.ArrayList]::new()

                        foreach ($tag in $splittedtags) {

                            # Check tag format, if format is not <tagname>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+$') {

                                $splittedtagName = $tag.TrimEnd().TrimStart()

                                $DeviceToRemoveTags.Status = "Failed"
                                $DeviceToRemoveTags.TagsDeleted = $Null
                                $DeviceToRemoveTags.Details = [PSCustomObject]@{TagsDeleted = 0; TagsNotFound = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>, <tagname>!" }

                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}' tag '{1}' format not supported! Expected format is <tagname>, <tagname>!" -f $DeviceToRemoveTags.SerialNumber, $splittedtagName
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
                            
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tag.TrimEnd().TrimStart()
                                
                                $TagsList += $tagname

                            }
                                
                        } 

                        if ($TagsList) {                                
                                
                            "[{0}] Tag list to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($TagsList | Out-String) | write-verbose
                                
                            foreach ($_Tag in $TagsList) {     
                                    
                                $_TagItem = $ExistingTags | Where-Object name -eq $_Tag
                                    
                                # Find tags that need to be deleted and that do exist
                                If ($_TagItem) {
                                        
                                    "[{0}] Tag '{1}' is present" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag | write-verbose
                                    [void]$TagsToBeDeleted.Add($_TagItem)
                                }
                                # Find tags that need to be deleted but that do not exist
                                else {
                
                                    "[{0}] Tag '{1}' cannot be found" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag | write-verbose
                                    [void]$TagsNotFoundList.Add($_Tag)
                
                                }
                            }
                
                            $TagsNotfoundNumber = $TagsNotFoundList.count
                                
                            # Add list of tags not found to the tracking object
                            if ($TagsNotFoundList  ) {
                                $DeviceToRemoveTags.TagsNotFound = $TagsNotFoundList    
                                    
                            }
                            else {
                                $objStatus.TagsNotFound = $Null
                            }
                        }
                            
                    }
                        
                    # Add list of tags to be deleted to the tracking object
                    if ( $TagsToBeDeleted) {
                        $DeviceToRemoveTags.TagsDeleted = $TagsToBeDeleted    
                        "[{0}] Tag list to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($TagsToBeDeleted | Out-String) | write-verbose
                            
                    }
                    else {
                        $DeviceToRemoveTags.TagsDeleted = $Null                    
                        "[{0}] No tag to delete!" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-verbose

                    }
                }
            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        # Removing objects where status is failed (condition when device is not found or tags not supported)
        $ObjectStatusListForFoundDevices = $ObjectStatusList | Where-Object { $_.Status -ne "Failed" }
        
        "[{0}] List of objects where status is not failed in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListforFoundDevices | Out-String) | Write-Verbose
        
        "[{0}] Grouping objects based on identical TagsDeleted property values" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        # Create a unique key for each object based on TagsDeleted
        $ObjectStatusListForFoundDevices | ForEach-Object {
            $uniqueKey = ($_.TagsDeleted | Sort-Object name, value | ForEach-Object { "$($_.name)=$($_.value)" }) -join ";"
            Add-Member -InputObject $_ -MemberType NoteProperty -Name UniqueKey -Value $uniqueKey
        }

        # Group objects based on the unique key
        $groupedObjects = $ObjectStatusListForFoundDevices | Group-Object -Property UniqueKey

        # Remove the UniqueKey property from each object in $groupedObjects
        $groupedObjects | ForEach-Object {
            $_.Group | ForEach-Object {
                $_ | ForEach-Object { $_.PSObject.Properties.Remove('UniqueKey') }

            }
        }
        
        "[{0}] List of object groups: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($groupedObjects | Out-String) | Write-Verbose

        
        foreach ($Group in $groupedObjects) {
            
            "[{0}] Group being processed: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Group | Out-String) | Write-Verbose

            $ListOfDevicesWithMatchingTagsDeleteded = $DevicesWithTagsToRemoveList | Where-Object serial_number -in $Group.group.SerialNumber 

            if ($Group.Count -eq 1 ) {
                $ListOfDevicesWithMatchingTagsDeleteded = @($ListOfDevicesWithMatchingTagsDeleteded)
            }

            $TagsToBeDeleted = $Group.group[0].TagsDeleted 

            # Build payload
            $payload = [PSCustomObject]@{
                devices     = $ListOfDevicesWithMatchingTagsDeleteded 
                delete_tags = $TagsToBeDeleted
                create_tags = @()
                
            }                         
                
                
            try {

                $jsonPayload = $payload | ConvertTo-Json -Depth 5

                if ($TagsToBeDeleted) {
                    
                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $jsonPayload -WhatIfBoolean $WhatIf     

                    if (-not $WhatIf) {
    
                        # Find tags that need to be deleted but that do not exist
                        $TagsNotfoundNumber = $TagsList.count - $TagsToBeDeleted.count
    
                        foreach ($object in $Group.Group) {
                            $object.Status = "Complete"
                            $object.Details = [PSCustomObject]@{TagsDeleted = $TagsToBeDeleted.count; TagsNotFound = $object.TagsNotFound.count; Error = $Null }
                            [void] $RemoveTagsDevicesStatus.add($object)
    
    
                        }
                    }
                }
                else {

                    "[{0}] No deletion is required, as there are no such tags to delete." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    if (-not $WhatIf) {

                        foreach ($object in $Group.Group) {
                            $object.Status = "Warning"
                            $object.Details = [PSCustomObject]@{TagsDeleted = $TagsToBeDeleted.count; TagsNotFound = $object.TagsNotFound.count; Error = "No action required, tags to remove cannot be found!" }
                            [void] $RemoveTagsDevicesStatus.add($object)

                        }
                    }
                    else {

                        foreach ($object in $Group.Group) {
                            Write-Warning "Device '$($object.SerialNumber)' has no action required, tags to remove cannot be found!"

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($object in $Group.Group) {
                        $object.Status = "Failed"
                        $object.Details = [PSCustomObject]@{TagsDeleted = 0; TagsNotFound = 0; Error = "Device untagging error!" }
                        $object.Exception = $_.Exception.message 
                        [void] $RemoveTagsDevicesStatus.add($object)

                    }
                }
            }
        }   
        
        # Getting objects where status is failed (condition when device is not found and tags are not supported)
        $ObjectStatusListOfDevicesNotFound = $ObjectStatusList | Where-Object { $_.Status -eq "Failed" } 


        "[{0}] List of objects with devices not found: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListOfDevicesNotFound | Out-String) | Write-Verbose

        foreach ($Object in $ObjectStatusListOfDevicesNotFound) {

            if (-not $WhatIf) {
                [void] $RemoveTagsDevicesStatus.add($object)

            }
                
        }

        if (-not $WhatIf) {

            if ($RemoveTagsDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the untagging attempt!"
        
            }

            $RemoveTagsDevicesStatus = Invoke-RepackageObjectWithType -RawObject $RemoveTagsDevicesStatus -ObjectName "Device.Tag.STTTSDE"  
            Return $RemoveTagsDevicesStatus
        }
    }
}


Function Get-HPEGLLocation {
    <#
    .SYNOPSIS
    Retrieve device locations.

    .DESCRIPTION
    This Cmdlet returns a collection of physical locations and service shipping addresses for all devices.

    .PARAMETER Name 
    (Optional) Specifies the name of a location to display its details.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLLocation

    Returns all physical locations.

    .EXAMPLE
    Get-HPEGLLocation -Name "Geneva"

    Returns the Geneva location information.

    #>

    [CmdletBinding()]
    Param( 
        [String]$Name,            
 
        [Switch]$WhatIf

    ) 
    
    Begin {
    
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Uri = $DevicesLocationUri
  
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
        
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       

        if ($Null -ne $Collection.data) {
              
            $CollectionList = $Collection.data 

            # $ListOfDetailedLocations = [System.Collections.ArrayList]::new()
            $ListOfDetailedLocations = @()

            foreach ($Location in $CollectionList) {

                "[{0}] Selected collection data '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Location.name | Write-Verbose

                $Uri = $DevicesLocationUri + "/" + $Location.id

                "[{0}] URI for the '{1}' location: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Uri | Write-Verbose

                try {
                    [array]$_Resp = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 

                    # [void]$ListOfDetailedLocations.Add($_Resp)
                    $ListOfDetailedLocations += $_Resp
            
                }
                catch {
        
                    $PSCmdlet.ThrowTerminatingError($_)
            
                }
            }
                       
            if ($Name) {
                
                $ListOfDetailedLocations = $ListOfDetailedLocations | Where-Object { $_.name -eq $Name } 
                
            }
                
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $ListOfDetailedLocations -ObjectName "Location" 

            $ReturnData = $ReturnData | Sort-Object name, country

            return $ReturnData
  
        }
        else {

            return 
            
        }
    }
}


Function New-HPEGLLocation {
    <#
    .SYNOPSIS
    Creates a new physical location and service shipping address for devices.

    .DESCRIPTION
    This Cmdlet creates a new physical location with its street address, and optionally, a separate shipping/receiving address if it differs from the street address. It also includes contact details, with the primary contact being mandatory and optional contacts for shipping/receiving, security, and operations.

    Later, this location can be assigned to devices using `Set-HPEGLDeviceLocation`.

    The street address represents the physical location of devices assigned to it and will be used as the default shipping and receiving address. A different shipping and receiving address can be set if needed. If specified, this alternate address will be used when support cases are generated for devices assigned to the location.

    Note: A location can be assigned to devices for automated HPE support case creation and services using `Set-HPEGLDeviceLocation` or removed with `Remove-HPEGLDeviceLocation`.

    .PARAMETER Name 
    Specifies the name of the physical location.

    .PARAMETER Description 
    (Optional) Provides a description of the location.

    .PARAMETER Country 
    Specifies the country of the street address of the location.

    .PARAMETER Street 
    Specifies the postal street address of the location.

    .PARAMETER Street2 
    (Optional) Specifies the second line of the postal street address of the location.

    .PARAMETER City 
    Specifies the city of the street address of the location.

    .PARAMETER State 
    Specifies the state of the street address of the location.

    .PARAMETER PostalCode 
    Specifies the postal code of the street address of the location.

    .PARAMETER ShippingReceivingCountry
    (Optional) Specifies the country for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingStreet
    (Optional) Specifies the street for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingStreet2
    (Optional) Specifies the second line of the street for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingCity
    (Optional) Specifies the city for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingState
    (Optional) Specifies the state for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingPostalCode
    (Optional) Specifies the postal code for the shipping and receiving address if it differs from the street address.

    .PARAMETER PrimaryContactEmail
    (Optional) Sets the primary contact email address for the location.

    .PARAMETER PrimaryContactPhone
    (Optional) Sets the primary contact phone number for the location.

    .PARAMETER ShippingReceivingContactEmail
    (Optional) Sets the shipping and receiving contact email address for the location.

    .PARAMETER ShippingReceivingContactPhone
    (Optional) Sets the shipping and receiving contact phone number for the location.

    .PARAMETER SecurityContactEmail
    (Optional) Sets the security contact email address for the location.

    .PARAMETER SecurityContactPhone
    (Optional) Sets the security contact phone number for the location.

    .PARAMETER OperationsContactEmail
    (Optional) Sets the operations contact email address for the location.

    .PARAMETER OperationsContactPhone
    (Optional) Sets the operations contact phone number for the location.

    .PARAMETER ValidationCycle
    Specifies how often you would like to validate this location. Valid validation cycle is 6, 12 or 18 months.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE  
    New-HPEGLLocation -Name "Boston" -Description "My Boston location" `
    -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" `
    -City "Boston" -State "MA" -PostalCode "02210" `
    -PrimaryContactEmail "Edmond@email.com" -PrimaryContactPhone "+1234567890" `
    -ShippingReceivingContactEmail "Lisa@email.com" -ShippingReceivingContactPhone "+1234567890"

    Creates a new location with shipping and receiving contact information the same as the primary contact, and with the service shipping address set to the same as the location address.

    .EXAMPLE   
    New-HPEGLLocation -Name "Boston" -Description "My Boston location" `
    -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" -City "Boston" -State "MA" -PostalCode "02210" `
    -PrimaryContactEmail "Edmond@email.com" -PrimaryContactPhone "+1234567890" `
    -ShippingReceivingContactEmail "Lisa@email.com" -ShippingReceivingContactPhone "+1234567890" `
    -ShippingReceivingCountry "France" -ShippingReceivingStreet "5th Avenue" -ShippingReceivingCity "Mougins" -ShippingReceivingState "NA" -ShippingReceivingPostalCode "06250"

    Creates a new location with a different service shipping and receiving address, with a primary contact information and with a service shipping address set with a different address than the location address.

    .EXAMPLE
    New-HPEGLLocation -Name "Boston" -Description "My Boston location" `
    -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" -City "Boston" -State "MA" -PostalCode "02210" `
    -PrimaryContactEmail "Edmond@email.com" -PrimaryContactPhone "+1234567890" `
    -ShippingReceivingContactEmail "Lisa@email.com" -ShippingReceivingContactPhone "+1234567890" `
    -ShippingReceivingCountry "France" -ShippingReceivingStreet "5th Avenue" -ShippingReceivingCity "Mougins" -ShippingReceivingState "NA" -ShippingReceivingPostalCode "06250" `
    -SecurityContactEmail Justine@ik.mail -OperationsContactEmail Walter@ik.mail

    Creates a new location with a different service shipping and receiving address, with primary, security, and operations contact information and with a service shipping address set with a different address than the location address.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList    
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the location object attempted to be created.
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.

    #>    

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [String]$Name,

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [String]$Description,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$Street,

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$Street2,        

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$City,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$State,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$PostalCode,
        
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingCountry, 

        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingStreet, 
        
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingStreet2, 
        
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingCity, 
        
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingState,    

        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingPostalCode,    

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$PrimaryContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateScript({
            if ($_ -match '^\+\d+(\s?\d+)*$') {
                $true
            } else {
                Throw "Invalid phone number format. The number must start with a '+' followed by digits, with or without spaces."
            }
        })]
        [String]$PrimaryContactPhone,  

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$ShippingReceivingContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateScript({
            if ($_ -match '^\+\d+(\s?\d+)*$') {
                $true
            } else {
                Throw "Invalid phone number format. The number must start with a '+' followed by digits, with or without spaces."
            }
        })]
        [String]$ShippingReceivingContactPhone,  

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$SecurityContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateScript({
            if ($_ -match '^\+\d+(\s?\d+)*$') {
                $true
            } else {
                Throw "Invalid phone number format. The number must start with a '+' followed by digits, with or without spaces."
            }
        })]
        [String]$SecurityContactPhone,      
        
        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$OperationsContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateScript({
            if ($_ -match '^\+\d+(\s?\d+)*$') {
                $true
            } else {
                Throw "Invalid phone number format. The number must start with a '+' followed by digits, with or without spaces."
            }
        })]
        [String]$OperationsContactPhone,    

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateSet('6', '12', '18')]
        [String]$ValidationCycle,

        [Switch]$WhatIf
    ) 

    Begin {

    
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesLocationUri  
        $NewLocationStatus = [System.Collections.ArrayList]::new()

               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }

        # Check if location already exists
        try {
            $Locationfound = Get-HPEGLLocation -Name $Name
                
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }


        if ( $Locationfound) {

            # Must return a message if Location is already created 
            "[{0}] Location '{1}' already exists in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Location '{0}': Resource already exists in the workspace! No action needed." -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Location already exists in the workspace! No action needed."
            }
            
        }
        else {

            # Get contact names from emails 
            $PrimaryContactInfo = Get-HPEGLUser -Email $PrimaryContactEmail

            if ( $PrimaryContactInfo) {
                $PrimaryContactName = $PrimaryContactInfo.contact.first_name + " " + $PrimaryContactInfo.contact.last_name
            }
            else {
                Write-Warning "$PrimaryContactEmail contact email is not found in the HPE GreenLake workspace! Please ensure the email address is valid and trustworthy!"
                $PrimaryContactName= "NONGLP"
            }

            if ($ShippingReceivingContactEmail) {

                $ShippingReceivingContactInfo = Get-HPEGLUser -Email $ShippingReceivingContactEmail

                if ( $ShippingReceivingContactInfo) {
                    $ShippingReceivingContactName = $ShippingReceivingContactInfo.contact.first_name + " " + $ShippingReceivingContactInfo.contact.last_name

                }
                else {
                    Write-Warning "$PrimaryContactEmail contact email is not found in the HPE GreenLake workspace! Please ensure the email address is valid and trustworthy!"
                    $ShippingReceivingContactName= "NONGLP"

                }
            }
            
            if ($SecurityContactEmail) {

                $SecurityContactInfo = Get-HPEGLUser -Email $SecurityContactEmail

                if ( $SecurityContactInfo) {
                    $SecurityContactName = $SecurityContactInfo.contact.first_name + " " + $SecurityContactInfo.contact.last_name

                }
                else {
                    Write-Warning "$PrimaryContactEmail contact email is not found in the HPE GreenLake workspace! Please ensure the email address is valid and trustworthy!"
                    $SecurityContactName = "NONGLP"
                }
            }
            
            if ($OperationsContactEmail) {

                $OperationsContactInfo = Get-HPEGLUser -Email $OperationsContactEmail

                if ( $OperationsContactInfo) {
                    $OperationsContactName = $OperationsContactInfo.contact.first_name + " " + $OperationsContactInfo.contact.last_name

                }
                else {
                    Write-Warning "$PrimaryContactEmail contact email is not found in the HPE GreenLake workspace! Please ensure the email address is valid and trustworthy!"
                    $OperationsContactName = "NONGLP"
                }
            }


            # Defining location street address or location street address with shipping and receiving address

            
            $LocationAddressList = [System.Collections.ArrayList]::new()

            $StreetAddress = [PSCustomObject]@{
                country         = $Country
                street_address  = $Street
                street_address2 = $Street2
                city            = $City
                state           = $State
                postal_code     = $PostalCode
                type            = "street"

            }

            $LocationAddressList += $StreetAddress 

            if ($ShippingReceivingCountry) {

                $ShippingReceivingAddress = [PSCustomObject]@{
                    country         = $ShippingReceivingCountry
                    street_address  = $ShippingReceivingStreet
                    street_address2 = $ShippingReceivingStreet2
                    city            = $ShippingReceivingCity
                    state           = $ShippingReceivingState
                    postal_code     = $ShippingReceivingPostalCode
                    type            = "shipping_receiving"
                }
                    
                $LocationAddressList += $ShippingReceivingAddress

            }
           
           
            # Defining contacts

            $ContactsList = [System.Collections.ArrayList]::new()


            $PrimaryContact = [PSCustomObject]@{ 
                type         = "primary"
                name         = $PrimaryContactName
                phone_number = $PrimaryContactPhone
                email        = $PrimaryContactEmail
            }              
            
            $ContactsList += $PrimaryContact 


            if ($ShippingReceivingContactEmail) {
    
                $ShippingReceivingContact = [PSCustomObject]@{ 
                    type         = "shipping_receiving"
                    name         = $ShippingReceivingContactName
                    phone_number = $ShippingReceivingContactPhone
                    email        = $ShippingReceivingContactEmail
                }

                $ContactsList += $ShippingReceivingContact

            }
            
            if ($SecurityContactEmail) {

                $SecurityContact = [PSCustomObject]@{ 
                    type         = "security"
                    name         = $SecurityContactName
                    phone_number = $SecurityContactPhone
                    email        = $SecurityContactEmail
                }

                $ContactsList += $SecurityContact
            }
            
            if ($OperationsContactEmail) {

                $OperationsContact = [PSCustomObject]@{ 
                    type         = "operations"
                    name         = $OperationsContactName
                    phone_number = $OperationsContactPhone
                    email        = $OperationsContactEmail
                }

                $ContactsList += $OperationsContact
            }

            # Building payload

            $Payload = [PSCustomObject]@{
                name                = $Name
                description         = $Description
                type                = "building"
                addresses           = $LocationAddressList
                contacts            = $ContactsList
                validated           = $true
                validation_cycle    = $ValidationCycle
                validated_by_email  = $HPEGreenLakeSession.username
                validated_by_name   = $HPEGreenLakeSession.name

            } | ConvertTo-Json -Depth 5
   
                   
            # Create Location
            try {

                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {

                    "[{0}] Location '{1}' successfully created" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Location successfully created"
        
                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Location cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }

            }

        }
        

        [void] $NewLocationStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($NewLocationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more location failed the creation attempt!"
          
            }

            $NewLocationStatus = Invoke-RepackageObjectWithType -RawObject $NewLocationStatus -ObjectName "ObjStatus.NSDE" 
            Return $NewLocationStatus
        }


    }
}


Function Set-HPEGLLocation {
    <#
    .SYNOPSIS
    Modify an existing physical location.

    .DESCRIPTION
    This Cmdlet modifies physical location information such as addresses (street and shipping/receiving), contacts (primary, shipping/receiving, security, and operations), and other details. 
    
    If you omit any parameter, the cmdlet retains the current settings for those fields and only updates the provided parameters.

    The street address represents the physical location of the devices assigned to the location. It will be used as the default shipping and receiving address for these devices. A different shipping and receiving address can be set if needed. If specified, this alternate address will be used when support cases are generated for devices assigned to the location.

    Note: A location can be assigned to devices for automated HPE support case creation and services using `Set-HPEGLDeviceLocation` or removed with `Remove-HPEGLDeviceLocation`.
    
    .PARAMETER Name 
    Specifies the name of the physical location.

    .PARAMETER NewName 
    (Optional) Sets a new name for the location.

    .PARAMETER Description 
    (Optional) Sets a description of the location.

    .PARAMETER Country 
    (Optional) Sets the country of the street address of the location.

    .PARAMETER Street 
    (Optional) Sets the street address of the street address of the location.

    .PARAMETER Street2 
    (Optional) Sets the secondary street address of the street address of the location.

    .PARAMETER City 
    (Optional) Sets the city of the street address of the location.
        
    .PARAMETER State 
    (Optional) Sets the state of the street address of the location.

    .PARAMETER PostalCode 
    (Optional) Sets the postal code of the street address of the location.

    .PARAMETER ShippingReceivingCountry
    (Optional) Sets the country for the shipping and receiving address if it differs from the street address.        

    .PARAMETER ShippingReceivingStreet
    (Optional) Sets the street for the shipping and receiving address if it differs from the street address.     

    .PARAMETER ShippingReceivingStreet2
    (Optional) Sets the secondary street for the shipping and receiving address if it differs from the street address.  

    .PARAMETER ShippingReceivingCity
    (Optional) Sets the city for the shipping and receiving address if it differs from the street address.  

    .PARAMETER ShippingReceivingState
    (Optional) Sets the state for the shipping and receiving address if it differs from the street address.  

    .PARAMETER ShippingReceivingPostalCode
    (Optional) Sets the postal code for the shipping and receiving address if it differs from the street address. 

    .PARAMETER RemoveShippingReceivingAddress
    (Optional) Deletes the shipping and receiving address of the location.

    .PARAMETER PrimaryContactEmail
    (Optional) Sets the primary contact email address of the location.    

    .PARAMETER PrimaryContactPhone
    (Optional) Sets the primary contact phone number of the location.

    .PARAMETER ShippingReceivingContactEmail
    (Optional) Sets the shipping and receiving contact email address of the location.

    .PARAMETER ShippingReceivingContactPhone
    (Optional) Sets the shipping and receiving contact phone number of the location.

    .PARAMETER RemoveShippingReceivingContact
    (Optional) Deletes the shipping and receiving contact of the location.

    .PARAMETER SecurityContactEmail
    (Optional) Sets the security contact email address of the location.

    .PARAMETER SecurityContactPhone
    (Optional) Sets the security contact phone number of the location.

    .PARAMETER RemoveSecurityContact
    (Optional) Deletes the security contact of the location.

    .PARAMETER OperationsContactEmail
    (Optional) Sets the operations contact email address of the location.

    .PARAMETER OperationsContactPhone
    (Optional) Sets the operations contact phone number of the location.

    .PARAMETER RemoveOperationsContact
    (Optional) Deletes the operations contact of the location.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
        
   .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -NewName "HPE Mougins" -Description "Location in Central Europe"
    Renames the "Mougins" location to "HPE Mougins" and changes its description.

    .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -Description ""

    Removes the description set for the "Mougins" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Boston" -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" -City "Boston" -State "MA" -PostalCode "02210"

    Modifies the street address of the "Boston" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Boston" -Street2 ""

    Removes the secondary street address from the "Boston" location's street address.

    .EXAMPLE
    Set-HPEGLLocation -Name "Houston" -PrimaryContactEmail TheBoss@email.com -PrimaryContactPhone "+123456789"

    Modifies the "Houston" location with a primary contact email and phone number.

    .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -ShippingReceivingCountry "France" -ShippingReceivingStreet "790 Avenue du Docteur Donat" -ShippingReceivingStreet2 "Marco Polo - Batiment B" -ShippingReceivingCity "Mougins" -ShippingReceivingPostalCode 06254

    Adds or modifies the shipping and receiving address for the "Mougins" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Boston" -RemoveShippingReceivingAddress

    Removes the existing shipping and receiving address from the "Boston" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -ShippingReceivingContactEmail TheTech@email.com -ShippingReceivingContactPhone "+123456789"

    Modifies or adds the shipping and receiving contact information for the "Mougins" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -RemoveShippingReceivingContact

    Removes the existing shipping and receiving contact information from the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -SecurityContactEmail Thesecurity@email.com -SecurityContactPhone "+3360000001"

    Modifies or adds the security contact information for the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -RemoveSecurityContact

    Removes the existing security contact from the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -OperationsContactEmail TheOperations@email.com -OperationsContactPhone "+1123456789"

    Modifies or adds the operations contact information for the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -RemoveOperationsContact

    Removes the existing operations contact from the "Barcelona" location.

    .EXAMPLE
    Get-HPEGLLocation | Set-HPEGLLocation -SecurityContactEmail security@domain.com -SecurityContactPhone +123456789123

    Modifies or adds security contact information for all locations found in the currently connected HPE GreenLake workspace.

    .INPUTS
    System.Collections.ArrayList
        List of location(s) from 'Get-HPEGLLocation'.

    .OUTPUTS
    System.Collections.ArrayList    
    A custom status object or array of objects containing the following PsCustomObject keys:  
    * Name - name of the location object attempted to be modified 
    * Status - status of the modification attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed) 
    * Details - more information about the status 
    * Exception - information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Details')]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Parameter (ParameterSetName = "Details")]
        [String]$NewName,

        [Parameter (ParameterSetName = "Details")]
        [String]$Description,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,
        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$Street,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$Street2,        

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$City,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$State,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$PostalCode,
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingCountry, 

        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingStreet, 
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingStreet2, 
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingCity, 
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingState,    

        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingPostalCode,    

        [Parameter (ParameterSetName = "RemoveShippingReceivingAddress")]
        [Switch]$RemoveShippingReceivingAddress,    

        [Parameter (ParameterSetName = "PrimaryContact")]
        [String]$PrimaryContactEmail,   

        [Parameter (ParameterSetName = "PrimaryContact")]
        [String]$PrimaryContactPhone,  

        [Parameter (ParameterSetName = "ShippingReceivingContact")]
        [String]$ShippingReceivingContactEmail,   

        [Parameter (ParameterSetName = "ShippingReceivingContact")]
        [String]$ShippingReceivingContactPhone, 
        
        [Parameter (ParameterSetName = "RemoveShippingReceivingContact")]
        [Switch]$RemoveShippingReceivingContact,    

        [Parameter (ParameterSetName = "SecurityContact")]
        [String]$SecurityContactEmail,   

        [Parameter (ParameterSetName = "SecurityContact")]
        [String]$SecurityContactPhone,  
        
        [Parameter (ParameterSetName = "RemoveSecurityContact")]
        [Switch]$RemoveSecurityContact,    
        
        [Parameter (ParameterSetName = "OperationsContact")]
        [String]$OperationsContactEmail,   

        [Parameter (ParameterSetName = "OperationsContact")]
        [String]$OperationsContactPhone,  
        
        [Parameter (ParameterSetName = "RemoveOperationsContact")]
        [Switch]$RemoveOperationsContact,  

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()

               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }
        

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            
            $Locations = Get-HPEGLLocation 
            $Users = Get-HPEGLUser 

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        foreach ($Object in $ObjectStatusList) {
            
            $Locationfound = $Locations | Where-Object name -eq $Object.Name
            $Uri = $DevicesLocationUri + "/" + $Locationfound.id

            if (-not $Locationfound) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Location cannot be found in the workspace!"

                if ($WhatIf) {
                    $ErrorMessage = "Location '{0}': Resource cannot be found in the workspace!" -f $Object.Name
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {
                                
                $LocationAddressList = [System.Collections.ArrayList]::new()
                $ContactsList = [System.Collections.ArrayList]::new()
                
                #Region Validate emails
                if ($PrimaryContactEmail) {

                    $PrimaryContactInfo = $Users | Where-Object email -eq $PrimaryContactEmail
                    
                    # Get contact names from emails 
                    if ( $PrimaryContactInfo) {
                        $PrimaryContactName = $PrimaryContactInfo.contact.first_name + " " + $PrimaryContactInfo.contact.last_name
                    }
                    else {
                        Throw "$PrimaryContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }          

                if ($ShippingReceivingContactEmail) {
                   
                    $ShippingReceivingContactInfo = $Users | Where-Object email -eq $ShippingReceivingContactEmail

                    if ( $ShippingReceivingContactInfo) {
                        $ShippingReceivingContactName = $ShippingReceivingContactInfo.contact.first_name + " " + $ShippingReceivingContactInfo.contact.last_name

                    }
                    else {
                        Throw "$ShippingReceivingContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }
                
                if ($SecurityContactEmail) {
                  
                    $SecurityContactInfo = $Users | Where-Object email -eq $SecurityContactEmail

                    if ( $SecurityContactInfo) {
                        $SecurityContactName = $SecurityContactInfo.contact.first_name + " " + $SecurityContactInfo.contact.last_name

                    }
                    else {
                        Throw "$SecurityContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }
                
                if ($OperationsContactEmail) {
                   
                    $OperationsContactInfo = $Users | Where-Object email -eq $OperationsContactEmail

                    if ( $OperationsContactInfo) {
                        $OperationsContactName = $OperationsContactInfo.contact.first_name + " " + $OperationsContactInfo.contact.last_name

                    }
                    else {
                        Throw "$OperationsContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }


                #EndRegion

                #Region Modifying details (Name or Description)

                if ($NewName) {

                    # newname cannot be used when more than one location is found in $ObjectStatusList
                    if ($ObjectStatusList.Count -gt 1) {
                        Throw "NewName cannot be used when more than one location is found in the pipeline!"
                    }
                    else {
                        $Name = $NewName
                    }

                }
                else {
                    $Name = $Locationfound.name
                }

                if (-not $PSBoundParameters.ContainsKey('Description')) {
                
                    if ($Locationfound.description) {
                                
                        $Description = $Locationfound.description
                    }
                    else {
                        $Description = $Null
                    }
                }

                if ($PSBoundParameters.ContainsKey('NewName') -or $PSBoundParameters.ContainsKey('Description')) {

                    # Building payload
            
                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
            
                    } | ConvertTo-Json -Depth 5
                }

                #EndRegion
            
                #Region Modifying street address
                if (-not $PSBoundParameters.ContainsKey('Country')) {
                
                    if (($Locationfound.addresses | Where-Object type -eq Street ).country) {
                                
                        $Country = ($Locationfound.addresses | Where-Object type -eq Street ).country
                    }
                    else {
                        $Country = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('Street')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).street_address) {
                                
                        $Street = ($Locationfound.addresses | Where-Object type -eq Street ).street_address
                    }
                    else {
                        $Street = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('Street2')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).street_address2) {
                                
                        $Street2 = ($Locationfound.addresses | Where-Object type -eq Street ).street_address2
                    }
                    else {
                        $Street2 = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('City')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).city) {
                                
                        $City = ($Locationfound.addresses | Where-Object type -eq Street ).city
                    }
                    else {
                        $City = $Null
                    }
                }
                # State is mandatory !
                if (-not $State) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).state) {
                                
                        $State = ($Locationfound.addresses | Where-Object type -eq Street ).state
                    }

                }
                if (-not $PSBoundParameters.ContainsKey('PostalCode')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).postal_code) {
                                
                        $PostalCode = ($Locationfound.addresses | Where-Object type -eq Street ).postal_code
                    }
                    else {
                        $PostalCode = $Null
                    }
                }

                if ($PSBoundParameters.ContainsKey('Country') -or $PSBoundParameters.ContainsKey('Street') -or $PSBoundParameters.ContainsKey('Street2') -or $PSBoundParameters.ContainsKey('City') -or $PSBoundParameters.ContainsKey('State') -or $PSBoundParameters.ContainsKey('PostalCode')) {
                
                    $PrimaryAddressId = ($Locationfound.addresses | Where-Object type -eq Street).id

                    $StreetAddress = [PSCustomObject]@{
                        country         = $Country
                        street_address  = $Street
                        street_address2 = $Street2
                        city            = $City
                        state           = $State
                        postal_code     = $PostalCode
                        type            = "street"
                        id              = $PrimaryAddressId
                    }

                    $LocationAddressList += $StreetAddress 
                }
                #Endregion

                #Region Modifying shipping/receiving address

                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingCountry')) {
                
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).country) {
                                
                        $ShippingReceivingCountry = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).country
                    }
                    else {
                        $ShippingReceivingCountry = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingStreet')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address) {
                                
                        $ShippingReceivingStreet = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address
                    }
                    else {
                        $ShippingReceivingStreet = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingStreet2')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address2) {
                                
                        $ShippingReceivingStreet2 = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address2
                    }
                    else {
                        $ShippingReceivingStreet2 = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingCity')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).city) {
                                
                        $ShippingReceivingCity = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).city
                    }
                    else {
                        $ShippingReceivingCity = $Null
                    }
                }
                # Mandatory
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingState')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).state) {
                                
                        $ShippingReceivingState = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).state
                    }
                    else {
                        $ShippingReceivingState = "N/A"
                    }
                    
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingPostalCode')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).postal_code) {
                                
                        $ShippingReceivingPostalCode = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).postal_code
                    }
                    else {
                        $ShippingReceivingPostalCode = $Null
                    }
                }


                if ($PSBoundParameters.ContainsKey('ShippingReceivingCountry') -or $PSBoundParameters.ContainsKey('ShippingReceivingStreet') -or $PSBoundParameters.ContainsKey('ShippingReceivingStreet2') `
                        -or $PSBoundParameters.ContainsKey('ShippingReceivingCity') -or $PSBoundParameters.ContainsKey('ShippingReceivingState') -or $PSBoundParameters.ContainsKey('ShippingReceivingPostalCode')) {

                    # if already exists
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving).id) {

                        $ShippingAddressId = ($Locationfound.addresses | Where-Object type -eq shipping_receiving).id
                        
                        $ShippingReceivingAddress = [PSCustomObject]@{
                            country         = $ShippingReceivingCountry
                            street_address  = $ShippingReceivingStreet
                            street_address2 = $ShippingReceivingStreet2
                            city            = $ShippingReceivingCity
                            state           = $ShippingReceivingState
                            postal_code     = $ShippingReceivingPostalCode
                            type            = "shipping_receiving"
                            id              = $ShippingAddressId 
                        }
                    }
                    else {
                        $ShippingReceivingAddress = [PSCustomObject]@{
                            country         = $ShippingReceivingCountry
                            street_address  = $ShippingReceivingStreet
                            street_address2 = $ShippingReceivingStreet2
                            city            = $ShippingReceivingCity
                            state           = $ShippingReceivingState
                            postal_code     = $ShippingReceivingPostalCode
                            type            = "shipping_receiving"
                        }

                    }
                        
                    $LocationAddressList += $ShippingReceivingAddress
                }

                #Endregion
                
                #Region Removing Shipping/receiving contact
                if ($RemoveShippingReceivingAddress) {
        
                    $ShippingAddressId = ($Locationfound.addresses | Where-Object type -eq shipping_receiving).id
        
                    if (! $ShippingAddressId) {
    
                        "[{0}] There is no Shipping and Receiving address for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                        $Object.Status = "Failed"
                        $Object.Details = "There is no Shipping and Receiving address in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($Object)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no Shipping and Receiving address in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }

                    }
                    else {

                        $StreetAddressId = ($Locationfound.addresses | Where-Object type -eq street).id

                        $Country = ($Locationfound.addresses | Where-Object type -eq Street ).country
                    
                        $Street = ($Locationfound.addresses | Where-Object type -eq Street ).street_address
        
                        $Street2 = ($Locationfound.addresses | Where-Object type -eq Street ).street_address2
        
                        $City = ($Locationfound.addresses | Where-Object type -eq Street ).city
        
                        $State = ($Locationfound.addresses | Where-Object type -eq Street ).state
        
                        $PostalCode = ($Locationfound.addresses | Where-Object type -eq Street ).postal_code
        
                        $StreetAddress = [PSCustomObject]@{
                            country         = $Country
                            street_address  = $Street
                            street_address2 = $Street2
                            city            = $City
                            state           = $State
                            postal_code     = $PostalCode
                            type            = "street"
                            id              = $StreetAddressId 
        
                        }

                        $LocationAddressList += $StreetAddress      
                        
                        $ShippingAddressInfo = [PSCustomObject]@{ 
                            type = "shipping_receiving"
                            id   = $ShippingAddressId
                        }         
                        
                        $LocationAddressList += $ShippingAddressInfo      

                    }
                }
                #Endregion

                #Region Modifying primary contact

                if (-not $PSBoundParameters.ContainsKey('PrimaryContactName')) {
                
                    if (($Locationfound.contacts | Where-Object type -eq primary).name) {
                                
                        $PrimaryContactName = ($Locationfound.contacts | Where-Object type -eq primary).name
                    }
                    else {
                        $PrimaryContactName = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('PrimaryContactPhone')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq primary).phone_number) {
                                
                        $PrimaryContactPhone = ($Locationfound.contacts | Where-Object type -eq primary).phone_number
                    }
                    else {
                        $PrimaryContactPhone = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('PrimaryContactEmail')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq primary).email) {
                                
                        $PrimaryContactEmail = ($Locationfound.contacts | Where-Object type -eq primary).email
                    }
                    else {
                        $PrimaryContactEmail = $Null
                    }
                }

                if ($PSBoundParameters.ContainsKey('PrimaryContactEmail') -or $PSBoundParameters.ContainsKey('PrimaryContactPhone')) {
            
                    $PrimaryContactId = ($Locationfound.contacts | Where-Object type -eq primary).id
                
                    $ContactInfo = [PSCustomObject]@{ 
                        type = "primary"
                        id   = $PrimaryContactId
                    }         
                    
                    $ContactsList += $ContactInfo             
                    
                    $PrimaryContact = [PSCustomObject]@{ 
                        type         = "primary"
                        name         = $PrimaryContactName
                        phone_number = $PrimaryContactPhone
                        email        = $PrimaryContactEmail
                        location_id  = $Locationfound.id
                    }              
                
                    $ContactsList += $PrimaryContact 

                }

                #EndRegion

                #Region Modifying shipping/receiving contact

                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingContactPhone')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq shipping_receiving).phone_number) {
                                
                        $ShippingReceivingContactPhone = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).phone_number
                    }
                    else {
                        $ShippingReceivingContactPhone = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingContactEmail')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq shipping_receiving).email) {
                                
                        $ShippingReceivingContactEmail = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).email
                    }
                    else {
                        $ShippingReceivingContactEmail = $Null
                    }
                }

                if ( $PSBoundParameters.ContainsKey('ShippingReceivingContactEmail') -or $PSBoundParameters.ContainsKey('ShippingReceivingContactPhone')) {
                    
                    # If contact not existing
                    if (! ($Locationfound.contacts | Where-Object type -eq shipping_receiving)) {

                        $ShippingReceivingContact = [PSCustomObject]@{ 
                            type         = "shipping_receiving"
                            name         = $ShippingReceivingContactName
                            phone_number = $ShippingReceivingContactPhone
                            email        = $ShippingReceivingContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $ShippingReceivingContact

                    }
                    # If contact already created
                    else {

                        $ShippingReceivingContactId = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).id
        
                        $ContactInfo = [PSCustomObject]@{ 
                            type = "shipping_receiving"
                            id   = $ShippingReceivingContactId
                        }         
                        
                        $ContactsList += $ContactInfo  

                        $ShippingReceivingContact = [PSCustomObject]@{ 
                            type         = "shipping_receiving"
                            name         = $ShippingReceivingContactName
                            phone_number = $ShippingReceivingContactPhone
                            email        = $ShippingReceivingContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $ShippingReceivingContact
                    }
                }

                #EndRegion

                #Region Remove Shipping/Receiving Contact
                if ($RemoveShippingReceivingContact) {
                    
                    $ShippingReceivingContactId = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).id

                    if ( ! $ShippingReceivingContactId) {
                        
                        "[{0}] There is no Shipping and Receiving contact for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        
                        $Object.Status = "Failed"
                        $Object.Details = "There is no Shipping and Receiving contact in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($objStatus)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no Shipping and Receiving contact in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }
                 

                    }
                    else {
        
                        $ContactInfo = [PSCustomObject]@{ 
                            type = "shipping_receiving"
                            id   = $ShippingReceivingContactId
                        }         
                    
                        $ContactsList += $ContactInfo  
                    }
                }
                #Endregion

                #Region Modifying security contact

                if (-not $PSBoundParameters.ContainsKey('SecurityContactPhone')) {
        
                    if (($Locationfound.contacts | Where-Object type -eq security).phone_number) {
                                
                        $SecurityContactPhone = ($Locationfound.contacts | Where-Object type -eq security).phone_number
        
                    }
                    else {
                        $SecurityContactPhone = $Null
                    }
        
                }
                if (-not $PSBoundParameters.ContainsKey('SecurityContactEmail')) {
        
                    if (($Locationfound.contacts | Where-Object type -eq security).email) {
                                
                        $SecurityContactEmail = ($Locationfound.contacts | Where-Object type -eq security).email
        
                    }
                    else {
                        $SecurityContactEmail = $Null
                    }
        
                }

                if ( $PSBoundParameters.ContainsKey('SecurityContactEmail') -or $PSBoundParameters.ContainsKey('SecurityContactPhone')) {

                    # If contact not existing

                    if (! ($Locationfound.contacts | Where-Object type -eq security)) {

                        $SecurityContact = [PSCustomObject]@{ 
                            type         = "security"
                            name         = $SecurityContactName
                            phone_number = $SecurityContactPhone
                            email        = $SecurityContactEmail
                            location_id  = $Locationfound.id

                        }

                        $ContactsList += $SecurityContact

                    }
                    # If contact already created
                    else {

                        $SecurityContactId = ($Locationfound.contacts | Where-Object type -eq security).id

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "security"
                            id   = $SecurityContactId
                        }         
                    
                        $ContactsList += $ContactInfo  

                        $SecurityContact = [PSCustomObject]@{ 
                            type         = "security"
                            name         = $SecurityContactName
                            phone_number = $SecurityContactPhone
                            email        = $SecurityContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $SecurityContact
                    }
                }
                #Endregion

                #Region Remove Security Contact
                if ($RemoveSecurityContact) {
                    
                    $SecurityContactId = ($Locationfound.contacts | Where-Object type -eq security).id

                    if ( ! $SecurityContactId) {
                        
                        "[{0}] There is no security contact for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                        $Object.Status = "Failed"
                        $Object.Details = "There is no security contact in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($Object)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no security contact in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }

                    }
                    else {

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "security"
                            id   = $SecurityContactId
                        }         
                
                        $ContactsList += $ContactInfo  
                    }
                }
                #Endregion

                #Region Modifying operations contact

                if (-not $PSBoundParameters.ContainsKey('OperationsContactPhone')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq operations).phone_number) {
                                
                        $OperationsContactPhone = ($Locationfound.contacts | Where-Object type -eq operations).phone_number
        
                    }
                    else {
                        $OperationsContactPhone = $Null
                    }
        
                }  
                if (-not $PSBoundParameters.ContainsKey('OperationsContactEmail')) {
        
                    if (($Locationfound.contacts | Where-Object type -eq operations).email) {
                                
                        $OperationsContactEmail = ($Locationfound.contacts | Where-Object type -eq operations).email
        
                    }
                    else {
                        $OperationsContactEmail = $Null
                    }
        
                }  

                if ($PSBoundParameters.ContainsKey('OperationsContactEmail') -or $PSBoundParameters.ContainsKey('OperationsContactPhone')) {

                    # If contact not existing

                    if (! ($Locationfound.contacts | Where-Object type -eq operations)) {

                        $OperationsContact = [PSCustomObject]@{ 
                            type         = "operations"
                            name         = $OperationsContactName
                            phone_number = $OperationsContactPhone
                            email        = $OperationsContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $OperationsContact

                    }                  
                    # If contact already created
                    else {

                        $OperationsContactId = ($Locationfound.contacts | Where-Object type -eq operations).id

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "operations"
                            id   = $OperationsContactId
                        }         
                
                        $ContactsList += $ContactInfo  

                        $OperationsContact = [PSCustomObject]@{ 
                            type         = "operations"
                            name         = $OperationsContactName
                            phone_number = $OperationsContactPhone
                            email        = $OperationsContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $OperationsContact
                    }
                }
                #Endregion

                #Region Remove Operations Contact
                if ($RemoveOperationsContact) {

                    $OperationsContactId = ($Locationfound.contacts | Where-Object type -eq operations).id

                    if ( ! $OperationsContactId) {
                        
                        "[{0}] There is no operations contact for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        
                        $Object.Status = "Failed"
                        $Object.Details = "There is no operations contact in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($Object)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no operations contact in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }
                       
                    }
                    else {

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "operations"
                            id   = $OperationsContactId
                        }         
            
                        $ContactsList += $ContactInfo  
                    }
                }
                #Endregion


                # Building payload

                if ( $LocationAddressList) {
                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
                        addresses   = $LocationAddressList
        
                    } | ConvertTo-Json -Depth 5
                }

                if ( $ContactsList) {

                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
                        contacts    = $ContactsList

                    } | ConvertTo-Json -Depth 5
                }
                
                
                if ( $LocationAddressList -and $ContactsList) {
                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
                        addresses   = $LocationAddressList
                        contacts    = $ContactsList

        
                    } | ConvertTo-Json -Depth 5
                }


                    
                # Modify Location
                try {

                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $Payload -WhatIfBoolean $WhatIf 
                    
                    if (-not $WhatIf) {

                        "[{0}] Location '{1}' successfully updated" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        $Object.Status = "Complete"
                        $Object.Details = "Location successfully modified"
            
                    }

                }
                catch {

                    if (-not $WhatIf) {
                        $Object.Status = "Failed"
                        $Object.Details = "Location cannot be modified!"
                        $Object.Exception = $_.Exception.message 
                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "One or more locations failed the modification attempt!"
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.NSDE" 
            Return $ObjectStatusList
        }
    }
}


Function Remove-HPEGLLocation {
    <#
    .SYNOPSIS
    Delete a physical location and service shipping address.

    .DESCRIPTION
    This Cmdlet can be used to delete a physical location and its addresses and contacts.

    The cmdlet issues a message at runtime to warn the user of the irreversible impact of this action and asks for a confirmation for the removal of the location.
        
    Any assigned devices will be released. Any associated addresses will no longer be accessible for automated support case creation. All associated contacts will no longer be assigned to any devices assigned to this location.

    .PARAMETER Name 
    Specifies the name of the physical location to be deleted.

    .PARAMETER Force
    Switch parameter that performs the deletion without prompting for confirmation.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLLocation -Name "Boston"

    Deletes the Boston physical location and any associated service shipping addresses and contacts after the user has confirmed the removal. Any devices assigned to the Boston location are released.

    .EXAMPLE
    Get-HPEGLLocation -Name "Mougins" | Remove-HPEGLLocation -Force

    Deletes the Mougins physical location and any associated service shipping addresses and contacts without prompting for confirmation.

    .EXAMPLE
    Get-HPEGLLocation | Remove-HPEGLLocation

    Deletes all physical locations and any associated service shipping addresses and contacts with prompting for confirmation.

    .INPUTS
    System.Collections.ArrayList
        List of location(s) from 'Get-HPEGLLocation'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the location's names.

    .OUTPUTS
    System.Collections.ArrayList    
    A custom status object or array of objects containing the following PsCustomObject keys:  
    * Name - name of the location object attempted to be deleted 
    * Status - status of the deletion attempt (Failed for HTTP error return; Complete if the deletion is successful; Warning if no action is needed) 
    * Details - more information about the status 
    * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [String]$Name, 

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $RemoveLocationStatus = [System.Collections.ArrayList]::new()
               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                      
        }

        if ($Force) {
            $decision = 0
        }
        else {
            $title = "Any assigned devices will be released. Any associated addresses will no longer be accessible for automated support case creation. All associated contacts will no longer be assigned to any devices assigned to this location." 
            $question = 'Are you sure you want to proceed?'
            $choices = '&Yes', '&No'
            $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
        }
           

        if ($decision -eq 0) {


            # Check if location exists
            try {
                $Locationfound = Get-HPEGLLocation -Name $Name

                $Uri = $DevicesLocationUri + "/" + $Locationfound.id
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)                
            }


            if ( -not $Locationfound) {
    
                # Must return a message if resource not found
                
                if ($WhatIf) {
                    $ErrorMessage = "Location '{0}': Resource cannot be found in the workspace!" -f $Name
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Location cannot be found in the workspace!"
                }
            
            }
            else {           
                   
                # Delete Location
                try {

                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $Payload -WhatIfBoolean $WhatIf 
                
                    if (-not $WhatIf) {

                        "[{0}] Location '{1}' successfully deleted" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Location successfully deleted"
        
                    }

                }
                catch {

                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Location cannot be deleted!"
                        $objStatus.Exception = $_.Exception.message 
                    }

                }

            }
        
        }

        else {
                
            'Operation cancelled by user!' | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Operation cancelled by the user!"
                Write-warning $ErrorMessage
                return
            }
            else {    
                $objStatus.Status = "Failed"
                $objStatus.Details = "Operation cancelled by the user!"
            }
        }

        [void] $RemoveLocationStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveLocationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more location failed the deletion attempt!"
          
            }

            $RemoveLocationStatus = Invoke-RepackageObjectWithType -RawObject $RemoveLocationStatus -ObjectName "ObjStatus.NSDE" 
            Return $RemoveLocationStatus
        }


    }
}


Function Set-HPEGLDeviceLocation {
    <#
    .SYNOPSIS
    Assign device(s) to a physical location.

    .DESCRIPTION
    This Cmdlet assigns device(s) to an HPE GreenLake physical location. This action enables automated HPE support case creation and services.    

    For HPE OneView servers, use 'Set-HPECOMOneViewServerLocation'.

    .PARAMETER DeviceSerialNumber 
    Serial number of the device to be assigned to the location. This value can be retrieved from 'Get-HPEGLDevice'.

    .PARAMETER LocationName 
    Name of the available physical location to assign. This value can be retrieved from 'Get-HPEGLLocation'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLDeviceLocation -LocationName London -DeviceSerialNumber CW12312332
        
    Assigns the device with the serial number 'CW12312332' to the 'London' location.

    .EXAMPLE
    Get-HPEGLDevice -SerialNumber CW12312332 | Set-HPEGLDeviceLocation -LocationName 'Houston' 
       
    Assigns the device with the serial number 'CW12312332' to the 'Houston' location.

    .EXAMPLE
    'CW12312332', 'CW12312333', 'CW12312334' | Set-HPEGLDeviceLocation -LocationName "London"

    Assigns the devices with the provided list of serial numbers to the 'London' location using pipeline input.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -name CW12312334 | Set-HPEGLDeviceLocation -LocationName Boston 

    Assigns the Cpmpute Ops Management server in the central european region with the serial number 'CW12312334' to the 'Boston' location.
        
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice' or from 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device being assigned to a physical location.
        * Location - Name of the location where the device is being assigned.
        * Status - Status of the assignment attempt (Failed for HTTP error return; Complete if assignment is successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory)]
        [String]$LocationName,

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('serial_number', 'serialnumber')]
        [String]$DeviceSerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

        try {
            
            $Locationfound = Get-HPEGLLocation -Name $LocationName

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }

        if ( -not $Locationfound) {
                    
            $ErrorMessage = "Location '{0}' cannot be found in the workspace!" -f $LocationName
            throw $ErrorMessage
        }

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Location     = $LocationName                       
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }
    

        [void]$ObjectStatusList.Add($objStatus)


    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ($device.location_name) {

                # Must return a message if device is already assigned to location and removed from the list of devices to be set
                $Object.Status = "Warning"
                $Object.Details = "Device is already assigned to the '$($device.location_name)' location!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is already assigned to the '{1}' location!" -f $Object.SerialNumber, $device.location_name
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {         

                # Build DeviceList object
                
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                    location_id   = $Locationfound.id
                }

                
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{
                devices = $DevicesList

            } | ConvertTo-Json -Depth 5

                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully assigned to device"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be assigned to device!"

                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more device locations failed to assign successfully!"

          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Location.SLSDE" 
            Return $ObjectStatusList
        }


    }
}


Function Remove-HPEGLDeviceLocation {
    <#
    .SYNOPSIS
    Remove device(s) from a physical location. 

    .DESCRIPTION
    This Cmdlet unassigns device(s) from an HPE GreenLake physical location.  

    For HPE OneView servers, use 'Remove-HPECOMOneViewServerLocation'.
        
    .PARAMETER DeviceSerialNumber 
    Serial number of the device to be unassigned from a physical location. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLDeviceLocation -DeviceSerialNumber CZ12312311
    
    Unassign the device with the serial number 'CZ12312311' from its physical location.

    .EXAMPLE
    Get-HPEGLDevice -SerialNumber CZ12312311 | Remove-HPEGLDeviceLocation -w

    Unassign the device with the serial number 'CZ12312311' from its physical location.

    .EXAMPLE
    'CW12312332', 'CW12312333' | Remove-HPEGLDeviceLocation 

    Unassign the devices with the serial numbers listed as a pipeline input from their physical location.

    .EXAMPLE
    Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString "Gen11" | Remove-HPEGLDeviceLocation

    Unassign all 'Gen11' server devices from their physical location.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -name CW12312334 | Remove-HPEGLDeviceLocation

    Unassign the Compute Ops Management server in the central european region with the serial number 'CW12312334' from its physical location.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice' or 'Get-HPECOMServer'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device to be unassigned from a physical location. 
        * Status - Status of the unassignment attempt (Failed for http error return; Complete if unassignment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('serial_number', 'serialnumber')]
        [String]$DeviceSerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()


    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }
    
        [void]$ObjectStatusList.Add($objStatus)


    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to remove the location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif (-not $device.location_name) {

                # Must return a message if device is not assigned to a location
                $Object.Status = "Warning"
                $Object.Details = "Device is not assigned to a location!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is not assigned to a location!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {         

                # Build DeviceList object
                
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                    location_id   = ""
                }

                
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{
                devices = $DevicesList

            } | ConvertTo-Json -Depth 5

                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully unassigned from device"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be unassigned from device!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more server locations failed to unassign successfully!"
                
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.SSDE"   
            Return $ObjectStatusList
        }


    }
}

#EndRegion


#Region --- REGION ---

Function Get-HPEGLRegion {
    <#
    .SYNOPSIS
    Retrieve HPE GreenLake regions.

    .DESCRIPTION
    This Cmdlet returns a collection of regions to assign to services.   

    .PARAMETER Name 
    Optional parameter that can be used to display all regions instances by name.

    .PARAMETER ShowProvisioned
    Optional parameter that can be used to display all provisioned regions instances associated with their service managers.

    .PARAMETER Code
    Optional parameter that can be used to display all regions instances by code.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLRegion

    Return all available regions.

    .EXAMPLE
    Get-HPEGLRegion -ShowProvisioned

    Return all provisioned regions associated with their service managers.

    .EXAMPLE
    Get-HPEGLRegion -Name "AP AusNZ" 

    Return the region named "AP AusNZ".

    .EXAMPLE
    Get-HPEGLRegion -Code "us-central " 

    Return the region whose code is "us-central".

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Provisioned')]
    Param( 
        
        [Parameter (ParameterSetName = 'Name')]
        [String]$Name,  
        
        [Switch]$ShowProvisioned,
        
        [Parameter (ParameterSetName = 'Code')]
        [String]$Code,     

        [Switch]$WhatIf

    ) 
    
    Begin {
    
        $Uri = $RegionsUri
  
    }

    Process {

        if ($ShowProvisioned) {

            try {
                
                Get-HPEGLService -ShowProvisioned
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
        }
        else {

            
            try {
                [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
                
            }
            catch {
                
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
            
            
            
            if ($Null -ne $Collection.regions) {
                
                $CollectionList = $Collection.regions 
                
                if ($Name) {
                    $CollectionList = $CollectionList | Where-Object name -eq $name
                    
                }
                
                if ($Code) {
                    $CollectionList = $CollectionList | Where-Object code -eq $code
                    
                }
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Region"         
                
                return $ReturnData 
                
            }
            else {
                
                return 
                
            }
        }
    }
}

#EndRegion


#Region --- SERVICE ---


Function Get-HPEGLService {
    <#
    .SYNOPSIS
    Retrieve the list of services and instances.

    .DESCRIPTION
    This Cmdlet returns a collection of services that are available for provisioning or that are already provisioned.    

    .PARAMETER Name 
    An optional parameter to display a service by name.

    .PARAMETER Region 
    An optional parameter to display a service instance in a region. You can use 'Get-HPEGLRegion' to see all available regions.

    .PARAMETER ShowProvisioned 
    An optional parameter to display the list of provisioned services.

    .PARAMETER ShowUnprovisioned 
    An optional parameter to display the list of available services that can be provisioned.

    .PARAMETER ShowAssignedDevices 
    An optional parameter to display the list of devices assigned to a particular service instance.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLService

    Returns all services, both those available for provisioning and those already provisioned.

    .EXAMPLE
    Get-HPEGLService -Name 'Compute Ops Management'

    Returns all Compute Ops Management service instances.

    .EXAMPLE
    Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned

    Returns all Compute Ops Management service instances that are provisioned. 

    .EXAMPLE
    Get-HPEGLService -Name 'Compute Ops Management' -Region EU

    Returns all Compute Ops Management service instances that are provisioned in Europe. 

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned 

    Returns all services available for provisioning in different regions.

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned -Region 'eu-central'

    Returns all services available for provisioning in the Central Europe region.
    

#>

    [CmdletBinding(DefaultParameterSetName = 'Provisioned')]
    Param( 
        [Parameter (ParameterSetName = 'Provisioned')]
        [Parameter (ParameterSetName = 'Available')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedDevices')]
        # [ValidateSet( 'Compute Ops Management', 'Data Services', 'Aruba Central', 'HPE GreenLake' )]
        [String]$Name,            
 
        [Parameter (ParameterSetName = 'Provisioned')]
        [Parameter (ParameterSetName = 'Available')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedDevices')]
        [String]$Region,
    
        [Parameter (ParameterSetName = 'Provisioned')]
        [Switch]$ShowProvisioned,

        [Parameter (ParameterSetName = 'Available')]
        [Switch]$ShowUnprovisioned,

        [Parameter (ParameterSetName = 'AssignedDevices')]
        [Switch]$ShowAssignedDevices,

        [Switch]$WhatIf

    ) 
    
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        $Uri = $ApplicationsProvisionsUri
  

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
        
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       
        
        if ($ShowAssignedDevices) {

            try {
                $AppRegionfound = Get-HPEGLService -Name $Name -Region $Region
            }
            catch {
       
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
          
            if ($AppRegionfound) {

                $ServiceInstanceId = $AppRegionfound.application_instance_id

                try {
                    [array]$Collection = Get-HPEGLdevice | Where-Object application_instance_id -eq $ServiceInstanceId
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Device"
                    $ReturnData = $ReturnData | Sort-Object serial_number, ccs_region
                    return $ReturnData 
                }
                catch {
           
                    $PSCmdlet.ThrowTerminatingError($_)
               
                }

            }
        }

        if ($Null -ne $Collection.applications) {
              
            $CollectionList = $Collection.applications 

            # Remove Company_name property as it is causing some issue with Get-HPEGLAuditLog when Get-HPEGLServie is used as a pipeline input. Company_name holds no important information but just "Hewlett Packard Enterprise"
            $CollectionList = $CollectionList | Select-Object -Property * -ExcludeProperty company_name

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Service"         
                         
            if ($Name -and -not $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.application_name -eq $name } | Sort-Object ccs_region

            }
            elseif ($Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.application_name -eq $name -and $_.ccs_region -eq $Region } | Sort-Object application_name

            }
            elseif (-not $Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.ccs_region -eq $Region } | Sort-Object application_name
                
            }
            else {
                $ReturnData = $ReturnData | Sort-Object application_name, ccs_region

            }     
      
            return $ReturnData 
  
        }
        elseif ($Null -ne $Collection.provisions) {

            $CollectionList = $Collection.provisions 

            # Remove Company_name property as it is causing some issue with Get-HPEGLAuditLog when Get-HPEGLServie is used as a pipeline input. Company_name holds no important information but just "Hewlett Packard Enterprise"
            $CollectionList = $CollectionList | Select-Object -Property * -ExcludeProperty company_name
            
            if ($ShowProvisioned) {
                
                $CollectionList = $CollectionList | Where-Object { $_.provision_status -eq "PROVISIONED" }
                        
            }


            if ($ShowUnprovisioned) {

                $CollectionList = $CollectionList | Where-Object { $_.provision_status -ne "PROVISIONED" }
                
            }
            
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Service"   


            if ($Name -and -not $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.name -eq $name } | Sort-Object region

            }
            elseif ($Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.name -eq $name -and $_.region -eq $Region } | Sort-Object name
                
            }
            elseif (-not $Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.region -eq $Region } | Sort-Object name
                
            }
            else {
                $ReturnData = $ReturnData | Sort-Object name, region
                
            }     
            
            

            return $ReturnData 
            


        }
        else {

            return 
            
        }
    }
}


Function Get-HPEGLServiceResourceRestrictionPolicyFilter {
    <#
    .SYNOPSIS
    Retrieve resource restriction policy filters.

    .DESCRIPTION
    This Cmdlet returns the resource restriction policy filters that are available in a service instance.    

    .PARAMETER ServiceName 
    Parameter to display resource restriction policy filter for a service name (can be retrieved using 'Get-HPEGLService').

    .PARAMETER ServiceRegion 
    Name of the region of the service (can be retrieved using Get-HPEGLService).

    .PARAMETER FilterName
    Name of a filter to display.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName 'Compute Ops Management' -ServiceRegion "eu-central"
  
    Returns all resource restriction policy filters for the Compute Ops Management service in the Central European region.

    .EXAMPLE
    Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName 'Compute Ops Management' -ServiceRegion "us-west" -FilterName RRP_ESXi_Houston
  
    Returns the 'RRP_ESXi_Houston' resource restriction policy filter for the 'Compute Ops Management' service in the US western region.
    
   #>
    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)]
        [String]$ServiceName,   
        
        [Parameter (Mandatory)]
        [String]$ServiceRegion,

        [String]$FilterName,

        [Switch]$WhatIf

    ) 
    
    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        try {

            $_Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName -Region $ServiceRegion
                     
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       
        
        if ($_Service) {

                  
            $ServiceID = $_Service.application_id

            $Uri = $ApplicationsScopeAssignmentsUri + "?application_id=" + $ServiceID + "&include_predefined_filters_and_scope_resource_instances=true"

            try {
                [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
              
            }
            catch {

                $PSCmdlet.ThrowTerminatingError($_)
   
            }
        }
       

        if ($Null -ne $Collection) {
           
            $Collection = $Collection | Where-Object region -eq $ServiceRegion

            # $Collection | Out-String | Write-Verbose

            $FilterList = @()
            
            if ($Collection.slug -eq "HPECC") {
               
                $ServiceInstanceId = $_Service.application_instance_id
                $ServiceCustomerId = $_Service.application_customer_id
                $Slug = $Collection.scope_resources.slug

                $Uri = $ApplicationInstancesUri + "/" + $ServiceInstanceId + "/scope_resource_instances?limit=200&offset=0&application_cid=" + $ServiceCustomerId + "&scope_resource=$slug"
            
                try {
                    [array]$FilterCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
              
                }
                catch {

                    $PSCmdlet.ThrowTerminatingError($_)
   
                }

                # $FilterCollection | Out-String | Write-Verbose

                foreach ($Filter in $FilterCollection.scope_resource_instances) {
                    
                    "[{0}] Filter '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $filter.name | Write-Verbose

                    $ReturnData = $FilterCollection | Select-Object  `
                    @{N = "filter_name"; E = { $Filter.name } }, `
                    @{N = "application_name"; E = { $ServiceName } }, `
                    @{N = "region"; E = { $Collection.region } }, `
                    @{N = "slug"; E = { $Filter.slug } }, `
                    @{N = "scope_type_name"; E = { $_.scope_resource_instances.name } }, `
                        # @{N = "description"; E = { $_.scope_resource_instances.description } }, `
                    @{N = "application_customer_id"; E = { $_.application_customer_id } }, `
                    @{N = "application_instance_id"; E = { $_.application_instance_id } }, `
                    @{N = "application_id"; E = { $_.application_id } }

                    $FilterList += $ReturnData | Sort-Object -Property filter_name
                }

            } 

            elseif ($Collection.scope_resources) {
               
                foreach ($Filter in $Collection.scope_resources) {
                    
                    "[{0}] Filter '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $filter.name | Write-Verbose

                    $ReturnData = $Collection | Select-Object  `
                    @{N = "filter_name"; E = { $Filter.name } }, `
                    @{N = "application_name"; E = { $ServiceName } }, `
                    @{N = "region"; E = { $_.region } }, `
                    @{N = "slug"; E = { $Filter.slug } }, `
                    @{N = "scope_type_name"; E = { $_.scope_resources.name } }, `
                        # @{N = "description"; E = { $_.scope_resources.description } }, `
                    @{N = "application_customer_id"; E = { $_.application_customer_id } }, `
                    @{N = "application_instance_id"; E = { $_.application_instance_id } }, `
                    @{N = "application_id"; E = { $_.application_id } }

                    $FilterList += $ReturnData | Sort-Object -Property filter_name
                }
            }
            elseif ($Collection.predefined_filters) {      
                    
                foreach ($Filter in $Collection.predefined_filters) {
                        
                    "[{0}] Predefined filter '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Filter.name | Write-Verbose

                    $ReturnData = $Collection | Select-Object  `
                    @{N = "filter_name"; E = { $Filter.name } }, `
                    @{N = "application_name"; E = { $ServiceName } }, `
                    @{N = "region"; E = { $_.region } }, `
                    @{N = "slug"; E = { $Filter.slug } }, `
                    @{N = "scope_type_name"; E = { $Filter.name } }, `
                        # @{N = "description"; E = { $Filter.description } }, `
                    @{N = "application_customer_id"; E = { $_.application_customer_id } }, `
                    @{N = "application_instance_id"; E = { $_.application_instance_id } }, `
                    @{N = "application_id"; E = { $_.application_id } }

                    $FilterList += $ReturnData | Sort-Object -Property filter_name
                }
            } 
      

            if ($FilterName) {
                $FilterList = $FilterList | Where-Object filter_name -eq $FilterName

            } 

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $FilterList -ObjectName "Service.Resource.Restriction.Policy.Filter"         
            $ReturnData = $ReturnData | sort-object filter_name, application_name, region

            return $ReturnData

        }     
       
        else {

            return 
            
        }
    }
}


Function New-HPEGLService {
    <#
    .SYNOPSIS
    Deploy a new service in a specified region.

    .DESCRIPTION
    This Cmdlet can be used to deploy a service in a new region within HPE GreenLake. By deploying a service, you enable its functionalities and resources in the selected region.
    
    If the service being deployed is a Compute Ops Management instance, the cmdlet automatically generates temporary API client credentials for the proper functioning of this library with COM.

    .PARAMETER Name 
    The name of the available service to deploy. This value can be retrieved from 'Get-HPEGLService -ShowUnprovisioned'.

    .PARAMETER Region 
    The name of the region where the service will be deployed. This value can be retrieved from 'Get-HPEGLService -ShowUnprovisioned'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    New-HPEGLService -Name "Compute Ops Management" -Region "eu-central"
    $HPEGreenLakeSession.username | Add-HPEGLRoleToUser -ComputeOpsManagementRole Administrator

    This example deploys the "Compute Ops Management" service in the "eu-central" region.
    It also assigns the Compute Ops Management administrator role to the currently connected user, as specified in the tracking object generated by Connect-HPEGL.

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned -Name "Aruba Central" -Region "us-west" | New-HPEGLService

    Retrieves the "Aruba Central" service available in the "us-west" region and deploys it.

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned -Name "Compute Ops Management" | New-HPEGLService

    Retrieves all unprovisioned instances of the "Compute Ops Management" service across all regions and deploys them in their respective regions.

    .INPUTS
    System.Collections.ArrayList
        A list of services obtained from 'Get-HPEGLService -ShowUnprovisioned'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the service attempted to be deployed.
        * Region - The name of the region where the service was deployed.
        * Status - The status of the deployment attempt (Failed for HTTP error return; Complete if deployment is successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.

    #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias('applicationname')]
        [String]$Name,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias('ccs_region')]
        [String]$Region,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $ApplicationProvisioningUri  
        $AddServiceStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
                                  
        }      


        try {

            $Appfound = Get-HPEGLService -Name $Name -Region $Region 

        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
    
        }
        
        if (-not $Appfound) {
            # Must return a message if Service is not found 
            "[{0}] Service '{1}' is not available in '{2}' region for provisioning!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}' is not available in '{1}' region for provisioning!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Service is not available in this region for provisioning!"
            }
        }
        elseif ($Appfound.provision_status -eq "PROVISIONED") {
            # Must return a message if Service is already provisioned 
            "[{0}] Service '{1}' is already provisioned in '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}': Resource is already provisioned in '{1}' region! No action needed." -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Service is already provisioned in this region! No action needed."
            }
        }
        else {
       
            $ServiceID = $Appfound.application_id


            # Build payload
            $payload = ConvertTo-Json @{
                region         = $Region
                application_id = $ServiceID 
                action         = "PROVISION"
                
            }
      

            # Deploy the service in a region. 
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | Out-Null

                if (-not $WhatIf) {

                    "[{0}] Service '{1}' successfully deployed in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Service successfully deployed in '$Region' region"
                        
                    do {
                        $provision_status = (Get-HPEGLService -Name $name -Region $Region ).provision_status
                        Start-Sleep 2
                    } until ($provision_status -eq "PROVISIONED")
                       
                    if ($Name -eq "Compute Ops Management") {
                            
                        # Add region to the global variable for the argument completer for the Region parameter of *HPECOM* cmdlets
                        # [void]$Global:HPECOMAPICredentialRegions.add($region)

                        # "[{0}] Added '{1}' region to the global variable `$HPECOMAPICredentialRegions used for the argument completer for the Region parameter of *HPECOM* cmdlets." -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

                        #Region- Generate new COM API client credential using template $APIClientCredentialTemplateName in $region
                  
                        "[{0}] ------- Create '{1}' temporary COM API client credential for '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                        # Save access token into $HPEGreenLakesession.comApiAccessToken
                        # It will save client_id / client_secret into $HPEGreenLakesession.apiCredentials.COM-<region>-PowerShell_Library_Temporary_Credential
                            
                        $COMAPICreationTask = New-HPEGLAPIcredential -ServiceName $Name -Region $Region -TemplateName $APIClientCredentialTemplateName -ErrorAction SilentlyContinue #| out-Null
                                                                                
                        if ($COMAPICreationTask.status -eq "Failed") {
                            "API Credential '{0}' cannot be created ! '{1}'" -f ($COMAPICreationTask.Name.substring(0, ($COMAPICreationTask.Name.length - ($APIClientCredentialTemplateName.Length + 1))))  , $COMAPICreationTask.Exception | Write-Error
                        }
                        else {
                            
                            "[{0}] ------- Create session with to capture access token " -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            # Create session with the API and capture new access tokens
                            $TemportaryCredential = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.region -match $Region }

                            "[{0}] Credential found: `n{1} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $TemportaryCredential | Write-Verbose
            

                            $SecureClientSecret = $TemportaryCredential.secure_client_secret | ConvertTo-SecureString
                            $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
                            $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr) 

                            $Payload = @{
                                'client_id'     = $TemportaryCredential.client_id
                                'client_secret' = $ClientSecret
                                'grant_type'    = 'client_credentials'
                            }
            
                            "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
                            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | convertto-json) | Write-Verbose
    
                            try {
    
                                $response = Invoke-RestMethod -Method Post -Uri $HPEGLtokenEndpoint -Body $Payload -ContentType 'application/x-www-form-urlencoded' 
            
                                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
    
                                $comApiAccessToken = [PSCustomObject]@{
                                    name          = $TemportaryCredential.name
                                    access_token  = $response.access_token 
                                    expires_in    = $response.expires_in
                                    creation_time = (Get-Date)
                                }
                            
                                [void]$global:HPEGreenLakeSession.comApiAccessToken.add($comApiAccessToken)
                                "[{0}] COM API access token has been set in `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            }
                            catch {
    
                                "[{0}] Create API session payload content: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Payload | Out-String) | Write-Verbose
    
                                if ($_.ErrorDetails.Message) {
                                    Write-Warning $_.ErrorDetails
                                }
    
                                $PSCmdlet.ThrowTerminatingError($_).Exception.Message
    
                            }
                        }
                        #endregion
                    }  
                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service cannot be deployed!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
       
        

        [void] $AddServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($AddServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more services failed the deployment attempt!"
          
            }

            $AddServiceStatus = Invoke-RepackageObjectWithType -RawObject $AddServiceStatus -ObjectName "ObjStatus.NSDE" 
            Return $AddServiceStatus
        }


    }
}


Function Remove-HPEGLService {
    <#
    .SYNOPSIS
    Remove a service from a specified region.

    .DESCRIPTION
    This Cmdlet can be used to remove a service from a region. This action is irreversible and cannot be canceled or undone once the process has begun. All users will lose access, and it will permanently delete all device and user data.

    The cmdlet issues a message at runtime to warn the user of the irreversible impact of this action and asks for a confirmation for the removal of the service.
    
    If the user confirms the action, the service is deleted. If the user cancels the action, the service is not deleted.
    
    .PARAMETER Name 
    The name of the available service to remove. This value can be retrieved from 'Get-HPEGLService -ShowProvisioned'.
        
    .PARAMETER Region 
    The name of the region where the service is removed. This value can be retrieved from 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER Force
    Forces the removal of the service without asking for confirmation. This option is useful for automation scripts that require the removal of services without user interaction.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLService -Name "Aruba Central" -Region "eu-central"

    Removes the "Aruba Central" service from the "eu-central" region after the user has confirmed the removal.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned -Name "Compute Ops Management" -Region "us-west" | Remove-HPEGLService

    Retrieves the provisioned "Compute Ops Management" service in the "us-west" region and removes it. A warning message appears and asks the user to confirm the action.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned -Name "Compute Ops Management" | Remove-HPEGLService

    Retrieves all provisioned instances of the "Compute Ops Management" service across all regions and removes them, pending user confirmation.

    .INPUTS
    System.Collections.ArrayList
        A list of services obtained from 'Get-HPEGLService -ShowProvisioned'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the service attempted to be removed.
        * Region - The name of the region where the service was removed.
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if removal is successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.


    #>


    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [Alias('applicationname')]
        [String]$Name,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [Alias('ccs_region')]
        [String]$Region,

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveServiceStatus = [System.Collections.ArrayList]::new()


    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $AppRegionfound = Get-HPEGLService -Name $name -Region $Region
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
    
        }
       
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
                                      
        }  
       
       
        if (-not $AppRegionfound) {
            # Must return a message if Serviceis not found in the region
            "[{0}] Service '{1}' not available in '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}': Resource cannot be found in the workspace!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Service not available in the region!"
            }



        }
        elseif (-not $AppRegionfound.provision_status) {
            # Must return a message if Service is not provisioned 
            "[{0}] Service '{1}' is not provisioned!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}': Resource is not provisioned in any region!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Service is not provisioned in any region!"
            }

        }
        else {       
           
            if (-not $Force) {

                $title = "All users will lose access and this will permanently delete all device and user data. Confirm that you would like to remove '{0}' from '{1}'." -f $name, $Region
                $question = 'This action is irreversible and cannot be canceled or undone once the process has begun. Are you sure you want to proceed?'
                $choices = '&Yes', '&No'
    
                $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
    
                if ($decision -eq 0) {
    
                    $ServiceID = $AppRegionfound.application_customer_id
    
                    $Uri = $ApplicationProvisioningUri + "/" + $ServiceID
        
                    # Build payload
                    $payload = ConvertTo-Json @{
                        action = "UNPROVISION"
                        
                    }
              
        
                    # Remove Service from a region. 
                    try {
    
                        Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | Out-Null
    
                        if (-not $WhatIf) {
        
                            "[{0}] '{1}' service successfully removed from '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
    
                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Service successfully removed from '$Region' region"
    
                            if ($name -eq "Compute Ops Management") {
                                
                                "[{0}] ------------------------------------- Remove COM API client credential objects from global variables -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                                
                                # Remove COM API client credential for $region (no longer required)
                                # When a service is removed, associated API credentials are automatically removed from the workspace.
                                # Adding a short sleep to allow the API credentials to be removed before attempting to remove them manually.
                                # Start-Sleep -Seconds 3
                                # $COMinstanceAPIcredential = Get-HPEGLAPICredential | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.name -match $Region }

                                # if ($COMinstanceAPIcredential) {

                                #     "[{0}]  COM API client credential found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $COMinstanceAPIcredential.name | Write-Verbose
                                #     Remove-HPEGLAPICredential -Name $COMinstanceAPIcredential.name -Force | Out-Null

                                # }
                                # else {

                                #     "[{0}] No COM API client credential found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $COMinstanceAPIcredential.name | Write-Verbose
                                # }

                                

                                # 1- Remove region object from $HPECOMAPICredentialRegions (used for the argument completer for the -Region parameter of *HPECOM* cmdlets)

                                "[{0}] ------- Deleting COM '{1}' region from `$HPECOMAPICredentialRegions" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                               
                                [void]$Global:HPECOMAPICredentialRegions.remove($region)
                                "[{0}] COM '{1}' region has been removed from `$HPECOMAPICredentialRegions global variable" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                                
                                

                                # 2- Remove API credential object from $HPEGreenLakesession.apiCredentials
                                
                                "[{0}] ------- Deleting '{1}' temporary API client credential for region '{2}' in `$HPEGreenLakeSession.apiCredentials" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                                
                                $comApiCredential = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.region -match $Region }                          
                                "[{0}] COM API credential found for '{1}' in `$HPEGreenLakeSession.apiCredentials: `n{2} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, $comApiCredential | Write-Verbose
                                [void]$global:HPEGreenLakeSession.apiCredentials.remove($comApiCredential)
                                "[{0}] COM API credential has been removed from `$HPEGreenLakeSession.apiCredentials` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose



                                # 3- Remove access token object from $HPEGreenLakesession.comApiAccessToken

                                "[{0}] ------- Deleting '{1}' temporary API client credential for region '{2}' in `$HPEGreenLakeSession.comApiAccessToken" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

                                $comApiAccessToken = $HPEGreenLakeSession.comApiAccessToken | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.name -match $Region }
                                "[{0}] COM access token found for '{1}' in `$HPEGreenLakeSession.comApiAccessToken: `n{2} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, $comApiAccessToken | Write-Verbose
                                [void]$global:HPEGreenLakeSession.comApiAccessToken.remove($comApiAccessToken)
                                "[{0}] COM API access token has been removed from `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                            }
                            
                        }  
                    }
                    catch {
    
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Service cannot be removed!"
                            $objStatus.Exception = $_.Exception.message 
                        }
                    }                          
              
                }
                else {
    
                    "[{0}] User cancelled the deletion of the service instance '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
    
                    if ($WhatIf) {
                        $ErrorMessage = "Operation cancelled by the user!"
                        Write-warning $ErrorMessage
                        return
                    }
                    else {    
                        $objStatus.Status = "Warning"
                        $objStatus.Details = "Operation cancelled by the user! Service instance not deleted!"
                    }
                }

            }
            else {

                $ServiceID = $AppRegionfound.application_customer_id
    
                $Uri = $ApplicationProvisioningUri + "/" + $ServiceID
    
                # Build payload
                $payload = ConvertTo-Json @{
                    action = "UNPROVISION"
                    
                }
          
    
                # Remove Service from a region. 
                try {

                    Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | Out-Null

                    if (-not $WhatIf) {
    
                        "[{0}] Service successfully removed from '{1}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Service successfully removed from '$Region' region"

                        if ($name -eq "Compute Ops Management") {

                            "[{0}] ------------------------------------- Remove COM API client credential objects from global variables -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                                
                            # Remove COM API client credential for $region (no longer required)
                            # When a service is removed, associated API credentials are automatically removed from the workspace.
                            # Adding a short sleep to allow the API credentials to be removed before attempting to remove them manually.
                            # Start-Sleep -Seconds 3
                            # $COMinstanceAPIcredential = Get-HPEGLAPICredential | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.name -match $Region }

                            # if ($COMinstanceAPIcredential) {

                            #     "[{0}]  COM API client credential found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $COMinstanceAPIcredential.name | Write-Verbose
                            #     Remove-HPEGLAPICredential -Name $COMinstanceAPIcredential.name -Force | Out-Null

                            # }
                            # else {

                            #     "[{0}] No COM API client credential found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $COMinstanceAPIcredential.name | Write-Verbose
                            # }

                            

                            # 1- Remove region object from $HPECOMAPICredentialRegions (used for the argument completer for the -Region parameter of *HPECOM* cmdlets)

                            "[{0}] ------- Deleting COM '{1}' region from `$HPECOMAPICredentialRegions" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                           
                            [void]$Global:HPECOMAPICredentialRegions.remove($region)
                            "[{0}] COM '{1}' region has been removed from `$HPECOMAPICredentialRegions global variable" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                            
                            

                            # 2- Remove API credential object from $HPEGreenLakesession.apiCredentials
                            
                            "[{0}] ------- Deleting '{1}' temporary API client credential for region '{2}' in `$HPEGreenLakeSession.apiCredentials" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                            
                            $comApiCredential = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.region -match $Region }                          
                            "[{0}] COM API credential found for '{1}' in `$HPEGreenLakeSession.apiCredentials: `n{2} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, $comApiCredential | Write-Verbose
                            [void]$global:HPEGreenLakeSession.apiCredentials.remove($comApiCredential)
                            "[{0}] COM API credential has been removed from `$HPEGreenLakeSession.apiCredentials` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose



                            # 3- Remove access token object from $HPEGreenLakesession.comApiAccessToken

                            "[{0}] ------- Deleting '{1}' temporary API client credential for region '{2}' in `$HPEGreenLakeSession.comApiAccessToken" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

                            $comApiAccessToken = $HPEGreenLakeSession.comApiAccessToken | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.name -match $Region }
                            "[{0}] COM access token found for '{1}' in `$HPEGreenLakeSession.comApiAccessToken: `n{2} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, $comApiAccessToken | Write-Verbose
                            [void]$global:HPEGreenLakeSession.comApiAccessToken.remove($comApiAccessToken)
                            "[{0}] COM API access token has been removed from `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        }
                        
                    }  
                }
                catch {

                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Service cannot be removed!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }   
            }
        }

        [void] $RemoveServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more services has failed!"

          
            }
            $RemoveServiceStatus = Invoke-RepackageObjectWithType -RawObject $RemoveServiceStatus -ObjectName "ObjStatus.NSDE" 
            Return $RemoveServiceStatus
            
        }


    }
}


Function Add-HPEGLDeviceToService {
    <#
    .SYNOPSIS
    Assign device(s) to an HPE GreenLake service instance.

    .DESCRIPTION
    This Cmdlet assigns device(s) to an HPE GreenLake service instance.

    .PARAMETER DeviceSerialNumber 
    Specifies the serial number of the device to assign to a service instance. This value can be retrieved using 'Get-HPEGLDevice -ShowRequireAssignment'.

    .PARAMETER ServiceName 
    Specifies the name of the available service to which the device will be assigned. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER ServiceRegion 
    Specifies the region of the service instance. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option helps in understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceToService -DeviceSerialNumber "1234567890" -ServiceName "Compute Ops Management" -Region "US-West"

    Assigns the device with the serial number '1234567890' to the "Compute Ops Management" service in the western US region.

    .EXAMPLE
    'MXQ72407P3', 'MXQ73200W1' | Add-HPEGLDeviceToService -ServiceName "Aruba Central" -Region "eu-central"

    Assigns devices with serial numbers 'MXQ72407P3' and 'MXQ73200W1' to the "Aruba Central" service in the "eu-central" region.

    .EXAMPLE
    Get-HPEGLDevice -ShowRequireAssignment | Add-HPEGLDeviceToService -ServiceName "Compute Ops Management" -Region "US-West"

    Assigns all devices that require service assignment to the "Compute Ops Management" service in the western US region.

    .EXAMPLE
    Add-Content -Path Tests\SerialNumbers.csv -Value '"Serialnumber"'
    $Serialnumbers = @('7CE244P9LM' , 'MXQ73200W1')
    $Serialnumbers | foreach { Add-Content -Path Tests\SerialNumbers.csv -Value $_ }

    Import-Csv Tests\SerialNumbers.csv | Add-HPEGLDeviceToService -ServiceName "Compute Ops Management" -Region "US-West"

    Assigns the devices listed in a CSV file to a service instance.

    .INPUTS
    System.Collections.ArrayList
        A list of devices from 'Get-HPEGLDevice -ShowRequireAssignment'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers.

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device assigned to a service instance. 
        * Status - Status of the assignment attempt (Failed for HTTP error return; Complete if assignment is successful; Warning if no action is needed).
        * Details - More information about the status. 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('serialnumber', 'serial_number')]
        [String]$DeviceSerialNumber,

        [Parameter (Mandatory)]
        [String]$ServiceName,

        [Parameter (Mandatory)]
        [String]$ServiceRegion,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $Uri = $DevicesApplicationInstanceUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

        try {
            
            $Servicefound = Get-HPEGLService -Name $ServiceName -Region $ServiceRegion -ShowProvisioned

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }

        if ( -not $Servicefound) {
                    
            $ErrorMessage = "Service '{0}' is not provisioned in the '{1}' region!" -f $ServiceName, $ServiceRegion
            throw $ErrorMessage
        }


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }
    

        [void]$ObjectStatusList.Add($objStatus)


    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( $device.application_id) {

                # Must return a message if device is already assigned to location and removed from the list of devices to be set
                $Object.Status = "Warning"
                $Object.Details = "Device already assigned to a service instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is already assigned to a service instance!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       
            
                # Build DeviceList object
                if ($device | Where-Object device_model -match "Gen11" ) {

                    $DeviceList = [PSCustomObject]@{
                        serial_number = $Device.serial_number
                        part_number   = $Device.part_number 
                        mac_address   = $Device.mac_address
                        device_type   = $Device.device_type
                    }
                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        serial_number = $Device.serial_number
                        part_number   = $Device.part_number 
                        device_type   = $Device.device_type
                    }
                }
            
               
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{ assign_list = @(
                    @{  devices                 = $DevicesList
                        application_id          = $Servicefound.application_id
                        application_instance_id = $Servicefound.application_instance_id
                    })
            } | ConvertTo-Json -Depth 5
                
                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Device successfully assigned to the service instance!"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Device cannot be assigned to the service instance!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the service assignment attempt!"
               
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.SSDE"  
            Return $ObjectStatusList
        }


    }
}


Function Remove-HPEGLDeviceFromService {
    <#
    .SYNOPSIS
    Unassign device(s) from a service instance. 

    .DESCRIPTION
    This Cmdlet unassigns device(s) from an HPE GreenLake service instance.    
        
    .PARAMETER DeviceSerialNumber 
    Serial number of the device to be unassigned from a service instance. 
    This value can be retrieved from 'Get-HPEGLDevice'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLDeviceFromService -DeviceSerialNumber MXQ73200W1

    Unassigns the specified device from its service instance.

    .EXAMPLE
    Get-HPEGLDevice -Location "Mougins"  | Remove-HPEGLDeviceFromService 

    Unassigns all devices in the 'Mougins' location from their respective service instances.

    .EXAMPLE
    'MXQ72407P3', 'MXQ73200W1'  | Remove-HPEGLDeviceFromService

    Unassigns devices with serial numbers 'MXQ72407P3' and 'MXQ73200W1' from their respective service instances.

    .INPUTS
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device to be unassigned from a service instance. 
        * Status - Status of the unassignment attempt (Failed for http error return; Complete if unassignment is successful) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   
   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('SerialNumber', 'serial_number')]
        [String]$DeviceSerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesApplicationInstanceUri  
        # $UnassignmentDevicesStatus = [System.Collections.ArrayList]::new()
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                      
        }
   

        [void] $ObjectStatusList.add($objStatus)
        
    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $device.application_id) {

                # Must return a message if device is already assigned to location and removed from the list of devices to be set
                $Object.Status = "Warning"
                $Object.Details = "Device not assigned to a service instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource not assigned to a service instance!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       
            
                # Build DeviceList object

                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                }
            
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{
                devices = $DevicesList
            } | ConvertTo-Json -Depth 5
   
                
                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Device successfully unassigned from the service instance!"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Device cannot be unassigned from the service instance!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more devices from the service assignment has failed!"
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.SSDE"  
            Return $ObjectStatusList
        }


    }
}


Function Get-HPEGLAPIcredential {
    <#
    .SYNOPSIS
    Retrieve API credentials for an HPE GreenLake service instance.

    .DESCRIPTION
    This Cmdlet returns a collection of API credential resources for an HPE GreenLake (GLP) service instance.

    .PARAMETER Name
    Specifies the name of the API client credential to retrieve.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. 
    This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLAPICredential

    Returns the API credentials for all service instances.

    .EXAMPLE
    Get-HPEGLAPICredential -Name "Grafana-COM-AP_NorthEast"

    Returns the API credential for the service instance named "Grafana-COM-AP_NorthEast".
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [String]$Name,  

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $Uri = $ApplicationsAPICredentialsUri
        
        $Services = Get-HPEGLService -ShowProvisioned

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        $ReturnData = @()

        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf

        }  
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($Null -ne $Collection ) {

            If ($Name) {

                $CollectionList = $Collection | Where-Object credential_name -eq $Name
            }
            else {

                $CollectionList = $Collection 
            }

            foreach ($item in $CollectionList) {
                
                if ($item.application_instance_id -eq "00000000-0000-0000-0000-000000000000" ) {
                    
                    $ServiceName = "HPE GreenLake"
                    $ServiceRegion = "N/A"
                    $ConnectivityEndPoint = "https://global.api.greenlake.hpe.com"
                    
                }
                else {
               
                    $Service = $Services | Where-Object application_instance_id -eq $item.application_instance_id
                    $ServiceName = $Service | ForEach-Object name
                    $ServiceRegion = $Service | ForEach-Object region

                    if ($Service.name -eq "Data Services") {
                        $ConnectivityEndPoint = "https://sso.common.cloud.hpe.com/as/token.oauth2"
    
                    }
                    else {
                        
                        $ConnectivityEndPoint = $item.app_nbapi_endpoint
                    }

                }

                $ReturnData += $item | Select-Object  `
                @{N = "name"; E = { $item.credential_name } }, `
                @{N = "application_name"; E = { $ServiceName } }, `
                @{N = "region"; E = { $ServiceRegion } }, `
                @{N = "application_instance_id"; E = { $item.application_instance_id } }, `
                @{N = "client_id"; E = { $item.client_id } }, `
                @{N = "connectivity_endpoint"; E = { $ConnectivityEndPoint } }

            }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "Service.API.Credential"         

            $ReturnData = $ReturnData | Sort-Object { $_.name }
            
            return $ReturnData 
    
        }
        else {
            return
        }
    }
}


Function New-HPEGLAPIcredential {
    <#
    .SYNOPSIS
    Creates personal API clients for a service instance.

    .DESCRIPTION
    This Cmdlet generates personal API clients for HPE GreenLake or an HPE GreenLake service instance.

    Personal API clients allow you to programmatically generate access tokens for accessing HPE GreenLake APIs using your own identity and roles. 
    
    You can maintain a maximum of 7 personal API clients.

    The prerequisite for generating an API access token is that the service instance must be provisioned/added to the user's workspace. 
    The user must have the necessary role to perform the intended operation in the service instance.

    .PARAMETER TemplateName
    Template name of the API client credential to create. This parameter automatically generates the name of the API client credential based on the template name, service name, and region.
    Format: <ServiceName>-<ServiceRegion>-<TemplateName>
    <ServiceName> can be either `COM`, `DS`, or the service name without spaces.
    Examples: "DS-US_West-Grafana", "COM-EU_Central-Ansible", "Aruba_Central-AP_Central-Terraform"

    For HPE GreenLake API client credentials:
    Format: GLP-<TemplateName>
    Examples: "GLP-Grafana", "GLP-Ansible"

    .PARAMETER ServiceName
    Name of the provisioned service accessible using the API credentials. Retrieve this value from `Get-HPEGLService -ShowProvisioned`.

    .PARAMETER Region
    Region of the service accessible using the API credentials. Retrieve this value from `Get-HPEGLService -ShowProvisioned`.

    .PARAMETER HPEGreenLake
    Switch parameter to generate API client credentials for the HPE GreenLake service.

    .PARAMETER Location
    Directory to export the API credentials to. The exported credentials include all necessary details for executing subsequent API requests.
    Exported filename format: "<Auto-generated API Credential name>_API_Credential.json".
    This parameter is optional. Note that generated API credentials are always stored during a session in `${Global:HPEGreenLakeSession.apiCredentials}`.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    New-HPEGLAPIcredential -ServiceName "Compute Ops Management" -Region "eu-central" -TemplateName POSH_Lib

    Generates a new 'COM-eu-central-POSH_Lib' API client credential for the 'Compute Ops Management' service instance in the Central Europe region.
    Adds an object containing the client_id, secure_client_secret, and connectivity_endpoint to the `${Global:HPEGreenLakeSession.apiCredentials}` variable, accessible as long as the PowerShell console is active and 'Disconnect-HPEGL' has not been executed.

    .EXAMPLE
    Get-HPEGLService -Name 'Data Services' -Region "EU-Central" | New-HPEGLAPIcredential -TemplateName Grafana -Location .

    Generates the 'DS-EU_Central-Grafana' API client credential for the 'Data Services' service instance in the Central Europe region.
    Exports the API credentials, including the client ID and secret, to a JSON file named 'DS-EU_Central-Grafana_API_Credentials.json' in the local folder.
    
    To read the encrypted API credential file contents later:
        $SecureClientSecret = (Get-Content .\DS-EU_Central-Grafana_API_Credentials.json | ConvertFrom-Json).secure_client_secret | ConvertTo-SecureString
        $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
        $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)

    Note: Decryption is only supported on the same machine where the cmdlet was executed.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned -Name 'Compute Ops Management' | New-HPEGLAPIcredential -TemplateName Grafana -Location c:\MyCredentials

    Generates API client credentials for all provisioned instances of 'Compute Ops Management'. Credential names are auto-generated from the TemplateName property, such as "COM-AP_NorthEast-Grafana" for 'Compute Ops Management AP NorthEast', and "COM-EU_Central-Grafana" for 'Compute Ops Management EU Central'.
    API credentials for each instance are exported to the c:\MyCredentials folder. Exported filenames format: 'COM-<Region_Name>-Grafana_API_Credentials.json'.

    .EXAMPLE
    # Step 1: Fetch the service details for 'Data Services' in the 'eu-west' region that is provisioned and pass that in the pipeline to create a new API client credential.
    $response = Get-HPEGLService -Name 'Data Services' -Region "eu-west" -ShowProvisioned | New-HPEGLAPIcredential -TemplateName Grafana 

    # Step 2: Extract the API credentials generated by 'New-HPEGLAPIcredential' in $HPEGreenLakeSession matching the response name and current workspace ID.
    $Grafana_DS_EU_Central_Credentials = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -eq $response.Name -and $_.workspace_id -eq $HPEGreenLakeSession.workspaceId }

    # Step 3: Convert the secure client secret from encrypted format to a SecureString object.
    $SecureClientSecret = $Grafana_DS_EU_Central_Credentials.secure_client_secret | ConvertTo-SecureString

    # Step 4: Marshal the SecureString to a BSTR (binary string).
    $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)

    # Step 5: Convert the BSTR to a plain text string.
    $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)

    # Step 6: Use the stored API credentials to connect to HPE Data Services (formerly known as Data Storage Cloud Services).
    Connect-DSCC -Client_Id $Grafana_DS_EU_Central_Credentials.client_id -Client_Secret $ClientSecret -GreenlakeType EU -AutoRenew -WhatIfToken

    # Explanation:
    # This script demonstrates how to pass the stored API credentials from the `$HPEGreenLakeSession` global variable to `Connect-DSCC`, which initiates a connection to HPE Data Services. 
    # The `$HPEGreenLakeSession` global variable remains accessible as long as the PowerShell console is active and 'Disconnect-HPEGL' has not been run.

    .INPUTS
    System.Collections.ArrayList
        List of service instance(s) from `Get-HPEGLService -ShowProvisioned`.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects with the following keys:
            * Name - name of the attempted API credential
            * Filename - name of the exported file
            * Location - path of the exported file
            * Encrypted - encryption status Boolean
            * Status - creation status (Failed for HTTP errors; Complete if successful; Warning if no action needed)
            * Details - additional status information
            * Exception - information about any exceptions during the operation

    HPEGreenLakeSession.apiCredentials
        When successful, an object is added to `${Global:HPEGreenLakeSession.apiCredentials}` with the following properties:
            ==================================================================================================
            | Name                      | Type               | Value                                         |
            |------------------------------------------------------------------------------------------------
            | name                      | String             | Name of the generated API client credential   |
            -------------------------------------------------------------------------------------------------
            | workspace_name            | String             | Name of the workspace                         |
            -------------------------------------------------------------------------------------------------
            | workspace_id              | String             | ID of the workspace                           |
            -------------------------------------------------------------------------------------------------
            | application_name          | String             | Name of the provisioned service               |
            -------------------------------------------------------------------------------------------------
            | region                    | String             | Name of the service region                    |
            -------------------------------------------------------------------------------------------------
            | application_instance_id   | String             | ID of the provisioned service instance        |
            -------------------------------------------------------------------------------------------------
            | secure_client_secret      | Secure String      | API Client Secret in a secure string format   |
            -------------------------------------------------------------------------------------------------
            | client_id                 | String             | API Client ID                                 |
            -------------------------------------------------------------------------------------------------
            | connectivity_endpoint     | String             | API connectivity endpoint                     |
            ==================================================================================================
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "GLP")]
        [String]$TemplateName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [Alias('name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ParameterSetName = "GLP")]
        [Switch]$HPEGreenLake,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [Alias('ccs_region')]
        [String]$Region,

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "GLP")]
        [Alias ("x", "export", 'exportFile')]
        [ValidateScript({ Test-Path $_ })]
        [String]$Location,


        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $ApplicationsAPICredentialsUri  
        $NewAPICredentialStatus = [System.Collections.ArrayList]::new()
        
        try {
            
            "[{0}] ------ About to run: Get-HPEGLService -ShowProvisioned" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            $Services = Get-HPEGLService -ShowProvisioned 
    
            "[{0}] ------ About to run: Get-HPEGLAPICredential" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            $Credentials = Get-HPEGLAPICredential
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        [int]$Numberofcredentials = $Credentials.count
               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Null
            Filename  = $Null
            Location  = $Null     
            Encrypted = $Null                       
            Status    = $Null
            Details   = $Null
            Exception = $Null
                      
        }

        if ($HPEGreenLake) {

            $ServiceName = "GLP"
            $ServiceInstanceId = "00000000-0000-0000-0000-000000000000"

            $CredentialName = $ServiceName + "-" + $TemplateName
    
            "[{0}] Credential name that will be generated: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose
            $objStatus.Name = $CredentialName 

            $Region = "N/A"
        }
        else {

            # "------ About to run: Get-HPEGLService -ShowProvisioned -Name '{0}' -Region '{1}'" -f $ServiceName, $Region | Write-Verbose
            # $service = Get-HPEGLService -ShowProvisioned -Name $ServiceName -Region $Region
            
            $service = $services | Where-Object { $_.name -eq $ServiceName -and $_.region -eq $Region }
            $ServiceInstanceId = $service.application_instance_id

            if (-not $service) {
                # Must return a message if resource not found
                "[{0}] Service '{1}' not found or not provisioned! API credential cannot be created!" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServiceName + " - " + $Region) | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Service '{0}' cannot be found or is not provisioned in '{1}' region!" -f $ServiceName, $Region
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service cannot be found in the HPE GreenLake workspace!"
                }
              
            }
            else {
            
                if ($ServiceName -eq "Compute Ops Management") {
                    $ServiceName = "COM"
                }  
                elseif ($ServiceName -eq "Data Services") {
                    $ServiceName = "DS"
                }
                else {
                    $ServiceName = $ServiceName.replace(" ", "_")
                }
           
                $CredentialName = $ServiceName + "-" + $service.region + "-" + $TemplateName
                "[{0}] Credential name that wil be generated: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose
    
                $objStatus.Name = $CredentialName 

            } 
        }      

        # Check if credential already exists or if more than 7 credentials

        # "------ About to run: Get-HPEGLAPICredential -Name '{0}'" -f $CredentialName | Write-Verbose
        # $Credentials = Get-HPEGLAPICredential
        $Credentialfound = $Credentials | Where-Object name -eq $CredentialName
            
        if ( $Credentialfound) {

            "[{0}] API credential name '{1}' already exists in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose

            # Must return a message if resource found

            if ($WhatIf) {
                $ErrorMessage = "API credential '{0}': Resource already exists in the workspace! No action needed." -f $CredentialName
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "API credential already exists in the workspace! No action needed."
            }
            
        }
        elseif ($Numberofcredentials -ge 7) {

            "[{0}] API credential '{1}' cannot be created because you have reached the maximum of 7 personal API clients" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "API credential '{0}': Resource cannot be created because you have reached the maximum of 7 personal API clients" -f $CredentialName
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "API credential cannot be created!"
                $objStatus.Exception = "You have reached the maximum of 7 personal API clients!"
            }


        }
        else {

            $Payload = [PSCustomObject]@{
                credential_name         = $CredentialName
                application_instance_id = $ServiceInstanceId 
            } | ConvertTo-Json -Depth 5
   
            # Create API Credential  
            try {

                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -WhatIfBoolean $WhatIf
                
                Start-Sleep 1
                
                if (-not $WhatIf) {

                    if ($Region -eq "N/A") {
                        "[{0}] API credential '{1}' successfully created for '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName, $ServiceName | Write-Verbose

                    }
                    else {
                        "[{0}] API credential '{1}' successfully created for '{2}' in '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName, $ServiceName, $Region | Write-Verbose
                    }
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "API Credential successfully created"
                    $Numberofcredentials += 1
                    "[{0}] Number of credentials: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofcredentials | Write-Verbose
            
                    # Save Service token 
                    # $Clientsecret = $Response.client_secret

                    $secClientSecret = ConvertTo-SecureString -String $Response.client_secret -AsPlainText -Force | ConvertFrom-SecureString  

                    $ClientID = $Response.client_id
    
                    # $ConnectivityEndpoint = (Get-HPEGLAPICredential -Name $CredentialName).connectivity_endpoint
                
                
                    $ServiceAPICredential = [PSCustomObject]@{
                        name                    = $CredentialName 
                        workspace_name          = $HPEGreenLakeSession.workspace
                        workspace_id            = $HPEGreenLakeSession.workspaceId
                        application_name        = $ServiceName
                        region                  = $Region
                        application_instance_id = $ServiceInstanceId
                        secure_client_secret    = $secClientSecret 
                        client_id               = $ClientID
                        connectivity_endpoint   = $Null
                        # connectivity_endpoint   = $ConnectivityEndpoint
                    }
    
                    "[{0}] API credential to add to `$HPEGreenLakeSession.apiCredentials global variable: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServiceAPICredential | ConvertTo-Json -d 10) | Write-Verbose                   
                                   
                    [void]$global:HPEGreenLakeSession.apiCredentials.Add($ServiceAPICredential)
                    "[{0}] `$HPEGreenLakeSession.apiCredentials global variable set with new content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose   
                    
                    # If the template name equal the template name set for the library temporary API credential, then set the region in $HPECOMAPICredentialRegions global variable 
                    # This variable is used for the argument completer for the Region parameter of *HPECOM* cmdlets

                    if ($TemplateName -eq $APIClientCredentialTemplateName -and $ServiceAPICredential.application_name -ne "GLP") {

                        [void]$Global:HPECOMAPICredentialRegions.Add($ServiceAPICredential.region)       
                        
                        "[{0}] Added '{1}' region to the global variable `$HPECOMAPICredentialRegions used for the argument completer for the Region parameter of *HPECOM* cmdlets." -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $ServiceAPICredential.region | Write-Verbose

                    }
                
                    if ($Location) {
                    
                        if ([System.IO.Path]::IsPathRooted($Location)) {

                            $objStatus.Location = $Location

                        }
                        else {
                            $objStatus.Location = (Resolve-Path $Location).Path

                        }

                        $_filename = "{0}_API_Credentials.json" -f $CredentialName

                        $objStatus.Filename = $_filename
    
                        $ServiceAPICredentialJson = $ServiceAPICredential | convertto-json -depth 99                 
                        
                        $ServiceAPICredentialJson | Out-File ($Location + '\' + $_filename)
                        "[{0}] API Client credential file '{1}' successfully created in '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_filename, ((get-Item ($Location + '\' + $_filename)).DirectoryName) | Write-Verbose
                        $objStatus.Encrypted = $False
                        
                    }
                }
            }
            catch {

                # if ($Response -match "Error status Code: 400") {
                #     "{0} API credential cannot be created because you have reached the maximum of 5 credentials" -f $CredentialName | Write-Verbose
    
                # }

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "API Credential cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }

            }

        }

        [void] $NewAPICredentialStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            "[{0}] Adding connectivity endpoints when absent to each generated credentials" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            try {
                $Credentials = Get-HPEGLAPICredential 
           
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            # Collect credentials that need modification
            $credentialsToUpdate = @()

            foreach ($credential in $HPEGreenLakeSession.apiCredentials) {
                if ($Null -eq $credential.connectivity_endpoint) {
                    $credentialsToUpdate += $credential
                }   
            }
    
            foreach ($credential in $credentialsToUpdate) {              
                
                $ConnectivityEndpoint = ($Credentials | Where-Object name -eq $credential.name ).connectivity_endpoint
    
                "[{0}] Removing credential `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($credential | Out-String) | Write-Verbose                
                [void]$global:HPEGreenLakeSession.apiCredentials.Remove($credential)
                    
                $credential.connectivity_endpoint = $ConnectivityEndpoint
                # "Adding connectivity endpoint '{0}' to credential '{1}'" -f $ConnectivityEndpoint, $credential.name | Write-Verbose
                "[{0}] Adding credential `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($credential | Out-String) | Write-Verbose                
                    
                "[{0}] Saving to `$HPEGreenLakeSession.apiCredentials" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-Verbose
                [void]$global:HPEGreenLakeSession.apiCredentials.Add($credential)
                
            }

            if ($NewAPICredentialStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more API Credentials failed the creation attempt!"
          
            }

            $NewAPICredentialStatus = Invoke-RepackageObjectWithType -RawObject $NewAPICredentialStatus -ObjectName "ObjStatus.NSDE" 
            Return $NewAPICredentialStatus
        }


    }
}


Function Remove-HPEGLAPICredential {
    <#
    .SYNOPSIS
    Deletes API credential of a service instance. 

    .DESCRIPTION
    This Cmdlet deletes API client credential for an HPE GreenLake service instance.
        
    .PARAMETER Name 
    Name (Case sensitve) of the API client credential to delete.

    .PARAMETER Force
    Switch parameter to force the deletion of the API credential even if it is used by the module.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLAPICredential -Name "Grafana-COM-AP_NorthEast"

    Delete the API credential "Grafana-COM-AP_NorthEast".

    .EXAMPLE
    Get-HPEGLAPICredential | Where-Object name -match Grafana | Remove-HPEGLAPIcredential

    Delete all API credentials whose name matches with Grafana (such as Grafana-COM-AP_NorthEast, Grafana-COM-EU_Central, Grafana-COM-US_West).

    .EXAMPLE
    Get-HPEGLAPICredential | Remove-HPEGLAPICredential

    Delete all API credentials.

    .INPUTS
    System.Collections.ArrayList
        List of API Credential(s) from 'Get-HPEGLAPICredential'.    
    
    .OUTPUTS
    System.Collections.ArrayList    
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - name of the API credential object attempted to be deleted 
        * Status - status of the creation attempt (Failed for http error return; Complete if the deletion is successful) 
        * Details - more information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [Alias ('credential_name')]
        [String]$Name,

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveAPICredentialStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $APIcredential = Get-HPEGLAPICredential -Name $Name
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }

        if (-not $APIcredential) {
            # Must return a message if API credential not found
            "[{0}] API credential '{1}' not found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

            # Must return a message if resource not found

            if ($WhatIf) {
                $ErrorMessage = "API credential '{0}': Resource cannot be found in the workspace!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "API credential cannot be found in the workspace!"
            }

               
        }
        else {

            # Delete API Credential  
            
            $Uri = $ApplicationsAPICredentialsUri + "/$Name" 
            

            # If the credential being deleted is one of the temporary ones used by the library, send a warning and delete the entry in the tracking object $HPECOMAPICredentialRegions
            if (($HPEGreenLakeSession.apiCredentials | Where-Object name -eq $Name) -and $Name -match $APIClientCredentialTemplateName -and -not $Force) {

                "[{0}] Credential '{1}' is used by the module and is attempted to be removed!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

                $title = "You are about to delete an API credential used by this module to interact with a service instance. Confirm that you would like to remove '{0}'" -f $name
                $question = "This action will impact all actions because there will be no more access to this service instance. Are you sure you want to proceed?"
                $choices = '&Yes', '&No'
                
                $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)

                if ($decision -eq 0) {

                    "[{0}] User confirmed the deletion of the API credential '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

                    try {
                    
                        Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -WhatIfBoolean $WhatIf | Out-Null
                        
                        if (-not $WhatIf) {
                            
                            "[{0}] API credential '{1}' successfully deleted!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                            $objStatus.Status = "Complete"
                            $objStatus.Details = "API Credential successfully deleted"
                            
                            # Remove credential from $HPEGreenLakeSession.apiCredentials global variable
                            $APICredentialtoRemove = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -eq $Name -and $_.workspace_id -eq $HPEGreenLakeSession.workspaceId } 
        
                            if ($APICredentialtoRemove) {
                            
                                "[{0}] API credential to remove from `$HPEGreenLakeSession.apiCredentials global variable: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($APICredentialtoRemove | ConvertTo-Json -d 10) | Write-Verbose                   
                                [void]$global:HPEGreenLakeSession.apiCredentials.Remove($APICredentialtoRemove)
                
                            }
        
                            Start-Sleep 1                     
        
                        }
                    }
                    catch {
        
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "API Credential cannot be deleted!"
                            $objStatus.Exception = $_.Exception.message 
                        }    
                    }

                    # Remove region if COM in $HPECOMAPICredentialRegions tracking object used for $Region argument completer
                    if ($APIcredential.application_name -eq "Compute Ops Management") {

                        [void]$Global:HPECOMAPICredentialRegions.Remove($APIcredential.region)       
                        "[{0}] Removed '{1}' region from the global variable `$HPECOMAPICredentialRegions used for the argument completer for the Region parameter of *HPECOM* cmdlets." -f $MyInvocation.InvocationName.ToString().ToUpper(), $APIcredential.region | Write-Verbose
                    }
                }
                else {

                    "[{0}] User cancelled the deletion of the API credential '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

                    $objStatus.Status = "Warning"
                    $objStatus.Details = "Operation cancelled by the user! API credential not deleted!"

                }
            } 
            else {

                try {
                    
                    Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -WhatIfBoolean $WhatIf | Out-Null
                    
                    if (-not $WhatIf) {
                        
                        "[{0}] API credential '{1}' successfully deleted!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "API Credential successfully deleted"
                        
                        # Remove credential from $HPEGreenLakeSession.apiCredentials global variable
                        $APICredentialtoRemove = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -eq $Name -and $_.workspace_id -eq $HPEGreenLakeSession.workspaceId } 
    
                        if ($APICredentialtoRemove) {
                        
                            "[{0}] API credential to remove from `$HPEGreenLakeSession.apiCredentials global variable: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($APICredentialtoRemove | ConvertTo-Json -d 10) | Write-Verbose                   
                            [void]$global:HPEGreenLakeSession.apiCredentials.Remove($APICredentialtoRemove)
            
                        }
    
                        Start-Sleep 1                     
    
                    }
                }
                catch {
    
                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "API Credential cannot be deleted!"
                        $objStatus.Exception = $_.Exception.message 
                    }    
                }
            }
        }  

        [void] $RemoveAPICredentialStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveAPICredentialStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more API Credentials failed the deletion attempt!"
          
            }

            $RemoveAPICredentialStatus = Invoke-RepackageObjectWithType -RawObject $RemoveAPICredentialStatus -ObjectName "ObjStatus.NSDE" 
            Return $RemoveAPICredentialStatus
        }


    }
}

#EndRegion


#Region --- SUBSCRIPTION - LICENSE ---


Function Get-HPEGLSubscription {
    <#
    .SYNOPSIS
    Retrieve device and service subscriptions from HPE GreenLake.

    .DESCRIPTION
    This Cmdlet returns a collection of device and service subscriptions or a filtered collection based on optional parameters.
    Subscriptions are necessary for assigning them to devices using the 'Add-HPEGLSubscriptionToDevice' Cmdlet.

    .PARAMETER SubscriptionKey
    Specifies the subscription key to display.

    .PARAMETER ShowDeviceSubscriptions 
    Optional parameter used to display device subscriptions.

    .PARAMETER ShowServiceSubscriptions
    Optional parameter used to display service subscriptions.

    .PARAMETER FilterBySubscriptionType
    Optional parameter used to filter the subscriptions by type. The available options are 'Access Point', 'Gateway', 'Server', 'Storage', 'Switch', 'OpsRamp', and 'HPE Aruba Networking UXI'.

    .PARAMETER ShowWithAvailableQuantity 
    Optional parameter that displays only the subscriptions with available quantity.

    .PARAMETER ShowExpired 
    Optional parameter that displays only the subscriptions that are expired.
    
    .PARAMETER ShowValid 
    Optional parameter that displays only the subscriptions that are not expired.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLSubscription

    Returns all device subscriptions.
    
    .EXAMPLE
    Get-HPEGLSubscription -SubscriptionKey "000000000000"
    
    Returns the subscription with the key '000000000000'.

    .EXAMPLE
    Get-HPEGLSubscription -ShowServiceSubscriptions 

    Returns all service subscriptions.

    .EXAMPLE
    Get-HPEGLSubscription -ShowDeviceSubscriptions 

    Returns all device subscriptions.

    .EXAMPLE
    Get-HPEGLSubscription -ShowValid
        
    Returns all device subscriptions that are not expired.

    .EXAMPLE
    Get-HPEGLSubscription -FilterBySubscriptionType Switch 

    Returns all device subscriptions of type 'Switch'.

    .EXAMPLE
    Get-HPEGLSubscription -ShowValid -ShowWithAvailableQuantity
        
    Returns all device subscriptions that are not expired and have available quantity.

    .EXAMPLE
    Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -FilterBySubscriptionType Server

    Returns all device subscriptions that are not expired, have available quantity, and are of type 'Server'.

    #>    
   
    [CmdletBinding(DefaultParameterSetName = 'Device')]
    Param( 

        [Parameter (ParameterSetName = 'Key')]
        [String]$SubscriptionKey,

        [Parameter (ParameterSetName = 'Device')]
        [Switch]$ShowDeviceSubscriptions,

        [Parameter (ParameterSetName = 'Service')]
        [Switch]$ShowServiceSubscriptions,

        [Parameter (ParameterSetName = 'Device')]
        [ValidateSet('Access Point', 'Gateway', 'Server', 'Storage', 'Switch', 'OpsRamp', 'HPE Aruba Networking UXI')]
        [String]$FilterBySubscriptionType,

        [Parameter (ParameterSetName = 'Device')]
        [Parameter (ParameterSetName = 'Service')]
        [Switch]$ShowWithAvailableQuantity,

        [Parameter (ParameterSetName = 'Device')]
        [Parameter (ParameterSetName = 'Service')]
        [Switch]$ShowValid,
        
        [Parameter (ParameterSetName = 'Expired')]
        [Switch]$ShowExpired,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $SubscriptionsUri
        # $Uri = $LicenseDevicesProductTypeDeviceUri
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
                
        if ($Null -ne $Collection) {
            
            $CollectionList = $Collection.items
            
            $CurrentDate = Get-Date
            
            if ($ShowWithAvailableQuantity -and $ShowValid) {  
                
                "ShowWithAvailableQuantity and ShowValid" | Write-Verbose
                $CollectionList = $CollectionList | Where-Object { $_.availableQuantity -ge 1 -and $_.endTime -gt $CurrentDate }
            }  
            elseif ($ShowWithAvailableQuantity -and -not $ShowValid) {    

                "ShowWithAvailableQuantity and not ShowValid" | Write-Verbose
                $CollectionList = $CollectionList | Where-Object { $_.availableQuantity -ge 1 }
            }
            elseif ($ShowValid -and -not $ShowWithAvailableQuantity) {
                
                "ShowValid and not ShowWithAvailableQuantity" | Write-Verbose
                $CollectionList = $CollectionList | Where-Object { $_.endTime -gt $CurrentDate }
            }    
            elseif ($ShowExpired) {
                
                "ShowExpired" | Write-Verbose
                $CollectionList = $CollectionList | Where-Object { $_.endTime -lt $CurrentDate }
            }    
   

            if ($ShowDeviceSubscriptions) {
                $CollectionList = $CollectionList | Where-Object { $_.productType -eq "DEVICE" }
            }
            elseif ($ShowServiceSubscriptions) {
                $CollectionList = $CollectionList | Where-Object { $_.productType -eq "SERVICE" }
            }

            if ($FilterBySubscriptionType) {

                if ($FilterBySubscriptionType -eq "Access Point") {
                    $_DeviceType = "AP"
                }
                    
                if ($FilterBySubscriptionType -eq "Gateway") {
                    $_DeviceType = "GW"
                }
        
                if ($FilterBySubscriptionType -eq "Server") {
                    $_DeviceType = "COMPUTE"
                }
        
                if ($FilterBySubscriptionType -eq "Storage") {
                    $_DeviceType = "STORAGE"
                }
        
                if ($FilterBySubscriptionType -eq "Switch") {
                    $_DeviceType = "SWITCH"
                }
      
                if ($FilterBySubscriptionType -eq "OpsRamp") {
                    $_DeviceType = "OPSRAMP"
                }

                if ($FilterBySubscriptionType -eq "HPE Aruba Networking UXI") {
                    $_DeviceType = "UXI"
                }

                $CollectionList = $CollectionList | Where-Object subscriptionType -match $_DeviceType
            }    

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "License"    

            $ReturnData = $ReturnData | Sort-Object { $_.key }

            if ($SubscriptionKey) {
                $ReturnData = $ReturnData | Where-Object key -eq $SubscriptionKey
            }
    
            return $ReturnData 
        }
        else {

            return 
            
        }
    }
}


Function New-HPEGLSubscription {
    <#
    .SYNOPSIS
    Add a subscription to HPE GreenLake.

    .DESCRIPTION
    This Cmdlet adds a service or device subscription to the HPE GreenLake workspace. You can add up to five subscriptions in a single pipeline input.

    .PARAMETER SubscriptionKey 
    The subscription key to add to the GreenLake workspace.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    New-HPEGLSubscription -SubscriptionKey 'Kxxxxxxxxxx' 

    Adds the subscription key 'Kxxxxxxxxxx'.
        
    .EXAMPLE
    "Kxxxxxxxxxx","Kxxxxxxxxxx","Kxxxxxxxxxx" | New-HPEGLSubscription

    Adds the subscription keys 'Kxxxxxxxxxx', 'Kxxxxxxxxxx', 'Kxxxxxxxxxx'.

    .EXAMPLE
    Import-Csv Private\csv\Subscription_keys.csv  | New-HPEGLSubscription

    Adds the subscription keys from the CSV file 'Subscription_keys.csv'.

    The content of the CSV file must use the following format:

        Key
        EZ12312312
        DZ12312312
        CZ12312312
        BZ12312312
        AZ12312312

    .INPUTS
    System.Collections.ArrayList
        List of subscription key(s) with the key property. 
    System.String, System.String[]
        A single string object or a list of string objects that represent the subscription keys.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SubscriptionKey - The subscription key attempted to be added 
        * Status - The status of the addition attempt (Failed for HTTP error return; Complete if addition is successful) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('key')]
        [String]$SubscriptionKey,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $SubscriptionKeysList = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($Subscription.Key) {
            $SubscriptionKey = $Subscription.Key
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SubscriptionKey = $SubscriptionKey
            Status          = $Null
            Details         = $Null
            Exception       = $Null
          
        }

        [void] $ObjectStatusList.add($objStatus)

  
    }
    end {

        try {
            $SubscriptionKeys = Get-HPEGLSubscription 
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
        
        }

        "[{0}] List of keys to add to workspace: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SubscriptionKey | out-string) | Write-Verbose

        # API supports Maximum five subscriptions per request

        if ($ObjectStatusList.Count -gt 5) {
            $ErrorMessage = "Maximum of 5 subscriptions per request is allowed!"
            Write-warning $ErrorMessage
            return
        }
        else {
            
            foreach ($Object in $ObjectStatusList) {
                
                "[{0}] Checking key '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SubscriptionKey | Write-Verbose
                
                $Subscription = $SubscriptionKeys | Where-Object key -eq $Object.SubscriptionKey
                
                
                if ($Subscription) {

                    # Must return a message if subscription already present

                    "[{0}] Subscription '{1}' already exists in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Subscription '{0}': Resource already exists in the workspace! No action needed." -f $Name
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Warning"
                        $objStatus.Details = "Subscription already exists in the workspace! No action needed."
                    }
                   
                }
                else {
            
                    $Uri = $SubscriptionsUri
                    
                    # Build Key object for paylaod
                    $Key = [PSCustomObject]@{
                        key = $Object.SubscriptionKey
                        
                    }
                    
                    # Building the list of keys object for payload
                    [void]$SubscriptionKeysList.Add($Key)
                }
            }


            if ($SubscriptionKeysList) {
                
                # Build payload
                $payload = ConvertTo-Json -Depth 10 @{
                    subscriptions = @($SubscriptionKeysList)
                } 
                
                # Add subscription keys
                try {
                
                    Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf | out-Null
                
                    if (-not $WhatIf) {

                        foreach ($Object in $ObjectStatusList) {

                            if ($Object.Status -ne "Warning") {
                                
                                $Object.Status = "Complete"
                                $Object.Details = "Service subscription successfully added to the HPE GreenLake platform"
                                $Object.Exception = $_.Exception.message 
                            }
                        }
                    
                    }
                    
                }
                catch {
                    
                    if (-not $WhatIf) {

                        foreach ($Object in $ObjectStatusList) {
                                
                            $Object.Status = "Failed"
                            $Object.Details = "Service subscription was not added to the HPE GreenLake platform"
                            $Object.Exception = $_.Exception.message 
    
                        }
                    }
                }   
            } 
    


            if (-not $WhatIf) {

                if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
    
                    write-error "One or more service subscriptions could not be added!"
            
                }
                
                $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "License.SSDE"    
                Return $ObjectStatusList
            }
        }
    }     
}


Function Remove-HPEGLSubscription {
    <#
    .SYNOPSIS
    Delete a subscription from the HPE GreenLake Workspace.

    .DESCRIPTION
    This cmdlet removes a subscription from the HPE GreenLake workspace. A subscription can be removed only if it has not been consumed.

    .PARAMETER SubscriptionKey 
    The subscription key to remove from the GreenLake workspace.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLSubscription -SubscriptionKey 'Kxxxxxxxxxx'

    Removes the subscription key 'Kxxxxxxxxxx'.

    .EXAMPLE
    Get-HPEGLSubscription -FilterBySubscriptionType Server | Remove-HPEGLSubscription

    Removes all 'Server' type subscriptions from the workspace.

    .EXAMPLE
    "Kxxxxxxxxxx","Kxxxxxxxxxx","Kxxxxxxxxxx","Kxxxxxxxxxx" | Remove-HPEGLSubscription 

    Removes multiple subscriptions from the workspace.

    .INPUTS
    System.Collections.ArrayList
        A list of subscriptions retrieved from 'Get-HPEGLSubscription'. 
    System.String, System.String[]
        A single string object or a list of string objects that represent the subscription keys.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SubscriptionKey - The subscription key attempted to be removed 
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if addition is successful) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    
    #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [alias('key')]
        [String]$SubscriptionKey,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveSubscriptionStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $SubscriptionKeyFound = Get-HPEGLSubscription -SubscriptionKey $SubscriptionKey

            $SubscriptionKeyNotConsumed = $SubscriptionKeyFound | Where-Object { $_.quantity -eq $_.availableQuantity }
      
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
        
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SubscriptionKey = $SubscriptionKey
            Status          = $Null
            Details         = $Null
            Exception       = $Null
          
        }


        if (-not $SubscriptionKeyFound) {
            # Must return a message if subscription not present
            "[{0}] Subscription '{1}' cannot be found in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SubscriptionKey | Write-Verbose
        
            if ($WhatIf) {
                $ErrorMessage = "Subscription '{0}': Resource cannot be found in the workspace!" -f $SubscriptionKey
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Subscription cannot be found in the workspace!"
            }
        }
        elseif (-not $SubscriptionKeyNotConsumed) {
            # Must return a message if subscription has been consumed
            "[{0}] Subscription '{1}' has been consumed and cannot be removed from the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SubscriptionKey | Write-Verbose
        
            if ($WhatIf) {
                $ErrorMessage = "Subscription '{0}': Resource has been consumed and cannot be removed from the workspace! This can be resolved by unassigning the device from its service instance using 'Remove-HPEGLDeviceFromService'." -f $SubscriptionKey
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Subscription has been consumed and cannot be removed from the workspace! This can be resolved by unassigning the device from its service instance using 'Remove-HPEGLDeviceFromService'."
            }
            
        }
        else {
           
            $SubscriptionKeyId = $SubscriptionKeyFound.key

            $Uri = $RemoveLicensesUri 

            
            # Build payload
            $payload = [PSCustomObject]@{
                subscription_keys = @($SubscriptionKeyId)                

            } | ConvertTo-Json 


            
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -Body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Device subscription successfully removed from the workspace"
                    
                }
                
            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Failed to remove the device subscription from the workspace."
                    $objStatus.Exception = $_.Exception.message 
                }
            
            }   
        } 

        [void] $RemoveSubscriptionStatus.add($objStatus)

  
    }
    end {

        if (-not $WhatIf) {

            if ($RemoveSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more subscriptions could not be removed!"
          
            }

            $RemoveSubscriptionStatus = Invoke-RepackageObjectWithType -RawObject $RemoveSubscriptionStatus -ObjectName "License.SSDE"    

            Return $RemoveSubscriptionStatus
        }
    }

}


Function Get-HPEGLDeviceAutoSubscription {
    <#
    .SYNOPSIS
    Retrieve the automatic subscription status of device(s) in the HPE GrenLake workspace.

    .DESCRIPTION
    This Cmdlet returns the automatic subscription status of device(s) in the HPE GreenLake workspace.

    Automatic subscription assignment allows HPE GreenLake to automatically assign an valid license to devices.
    
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLDeviceAutoSubscription

    Returns the automatic subscription status of device(s) in the HPE GreenLake workspace.
    
   #>

    [CmdletBinding()]
    Param( 
        [Switch]$WhatIf   
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoLicenseDevicesUri
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
  
        
        if ($Null -ne $Collection.autolicenses) {

            $CollectionList = $Collection.autolicenses #| Where-Object { $_.enabled -eq $True }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "License.AutoSubscribe"    

            $ReturnData = $ReturnData | Sort-Object { $_.device_type }
    
            return $ReturnData 
        }
        else {

            return 
            
        }  
    }
}


function Set-HPEGLDeviceAutoSubscription {
    <#
    .SYNOPSIS
    Configure automatic subscription assignment for each supported device type.

    .DESCRIPTION
    This Cmdlet enables the automatic assignment of subscriptions to different type of devices. 
    
    Automatic subscription assignment allows HPE GreenLake to automatically assign an valid license to devices.

    .PARAMETER AccessPointSubscriptionTier 
    Defines the automatic subscription for "Access Points". The subscription level can be selected from a predefined list.

    .PARAMETER GatewaySubscriptionTier 
    Defines the automatic subscription for "Gateways". The subscription level can be selected from a predefined list.

    .PARAMETER ComputeSubscriptionTier 
    Defines the automatic subscription for "Computes". The subscription level can be selected from a predefined list.

    .PARAMETER SwitchSubscriptionTier 
    Defines the automatic subscription for "Switches". The subscription level can be selected from a predefined list.

    .PARAMETER SensorsSubscriptionTier 
    Defines the automatic subscription for "Sensors". The subscription level can be selected from a predefined list.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLDeviceAutoSubscription -ComputeSubscriptionTier ENHANCED

    Configures auto-subscription for compute devices using the Enhanced subscription tier.

    .EXAMPLE
    Set-HPEGLDeviceAutoSubscription -SwitchSubscriptionTier ADVANCED

    Configures auto-subscription for switch devices using the Advanced subscription tier.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or an array of objects containing the following PsCustomObject keys:  
        * DeviceType - The type of device configured for auto-subscription.
        * Status - The status of the auto-subscription assignment attempt (Failed for HTTP error return; Complete if successful).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "AP")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION', 'ADVANCED')]
        [String]$AccessPointSubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Gateway")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION', 'ADVANCED')]
        [String]$GatewaySubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Compute")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('STANDARD', 'ENHANCED')]
        [String]$ComputeSubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Switch")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION', 'ADVANCED')]
        [String]$SwitchSubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Sensor")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION')]
        [String]$SensorSubscriptionTier,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoLicenseDevicesUri  
        $AutoSubscriptionStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        if ($AccessPointSubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_AP"
            $DeviceType = "AP"
        }
        elseif ($AccessPointSubscriptionTier -eq 'ADVANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ADVANCED_AP"
            $DeviceType = "AP"
        }


        if ($GatewaySubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_GW"
            $DeviceType = "GATEWAY"

        }
        elseif ($GatewaySubscriptionTier -eq 'ADVANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ADVANCED_GW"
            $DeviceType = "GATEWAY"

        }


        if ($ComputeSubscriptionTier -eq 'STANDARD' ) {
            $AutoLicenseSubscriptionTierGroup = "STANDARD_COMPUTE"
            $DeviceType = "COMPUTE"

        }
        elseif ($ComputeSubscriptionTier -eq 'ENHANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ENHANCED_COMPUTE"
            $DeviceType = "COMPUTE"

        }


        if ($SwitchSubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_SWITCH"
            $DeviceType = "SWITCH"

        }
        elseif ($SwitchSubscriptionTier -eq 'ADVANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ADVANCED_SWITCH"
            $DeviceType = "SWITCH"

        }


        if ($SensorSubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_SENSOR"
            $DeviceType = "SENSOR"

        }
       

        # Build object for the output
        $objStatus = [pscustomobject]@{
 
            DeviceType = $DeviceType
            Status     = $Null
            Details    = $Null
            Exception  = $Null
                 
        }


        # Build payload
        $payload = ConvertTo-Json @(
            @{
                device_type                          = $DeviceType
                enabled                              = $True 
                auto_license_subscription_tier_group = $AutoLicenseSubscriptionTierGroup
                    
            }
        ) 
  

        try {
            Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | Out-Null
               
            if (-not $WhatIf) {

                $objStatus.Status = "Complete"
                $objStatus.Details = "Automatic assignment of subscriptions to '$DeviceType' successfully set!"
                

            }
        }
        catch {
            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Automatic assignment of subscriptions to '$DeviceType' cannot be set!"
                $objStatus.Exception = $_.Exception.message 
            }
        }
        

        [void] $AutoSubscriptionStatus.add($objStatus)
    }

    end {

        if (-not $WhatIf) {

            if ($AutoSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
 
                write-error "'$DeviceType' automatic assignment of subscription configuration failure!"
         
            }

            $AutoSubscriptionStatus = Invoke-RepackageObjectWithType -RawObject $AutoSubscriptionStatus -ObjectName "License.DSDE" 
            Return $AutoSubscriptionStatus
        }


    }
}


function Remove-HPEGLDeviceAutoSubscription {
    <#
    .SYNOPSIS
    Remove automatic subscription assignment for specified device types.

    .DESCRIPTION
    This Cmdlet disables the automatic assignment of subscriptions to specified device types. It allows you to remove auto-subscription settings for Access Points, Gateways, Computes, Sensors and Switches.

    Automatic subscription assignment allows HPE GreenLake to automatically assign an valid license to devices.

    .PARAMETER AccessPoints 
    Removes the automatic subscription assignment for "Access Points".

    .PARAMETER Gateways 
    Removes the automatic subscription assignment for "Gateways".

    .PARAMETER Computes 
    Removes the automatic subscription assignment for "Computes".

    .PARAMETER Switches 
    Removes the automatic subscription assignment for "Switches".

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLDeviceAutoSubscription -Computes

    Removes the auto-subscription for Compute devices.

    .EXAMPLE
    Remove-HPEGLDeviceAutoSubscription -Switches

    Removes the auto-subscription for Switch devices.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or an array of objects containing the following PsCustomObject keys:  
        * DeviceType - The type of device removed from auto-subscription.
        * Status - The status of the auto-subscription unassignment attempt (Failed for HTTP error return; Complete if successful).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "AP")]
        [Switch]$AccessPoints,

        [Parameter (Mandatory, ParameterSetName = "Gateway")]
        [Switch]$Gateways,

        [Parameter (Mandatory, ParameterSetName = "Compute")]
        [Switch]$Computes,

        [Parameter (Mandatory, ParameterSetName = "Switch")]
        [Switch]$Switches,

        [Parameter (Mandatory, ParameterSetName = "Sensor")]
        [Switch]$Sensors,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoLicenseDevicesUri  
        $AutoSubscriptionStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        switch ($true) {
            $AccessPoints { $DeviceType = "AP" }
            $Gateways { $DeviceType = "GATEWAY" }
            $Computes { $DeviceType = "COMPUTE" }
            $Switches { $DeviceType = "SWITCH" }
            $Sensors { $DeviceType = "SENSOR" }
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{

            DeviceType = $DeviceType
            Status     = $Null
            Details    = $Null
            Exception  = $Null
             
        }


        try {
            
            $AutoLicenseSubscriptionTierGroup = (Get-HPEGLDeviceAutoSubscription | Where-Object { $_.device_type -eq $DeviceType }).auto_license_subscription_tier_group
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ($AutoLicenseSubscriptionTierGroup) {

            # Build payload
            $payload = ConvertTo-Json @(
                @{
                    device_type                          = $DeviceType
                    enabled                              = $False 
                    auto_license_subscription_tier_group = $AutoLicenseSubscriptionTierGroup
                    
                }
            ) 
  

            # Assign Device to Service 
    
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | Out-Null
               
                if (-not $WhatIf) {

                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Automatic assignment of subscriptions to '$DeviceType' successfully set!"
                
                }
            }
            catch {
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Automatic assignment of subscriptions to '$DeviceType' cannot be set!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }
        }

        else {

            if ($WhatIf) {
                $ErrorMessage = "Automatic subscription cannot be found for '$DeviceType'!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Automatic subscription cannot be found!"
            }
           
        }

        [void] $AutoSubscriptionStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($AutoSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
 
                write-error "'$DeviceType' automatic assignment of subscription configuration failure!"
         
            }

            $AutoSubscriptionStatus = Invoke-RepackageObjectWithType -RawObject $AutoSubscriptionStatus -ObjectName "License.DSDE" 
            Return $AutoSubscriptionStatus
        }


    }
}


Function Get-HPEGLDeviceAutoReassignSubscription {
    <#
    .SYNOPSIS
    Retrieve the automatic subscription reassignment status of device(s) in the HPE GrenLake workspace.

    .DESCRIPTION
    This Cmdlet returns the device types enabled for automatic subscription reassignment.

    Automatic subscription reassignment is a feature to switche the device when a subscription expires to another subscription of the same type preventing disruptions.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLDeviceAutoReassignSubscription

    Returns the automatic subscription reassignment status of device(s) in the HPE GreenLake workspace.
    
   #>

    [CmdletBinding()]
    Param( 
        [Switch]$WhatIf   
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoRenewalDevicesUri
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
  
        
        if ($Null -ne $Collection.renewalSettingsList) {

            $CollectionList = $Collection.renewalSettingsList #| Where-Object { $_.enabled -eq $True }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "License.AutoReassign"    

            $ReturnData = $ReturnData | Sort-Object { $_.device_type }
    
            return $ReturnData 
        }
        else {

            return 
            
        }  
    }
}


function Set-HPEGLDeviceAutoReassignSubscription {
    <#
    .SYNOPSIS
    Configure automatic subscription reassignment for each supported device type.

    .DESCRIPTION
    This Cmdlet enables the automatic reassignment of subscriptions to devices. 
    Automatic subscription reassignment is a feature to switche the device when a subscription expires to another subscription of the same type preventing disruptions.

    .PARAMETER AccessPoints
    Defines the automatic subscription reassignment for "Access Points".

    .PARAMETER Gateways 
    Defines the automatic subscription reassignment for "Gateways".

    .PARAMETER Computes 
    Defines the automatic subscription reassignment for "Computes".

    .PARAMETER Switches 
    Defines the automatic subscription reassignment for "Switches".

    .PARAMETER Sensors 
    Defines the automatic subscription reassignment for "Sensors".

    .PARAMETER Bridges 
    Defines the automatic subscription reassignment for "Bridges".

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLDeviceAutoReassignSubscription -Computes

    Configures auto-reassignment for compute devices.

    .EXAMPLE
    Set-HPEGLDeviceAutoReassignSubscription -Switches

    Configures auto-reassignment for switch devices.

    .EXAMPLE
    Set-HPEGLDeviceAutoReassignSubscription -AccessPoints -Gateways

    Configures auto-reassignment for access points and gateways.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or an array of objects containing the following PsCustomObject keys:  
        * DeviceType - The type of device configured for auto-subscription.
        * Status - The status of the auto-subscription assignment attempt (Failed for HTTP error return; Complete if successful).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [switch]$AccessPoints,

        [switch]$Gateways,

        [switch]$Computes,

        [switch]$Switches,

        [switch]$Sensors,

        [switch]$Bridges,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoRenewalDevicesUri
        $AutoReassignmentStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $ExistingSettings = Get-HPEGLDeviceAutoReassignSubscription
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if ($AccessPoints) {
            ($ExistingSettings | Where-Object deviceType -eq "AP").enabled = $true
            $DeviceType = "AccessPoints"
        }
        if ($Gateways) {
            ($ExistingSettings | Where-Object deviceType -eq "GATEWAY").enabled = $true
            $DeviceType = "Gateways"
        }
        if ($Computes) {
            ($ExistingSettings | Where-Object deviceType -eq "COMPUTE").enabled = $true
            $DeviceType = "Computes"
        }
        if ($Sensors) {
            ($ExistingSettings | Where-Object deviceType -eq "SENSOR").enabled = $true
            $DeviceType = "Sensors"
        }
        if ($Switches) {
            ($ExistingSettings | Where-Object deviceType -eq "SWITCH").enabled = $true
            $DeviceType = "Switches"
        }
        if ($Bridges) {
            ($ExistingSettings | Where-Object deviceType -eq "BRIDGE").enabled = $true
            $DeviceType = "Bridges"
        }

        if ($PSBoundParameters.Count -gt 1) {
            $DeviceType = "Multiple Types"
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
 
            DeviceType = $DeviceType
            Status     = $Null
            Details    = $Null
            Exception  = $Null
                 
        }

       
        # Remove PSObject.TypeNames property
        $CleanedSettings = $ExistingSettings | Select-Object -Property * -ExcludeProperty PSObject.TypeNames 

        # Build payload
        $payload = ConvertTo-Json @{ 
            
            renewalSettingsList = $CleanedSettings
        
        }
              

        try {
            Invoke-HPEGLWebRequest -Uri $Uri -method PATCH -body $payload -WhatIfBoolean $WhatIf | Out-Null
               
            if (-not $WhatIf) {

                $objStatus.Status = "Complete"
                $objStatus.Details = "Automatic reassignment of subscriptions successfully set!"
                

            }
        }
        catch {
            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Automatic reassignment of subscriptions cannot be set!"
                $objStatus.Exception = $_.Exception.message 
            }
        }
        

        [void] $AutoReassignmentStatus.add($objStatus)
    }

    end {

        if (-not $WhatIf) {

            if ($AutoReassignmentStatus | Where-Object { $_.Status -eq "Failed" }) {
 
                write-error "Automatic reassignment of subscription configuration failure!"
         
            }

            $AutoReassignmentStatus = Invoke-RepackageObjectWithType -RawObject $AutoReassignmentStatus -ObjectName "License.DSDE" 
            Return $AutoReassignmentStatus
        }


    }
}


function Remove-HPEGLDeviceAutoReassignSubscription {
    <#
    .SYNOPSIS
    Remove automatic subscription reassignment for specified device types.

    .DESCRIPTION
    This Cmdlet disables the automatic reassignment of subscriptions to specified device types.
    Automatic subscription reassignment is a feature to switche the device when a subscription expires to another subscription of the same type preventing disruptions.

    .PARAMETER AccessPoints 
    Removes the automatic subscription reassignment for "Access Points".

    .PARAMETER Gateways 
    Removes the automatic subscription reassignment for "Gateways".

    .PARAMETER Computes 
    Removes the automatic subscription reassignment for "Computes".

    .PARAMETER Switches 
    Removes the automatic subscription reassignment for "Switches".
    
    .PARAMETER Sensors 
    Removes the automatic subscription reassignment for "Sensors".
    
    .PARAMETER Bridges
    Removes the automatic subscription reassignment for "Bridges".

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLDeviceAutoReassignSubscription -Computes

    Removes the auto-reassignment for compute devices.
    
    .EXAMPLE
    Remove-HPEGLDeviceAutoReassignSubscription -Switches

    Removes the auto-reassignment for switch devices.

    .EXAMPLE
    Remove-HPEGLDeviceAutoReassignSubscription -Gateways -Computes -Switches 

    Removes the auto-reassignment for gateways, computes, and switches.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or an array of objects containing the following PsCustomObject keys:  
        * DeviceType - The type of device removed from auto-subscription.
        * Status - The status of the auto-subscription unassignment attempt (Failed for HTTP error return; Complete if successful).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Switch]$AccessPoints,

        [Switch]$Gateways,

        [Switch]$Computes,

        [Switch]$Switches,

        [Switch]$Sensors,

        [Switch]$Bridges,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoRenewalDevicesUri
        $AutoReassignmentStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        try {

            $ExistingSettings = Get-HPEGLDeviceAutoReassignSubscription
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if ($AccessPoints) {
            ($ExistingSettings | Where-Object deviceType -eq "AP").enabled = $false
            $DeviceType = "AccessPoints"
        }
        if ($Gateways) {
            ($ExistingSettings | Where-Object deviceType -eq "GATEWAY").enabled = $false
            $DeviceType = "Gateways"
        }
        if ($Computes) {
            ($ExistingSettings | Where-Object deviceType -eq "COMPUTE").enabled = $false
            $DeviceType = "Computes"
        }
        if ($Sensors) {
            ($ExistingSettings | Where-Object deviceType -eq "SENSOR").enabled = $false
            $DeviceType = "Sensors"
        }
        if ($Switches) {
            ($ExistingSettings | Where-Object deviceType -eq "SWITCH").enabled = $false
            $DeviceType = "Switches"
        }
        if ($Bridges) {
            ($ExistingSettings | Where-Object deviceType -eq "BRIDGE").enabled = $false
            $DeviceType = "Bridges"
        }

        if ($PSBoundParameters.Count -gt 1) {
            $DeviceType = "Multiple types"
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{

            DeviceType = $DeviceType
            Status     = $Null
            Details    = $Null
            Exception  = $Null
             
        }

          
        # Remove PSObject.TypeNames property
        $CleanedSettings = $ExistingSettings | Select-Object -Property * -ExcludeProperty PSObject.TypeNames 

        # Build payload
        $payload = ConvertTo-Json @{ 
            
            renewalSettingsList = $CleanedSettings
        
        }
              

        try {
            Invoke-HPEGLWebRequest -Uri $Uri -method PATCH -body $payload -WhatIfBoolean $WhatIf | Out-Null
               
            if (-not $WhatIf) {

                $objStatus.Status = "Complete"
                $objStatus.Details = "Automatic reassignment of subscriptions successfully disabled!"
                

            }
        }
        catch {
            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Automatic reassignment of subscriptions cannot be disabled!"
                $objStatus.Exception = $_.Exception.message 
            }
        }
        

        [void] $AutoReassignmentStatus.add($objStatus)
    }

    end {

        if (-not $WhatIf) {

            if ($AutoReassignmentStatus | Where-Object { $_.Status -eq "Failed" }) {
 
                write-error "Automatic reassignment of subscription configuration failure!"
         
            }

            $AutoReassignmentStatus = Invoke-RepackageObjectWithType -RawObject $AutoReassignmentStatus -ObjectName "License.DSDE" 
            Return $AutoReassignmentStatus
        }


    }

      
}


Function Add-HPEGLSubscriptionToDevice {
    <#
        .SYNOPSIS
        Apply a subscription key to device(s). 

        .DESCRIPTION
        This Cmdlet applies a license subscription key to device(s).     
            
        .PARAMETER DeviceSerialNumber 
        Specifies the serial number of the device to which a subscription key will be applied. This value can be retrieved using 'Get-HPEGLDevice'.

        .PARAMETER SubscriptionKey 
        Specifies the subscription key of a valid and non-expired license. This value can be retrieved using 'Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid'.

        .PARAMETER WhatIf
        Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

        .EXAMPLE
        Add-HPEGLSubscriptionToDevice -DeviceSerialNumber CNX2380BLC -SubscriptionKey ABCDEFG1234

        Applies a the subscription key 'ABCDEFG1234' to the device with the serial number CNX2380BLC.

        .EXAMPLE
        Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -ShowDeviceType | Select-Object -First 1 | Add-HPEGLSubscriptionToDevice -DeviceSerialNumber CNX2380BLC 

        Applies a subscription key to the device with the license provided in the pipeline.

        .EXAMPLE
        $Subscription_Key = Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid -FilterBySubscriptionType Server | select -First 1 -ExpandProperty key

        'CNX2380BLC', 'MXQ73200W1' | Add-HPEGLSubscriptionToDevice -SubscriptionKey $SubscriptionKey

        Applies a server subscription key to devices with serial numbers 'CNX2380BLC' and 'MXQ73200W1'.

        .EXAMPLE
        Import-Csv Tests/Network_Devices.csv | Add-HPEGLSubscriptionToDevice -SubscriptionKey $SubscriptionKey

        Applies a subscription key to devices listed in a CSV file containing at least a SerialNumber column.

        .INPUTS
        System.Collections.ArrayList
            List of device(s) retrieved using the 'Get-HPEGLDevice' cmdlet.
        System.String, System.String[]
            A single string object or a list of string objects representing device serial numbers.
        System.String
            A subscription key obtained from the 'Get-HPEGLSubscription' cmdlet.

        .OUTPUTS
        System.Collections.ArrayList
            A custom status object or array of objects containing the following PsCustomObject keys:
                * SerialNumber - Serial number of the device assigned to a subscription key.
                * Status - Status of the assignment attempt (Failed for HTTP error return; Complete if assignment is successful; Warning if no action is needed).
                * Details - More information about the status.
                * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias('SerialNumber', 'serial_number')]
        [String]$DeviceSerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias('key')]
        [String]$SubscriptionKey,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $LicenseDevicesUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

        try {
            
            $subscriptionKeyFound = Get-HPEGLSubscription -ShowWithAvailableQuantity -ShowValid | Where-Object key -eq $SubscriptionKey

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }

        if ( -not $subscriptionKeyFound) {

            $ErrorMessage = "'{0}' is not a valid subscription or without available quantity or it cannot be found in the HPE GreenLake workspace!" -f $SubscriptionKey
            throw $ErrorMessage

        }


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            
            SerialNumber = $DeviceSerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
            
        }
        

        [void] $ObjectStatusList.add($objStatus)
    }

    end {
        
        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( $device.subscription_key ) {

                # Must return a message if device is already licensed to a subscription key
                $Object.Status = "Warning"
                $Object.Details = "Device already licensed with a subscription key!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is already licensed with a subscription key!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            elseif (-not $device.application_name) {
        
                # Must return a message if the device is not assigned to a service
                $Object.Status = "Failed"
                $Object.Details = "Device not assigned to a service! Use first Add-HPEGLDeviceToService!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is not assigned to a service! Use first 'Add-HPEGLDeviceToService'!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
          
            }
            else {       
            
                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number    = $Device.serial_number
                    part_number      = $Device.part_number 
                    device_type      = $Device.device_type
                    subscription_key = $SubscriptionKey
                }
              
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Check to see if there is enough license available fro the number of devices
            if ( $subscriptionKeyFound.available_quantity -lt $DevicesList.Count ) {
                $ErrorMessage = "There are not enough licenses available in $subscriptionKey for the number of devices to be assigned!"
                throw $ErrorMessage
            }
            else {
                
                # Build payload
                $payload = ConvertTo-Json $DevicesList
                    
                                    
                # Assign Devices to location  
                try {

                    Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null
                    
                    if (-not $WhatIf) {
                        
                        foreach ($Object in $ObjectStatusList) {

                            $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                            If ($DeviceSet) {
                                
                                $Object.Status = "Complete"
                                $Object.Details = "Device successfully attached to subscription key!"

                            }
                        }

                    }
                }
                catch {
                    
                    if (-not $WhatIf) {

                        foreach ($Object in $ObjectStatusList) {

                            $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                            If ($DeviceSet) {
                                
                                $Object.Status = "Failed"
                                $Object.Details = "Device cannot be attached to subscription key!"
                                $Object.Exception = $_.Exception.message 

                            }
                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the assignment attempt!"
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.SSDE"  
            Return $ObjectStatusList
        }
    }
}


Function Remove-HPEGLSubscriptionFromDevice {
    <#
    .SYNOPSIS
    Detach a subscription key from device(s). 

    .DESCRIPTION
    This Cmdlet detaches a license subscription key from device(s).     

    .PARAMETER DeviceSerialNumber 
    Serial number of the device to which a subscription key must be detached. This value can be retrieved from 'Get-HPEGLDevice'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLSubscriptionFromDevice -DeviceSerialNumber CNX2380BLC 

    Detach a subscription key from a device using its serial number.

    .EXAMPLE
    'CNX2380BLC', 'MXQ73200W1' | Remove-HPEGLSubscriptionFromDevice

    Detach subscription keys from devices with serial numbers 'CNX2380BLC' and 'MXQ73200W1'.

    .EXAMPLE
    Import-Csv Tests/Network_Devices.csv  |  Remove-HPEGLSubscriptionFromDevice 

    Detach subscription keys from devices listed in a csv file containing at least a SerialNumber column.

    .EXAMPLE
    Get-HPEGLdevice | Remove-HPEGLSubscriptionFromDevice 

    Detach subscription keys from all devices found in the workspace.

    .INPUTS
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device detached from a subscription key. 
        * Status - Status of the detachment attempt (Failed for http error return; Complete if assignment is successful) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('SerialNumber', 'serial_number')]
        [String]$DeviceSerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $LicenseDevicesUri  
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                      
        }
    

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource cannot be found in the workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $device.subscription_key ) {

                # Must return a message if device is not licensed with a subscription key
                $Object.Status = "Warning"
                $Object.Details = "Device is not licensed with a subscription key!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}': Resource is not licensed with a subscription key!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       
            
                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                }
              
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            
            # Build payload
            $payload = ConvertTo-Json $DevicesList
                
                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Device successfully detached from subscription key!"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Device cannot be detached from subscription key!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more devices from the subscription assignment has failed!"

          
            }


            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.SSDE"  
            Return $ObjectStatusList
        }


    }
}

#EndRegion


#Region --- USER - ROLES - PERMISSIONS ---


Function Get-HPEGLUser {
    <#
    .SYNOPSIS
    Retrieve user resource(s).

    .DESCRIPTION
    This Cmdlet returns a collection of user resources or user statistics. Roles and permissions can also be retrieved.

    .PARAMETER FirstName 
    Specifies the first name associated with resources (case-sensitive!).

    .PARAMETER LastName 
    Specifies the last name associated with resources (case-sensitive!).
  
    .PARAMETER Email 
    Specifies the email associated with resources.

    .PARAMETER ShowUnverified 
    Optional parameter that can be used to display unverified users.

    .PARAMETER ShowStats 
    Optional parameter that can be used to display user statistics.

    .PARAMETER ShowRoles 
    This option can be used to see the roles assigned to a user.

    .PARAMETER ShowPermissions 
    This option can be used to see the permissions assigned to a user.
    
    .PARAMETER ShowActivities
    This option can be used to see the last month activities data of a user.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLUser -FirstName Eddy 

    Return the user resource with first name "Eddy".

    .EXAMPLE
    Get-HPEGLUser -ShowStats 

    Return user statistics.

    .EXAMPLE
    Get-HPEGLUser -ShowPermissions -FirstName Albert -LastName Einstein

    Return Albert Einstein permissions.

    .EXAMPLE
    Get-HPEGLUser -ShowRoles -FirstName Albert -LastName Einstein

    Return Albert Einstein roles.
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (Mandatory, ParameterSetName = 'Roles')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions')]
        [Parameter (Mandatory, ParameterSetName = 'Activity')]
        [ValidateNotNullOrEmpty()]
        [String]$FirstName,  

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (Mandatory, ParameterSetName = 'Roles')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions')]
        [Parameter (Mandatory, ParameterSetName = 'Activity')]
        [ValidateNotNullOrEmpty()]
        [String]$LastName,  
        
        [Parameter (Mandatory, ParameterSetName = 'Email')]
        [Parameter (Mandatory, ParameterSetName = 'EmailRoles')]
        [Parameter (Mandatory, ParameterSetName = 'EmailPermissions')]
        [Parameter (Mandatory, ParameterSetName = 'EmailActivity')]
        [ValidateNotNullOrEmpty()]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,  

        [Parameter(Mandatory, ParameterSetName = 'Unverified')]
        [Switch]$ShowUnverified,
                
        [Parameter (Mandatory, ParameterSetName = 'Roles')]
        [Parameter (Mandatory, ParameterSetName = 'EmailRoles')]
        [Switch]$ShowRoles,
        
        [Parameter (Mandatory, ParameterSetName = 'EmailActivity')]
        [Parameter (Mandatory, ParameterSetName = 'Activity')]
        [Switch]$ShowActivities,

        [Parameter (Mandatory, ParameterSetName = 'Permissions')]
        [Parameter (Mandatory, ParameterSetName = 'EmailPermissions')]
        [Switch]$ShowPermissions,
        
        [Parameter(Mandatory, ParameterSetName = 'Stats')]
        [Switch]$ShowStats,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $Uri = $UsersUri + "?limit=2000&include_unverified=true"

        $query = @()

        if ($FirstName) {
            $query += "first_name=$FirstName"
        }

        if ($LastName) {
            $query += "last_name=$LastName"
        }

        if ($ShowStats) {
            $Uri = $UsersStatsUri
        }
        
        if ($query) {
            foreach ($Item in $query) {
                if ($query.count -eq 1) {
                    $queries = $Item
                }
                else {
                    $queries += ($Item + "&")
                }

                $Uri = $Uri + "&" + $queries

            }
            
        }
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        $ReturnData = @()

   
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if ($ShowStats) {

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "User.stat"         
            return $ReturnData 

        }
        else {

            if ($Null -ne $Collection.users) {
                
                $CollectionList = $Collection.users 

                # "[{0}] List of users: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ( $CollectionList | out-string ) | Write-Verbose

                if ($Email) {
                    $CollectionList = $CollectionList | Where-Object { $_.contact.email -eq $email }
                }

                if ($ShowUnverified) {
                    $CollectionList = $CollectionList | Where-Object { $_.user_status -eq "UNVERIFIED" }
                }

                if ($ShowRoles) {      
                    
                    $RolesList = @()                    

                    if (-not $Email) {
                         
                        $Emailfound = $CollectionList.contact.email
                        
                    }
                    else {
                        $Emailfound = $Email
                    }

                    "[{0}] Number of users: '{1}': retreiving role for: '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CollectionList.count, $Emailfound, ( $CollectionList | out-string ) | Write-Verbose

                    foreach ($Item in $Emailfound) {
                        
                        try {

                            $Rolesfound = Get-HPEGLUserRole -Email $Item 
                            $RolesList += $Rolesfound
                        
                    
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }
                
                    }
    
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $RolesList -ObjectName "User.Role"         
                    $ReturnData = $ReturnData | sort-object email, application_name, role, resource_restriction_policy
                    
                    return $ReturnData
                       
                    
                }
                elseif ($ShowPermissions) {

                    $PermissionsList = @()

                    if ($Email) {
                         
                        $CollectionList = $CollectionList | Where-Object { $_.contact.email -eq $Email }
                    }

                    "[{0}] Number of users: '{1}': retreiving permissions for: '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CollectionList.count, $Email, ( $CollectionList | out-string ) | Write-Verbose

            
                    if ($CollectionList.count -ne "1") {
                        throw "You need to refine your query as several users have been found and this is not compatible with the Permissions parameter!"
                    }
                    else {

                        $UserRoles = $CollectionList.user_role
                                       
                        foreach ($UserRole in $UserRoles) {

                            $Rolename = $UserRole | ForEach-Object role_name
                            $AppName = $UserRole | ForEach-Object application_name
                        
                            "[{0}] Service: '{1}' - Role: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $AppName, $Rolename | Write-Verbose

                            try {
                                $ResourcePolicies = Get-HPEGLRole -ServiceName $AppName -ServiceRole $RoleName -ShowPermissions

                                $PermissionsList += $ResourcePolicies

                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }

                     
                       
                        }
                        
                        $PermissionsList = $PermissionsList | Sort-Object application, rolename, resource
                        return $PermissionsList

                    }


                }
                else {


                    # Add email to object
                    foreach ($user in $CollectionList) {
                        $user | Add-Member -MemberType NoteProperty -Name email -Value $user.contact.email
                        $user | Add-Member -MemberType NoteProperty -Name firstname -Value $user.contact.first_name
                        $user | Add-Member -MemberType NoteProperty -Name lastname -Value $user.contact.last_name
                    }
                   
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "User"         
                    $ReturnData = $ReturnData | Sort-Object firstName, lastname, email
           

                    if ($ShowActivities) {

                        $SearchString = $ReturnData.contact.Email
                        $ReturnData = Get-HPEGLAuditLog -SearchString $SearchString -ShowLastMonth
                        return $ReturnData 

                    }
                    else {
                        return $ReturnData 
                        
                    }

                }
    
            }
            else {

                return 
                
            }
        }
        
    }
}


Function Send-HPEGLUserInvitation {
    <#
    .SYNOPSIS
    Send an invitation email to join the HPE GreenLake workspace.

    .DESCRIPTION
    This cmdlet is used by workspace administrators to invite team members to join the currently connected HPE GreenLake workspace. 
    An email notification is sent to the specified user's address, and the user is added to the team members with the designated role.

    .PARAMETER Email
    Specifies the email address of the user to be invited.

    .PARAMETER Role
    Specifies the HPE GreenLake role to assign to the user.
    The predefined roles are:
        * Workspace Administrator
        * Workspace Observer
        * Workspace Operator
        * Orders Administrator
        * Orders Observer
        * Orders Operator

    .PARAMETER SenderEmail
    (Optional) Specifies the email address of the sender of this invitation. When not defined, the user email address used with Connect-HPEGL to create a session with the worksapce is used.

    .PARAMETER Resend
    Indicates that a new invitation should be sent to an existing user.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Send-HPEGLUserInvitation -Email leonhard.euler@mathematician.edu -Role 'Orders Operator' -SenderEmail bernhard.riemann@mathematician.edu

    Leonhard Euler is added to the team members as an Orders Operator, and an email notification is sent to the specified email address.
    Bernhard Riemann is recorded as the administrator who added Leonhard Euler to the group.

    .EXAMPLE
    Send-HPEGLUserInvitation -Email leonhard.euler@mathematician.com -Resend

    A new invitation is re-sent to Leonhard Euler.

    .EXAMPLE
    'leonhard.euler@mathematician.com','bernhard.riemann@mathematician.edu' | Send-HPEGLUserInvitation -Role 'Account Administrator'

    Leonhard Euler and Bernhard Riemann are added to the team members as Account Administrators, and email notifications are sent to them.

    .EXAMPLE
    Import-Csv emails.csv | Send-HPEGLUserInvitation 

    Sends an invitation to the email addresses listed in a CSV file containing at least the Email and Role columns.

    The content of the CSV file must use the following format:
        Email, Role
        leonhard.euler@mathematician.com, Workspace Administrator
        bernhard.riemann@mathematician.edu, Workspace Observer

    .INPUTS
    System.String, System.String[]
        A single string object or an array of string objects that represent the user's email addresses.
    System.Collections.ArrayList
       List of users from a CSV file containing columns for email and role.
    

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - The email address of the user.
        * Status - The status of the join group/email notification attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, ParameterSetName = 'Default')]
        [Parameter (Mandatory, ValueFromPipeline, ParameterSetName = 'Resend')]
        [ValidateNotNullOrEmpty()]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [ValidateSet('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$Role,

        [Parameter (ParameterSetName = 'Default')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$SenderEmail,  

        [Parameter (ParameterSetName = 'Resend')]
        [Switch]$Resend,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        if ($Resend) {
            # Resend an invite
            $Uri = $ReInviteUserUri 
        }
        else {
            $Uri = $InviteUserUri
        }
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $UsernamesList = [System.Collections.ArrayList]::new()


        try {
            $AppRole = Get-HPEGLRole -HPEGreenLake
            $Users = Get-HPEGLUser

            $RoleSlug = $AppRole | Where-Object name -eq $Role | ForEach-Object slug

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        

    }

    Process {                   
       
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            
            Email     = $Email
            Status    = $Null
            Details   = $Null
            Exception = $Null
            
        }
        
        $User = $Users | Where-Object email -eq $Email


        if ($Resend) {

            if (-not $User) {
                # Must return a message if account not found
                "[{0}] User '{1}' account does not exist!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "User '{0}' cannot be found in the workspace to resend an invitation!" -f $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "User account cannot be found in the workspace to resend an invitation!"
                    
                }

            }
            elseif ($User.user_status -eq "VERIFIED") {
                # Must return a message if account is already verified
                "[{0}] User '{1}' account is already verified!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "User '{0}' is already verified!" -f $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "User is already verified!"
                    
                }

            }
            else {
             
                # Create payload  
                $Payload = [PSCustomObject]@{
                    usernames = @($Email)
            
                } | ConvertTo-Json      

                # Resend invitation      
                
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Post -Uri $Uri -Body $Payload -whatifBoolean $WhatIf

                    if (-not $WhatIf) {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Invitation resent!"
                    }

                    if ($Collection.message) {
                        $Collection.message | Write-Verbose
                    }
                }
                catch {
            
                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Invitation resending failure!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }
           
            }
        }
        else {

            if ($User) {
                # Must return a message if account found
                "[{0}] User '{1}' account has already been invited!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "User '{0}' has already been invited to the HPE GreenLake workspace!" -f $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "User account has already been invited!"
                }
            }
            else {

                try {
                    $AppRole = Get-HPEGLRole -HPEGreenLake
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
            
                $RoleSlug = $AppRole | Where-Object name -eq $Role | ForEach-Object slug
 

                # Create payload  
                $Payload = [PSCustomObject]@{
                    user_names          = @($Email)
                    contact_information = if ($SenderEmail) { $SenderEmail } else { $HPEGreenLakeSession.username }
                    roles               = @(
                        @{ role = @{
                                application_id = "00000000-0000-0000-0000-000000000000"
                                slug           = $RoleSlug 
                            }
                            
                        })
                } | ConvertTo-Json -Depth 5
                    
        
                # Send invitation      
                
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Post -Uri $Uri -Body $Payload -whatifBoolean $WhatIf
        
                    if (-not $WhatIf) {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Invitation sent!"
                    }
        
                    if ($Collection.message) {
                        $Collection.message | Write-Verbose
                    }
                }
                catch {
                    
                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Invitation sending failure!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }
            }
        }     



        [void] $ObjectStatusList.add($objStatus)
    }

    end {

        # API DOES NOT SUPPORT LIST OF EMAILS IN PAYLOAD RIGHT NOW !

        # try {
        #     $Users = Get-HPEGLUser
           
        # }
        # catch {
        #     $PSCmdlet.ThrowTerminatingError($_)
            
        # }


        # "[{0}] List of users to send an invitation: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.Email | out-string) | Write-Verbose

        # foreach ($Object in $ObjectStatusList) {

        #     $User = $Users | Where-Object email -eq $Object.Email

        #     if ($Resend) {
                
        #         if (-not $User) {
                    
        #             # Must return a message if not found
        #             $Object.Status = "Failed"
        #             $Object.Details =  "User account cannot be found in the HPE GreenLake workspace to resend an invitation!"
                    
        #             if ($WhatIf) {
        #                 $ErrorMessage = "User '{0}' cannot be found in the HPE GreenLake workspace to resend an invitation!" -f $Object.Email
        #                 Write-warning $ErrorMessage
        #                 continue
        #             }
                    
        #         } 

        #     }
        #     else {

        #         if ( $User) {
                    
        #             # Must return a message if account found
        #             $Object.Status = "Warning"
        #             $Object.Details = "User account has already been invited!"
                    
        #             if ($WhatIf) {
        #                 $ErrorMessage = "User '{0}' has already been invited to the HPE GreenLake workspace!" -f $Object.Email
        #                 Write-warning $ErrorMessage
        #                 continue
        #             }
                    
        #         } 
        #     }

        #     # Building the list of email object where to send the invitation
        #     [void]$UsernamesList.Add($Object.Email)

        # }


        # if ($UsernamesList) {

        #     # Build payload
        #     $payload = ConvertTo-Json $UsernamesList
            
        #     if ($Resend) {
                
        #         # Create payload  
        #         $Payload = [PSCustomObject]@{
        #             usernames = $UsernamesList
            
        #         } | ConvertTo-Json  
                
        #     }
        #     else {
                
        #         # Create payload  
        #         $Payload = [PSCustomObject]@{
        #             user_names          = $UsernamesList
        #             contact_information = if ($SenderEmail) { $SenderEmail } else { $HPEGreenLakeSession.username }
        #             roles               = @(
        #                 @{ role = @{
        #                         application_id = "00000000-0000-0000-0000-000000000000"
        #                         slug           = $RoleSlug 
        #                     }
                            
        #                 })
        #         } | ConvertTo-Json -Depth 5

        #     }
            
            
        #     # Send invitation      
        #     try {

        #         Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
        #         if (-not $WhatIf) {
                    
        #             foreach ($Object in $ObjectStatusList) {

        #                 $Username = $UsernamesList | Where-Object {$_ -eq $Object.email}

        #                 If ($Username) {

        #                     if ($Resend) {

        #                         $Object.Status = "Complete"
        #                         $Object.Details = "Invitation resent successfully!"

        #                     }
        #                     else {
        #                         $Object.Status = "Complete"
        #                         $Object.Details = "Invitation sent successfully!"
        #                     }
        #                 }
        #             }
        #         }
        #     }
        #     catch {
                
        #         if (-not $WhatIf) {

        #             foreach ($Object in $ObjectStatusList) {

        #                 $Username = $UsernamesList | Where-Object {$_ -eq $Object.email}
                        
        #                 If ($Username) {

        #                     if ($Resend) {

        #                         $Object.Status = "Failed"
        #                         $Object.Details =  "Invitation resending failure!"
        #                         $Object.Exception = $_.Exception.message 
                                

        #                     }
        #                     else {
                                  
        #                         $Object.Status = "Failed"
        #                         $Object.Details =  "Invitation sending failure!"
        #                         $Object.Exception = $_.Exception.message 
        #                     }
        #                 }
        #             }
        #         }
        #     }
        # }
                            

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to send an invitation!"
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.ESDE" 
            Return $ObjectStatusList
        }
    }
}


Function Remove-HPEGLUser {
    <#
    .SYNOPSIS
    Delete a user from the HPE GreenLake workspace.

    .DESCRIPTION
    This cmdlet can be used by account administrators to delete a user account from the currently connected HPE GreenLake workspace.

    .PARAMETER Email
    Specifies the email address of the user to delete.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLUser -Email johanncarlfriedrich.gauss@mathematician.edu

    Deletes the user Johann Carl Friedrich Gauss.

    .EXAMPLE
    'leonhard.euler@mathematician.com','bernhard.riemann@mathematician.edu' | Remove-HPEGLUser

    Deletes Leonhard Euler and Bernhard Riemann from the currently connected HPE GreenLake workspace.

    .EXAMPLE
    Import-Csv emails.csv | Remove-HPEGLUser 

    Deletes the users whose email addresses are listed in a CSV file containing at least an Email column.

    The content of the CSV file must use the following format:
        Email
        leonhard.euler@mathematician.com
        bernhard.riemann@mathematician.edu

    .EXAMPLE
    Get-HPEGLUser | Remove-HPEGLUser 
    
    Deletes all users from the HPE GrenLake workspace.

    .INPUTS
    System.Collections.ArrayList
        List of user(s) from 'Get-HPEGLUser'.
    System.String, System.String[]
        A single string object or an array of string objects representing the user's email addresses.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - The email address of the user.
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,  

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
       
        $Uri = $UsersUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $UsernamesList = [System.Collections.ArrayList]::new()
        
    }

    Process {   

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email     = $Email
            Status    = $Null
            Details   = $Null
            Exception = $Null
              
        }
        
        [void] $ObjectStatusList.add($objStatus)

    }
    end {
        
        try {

            $Users = Get-HPEGLUser
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        "[{0}] List of users to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.Email | out-string) | Write-Verbose
        

        foreach ($Object in $ObjectStatusList) {

            $User = $Users | Where-Object email -eq $Object.Email

            if ($Resend) {
                
                if (-not $User) {
                    
                    # Must return a message if not found
                    $Object.Status = "Failed"
                    $Object.Details = "User account cannot be found in the workspace!"
                    
                    if ($WhatIf) {
                        $ErrorMessage = "User '{0}': Resource cannot be found in the workspace!" -f $Object.Email
                        Write-warning $ErrorMessage
                        continue
                    }
                    
                } 

            }

            # Building the list of email object where to send the invitation
            [void]$UsernamesList.Add($Object.Email)

        }


        if ($UsernamesList) {

            # Build payload
            $Payload = [PSCustomObject]@{
                usernames = $UsernamesList
                
            } | ConvertTo-Json     
                       
            
            # Send invitation      
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $Username = $UsernamesList | Where-Object { $_ -eq $Object.email }

                        If ($Username) {

                            $Object.Status = "Complete"
                            $Object.Details = "User account successfully removed!"
                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $Username = $UsernamesList | Where-Object { $_ -eq $Object.email }
                        
                        If ($Username) {

                            $Object.Status = "Failed"
                            $Object.Details = "User account removal failure!"
                            $Object.Exception = $_.Exception.message 
                            
                        }
                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more user accounts has failed!"

          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.ESDE" 
            Return $ObjectStatusList
        }


    }
}


Function Get-HPEGLRole {
    <#
    .SYNOPSIS
    View service roles.

    .DESCRIPTION
    This Cmdlet returns the service roles. Roles are groups of permissions that grant access to users.

    .PARAMETER ServiceName 
    Name of the service retrieved using 'Get-HPEGLService'.   
    
    .PARAMETER ArubaCentral 
    Optional parameter to display the roles of the Aruba Central service.

    .PARAMETER ComputeOpsManagement 
    Optional parameter to display the roles of the Compute Ops Management service.

    .PARAMETER DataServices 
    Optional parameter to display a specific role of the Data Services service.

    .PARAMETER HPEGreenLake 
    Optional parameter to display the roles of the HPE GreenLake service.

    .PARAMETER ArubaCentralRole 
    Optional parameter to display a specific role of the Aruba Central service.
    The predefined roles are as follows:
        * Aruba Central Administrator  
        * Aruba Central Guest Operator
        * Aruba Central Operator
        * Aruba Central view edit role
        * Aruba Central View Only
        * Netlnsight Campus Admin
        * Netlnsight Campus Viewonly

    .PARAMETER ComputeOpsManagementRole 
    Optional parameter to display a specific role of the Compute Ops Management service.
    The predefined roles are as follows:
        * Administrator
        * Observer
        * Operator

    .PARAMETER DataServicesRole 
    Optional parameter to display a specific role of the Data Services service.
    The predefined roles are as follows:
        * Administrator
        * Backup and Recovery Administrator
        * Backup and Recovery Operator
        * Data Ops Manager Administrator
        * Data Ops Manager Operator
        * Disaster Recovery Admin
        * Read only

    .PARAMETER HPEGreenLakeRole 
    Optional parameter to display a specific role of the HPE GreenLake service.
    The predefined roles are as follows:
        * Workspace Administrator
        * Workspace Observer
        * Workspace Operator
        * Orders Administrator
        * Orders Observer
        * Orders Operator

    .PARAMETER ShowAssignedUsers 
    The AssignedUsers directive returns the users assigned to the role name.

    .PARAMETER ShowPermissions
    The ShowPermissions directive returns the permissions of a role name.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLRole 

    Return the service roles in an HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLRole -ArubaCentral 

    Return the roles for the Aruba Central service instances in your HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLRole -ServiceName "Data Services" 

    Return the roles for the Data Services service instances in your HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLRole -ServiceName "Data Services" -ServiceRole "Disaster Recovery Admin"
    
    Return the "Disaster Recovery Admin" role information for the Data Services service.

    .EXAMPLE
    Get-HPEGLRole -ComputeOpsManagementRole Administrator 

    Return the Administrator role information for the Compute Ops Management service.
           
    .EXAMPLE
    Get-HPEGLRole -ComputeOpsManagementRole Administrator -ShowAssignedUsers 

    Return the users assigned to the Administrator role of the Compute Ops Management service.

    .EXAMPLE
    Get-HPEGLRole -DataServicesRole 'Backup and Recovery Administrator' -ShowPermissions

    Return the list of permissions for the 'Backup and Recovery Administrator' role of the Data Services service.

    .EXAMPLE
    Get-HPEGLRole -ServiceName "Compute Ops Management" -ServiceRole Administrator -ShowPermissions

    Return the list of permissions for the Administrator role of the Compute Ops Management service.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ComputeOpsManagement')]
    Param(        
        [Parameter (Mandatory, ParameterSetName = 'ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ApplicationName')]
        [String]$ServiceName,
    
        [Parameter (ParameterSetName = 'ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ApplicationName')]
        [String]$ServiceRole,

        [Parameter (ParameterSetName = 'ArubaCentral')]
        [Switch]$ArubaCentral,

        [Parameter (ParameterSetName = 'ArubaCentralRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ArubaCentral')]
        [ValidateSet ('Aruba Central Administrator', 'Aruba Central Guest Operator', 'Aruba Central Operator', 'Aruba Central view edit role', 'Aruba Central View Only', 'Netlnsight Campus Admin', 'Netlnsight Campus Viewonly')]
        [String]$ArubaCentralRole,

        [Parameter (ParameterSetName = 'ComputeOpsManagement')]
        [Switch]$ComputeOpsManagement,

        [Parameter (ParameterSetName = 'ComputeOpsManagementRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ComputeOpsManagement')]
        [ValidateSet ('Administrator', 'Observer', 'Operator')]
        [String]$ComputeOpsManagementRole,

        [Parameter (ParameterSetName = 'DataServices')]
        [Switch]$DataServices,

        [Parameter (ParameterSetName = 'DataServicesRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-DataServicesCloudConsole')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-DataServicesCloudConsole')]
        [ValidateSet ('Administrator', 'Backup and Recovery Administrator', 'Backup and Recovery Operator', 'Data Ops Manager Administrator', 'Data Ops Manager Operator', 'Disaster Recovery Admin', 'Read only')]
        [String]$DataServicesRole,

        [Parameter (ParameterSetName = 'HPEGreenLake')]
        [Switch]$HPEGreenLake,

        [Parameter (ParameterSetName = 'HPEGreenLakeRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-HPEGreenLake')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-HPEGreenLake')]
        [ValidateSet ('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$HPEGreenLakeRole,

        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-DataServicesCloudConsole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-HPEGreenLake')]
        [Switch]$ShowAssignedUsers,

        [Parameter (Mandatory, ParameterSetName = 'Permissions-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-DataServicesCloudConsole')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-HPEGreenLake')]
        [Switch]$ShowPermissions,

        [Switch]$WhatIf


 
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        # $Uri = $UsersRolesUri + $HPEGreenLakeSession.workspaceId + "/roles"
        # $Uri = $UsersRolesUri 

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ShowPermissions) {
            
            if ($ServiceName) {

                try {
                    $Service = Get-HPEGLService -Name $ServiceName | sort-object application_id -Unique 
                
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
    
                if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                    "[{0}] Service'{1}' not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
                    Return
                }
                else {

                    $Uri = $UsersRolesUri 

                    $ReturnData = @()
                    $PermissionsList = @()

        
                    try {
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($Null -ne $Collection.roles) {

                        $CollectionList = $Collection.roles | Where-Object application_name -eq $ServiceName       
                    
                        if ($ServiceRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ServiceRole
                        }

                        "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose


                        # If role name not found, then return
                        if (-Not $CollectionList) {
                            Return
                        }

                        $Slug = $CollectionList.slug 
                        $ServiceID = $CollectionList.application_id

                        "[{0}] Permission + ServiceName -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceID, $ServiceRole | Write-Verbose

    
                        # GET /ui-doorway/ui/v2/um/customers/roles/ccs.observer?application_id=00000000-0000-0000-0000-000000000000
                        $Uri = $UsersRolesUri + "/" + $Slug + "?application_id=" + $ServiceID

                        try {
                            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        if ($Null -ne $Collection.resource_policies) {

                            foreach ($ResourcePolicy in $Collection.resource_policies) {

                                if ($ResourcePolicy.resource.Name) {
                                    $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.name } }, @{N = "Permissions"; E = { $_.permissions.name } }
                                }
                                else {
                                    $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.matcher } }, @{N = "Permissions"; E = { $_.permissions.slug } }
                                }
                                $PermissionsList += $ReturnData 
                            }

                            $PermissionsList = $PermissionsList | Sort-Object application, rolename, resource
                            return $PermissionsList
                           
                        }

    
                                    
                    }
                    else {
                        return   
                    }

                } 

            }
        
            else {

                $Uri = $UsersRolesUri 

                $ReturnData = @()
                $PermissionsList = @()
        
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                   
                if ($Null -ne $Collection.roles) {

                    if ($ComputeOpsManagementRole) {
                        $ServiceName = "Compute Ops Management"
                    }
                    elseif ($DataServicesRole) { 
                        $ServiceName = "Data Services" 
                    }
                    elseif ($ArubaCentralRole) { 
                        $ServiceName = "Aruba Central" 
                    }
                    elseif ($HPEGreenLakeRole) { 
                        $ServiceName = "HPE GreenLake platform"
                    }

                        
                    $CollectionList = $Collection.roles | Where-Object application_name -eq $ServiceName

                    "[{0}] Roles for the service: '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, ($CollectionList | Out-String) | Write-Verbose

                    if ($ArubaCentralRole) {
                        
                        $CollectionList = $CollectionList | Where-Object name -eq $ArubaCentralRole
                        $ServiceRole = $ArubaCentralRole
                    }
                    if ($ComputeOpsManagementRole) {
                        
                        $CollectionList = $CollectionList | Where-Object name -eq $ComputeOpsManagementRole
                        $ServiceRole = $ComputeOpsManagementRole

                    } 
                        
                    if ($DataServicesRole) {
                        
                        $CollectionList = $CollectionList | Where-Object name -eq $DataServicesRole
                        $ServiceRole = $DataServicesRole

                    }
                    if ($HPEGreenLakeRole) {
    
                        $CollectionList = $CollectionList | Where-Object name -eq $HPEGreenLakeRole
                        $ServiceRole = $HPEGreenLakeRole

                    }
                            
                    "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose

                    
                    # If role name not found, then return
                    if (-Not $CollectionList) {
                        Return
                    }

                    $Slug = $CollectionList.slug 
                    $ServiceID = $CollectionList.application_id 

                    "[{0}] Permission + Predefined Role -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceID, $ServiceRole | Write-Verbose

    
                    # GET /ui-doorway/ui/v1/um/customers/roles/ccs.observer?application_id=00000000-0000-0000-0000-000000000000
                    $Uri = $UsersRolesUri + "/" + $Slug + "?application_id=" + $ServiceID

                    try {
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($Null -ne $Collection.resource_policies) {

                        foreach ($ResourcePolicy in $Collection.resource_policies) {

                            if ($ResourcePolicy.resource.Name) {
                                $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.name } }, @{N = "Permissions"; E = { $_.permissions.name } }
                            }
                            else {
                                $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.matcher } }, @{N = "Permissions"; E = { $_.permissions.slug } }
                            }
                            $PermissionsList += $ReturnData 
                        }

                        $PermissionsList = $PermissionsList | Sort-Object application, rolename, resource
                        return $PermissionsList
                           
                    }

    
                                    
                }
                else {
                    return   
                }
            }

        }
        else {

            $Uri = $UsersRolesUri 

            if ($ServiceName) {
            
                try {
                    $Service = Get-HPEGLService -Name $ServiceName 
                
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
    
                if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                    "[{0}] Service '{1}' not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
                    Return
                }
                else {
                
                    $ReturnData = @()
        
                    try {
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($Null -ne $Collection.roles) {

                        $CollectionList = $Collection.roles | Where-Object application_name -eq $ServiceName   
                        
                                            
                        if ($ServiceRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ServiceRole
   
                            "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose

                        }
                                  
                        if ($ShowAssignedUsers) {

                            $ServiceID = $CollectionList.application_id
                            $Slug = $CollectionList.slug
    
                            $Uri = $AuthzRolesUri + $HPEGreenLakeSession.workspaceId + "/applications/" + $ServiceID + "/roles/" + $Slug + "/user_assignments"
    
                            try {
                                [array]$UserCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }

                            "[{0}] AssignedUsers to roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose


                            if ($Null -ne $UserCollection.users) {
            
                                $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserCollection.users -ObjectName "User.Role.Assigned.Users"    
                                $ReturnData = $UserCollection.users | Sort-Object { $_.email }

                                return $ReturnData 

                                        
                            }
                            else {
                                return   
                            }
                        }

            
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Role"    

                        $ReturnData = $ReturnData | Sort-Object { $_.application_name, $_.name }

                        return $ReturnData 
                    }
                    else {

                        return
            
                    }
        
                }           
            }
            else {

                $ReturnData = @()
        
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
   
                if ($Null -ne $Collection.roles) {

                    $CollectionList = $Collection.roles 

                    if ($ComputeOpsManagement) {
                        $ServiceName = "Compute Ops Management"
                    }
                    elseif ($DataServices) { 
                        $ServiceName = "Data Services" 
                    }
                    elseif ($ArubaCentral) { 
                        $ServiceName = "Aruba Central" 
                    }
                    elseif ($HPEGreenLake) { 
                        # $Service = "Common Cloud Service" 
                        $ServiceName = "HPE GreenLake platform"

                    }


                    if ($ComputeOpsManagementRole) {
                        $ServiceName = "Compute Ops Management"
                        $ServiceRole = $ComputeOpsManagementRole

                    }
                    elseif ($DataServicesRole) { 
                        $ServiceName = "Data Services" 
                        $ServiceRole = $DataServicesRole

                    }
                    elseif ($ArubaCentralRole) { 
                        $ServiceName = "Aruba Central" 
                        $ServiceRole = $ArubaCentralRole

                    }
                    elseif ($HPEGreenLakeRole) { 
                        $ServiceName = "HPE GreenLake platform"
                        $ServiceRole = $HPEGreenLakeRole

                    }


                    if ($ServiceName) {

                        $CollectionList = $CollectionList | Where-Object application_name -eq $ServiceName

                        if ($ArubaCentralRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ArubaCentralRole
                        }
                        if ($ComputeOpsManagementRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ComputeOpsManagementRole
                        } 
                    
                        if ($DataServicesRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $DataServicesRole
                        }
                        if ($HPEGreenLakeRole) {

                            $CollectionList = $CollectionList | Where-Object name -eq $HPEGreenLakeRole
                        }

                        "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose

                        
                    }
                     
                    if ($ShowAssignedUsers) {

                        $ServiceID = $CollectionList.application_id
                        $Slug = $CollectionList.slug
    
                        $Uri = $AuthzRolesUri + $HPEGreenLakeSession.workspaceId + "/applications/" + $ServiceID + "/roles/" + $Slug + "/user_assignments"
    
                        try {
                            [array]$UserCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        "[{0}] AssignedUsers + Predefined Role -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceID, $ServiceRole | Write-Verbose


                        if ($Null -ne $UserCollection.users) {
            
                            $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserCollection.users -ObjectName "User.Role.Assigned.Users"    
                            $ReturnData = $UserCollection.users | Sort-Object { $_.email }

                            return $ReturnData 

                                        
                        }
                        else {
                            return   
                        }
                    }

            
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Role"    

                    $ReturnData = $ReturnData | Sort-Object { $_.application_name, $_.name }

                    return $ReturnData 
                }
                else {

                    return
            
                }
            }
        }
    }
}


Function Get-HPEGLUserRole {
    <#
    .SYNOPSIS
        View user roles in an HPE GreenLake workspace.

    .DESCRIPTION
        This Cmdlet lists the users' roles and permissions in an HPE GreenLake workspace. Roles are groups of permissions that grant access to users.

    .PARAMETER Email 
        The email address of the user for whom you want to obtain roles and permissions (can be retrieved using 'Get-HPEGLUser').

    .PARAMETER ServiceName 
        An optional parameter to display user roles and permissions for a specified service name (can be retrieved using 'Get-HPEGLService').
        
    .PARAMETER ShowPermissions 
        A switch to display the specific permissions assigned to a user.
    
    .PARAMETER WhatIf 
        Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com 

        Returns the user's roles for all services for which the user has privileges.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ShowPermissions

        Returns the user's permissions for all services for which the user has privileges.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ServiceName 'Compute Ops Management' 

        Returns the user's roles for the Compute Ops Management service.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ServiceName 'Data Services' -ShowPermissions

        Returns the user's permissions for the Data Services service.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ServiceName "Aruba Central"

        Returns the user's roles for the Aruba Central service.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Application')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'Application')]
        [Parameter (Mandatory, ParameterSetName = 'ApplicationInstance')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,
       
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "ApplicationInstance")]
        [ValidateNotNullOrEmpty()]
        [Alias('name')]
        [String]$ServiceName,

        [Parameter (ParameterSetName = 'Application')]
        [Parameter (ParameterSetName = 'ApplicationInstance')]
        [Switch]$ShowPermissions,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AuthzUsersRolesAssignmentsUri + $HPEGreenLakeSession.workspaceId + "/users/" + $Email.ToLower() + "/role_assignments"

    }

    Process {
       
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $User = Get-HPEGLUser -Email $Email
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if (-not $user) {
            Return
        }

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
     
        
        if ($Null -ne $Collection.roles) {
            
            $PermissionsList = @()
            
            if ($ServiceName) {
                
                try {
                    
                    $App = Get-HPEGLService -Name $ServiceName | sort-object application_id -Unique 
                    
                    "[{0}] Service '{1}' found: `n{2}!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $App | Write-Verbose

                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                                    
                if (-not $App -and $ServiceName -ne "HPE GreenLake platform") {
                    "[{0}] Service '{1}' not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
                    Throw "Error! Service name not found!"
                }

                if ($ServiceName -eq "HPE GreenLake platform") {

                    $ServiceID = "00000000-0000-0000-0000-000000000000"

                }
                else {
                    $ServiceID = $App.application_id

                }

                $UserRoles = $Collection.roles | Where-Object application_id -eq $ServiceID

                
            }
            else {
                $userRoles = $Collection.roles

            } 
            

            foreach ($UserRole in $UserRoles) {

                $UserFirstName = $Collection | ForEach-Object user_first_name
                $UserLastName = $Collection | ForEach-Object user_last_name
                $UserType = $Collection | ForEach-Object user_type

                $RoleName = $UserRole | ForEach-Object role_name
                $AppName = $UserRole | ForEach-Object application_name

                $AppID = $UserRole | ForEach-Object application_id
             
                $Slug = $UserRole | ForEach-Object slug
                    
                
                if ($ShowPermissions) {

                    "[{0}] Permission -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $AppName, $AppID, $RoleName | Write-Verbose
                   
                    try {
              
                        $ResourcePolicies = Get-HPEGLRole -ServiceName $AppName -ServiceRole $RoleName -ShowPermissions
              
                        $PermissionsList += $ResourcePolicies 

                        "[{0}] Resource Policies: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ResourcePolicies | Out-String) | Write-Verbose
                                          
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                }
                else {

                    if ($UserRole.resource_restriction_policies) {
                            
                        "[{0}] Resource Restriction policies found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-Verbose
                                                       
                        if ($UserRole.resource_restriction_policies.name -eq "Allscopes") {
                            $RRPName = "Full Access"

                        }
                        elseif (-not $UserRole.resource_restriction_policies.name ) {
                            $RRPName = "None"

                        }
                        else {
                            $RRPName = $UserRole.resource_restriction_policies.name 

                        }

                        $RRPDescription = $UserRole.resource_restriction_policies.description 
                        $ResourceRestrictionPolicyId = $UserRole.resource_restriction_policies.resource_restriction_policy_id
                          

                        $ReturnData = $UserRole | Select-Object `
                        @{N = "email"; E = { $Email } }, `
                        @{N = "user_first_name"; E = { $UserFirstName } }, `
                        @{N = "user_last_name"; E = { $UserLastName } }, `
                        @{N = "user_type"; E = { $UserType } }, `
                        @{N = "application_name"; E = { $AppName } }, `
                        @{N = "application_id"; E = { $AppID } }, `
                        @{N = "resource_restriction_policy_description"; E = { $RRPDescription } }, `
                        @{N = "resource_restriction_policy_id"; E = { $ResourceRestrictionPolicyId } }, `
                        @{N = "role"; E = { $Rolename } }, `
                        @{N = "resource_restriction_policy"; E = { $RRPName } }, `
                        @{N = "slug"; E = { $Slug } }

                        $PermissionsList += $ReturnData 
                            
                    }
                    else {

                        $RRPName = "None"
              
                        $ReturnData = $UserRole | Select-Object `
                        @{N = "email"; E = { $Email } }, `
                        @{N = "user_first_name"; E = { $UserFirstName } }, `
                        @{N = "user_last_name"; E = { $UserLastName } }, `
                        @{N = "user_type"; E = { $UserType } }, `
                        @{N = "application_name"; E = { $AppName } }, `
                        @{N = "application_id"; E = { $AppID } }, `
                        @{N = "resource_restriction_policy_description"; E = { $Null } }, `
                        @{N = "resource_restriction_policy_id"; E = { $Null } }, `
                        @{N = "role"; E = { $Rolename } }, `
                        @{N = "resource_restriction_policy"; E = { $RRPName } }, `
                        @{N = "slug"; E = { $Slug } }

                        $PermissionsList += $ReturnData 

                    }
                }
            }

            if (-not $ShowPermissions) {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $PermissionsList -ObjectName "User.Role"         
                $ReturnData = $ReturnData | sort-object application_name, role

            }
            else {
                
                $ReturnData = $PermissionsList

            }
            

            return $ReturnData
           
        }

        else {
            return
        }
    }
}


Function Add-HPEGLRoleToUser {
    <#
    .SYNOPSIS
    Assign a role to a user.

    .DESCRIPTION
    This cmdlet assigns roles and permissions to a user in an HPE GreenLake workspace. Roles are collections of permissions that grant users access to various HPE GreenLake services.

    Roles are assigned to a service across all regions. To further restrict the scope of resources a user role can access, you can use the resource restriction policy feature with 'Set-HPEGLResourceRestrictionPolicy'.

    .PARAMETER Email 
    Email address of the user for whom you want to set roles and permissions (can be retrieved using 'Get-HPEGLUser').

    .PARAMETER ArubaCentralRole 
    Name of the Aruba Central role to add to the user's roles. 
    The predefined roles are as follows:
    - Aruba Central Administrator  
    - Aruba Central Guest Operator
    - Aruba Central Operator
    - Aruba Central View Edit Role
    - Aruba Central View Only
    - Netlnsight Campus Admin
    - Netlnsight Campus Viewonly

    .PARAMETER ComputeOpsManagementRole 
    Name of the Compute Ops Management role to add to the user's roles. 
    The predefined roles are as follows:
    - Administrator
    - Observer
    - Operator

    .PARAMETER DataServicesRole 
    Name of the Data Services role to add to the user's roles. 
    The predefined roles are as follows:
    - Administrator
    - Backup and Recovery Administrator
    - Backup and Recovery Operator
    - Data Ops Manager Administrator
    - Data Ops Manager Operator
    - Disaster Recovery Admin
    - Read Only

    .PARAMETER HPEGreenLakeRole 
    Name of the HPE GreenLake role to add to the user's roles. 
    The predefined roles are as follows:
    - Workspace Administrator
    - Workspace Observer
    - Workspace Operator
    - Orders Administrator
    - Orders Observer
    - Orders Operator

    .PARAMETER ServiceName 
    Name of the service to which the role name will be assigned (can be retrieved using 'Get-HPEGLRole').   
        
    .PARAMETER RoleName 
    Name of the role of a service to be assigned to the user (can be retrieved using 'Get-HPEGLRole').   

    .PARAMETER ResourceRestrictionPolicyName 
    Specifies the name of a resource restriction policy to further limit the scope of resources accessible by the user (can be retrieved using 'Get-HPEGLResourceRestrictionPolicy').

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLRoleToUser -Email richardfeynman@quantummechanics.lab -ComputeOpsManagementRole Observer 

    Adds the Observer role to richardfeynman@quantummechanics.lab for the "Compute Ops Management" service.

    .EXAMPLE
    Add-HPEGLRoleToUser -Email richardfeynman@quantummechanics.lab -ServiceName "Data Services" -RoleName "Backup and Recovery Administrator"

    Adds the Backup and Recovery Administrator role to richardfeynman@quantummechanics.lab for the "Data Services" service.

    .EXAMPLE
    "richardfeynman@quantummechanics.lab", "alexandreliapounov@math.edu" | Add-HPEGLRoleToUser -ComputeOpsManagementRole Administrator 

    Adds the Administrator role to richardfeynman@quantummechanics.lab and alexandreliapounov@math.edu for the "Compute Ops Management" service.

    .EXAMPLE
    $AdministratorUserEmails = @("richardfeynman@quantummechanics.lab","alexandreliapounov@math.edu")
    $AdministratorUserEmails | Add-HPEGLRoleToUser -ComputeOpsManagementRole Administrator

    Adds the Administrator role to the users in the $AdministratorUserEmails array for the "Compute Ops Management" service.

    .EXAMPLE
    Get-HPEGLUser | Where-Object email -match "quantummechanics" | Add-HPEGLRoleToUser -ArubaCentralRole 'Aruba Central Administrator'

    Adds the Aruba Central Administrator role to all users whose email addresses contain the string 'quantummechanics'.

    .EXAMPLE
    Add-HPEGLRoleToUser -Email alexandreliapounov@math.edu -ComputeOpsManagementRole 'Administrator' -ResourceRestrictionPolicyName 'RRP_COM-Location-Texas'

    Adds the Administrator role to alexandreliapounov@math.edu for the "Compute Ops Management" service, limiting the scope of accessible resources to the Texas location using the resource restriction policy named 'RRP_COM-Location-Texas'.
      
    .INPUTS
    System.Collections.ArrayList
        List of users from 'Get-HPEGLUser'.        
    System.String, System.String[]
        A single string object or a list of string objects that represent the email addresses.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        - Email: Email of the user 
        - Role: Name of the role to add 
        - Service: Name of the service 
        - ResourceRestrictionPolicyName: Name of the resource restriction policy to assign
        - Status: Status of the role assignment attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed) 
        - Details: More information about the status 
        - Exception: Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'ComputeOpsManagement')]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName , ParameterSetName = 'ArubaCentral')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName , ParameterSetName = 'HPEGreenLake')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName , ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName , ParameterSetName = 'DataServices')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName , ParameterSetName = 'Other')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,
       
        [Parameter (Mandatory, ParameterSetName = 'ArubaCentral')]
        [ValidateSet ('Aruba Central Administrator', 'Aruba Central Guest Operator', 'Aruba Central Operator', 'Aruba Central view edit role', 'Aruba Central View Only', 'Netlnsight Campus Admin', 'Netlnsight Campus Viewonly')]
        [String]$ArubaCentralRole,

        [Parameter (Mandatory, ParameterSetName = 'HPEGreenLake')]
        [ValidateSet ('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$HPEGreenLakeRole,

        [Parameter (Mandatory, ParameterSetName = 'ComputeOpsManagement')]
        [ValidateSet ('Administrator', 'Observer', 'Operator')]
        [String]$ComputeOpsManagementRole,

        [Parameter (Mandatory, ParameterSetName = 'DataServices')]
        [ValidateSet ('Administrator', 'Backup and Recovery Administrator', 'Backup and Recovery Operator', 'Data Ops Manager Administrator', 'Data Ops Manager Operator', 'Disaster Recovery Admin', 'Read only')]
        [String]$DataServicesRole,

        [Parameter (Mandatory, ParameterSetName = 'Other')]
        [String]$ServiceName,

        [Parameter (Mandatory, ParameterSetName = 'Other')]
        [String]$RoleName,

        [Parameter (ParameterSetName = 'ArubaCentral')]
        [Parameter (ParameterSetName = 'HPEGreenLake')]
        [Parameter (ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (ParameterSetName = 'DataServices')]
        [Parameter (ParameterSetName = 'Other')]
        [String]$ResourceRestrictionPolicyName,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        
        $UserRoleAssignmentStatus = [System.Collections.ArrayList]::new()
        
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        $Uri = $AuthzUsersRolesUri + $Email.ToLower() + "/roles"

        # Test if user present
        try {
            $User = (Get-HPEGLUser).contact | Where-Object email -eq $Email
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email                         = $Email
            Role                          = $Null
            Service                       = $Null
            ResourceRestrictionPolicyName = $Null
            Status                        = $Null
            Details                       = $Null
            Exception                     = $Null
                  
        }
        
        if (-not $User) {
            # Must return a message if user not found
            "[{0}] User '{1}' not found." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

            if ($Whatif) {
                $ErrorMessage = "User '{0}': Resource cannot be found in the workspace!" -f $Email
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "User cannot be found in the workspace!"
                $objStatus.Service = $ServiceName
                    
            }

            
        }
        
        ############## If RoleName / ServiceName ##############
        elseif ($RoleName) {

            $objStatus.Role = $RoleName
            $objStatus.Service = $ServiceName

            try {
                $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique

                $ServiceID = $Service.application_id
                
            }
            catch {    
                $PSCmdlet.ThrowTerminatingError($_)

            }

            # If ServiceName not found except if GreenLake service
            if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                # Must return a message if Service is not provisioned in the region
                "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
    
                if ($Whatif) {
                    $ErrorMessage = "Service '{0}': Resource is not provisioned in any region!" -f $ServiceName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service not provisioned in any region!"
                    $objStatus.Service = $ServiceName
                               
                }

    
            }

            # If ServiceName 
            else {

                # Role already assigned?                       
                try {

                    $AppRoles = Get-HPEGLRole -ServiceName $ServiceName 
                    $AppRole = $AppRoles | Where-Object name -eq $RoleName
                    $Slug = $AppRole.slug
                              
                    "[{0}] role '{1}' found for '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolename, $ServiceName | Write-Verbose
                    "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose

                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                # If service role found
                if ( $AppRole) {
                    
                    try {

                        $ExistingUserRoles = Get-HPEGLUserRole -Email $email

                        $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName

                        $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName

                        # Check if RRP name already assigned to the role
                        $RRPAlreadyAssigned = $Rolefound.resource_restriction_policy


                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }


                    # Role found without RRP parameter = ERROR
                    if ($Rolefound -and -not $ResourceRestrictionPolicyName) {

                        # Must return a message if Rolename is already assigned
                        "[{0}] Role name '{1}' is already assigned to this user!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName | Write-Verbose
    
                        if ($Whatif) {
                            $ErrorMessage = "Service role '{0}': Resource is already assigned to this user!" -f $RoleName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Warning"
                            $objStatus.Details = "Service role name is already assigned to this user!"
                            
                        }                      

                    }

                    
                    # Role found with RRP parameter = MODIFICATION
                    elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                        $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                        try {
                            $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
        
                        }
                        catch {    
                            $PSCmdlet.ThrowTerminatingError($_)

                        }


                        # Check if RRP is available
                        try {
                            $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        if ($RRP) {
                   
                            $ResourceRestrictionPolicyIDToSet = $RRP.resource_restriction_policy_id

                            # If RRP name not already assigned to the role: Overwrite needed !
                            if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                                $RolesList = [System.Collections.ArrayList]::new()
                
                                foreach ($ExistingUserRole in $ExistingUserRoles) {
                 
                                    $Slug = $ExistingUserRole.slug
                                    $ServiceID = $ExistingUserRole.application_id
                 
                                    # If ExistingUserRole is not the one we want to modify with new RRP, we capture existing RRP
                                    if ($ExistingUserRole.resource_restriction_policy) {

                                        $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                                        # If ExistingUserRole is the one we want to modify with new RRP
                                        if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                        
                                            $ResourceRestrictionPolicyID = $ResourceRestrictionPolicyIDToSet
                      
                                        }
                        
                                        $Role = [PSCustomObject]@{
                                            role                          = @{  
                                                slug           = $Slug
                                                application_id = $ServiceID
                                            }
                                            resource_restriction_policies = @(
                                                $ResourceRestrictionPolicyID
                                            )
                                        }

                                    }
                                    else {                                
                  
                                        $Role = [PSCustomObject]@{
                                            role                          = @{  
                                                slug           = $Slug
                                                application_id = $ServiceID
                                            }
                                            resource_restriction_policies = @( )
                                        }
                                    }

                                    $RolesList += $Role

                                }
                

                                # Build payload
                                $Payload = [PSCustomObject]@{ overwrite = @( 
                                        $RolesList
                                    )
                                } | ConvertTo-Json -Depth 5
                

                                # Set user role with RRP      
                                try {
                                    Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                                    if (-not $WhatIf) {

                                        "[{0}] Role '{1}' with resource restriction policy '{2}' successfully set for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                                        $objStatus.Status = "Complete"
                                        $objStatus.Details = "Resource restriction policy successfully set!"
                                        $objStatus.Service = $ServiceName

                                    }

                                }
                                catch {
                                    if (-not $WhatIf) {
                                        $objStatus.Status = "Failed"
                                        $objStatus.Details = "Resource restriction policy cannot be set!"
                                        $objStatus.Exception = $_.Exception.message 
                                        $objStatus.Service = $ServiceName
                                    }
                                }

                            }
                            # If RRP name already assigned to the role
                            else {
                                # Must return a message if RRP name is already assigned to the role
                                "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                if ($Whatif) {
                                    $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                    Write-warning $ErrorMessage
                                    return
                                }
                                else {
                                    $objStatus.Status = "Warning"
                                    $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                    
                                }

                            }
                        }
                        else {
                            # Must return a message if RRP name is not found in the region
                            "[{0}] Resource restriction policy name '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                            if ($Whatif) {
                                $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                                Write-warning $ErrorMessage
                                return
                            }
                            else {
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                                
                            }
         
                        } 
                    }

                    # Role not found without RRP parameter = CREATION
                    # Role not found with RRP parameter = CREATION
                    elseif (-not $Rolefound) {    

                        $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                        if ($ServiceName -eq "HPE GreenLake platform") {
                            $ServiceID = "00000000-0000-0000-0000-000000000000"
                        }
                        else {
                            $ServiceID = $Service.application_id
                        }

                        # If not RRP
                        if (-Not $ResourceRestrictionPolicyName) {

                            # Build payload
                            $Payload = [PSCustomObject]@{ add = @( 
                                    @{ 
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = $Null
                                    
                                    }
    
                                )
                            } | ConvertTo-Json -Depth 5

                            # Set user roles without RRP       
                            try { 
                                Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                                
                                if (-not $WhatIf) {

                                    "[{0}] Role '{1}' successfully assigned to user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                                    $objStatus.Status = "Complete"
                                    $objStatus.Details = "Role successfully assigned!"
                                    $objStatus.Service = $ServiceName

                                }
                            }
                            catch {
                                if (-not $WhatIf) {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Role cannot be assigned to user!"
                                    $objStatus.Exception = $_.Exception.message 
                                    $objStatus.Service = $ServiceName
                                }
                            }

                        }
                        # If RRP
                        else {

                            $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                            # Check if RRP is available

                            try {
                                $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }
                            # If RRP name found
                            if ($RRP) {
                               
                                $ResourceRestrictionPolicyID = $RRP.resource_restriction_policy_id

                                # Check if RRP name already assigned to the role

                                try {
                                    $RRPAlreadyAssigned = ($ServiceNameUserRoles | Where-Object role -eq $RoleName).resource_restriction_policy
                                }
                                catch {
                                    $PSCmdlet.ThrowTerminatingError($_)
                                }


                                if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                                    # Build payload
                                    $Payload = [PSCustomObject]@{ add = @( 
                                            @{ 
                                                role                          = @{  
                                                    slug           = $Slug
                                                    application_id = $ServiceID
                                                }
                                                resource_restriction_policies = @(
                                                    $ResourceRestrictionPolicyID
                                                )
                                            }
        
                                        )
                                    } | ConvertTo-Json -Depth 5
                        
                                    # Set user roles with RRP    
                                    try { 
                                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                                    
                                        if (-not $WhatIf) {

                                            "[{0}] Role '{1}' successfully assigned to user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                                            $objStatus.Status = "Complete"
                                            $objStatus.Details = "Role successfully assigned!"
                                            $objStatus.Service = $ServiceName

                                        }
                                    }
                                    catch {
                                        if (-not $WhatIf) {
                                            $objStatus.Status = "Failed"
                                            $objStatus.Details = "Role cannot be assigned to user!"
                                            $objStatus.Exception = $_.Exception.message 
                                            $objStatus.Service = $ServiceName
                                        }
                                    }
                                }
                                else {
                                    # Must return a message if RRP name is already assigned to the role
                                    "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                    if ($Whatif) {
                                        $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                        Write-warning $ErrorMessage
                                        return
                                    }
                                    else {
                                        $objStatus.Status = "Warning"
                                        $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                        
                                    }

                
                                }
                            
                            }
                            # If not RRP name not found
                            else {
                                # Must return a message if RRP name is not found in the region
                                "[{0}] Resource restriction policy nam '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose
    
                                if ($Whatif) {
                                    $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                                    Write-warning $ErrorMessage
                                    return
                                }
                                else {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                                    
                                }

                              
                            }
                        }
                    }
                }
                # If role not found
                else {
                    # Must return a message if Rolename is not found
                    "[{0}] Role name '{1}' cannot be found for service '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ServiceName | Write-Verbose
    
                    if ($Whatif) {
                        $ErrorMessage = "Role '{0}' cannot be found for service '{1}'!" -f $RoleName, $ServiceName
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Role name cannot be found for this service!"
                        $objStatus.Service = $ServiceName
                        
                    }

                }            
            }
            
        }

        ############## If Predefined roles (i.e. -ComputeOpsManagementRole, etc.) ##############
        else {

            try {
                $ExistingUserRoles = Get-HPEGLUserRole -Email $email
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }


            # Role already assigned?
            if ($MyInvocation.BoundParameters["ArubaCentralRole"] ) {
            
                $ServiceName = "Aruba Central"
                $Rolename = $ArubaCentralRole
            
            }
            elseif ($MyInvocation.BoundParameters["HPEGreenLakeRole"] ) {
            
                $ServiceName = "HPE GreenLake platform"
                $Rolename = $HPEGreenLakeRole
            
            }
            elseif ($MyInvocation.BoundParameters["ComputeOpsManagementRole"] ) {

                $ServiceName = "Compute Ops Management"
                $Rolename = $ComputeOpsManagementRole
            
            }
            elseif ($MyInvocation.BoundParameters["DataServicesRole"] ) {
            
                $ServiceName = "Data Services"
                $Rolename = $DataServicesRole

            }

            $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName
            $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName

            $objStatus.Role = $Rolename
            $objStatus.Service = $ServiceName
        
            # Role found without RRP parameter = ERROR
            if ($Rolefound -and -not $ResourceRestrictionPolicyName) {
        
                # Must return a message if Rolename is already assigned
                "[{0}] Role name '{1}' is already assigned to this user!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName | Write-Verbose
        
                if ($Whatif) {
                    $ErrorMessage = "Service role '{0}' is already assigned to this user!" -f $RoleName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "Service role name is already assigned to this user!"
                    $objStatus.Service = $ServiceName
                    
                }


            }

            # Role found with RRP parameter = MODIFICATION
            elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                # Get slug
                try {
                    $Slug = (Get-HPEGLRole -ServiceName $ServiceName -ServiceRole $RoleName).slug
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose
                

                try {
                    $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique

                    $ServiceID = $Service.application_id

                    
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }

                if (-not $Service) {
                    # Must return a message if Service is not provisioned in the region
                    "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
        
                    if ($Whatif) {
                        $ErrorMessage = "Service '{0}' is not provisioned in a region!" -f $ServiceName
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Service not provisioned in a region!"
                        $objStatus.Service = $ServiceName
                        
                    }

        
                }
                else {

                    # Check if RRP is available

                    try {
                        $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($RRP) {
                               
                        $ResourceRestrictionPolicyIDToSet = $RRP.resource_restriction_policy_id

                        # Check if RRP name already assigned to the role
                        $RRPAlreadyAssigned = $Rolefound.resource_restriction_policy

                        # If RRP name not already assigned to the role: Overwrite needed !
                        if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                            $RolesList = [System.Collections.ArrayList]::new()
                            
                            foreach ($ExistingUserRole in $ExistingUserRoles) {
                             
                                $Slug = $ExistingUserRole.slug
                                $ServiceID = $ExistingUserRole.application_id
                             
                                # If ExistingUserRole is not the one we want to modify with new RRP, we capture existing RRP
                                if ($ExistingUserRole.resource_restriction_policy) {

                                    $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                                    # If ExistingUserRole is the one we want to modify with new RRP
                                    if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                                    
                                        $ResourceRestrictionPolicyID = $ResourceRestrictionPolicyIDToSet
                                  
                                    }
                                    
                                    $Role = [PSCustomObject]@{
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = @(
                                            $ResourceRestrictionPolicyID
                                        )
                                    }

                                }
                                else {                                
                              
                                    $Role = [PSCustomObject]@{
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = @( )
                                    }
                                }

                                $RolesList += $Role

                            }
                            

                            # Build payload
                            $Payload = [PSCustomObject]@{ overwrite = @( 
                                    $RolesList
                                )
                            } | ConvertTo-Json -Depth 5
                            

                            # Set user role with RRP      
                            try {
                                Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                                if (-not $WhatIf) {

                                    "[{0}] Role '{1}' with resource restriction policy '{2}' successfully set for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                                    $objStatus.Status = "Complete"
                                    $objStatus.Details = "Resource restriction policy successfully set!"
                                    $objStatus.Service = $ServiceName

                                }

                            }
                            catch {
                                if (-not $WhatIf) {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Resource restriction policy cannot be set!"
                                    $objStatus.Exception = $_.Exception.message 
                                    $objStatus.Service = $ServiceName
                                }
                            }

                        }
                        # If RRP name already assigned to the role
                        else {
                            # Must return a message if RRP name is already assigned to the role
                            "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                            if ($Whatif) {
                                $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                Write-warning $ErrorMessage
                                return
                            }
                            else {
                                $objStatus.Status = "Warning"
                                $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                
                            }

                        }
                    }
                    else {
                        # Must return a message if RRP name is not found in the region
                        "[{0}] Resource restriction policy name '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                        if ($Whatif) {
                            $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                            
                        }
                    }
                }
            }
            
            # Role not found without RRP parameter = CREATION
            # Role not found with RRP parameter = CREATION
            elseif (-not $Rolefound) {   

                $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                # Get slug
                try {
                    $Slug = (Get-HPEGLRole -ServiceName $ServiceName -ServiceRole $RoleName).slug
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose
                
                # If all apps except GreenLake service
                if (-not $MyInvocation.BoundParameters["HPEGreenLakeRole"]) {

                    try {
                        $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
                    
                    }
                    catch {    
                        $PSCmdlet.ThrowTerminatingError($_)
    
                    }

                    if (-not $Service) {
                        # Must return a message if Service is not provisioned in the region
                        "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
        
                        if ($Whatif) {
                            $ErrorMessage = "Service '{0}' is not provisioned in a region!" -f $ServiceName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Service not provisioned in a region!"
                            $objStatus.Service = $ServiceName
                            
                        }       
        
                    }
                    else {

                        $ServiceID = $Service.application_id
                        
                        # If not RRP
                        if (-Not $ResourceRestrictionPolicyName) {

                            # Build payload
                            $Payload = [PSCustomObject]@{ add = @( 
                                    @{ 
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = $Null
                                    
                                    }
    
                                )
                            } | ConvertTo-Json -Depth 5

                            # Set user roles without RRP       
                            try { 
                                Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                                
                                if (-not $WhatIf) {

                                    "[{0}] Role '{1}' successfully assigned to user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                                    $objStatus.Status = "Complete"
                                    $objStatus.Details = "Role successfully assigned!"
                                    $objStatus.Service = $ServiceName

                                }
                            }
                            catch {
                                if (-not $WhatIf) {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Role cannot be assigned to user!"
                                    $objStatus.Exception = $_.Exception.message 
                                    $objStatus.Service = $ServiceName
                                }
                            }

                        }
                        
                        # If RRP
                        else {

                            $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                            # Check if RRP is available

                            try {
                                $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }

                            if ($RRP) {
                               
                                $ResourceRestrictionPolicyID = $RRP.resource_restriction_policy_id

                                # Check if RRP name already assigned to the role

                                try {
                                    $RRPAlreadyAssigned = (Get-HPEGLUserRole -Email $email -ServiceName $ServiceName | Where-Object role -eq $RoleName).resource_restriction_policy
                                }
                                catch {
                                    $PSCmdlet.ThrowTerminatingError($_)
                                }

                                # If RRP name not already assigned to the role
                                if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                                    # Build payload
                                    $Payload = [PSCustomObject]@{ add = @( 
                                            @{ 
                                                role                          = @{  
                                                    slug           = $Slug
                                                    application_id = $ServiceID
                                                }
                                                resource_restriction_policies = @(
                                                    $ResourceRestrictionPolicyID
                                                )
                                            }
        
                                        )
                                    } | ConvertTo-Json -Depth 5
                            

                                    # Set user role with RRP      
                                    try {
                                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                                        if (-not $WhatIf) {

                                            "[{0}] Role '{1}' successfully assigned to user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $Email | Write-Verbose

                                            $objStatus.Status = "Complete"
                                            $objStatus.Details = "Role successfully assigned!"
                                            $objStatus.Service = $ServiceName

                                        }

                                    }
                                    catch {
                                        if (-not $WhatIf) {
                                            $objStatus.Status = "Failed"
                                            $objStatus.Details = "Role cannot be assigned to user!"
                                            $objStatus.Exception = $_.Exception.message 
                                            $objStatus.Service = $ServiceName
                                        }
                                    }

                                }
                                # If RRP name already assigned to the role
                                else {
                                    # Must return a message if RRP name is already assigned to the role
                                    "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                    if ($Whatif) {
                                        $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                        Write-warning $ErrorMessage
                                        return
                                    }
                                    else {
                                        $objStatus.Status = "Warning"
                                        $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                        
                                    }
                    
                                }
                            }
                            else {
                                # Must return a message if RRP name is not found in the region
                                "[{0}] Resource restriction policy name '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                if ($Whatif) {
                                    $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                                    Write-warning $ErrorMessage
                                    return
                                }
                                else {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                                    
                                }
                
                      
                            }
                        }
                    }
                }

                # If GreenLake service
                else {

                    $ServiceID = "00000000-0000-0000-0000-000000000000"

                    # Build payload

                    # No resource restriction policy exists for HPE GreenLake = "HPE GreenLake platform"

                    # Build payload
                    $Payload = [PSCustomObject]@{ add = @( 
                            @{ 
                                role                          = @{  
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                                resource_restriction_policies = $Null
                                
                            }

                        )
                    } | ConvertTo-Json -Depth 5

                    # Set user roles without RRP       
                    try { 
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                            
                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' successfully assigned to user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Role successfully assigned!"
                            $objStatus.Service = $ServiceName

                        }
                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Role cannot be assigned to user!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }

                               
                }
            }
        }

        [void] $UserRoleAssignmentStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($UserRoleAssignmentStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more users failed the role assignment attempt!"
                
          
            }

            $UserRoleAssignmentStatus = Invoke-RepackageObjectWithType -RawObject $UserRoleAssignmentStatus -ObjectName "User.Role.ERSRSDE" 
            Return $UserRoleAssignmentStatus
        }


    }
}


Function Remove-HPEGLRoleFromUser {
    <#
    .SYNOPSIS
    Removes a role from a user.

    .DESCRIPTION
    This Cmdlet removes roles and permissions from users in an HPE GreenLake workspace. 
    Roles are collections of permissions that provide users access to HPE GreenLake services.

    Roles are unassigned from a service across all regions.

    .PARAMETER Email 
    Email address of the user for whom you want to remove roles and permissions (can be retrieved using Get-HPEGLUser).    

    .PARAMETER ArubaCentralRole 
    Name of the Aruba Central role to remove from the user's roles. 
    The predefined roles are as follows:
        * Aruba Central Administrator  
        * Aruba Central Guest Operator
        * Aruba Central Operator
        * Aruba Central view edit role
        * Aruba Central View Only
        * Netlnsight Campus Admin
        * Netlnsight Campus Viewonly

    .PARAMETER ComputeOpsManagementRole 
    Name of the Compute Ops Management role to remove from the user's roles. 
    The predefined roles are as follows:
        * Administrator
        * Observer
        * Operator

    .PARAMETER DataServicesRole 
    Name of the Data Services role to remove from the user's roles. 
    The predefined roles are as follows:
        * Administrator
        * Backup and Recovery Administrator
        * Backup and Recovery Operator
        * Data Ops Manager Administrator
        * Data Ops Manager Operator
        * Disaster Recovery Admin
        * Read only

    .PARAMETER HPEGreenLakeRole 
    Name of the HPE GreenLakeRole role to remove from the user's roles. 
    The predefined roles are as follows:
        * Workspace Administrator
        * Workspace Observer
        * Workspace Operator
        * Orders Administrator
        * Orders Observer
        * Orders Operator

    .PARAMETER RoleName 
    Role name of a service to be unassigned (can be retrieved using Get-HPEGLUserRole).   
        
    .PARAMETER ServiceName 
    Name of the service to which the role name will be unassigned (can be retrieved using Get-HPEGLUserRole).   

    .PARAMETER ResourceRestrictionPolicyName 
    Name of a resource restriction policy to be removed (can be retrieved with Get-HPEGLUserRole ).  

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLRoleFromUser -Email richardfeynman@quantummechanics.lab -ComputeOpsManagementRole Observer 

    Removes the Observer role to richardfeynman@quantummechanics.lab for the "Compute Ops Management" service.

    .EXAMPLE
    Remove-HPEGLRoleFromUser -Email richardfeynman@quantummechanics.lab -ServiceName "Aruba Central" -RoleName 'Aruba Central Administrator'

    Removes the Aruba Central Administrator role to richardfeynman@quantummechanics.lab for the "Aruba Central" service.
  
    .EXAMPLE
    "richardfeynman@quantummechanics.lab", "alexandreliapounov@math.edu" | Remove-HPEGLRoleFromUser -ComputeOpsManagementRole Administrator 

    Removes the Administrator role to richardfeynman@quantummechanics.lab and alexandreliapounov@math.edu for the "Compute Ops Management" service.

    .EXAMPLE
    $AdministratorUserEmails = @("richardfeynman@quantummechanics.lab","alexandreliapounov@math.edu")
    $AdministratorUserEmails | Remove-HPEGLRoleFromUser -ComputeOpsManagementRole Administrator
  
    Removes the Administrator role to the users in the $AdministratorUserEmails array for the "Compute Ops Management" service.

    .EXAMPLE
    Get-HPEGLUser | Where-Object email -match "quantummechanics" | Remove-HPEGLRoleFromUser -DataServicesRole Administrator

    Removes the Data Service Administrator role to all users whose email addresses contain the string 'quantummechanics'.

    .EXAMPLE
    Get-HPEGLUserRole -Email richardfeynman@quantummechanics.lab -ServiceName "Compute Ops Management" | Remove-HPEGLRoleFromUser

    Removes all Compute Ops Management roles for the user richardfeynman@quantummechanics.lab

    .EXAMPLE
    Remove-HPEGLRoleFromUser -Email richardfeynman@quantummechanics.lab -ComputeOpsManagementRole Administrator -ResourceRestrictionPolicyName RRP_COM-Location-Texas

    Removes the resource restriction policy named 'RRP_COM-Location-Texas' to the user Alexandre Liapounov for the "Compute Ops Management" service with the Administrator role. 
        
    .INPUTS
    System.Collections.ArrayList          
        List of roles from 'Get-HPEGLUserRole'.        
    System.Collections.ArrayList
        List of users from 'Get-HPEGLUser'.      
    System.String, System.String[]
        A single string object or a list of string objects that represent the email addresses.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - Email of the user 
        * Role - Name of the role to remove 
        * Service - Name of the service 
        * ResourceRestrictionPolicyName - Name of the resource restriction policy to remove
        * Status - Status of the role unassignment attempt (Failed for http error return; Complete if successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ComputeOpsManagement')]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ArubaCentral')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'HPEGreenLake')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'DataServices')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,
      
        [Parameter (Mandatory, ParameterSetName = 'ArubaCentral')]
        [ValidateSet ('Aruba Central Administrator', 'Aruba Central Guest Operator', 'Aruba Central Operator', 'Aruba Central view edit role', 'Aruba Central View Only', 'Netlnsight Campus Admin', 'Netlnsight Campus Viewonly')]
        [String]$ArubaCentralRole,

        [Parameter (Mandatory, ParameterSetName = 'HPEGreenLake')]
        [ValidateSet ('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$HPEGreenLakeRole,

        [Parameter (Mandatory, ParameterSetName = 'ComputeOpsManagement')]
        [ValidateSet ('Administrator', 'Observer', 'Operator')]
        [String]$ComputeOpsManagementRole,

        [Parameter (Mandatory, ParameterSetName = 'DataServices')]
        [ValidateSet ('Administrator', 'Backup and Recovery Administrator', 'Backup and Recovery Operator', 'Data Ops Manager Administrator', 'Data Ops Manager Operator', 'Disaster Recovery Admin', 'Read only')]
        [String]$DataServicesRole,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [Alias('Application_name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [Alias('Role')]
        [String]$RoleName,

        [Parameter (ParameterSetName = 'ArubaCentral')]
        [Parameter (ParameterSetName = 'HPEGreenLake')]
        [Parameter (ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (ParameterSetName = 'DataServices')]
        [Parameter (ParameterSetName = 'Other')]
        [String]$ResourceRestrictionPolicyName,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $UserRoleUnassignmentStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        $Uri = $AuthzUsersRolesUri + $Email.ToLower() + "/roles"


        # Test if user present
        try {
            
            $User = (Get-HPEGLUser).contact | Where-Object email -eq $Email
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email                         = $Email
            Role                          = $Null
            Service                       = $Null
            ResourceRestrictionPolicyName = $Null
            Status                        = $Null
            Details                       = $Null
            Exception                     = $Null
                  
        }
        
        if (-not $User) {
            # Must return a message if user not found
            "[{0}] User '{1}' not found." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "User '{0}': Resource cannot be found in the workspace!" -f $Email
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "User cannot be found in the workspace!"
            }
    
            $objStatus.Service = $ServiceName
            
        }

        ############### If RoleName / ServiceName ###############
        elseif ($RoleName) {

            $objStatus.Role = $RoleName
            $objStatus.Service = $ServiceName


            try {
                $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
                
            }
            catch {    
                $PSCmdlet.ThrowTerminatingError($_)

            }
            # If ServiceName not found except if GreenLake service
            if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                # Must return a message if Service is not provisioned in the region
                "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Service '{0}' is not provisioned in any region!" -f $ServiceName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service is not provisioned in any region!"
                }
        
                $objStatus.Service = $ServiceName
    
            }
            else {
                
                # Role assigned?  
                try {
                   
                    $ExistingUserRoles = Get-HPEGLUserRole -Email $email

                    $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName

                    $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName

                    $Slug = $Rolefound.slug

                    "[{0}] Rolefound = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolefound | write-verbose

                 

                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                # Role found but not RRP modification = DELETE
                if ( $Rolefound -and -not $ResourceRestrictionPolicyName) {

                    "[{0}] Role '{1}' found for '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolename, $ServiceName | Write-Verbose
                    "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose


                    if ($ServiceName -eq "HPE GreenLake platform") {

                        $ServiceID = "00000000-0000-0000-0000-000000000000"

                    }
                    else {
                        $ServiceID = $Service.application_id
                    }

                    # Build payload
                    $Payload = [PSCustomObject]@{ delete = @( 
                            @{ 
                                slug           = $Slug
                                application_id = $ServiceID
                            }
                        )
                    } | ConvertTo-Json -Depth 5
                  

                    # Remove user role      
                    try {
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' successfully removed from user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Role successfully removed!"
                            $objStatus.Service = $ServiceName

                        }

                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Role cannot be removed from user!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }

                }

                # Role found with RRP parameter = MODIFICATION 
                elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                    $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                    # Check if RRP name assigned to the role
                    $RRPAssigned = $Rolefound.resource_restriction_policy
                    
                    # If RRP assigned to role, modification
                    if ($RRPAssigned -eq $ResourceRestrictionPolicyName) {
    
                        $RolesList = [System.Collections.ArrayList]::new()

                        foreach ($ExistingUserRole in $ExistingUserRoles) {
                 
                            $Slug = $ExistingUserRole.slug
                            $ServiceID = $ExistingUserRole.application_id
         
                            if ($ExistingUserRole.resource_restriction_policy) {

                                $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                                # If ExistingUserRole is the one we want to remove the exisiting RRP and set the default AllScopes RRP back
                                if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                        
                                    # Get the AllScopes default resource restriction policy ID of this role
                                    $ResourceRestrictionPolicyID = (Get-HPEGLResourceRestrictionPolicy -Name 'Allscopes' | Where-Object application_name -eq $ServiceName).resource_restriction_policy_id
              
                                }
                                    
                                $Role = [PSCustomObject]@{
                                    role                          = @{  
                                        slug           = $Slug
                                        application_id = $ServiceID
                                    }
                                    resource_restriction_policies = @(
                                        $ResourceRestrictionPolicyID
                                    )
                                }

                            }
                            else {                                
          
                                $Role = [PSCustomObject]@{
                                    role                          = @{  
                                        slug           = $Slug
                                        application_id = $ServiceID
                                    }
                                    resource_restriction_policies = @( )
                                }
                            }

                            $RolesList += $Role

                        }
        

                        # Build payload
                        $Payload = [PSCustomObject]@{ overwrite = @( 
                                $RolesList
                            )
                        } | ConvertTo-Json -Depth 5
        

                        # Set user role with RRP      
                        try {
                            Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                            if (-not $WhatIf) {

                                "[{0}] Role '{1}' with resource restriction policy '{2}' successfully removed for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                                $objStatus.Status = "Complete"
                                $objStatus.Details = "Resource restriction policy successfully removed!"
                                $objStatus.Service = $ServiceName

                            }

                        }
                        catch {
                            if (-not $WhatIf) {
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Resource restriction policy cannot be removed!"
                                $objStatus.Exception = $_.Exception.message 
                                $objStatus.Service = $ServiceName
                            }
                        }


                    }

                    # If RRP name not assigned to the role: ERROR
                    else {
                        # Must return a message if RRP name is not found
                        "[{0}] Resource restriction policy name '{1}' cannot be found for the role '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName, $Rolename | Write-Verbose

                        if ($WhatIf) {
                            $ErrorMessage = "Resource restriction policy '{0}' cannot be found for the role '{1}'!" -f $Name, $Rolename
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Resource restriction policy name cannot be found for this role!"
                        }
                        
                    }




                }

                # Role not found = ERROR
                elseif (-not $Rolefound) {
                    # Must return a message if Rolename is not found
                    "[{0}] Role name '{1}' is not assigned to user '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $Email | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Role name '{0}' is not assigned to user '{1}'!" -f $RoleName, $Email
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Role name is not assigned to the user!"
                    }
    
                    $objStatus.Service = $ServiceName
                }            
            }
            
        }

        ############## If Predefined roles (i.e. -ComputeOpsManagementRole, etc.) ##############
        else {

            try {
                $ExistingUserRoles = Get-HPEGLUserRole -Email $email
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }


            if ($MyInvocation.BoundParameters["ArubaCentralRole"] ) {
            
                $ServiceName = "Aruba Central"
                $Rolename = $ArubaCentralRole
            
            }
            elseif ($MyInvocation.BoundParameters["HPEGreenLakeRole"] ) {
            
                $ServiceName = "HPE GreenLake platform"
                $Rolename = $HPEGreenLakeRole
            
            }
            elseif ($MyInvocation.BoundParameters["ComputeOpsManagementRole"] ) {

                $ServiceName = "Compute Ops Management"
                $Rolename = $ComputeOpsManagementRole
            
            }
            elseif ($MyInvocation.BoundParameters["DataServicesRole"] ) {
            
                $ServiceName = "Data Services"
                $Rolename = $DataServicesRole

            }

            $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName
            $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName
            $Slug = $Rolefound.slug

            $objStatus.Role = $Rolename
            $objStatus.Service = $ServiceName
            
            # Role found but not RRP modification = DELETE
            if ($Rolefound -and -not $ResourceRestrictionPolicyName) {
                            
                if (-not $MyInvocation.BoundParameters["HPEGreenLakeRole"]) {

                    try {
                        $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
                    
                    }
                    catch {    
                        $PSCmdlet.ThrowTerminatingError($_)
    
                    }

                    if (-not $Service) {
                        # Must return a message if Service is not provisioned in the region
                        "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose


                        if ($WhatIf) {
                            $ErrorMessage = "Service '{0}' not provisioned in any region!" -f $ServiceName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Service not provisioned in a region!"
                        }

                        $objStatus.Service = $ServiceName
        
                    }
                    else {

                        $ServiceID = $Service.application_id

                        $Payload = [PSCustomObject]@{ delete = @( 
                                @{ 
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                            )
                        } | ConvertTo-Json -Depth 5
                      

                        # Remove user role      
                        try {
                            Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                            if (-not $WhatIf) {

                                "[{0}] Role '{1}' successfully removed from user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolename, $Email | Write-Verbose

                                $objStatus.Status = "Complete"
                                $objStatus.Details = "Role successfully removed!"
                                $objStatus.Service = $ServiceName

                            }

                        }
                        catch {
                            if (-not $WhatIf) {
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Role cannot be removed!"
                                $objStatus.Exception = $_.Exception.message 
                                $objStatus.Service = $ServiceName
                            }
                        }
                    }
                }

                else {

                    $ServiceID = "00000000-0000-0000-0000-000000000000"

                    # Build payload
                    $Payload = [PSCustomObject]@{ delete = @( 
                            @{ 
                                slug           = $Slug
                                application_id = $ServiceID
                            }
                        )
                    } | ConvertTo-Json -Depth 5
              

                    # Remove user role     
    
                    try {
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' successfully removed from user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Role successfully removed!"
                            $objStatus.Service = $ServiceName

                        }

                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Role cannot be removed!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }

                }

            }

            # Role found with RRP parameter = MODIFICATION 
            elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                # Check if RRP name assigned to the role
                $RRPAssigned = $Rolefound.resource_restriction_policy
                
                # If RRP assigned to role, modification
                if ($RRPAssigned -eq $ResourceRestrictionPolicyName) {

                    $RolesList = [System.Collections.ArrayList]::new()

                    foreach ($ExistingUserRole in $ExistingUserRoles) {
             
                        $Slug = $ExistingUserRole.slug
                        $ServiceID = $ExistingUserRole.application_id
     
                        if ($ExistingUserRole.resource_restriction_policy) {

                            $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                            # If ExistingUserRole is the one we want to remove the exisiting RRP and set the default AllScopes RRP back
                            if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                    
                                # Get the AllScopes default resource restriction policy ID of this role
                                $ResourceRestrictionPolicyID = (Get-HPEGLResourceRestrictionPolicy -Name 'Allscopes' | Where-Object application_name -eq $ServiceName).resource_restriction_policy_id
          
                            }
                                
                            $Role = [PSCustomObject]@{
                                role                          = @{  
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                                resource_restriction_policies = @(
                                    $ResourceRestrictionPolicyID
                                )
                            }

                        }
                        else {                                
      
                            $Role = [PSCustomObject]@{
                                role                          = @{  
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                                resource_restriction_policies = @( )
                            }
                        }

                        $RolesList += $Role

                    }
    

                    # Build payload
                    $Payload = [PSCustomObject]@{ overwrite = @( 
                            $RolesList
                        )
                    } | ConvertTo-Json -Depth 5
    

                    # Set user role with RRP      
                    try {
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' with resource restriction policy '{2}' successfully removed for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Resource restriction policy successfully removed!"
                            $objStatus.Service = $ServiceName

                        }

                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Resource restriction policy cannot be removed!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }


                }

                # If RRP name not assigned to the role: ERROR
                else {
                    # Must return a message if RRP name is not found
                    "[{0}] Resource restriction policy name '{1}' cannot be found for the role '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName, $Rolename | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Resource restriction policy name '{0}' cannot be found for the role '{1}'!" -f $ResourceRestrictionPolicyName, $Rolename
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Resource restriction policy name cannot be found for this role!"
                    }
    

                }




            }

            # Role not found = ERROR
            elseif (-not $Rolefound) {
                # Must return a message if Rolename is not found
                "[{0}] Role name '{1}' is not assigned to this user!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Role name '{0}' is not assigned to user '{1}'!" -f $RoleName, $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "Role name is not assigned to this user!"
                }

                $objStatus.Service = $ServiceName
              
            }
        }

        [void] $UserRoleUnassignmentStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($UserRoleUnassignmentStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more users from the role assignment has failed!"

          
            }

            $UserRoleUnassignmentStatus = Invoke-RepackageObjectWithType -RawObject $UserRoleUnassignmentStatus -ObjectName "User.Role.ERSRSDE" 
            Return $UserRoleUnassignmentStatus
        }


    }
}


Function Get-HPEGLResourceRestrictionPolicy {
    <#
    .SYNOPSIS
    View resource restriction policies in an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet returns the resource restriction policies in an HPE GreenLake workspace.  
    Resource restriction policies limit which resources can be accessed by creating customizable resource groupings.

    .PARAMETER Name 
    Name of the resource restriction policy.

    .PARAMETER ServiceName 
    Optional parameter to display resource restriction policies for a service name (can be retrieved using Get-HPEGLService -ShowProvisioned).
   
    .PARAMETER ShowFilter 
    Switch parameter to get the filters used by a resource restriction policy.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy 

    Return the resource restriction policies in an HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -Name RRP_COM-Location-Texas 

    Return the resource restriction policy information with the filter names in use for the 'RRP_COM-Location-Texas' resource restriction policy name.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -ServiceName 'Compute Ops Management'   

    Return all resource restriction policies for the Compute Ops Management service instances.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -Name RRP_with_3_COM_filters -ShowFilter
 
    Return all filters used by the 'RRP_with_3_COM_filters' resource restriction policy.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
                    
        [Parameter (ParameterSetName = 'Name')]
        [String]$Name,
            
        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ApplicationName')]
        [Alias('Application_name')]
        [String]$ServiceName,

        [Parameter (ParameterSetName = 'Name')]
        [Switch]$ShowFilter,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $FilterList = [System.Collections.ArrayList]::new()

        $Uri = $ResourceRestrictionsPolicyUri 
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
   
        
        if ($Null -ne $Collection.policies) {

            if ($Name -and $ShowFilter) {

                if ($Collection.policies | Where-Object name -eq $Name) {

                    $ResourceRestrictionPolicyID = ( $Collection.policies | Where-Object name -eq $Name).resource_restriction_policy_id
                    "[{0}] Resource Restriction Policy ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyID | Write-Verbose
                    
                    $Uri = $ResourceRestrictionPolicyUri + $ResourceRestrictionPolicyID
                    
                    "[{0}] URIAdd to retrieve the RRP '{1}': '{2}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Uri | Write-Verbose
                    
                    try {
                        
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }    

                    $Uri = $ResourceRestrictionsPolicyUsersUri + $ResourceRestrictionPolicyID + "/users?limit=2000"

                    "[{0}] URIAdd to retrieve the users using the RRP '{1}': '{2}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Uri | Write-Verbose

                    try {

                        [array]$Users = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf

                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }    
                    
                    foreach ($_Filter in $collection.scope_resource_instances) {
                        
                        $Region = (Get-HPEGLService -Name $Collection.application_name ) | Where-Object application_instance_id -eq $_Filter.application_instance_id | ForEach-Object region
                        
                        $ReturnData = $Collection | Select-Object `
                        @{N = "name"; E = { $_Filter.name } }, `
                        @{N = "description"; E = { $_Filter.description } }, `
                        @{N = "slug"; E = { $_Filter.slug } }, `
                        @{N = "application_instance_id"; E = { $_Filter.application_instance_id } }, `
                        @{N = "region"; E = { $Region } }, `
                        @{N = "application_cid"; E = { $_Filter.application_cid } }, `
                        @{N = "type"; E = { $_Filter.type } }, `
                        @{N = "scope_type_name"; E = { $_Filter.scope_type_name } }, `
                        @{N = "resource_restriction_policy_name"; E = { $Name } }, `
                        @{N = "resource_restriction_policy_id"; E = { $_.resource_restriction_policy_id } }, `
                        @{N = "resource_restriction_policy_description"; E = { $_.description } }, `
                        @{N = "platform_cid"; E = { $_.platform_cid } }, `
                        @{N = "application_id"; E = { $_.application_id } }, `
                        @{N = "application_name"; E = { $_.application_name } }, `
                        @{N = "users"; E = { $Users.users } }, `
                        @{N = "created_at"; E = { $_.created_at } }, `
                        @{N = "updated_at"; E = { $_.updated_at } }
                        
                        $FilterList += $ReturnData 
                        
                    }
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $FilterList -ObjectName "Resource.Restriction.Policy.GetFilter"    
                    $ReturnData = $ReturnData | Sort-Object { $_.name }
                }
                else {
                    Return
                }


            }
            elseif ($Name -and -not $ShowFilter) {

                if ($Collection.policies | Where-Object name -eq $Name) {

                    $ResourceRestrictionPolicyID = ( $Collection.policies | Where-Object name -eq $Name).resource_restriction_policy_id
                    "[{0}] Resource Restriction Policy ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyID | Write-Verbose
                    
                    $Uri = $ResourceRestrictionPolicyUri + $ResourceRestrictionPolicyID
                    
                    "[{0}] URIAdd: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose
                    
                    try {
                        
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }    
                    
                    "[{0}] Number of filters: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $collection.scope_resource_instances.Length | write-Verbose
                    
                    $FilterCount = ($collection.scope_resource_instances).count
                    
                    if (-not $FilterCount) {
                        $FilterCount = 1
                    }
                    
                    # $ReturnData = $Collection  |  Select-Object `
                    # @{N = "resource_restriction_policy_name"; E = { $Name } }, `
                    # @{N = "resource_restriction_policy_id"; E = { $_.resource_restriction_policy_id } }, `
                    # @{N = "resource_restriction_policy_description"; E = { $_.description } }, `
                    # @{N = "platform_cid"; E = { $_.platform_cid } }, `
                    # @{N = "application_id"; E = { $_.application_id } }, `
                    # @{N = "application_name"; E = { $_.application_name } }, `
                    # @{N = "filter_number"; E = { $FilterCount } }, `
                    # @{N = "created_at"; E = { $_.created_at } }, `
                    # @{N = "updated_at"; E = { $_.updated_at } }
                    
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Resource.Restriction.Policy"    
                }
                else {
                    Return
                }

            }
            else {

                $CollectionList = $Collection.policies 

            
                if ($ServiceName) {

                    $CollectionList = $CollectionList | Where-Object application_name -eq $ServiceName
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Resource.Restrictions.Policy"    

                $ReturnData = $ReturnData | Sort-Object { $_.name }


            }

            return $ReturnData 

        }
        else {

            return
            
        }
 
    }
}


Function New-HPEGLResourceRestrictionPolicy {
    <#
    .SYNOPSIS
    Creates a resource restriction policy in an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet creates a resource restriction policy for a service instance. 
    A resource restriction policy can limit users' ability to perform actions on a selected list of resources provided by a service instance.

    Note that the resource restriction policy requires filters, which need to be created and saved with the resource restriction policy option enabled in the service instance.
    For Compute Ops Management, use 'New-HPECOMFilter'.

    .PARAMETER Name 
    Specifies the name of the resource restriction policy.

    .PARAMETER ServiceName 
    Specifies the name of the service to which the resource restriction policy will be applied.

    .PARAMETER ServiceRegion 
    Specifies the service region to which the resource restriction policy will be applied.

    .PARAMETER FilterName 
    Specifies the name of the filter to assign to the resource restriction policy. This can be retrieved using 'Get-HPEGLServiceResourceRestrictionPolicyFilter' and created using 'New-HPECOMFilter'.

    .PARAMETER Description 
    Provides a description of the resource restriction policy.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of sending the request. This is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    New-HPEGLResourceRestrictionPolicy -Name COM-US-West -ServiceName "Compute Ops Management" -ServiceRegion us-west -FilterName "RRP_ESXi_Group" -Description "My description"
    
    Defines a resource restriction policy named "COM-US-West" for the "Compute Ops Management" service in the US-West region using the filter "RRP_ESXi_Group".

    .EXAMPLE
    Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName "Compute Ops Management" -ServiceRegion us-west | New-HPEGLResourceRestrictionPolicy -Name RRP_Group_1
    
    Defines a resource restriction policy named "RRP_Group_1" for the "Compute Ops Management" service in the US-West region using all available filters in this service instance.

    .INPUTS
    System.Collections.ArrayList
        List of resource restriction policy filters from 'Get-HPEGLServiceResourceRestrictionPolicyFilter'.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - Name of the resource restriction policy attempted to be created 
        * Service - Name of the service to which the resource restriction policy will be applied
        * Region - Name of the service region to which the resource restriction policy will be applied
        * Filtername - Name of the filter assigned to the resource restriction policy
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if successful) 
        * Details - More information about the status         
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
                
        [Parameter (ParameterSetName = 'Default')]
        [String]$Name,
            
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Alias('application_name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Alias('region')]
        [String]$ServiceRegion,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Alias('filter_name')]
        [String]$FilterName,

        [Parameter (ParameterSetName = 'Default')]
        [String]$Description,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetResourceRestrictionPolicyStatus = [System.Collections.ArrayList]::new()

        $FilterList = [System.Collections.ArrayList]::new()

        $objStatus = @{}
        $FilternamesList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        

        try {
            $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName -Region $ServiceRegion
            
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        
        # Build object for the output
        $objStatus = [pscustomobject]@{

            Name       = $Name
            Service    = $ServiceName
            Region     = $ServiceRegion 
            Filtername = [System.Collections.ArrayList]::new()
            Status     = $Null
            Details    = $Null
            Exception  = $Null
                                  
        }


        if ( $ServiceName -eq "HPE GreenLake platform") {
            # Must return a message if Service is CCS 
            "[{0}] HPE GreenLake service '{1}' does not support RRP!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose

            
            if ($WhatIf) {
                $ErrorMessage = "HPE GreenLake service does not support resource restriction policy!" 
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "HPE GreenLake service does not support resource restriction policy!"
    
            }


        }
        elseif (-not $Service) {
            # Must return a message if Service is not provisioned in the region
            "[{0}] Service instance '{1}' cannot be found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service instance '{0}': Resource cannot be found in the workspace!" -f $ServiceName
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Service instance cannot be found in the workspace!"
    
            }


        }
        else {

            $ServiceID = $Service.application_id
            $ApplicatrionCid = $Service.application_customer_id
            $ServiceInstanceId = $Service.application_instance_id

            $Uri = $SetResourceRestrictionPolicyUri + "/" + $ServiceID + "/resource_restriction"

            #  Get filters
            try {
                $Filterfound = Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName $ServiceName -ServiceRegion $ServiceRegion -FilterName $FilterName
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            

            if (-not $Filterfound) {
                # Must return a message if Service is not provisioned in the region
                "[{0}] Filter name '{1}' cannot be found in this service instance!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Filtername | Write-Verbose

                # Must return a message if resource not found

                if ($WhatIf) {
                    $ErrorMessage = "Filter '{0}' cannot be found in the '{1}' region of '{2}'!" -f $Filtername, $ServiceRegion, $ServiceName
                    Write-warning $ErrorMessage
                    continue # Continue in Process block stop processing the object in pipeline and DOES NOT go to End block 
                    
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter name cannot be found in this service instance!"
                }
    
            }
            else {

                "[{0}] Filter '{1}' found" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Filtername | Write-Verbose


                #  Get RRPs
                try {
                    $RRPfound = Get-HPEGLResourceRestrictionPolicy -Name $Name
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                

                if ($RRPfound) {
                    # Must return a message if RRP is present
                    "[{0}] RRP name '{1}' is already present in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Resource restriction policy '{0}' is already present in the HPE GreenLake workspace!" -f $Name
                        Write-warning $ErrorMessage
                        return
                        
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Resource restriction policy name already present in the HPE GreenLake workspace!!"
                    }
                }
                else {

                    $Slug = $Filterfound.slug
                    $ScopeTypeName = "Server filter"
                    # $ScopeTypeName = $Filterfound.scope_type_name
                    $ScopeTypeSlug = "/compute/filter"
                    # $ScopeTypeSlug = $Filterfound.scope_type_slug
                    
                    # Build object               
                    $FilterList += [PSCustomObject]@{
                        name                    = $Filtername
                        slug                    = $Slug 
                        # description             = $Null
                        matcher                 = $Slug 
                        scope_type_name         = $ScopeTypeName
                        scope_type_slug         = $ScopeTypeSlug
                        type                    = $ScopeTypeSlug
                        application_cid         = $ApplicatrionCid
                        application_instance_id = $ServiceInstanceId
                    }
                    
                    
                    # Build payload
                    $payload = [PSCustomObject]@{
                        
                        name                     = $Name
                        description              = $Description
                        application_name         = $ServiceName
                        scope_resource_instances = $FilterList
                        
                    } | ConvertTo-Json -Depth 5
                    
                    $FilternamesList += $FilterName
                    
                }
            }
        }
    }

    end {

        $FilternamesList | write-verbose

        foreach ($Item in $FilternamesList) {

            $objStatus.filtername += $Item
        }
          

        # Set resource restriction policy

        try {
            Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

            if (-not $WhatIf) {

                $objStatus.Status = "Complete"
                $objStatus.Details = "Resource restriction policy successfully created!"

            }

        }
        catch {

            if (-not $WhatIf) {

                if ($objStatus.Status -ne "Failed") {
                
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Resource restriction policy cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                
                }            
            }

        }    
        
        [void] $SetResourceRestrictionPolicyStatus.add($objStatus)

        if (-not $WhatIf) {

            if ($SetResourceRestrictionPolicyStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more resource restriction policies failed the creation attempt!"
          
            }

            $SetResourceRestrictionPolicyStatus = Invoke-RepackageObjectWithType -RawObject $SetResourceRestrictionPolicyStatus -ObjectName "Resource.Restriction.Policy.NSRFSDE" 
            Return $SetResourceRestrictionPolicyStatus
        }


    }


}


Function Remove-HPEGLResourceRestrictionPolicy {
    <#
    .SYNOPSIS
    Removes a resource restriction policy from an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet removes a resource restriction policy from the currently connected HPE GreenLake workspace.
    
    When a resource restriction policy assigned to a user is deleted, the user's resource access will still be marked as "Limited access", and the user will have read-only access to all server resources.

    The cmdlet issues a message at runtime to warn the user of the irreversible impact of this action and prompts for confirmation before proceeding with the removal.

    .PARAMETER Name 
    Specifies the name of the resource restriction policy to delete.

    .PARAMETER Force
    Switch parameter that performs the deletion without prompting for confirmation.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of sending the request. This is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLResourceRestrictionPolicy -Name COM-RRP-US-West
    
    Removes the resource restriction policy named 'COM-RRP-US-West' after the user has confirmed the removal.

    .EXAMPLE
    Remove-HPEGLResourceRestrictionPolicy -Name COM-RRP-US-West -Force
    
    Removes the resource restriction policy named 'COM-RRP-US-West' without prompting for confirmation.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -Name RRP_with_2_COM_filters | Remove-HPEGLResourceRestrictionPolicy 
    
    Retrieves the resource restriction policy named 'RRP_with_2_COM_filters' and removes it, pending user confirmation.

    .EXAMPLE
    "RRP_with_2_COM_filters", "RRP_Gen11_filters" | Remove-HPEGLResourceRestrictionPolicy -Force

    Removes the resource restriction policy named 'RRP_with_2_COM_filters' and 'RRP_Gen11_filters' without prompting for confirmation.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy | Remove-HPEGLResourceRestrictionPolicy
    
    Retrieves all resource restriction policies and removes them. A warning message appears and asks the user to confirm the action for each resource restriction policy found.

    .INPUTS
    System.Collections.ArrayList
        List of resource restriction policy filters from 'Get-HPEGLResourceRestrictionPolicy'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the resource restriction policy's names.


    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the resource restriction policy object attempted to be deleted 
        * Status - Status of the deletion attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed) 
        * Details - More information about the status         
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
                
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$Force,
            
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose      

        $Uri = $DeleteResourceRestrictionPolicyUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $RRPIdsList = [System.Collections.ArrayList]::new()
        $RRPNameIdsList = [System.Collections.ArrayList]::new()

    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        # Condition met when 'Get-HPEGLResourceRestrictionPolicy |  Remove-HPEGLResourceRestrictionPolicy' is used 
        if ($name -eq "AllScopes" -and $PSCmdlet.MyInvocation.ExpectingInput) {
            
            # Skipping All scopes from deletion as read only.
            return

        }
        # Condition met when 'Remove-HPEGLResourceRestrictionPolicy -Name Allscopes' is used
        elseif ($name -eq "AllScopes") {
            
            $ErrorMessage = "Resource restriction policy '{0}' does not support delete operation!" -f $Name
            Write-warning $ErrorMessage
            break

        }
        else {

            # Build object for the output
            $objStatus = [pscustomobject]@{

                Name      = $Name
                Status    = $Null
                Details   = $Null
                Exception = $Null
                            
            }
                
        }

        [void]$ObjectStatusList.add($objStatus)
    
    }
    end {
        
        try {
            $ResourceRestrictionPolicies = Get-HPEGLResourceRestrictionPolicy 
            
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        "[{0}] List of policies to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.name | out-string) | Write-Verbose

        
        foreach ($Object in $ObjectStatusList) {

            $RRP = $ResourceRestrictionPolicies | Where-Object name -eq $Object.Name

            if (-not $RRP) {
                    
                # Must return a message if not found
                $Object.Status = "Failed"
                $Object.Details = "Resource restriction policy cannot be found in the workspace!"
                
                if ($WhatIf) {
                    $ErrorMessage = "Resource restriction policy '{0}': Resource cannot be found in the workspace!" -f $Object.name
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {

                $ID = $RRP.resource_restriction_policy_id
                

                # Building the list of RRP IDs object for payload
                [void]$RRPIdsList.Add($ID)

                
                # Building the list of RRP name and IDs object for tracking
                $_Obj = [pscustomobject]@{
                    Name = $Object.Name
                    ID   = $ID
                }

                [void]$RRPNameIdsList.Add($_Obj)
            }
        }

        If ($RRPNameIdsList) {

            if ($Force) {
                $decision = 0
            }
            else {
    
                if ($RRPNameIdsList.Count -gt 1) {
                    $title = "All data associated with the restriction policies will be deleted. Confirm that you would like to remove {0} policies: {1}" -f $RRPNameIdsList.count, ($RRPNameIdsList.name -join ", ")
                    $question = 'This action cannot be undone. Are you sure you want to proceed?'
                    $choices = '&Yes', '&No'
    
                    $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
                }
                else {
                    $name = $RRPNameIdsList.name
                    $title = "All data associated with the '{0}' restriction policy will be deleted. Confirm that you would like to remove '{0}'." -f $name
                    $question = 'This action cannot be undone. Are you sure you want to proceed?'
                    $choices = '&Yes', '&No'
    
                    $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
                }
            }
    
            if ($decision -eq 0) {
                
                # Build payload
                $payload = [PSCustomObject]@{
    
                    ids = $RRPIdsList
                
                } | ConvertTo-Json -Depth 5
    
    
                # Remove resource restriction policy
    
                try {
                    Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
    
                    if (-not $WhatIf) {
    
                        foreach ($Object in $ObjectStatusList) {

                            $RRPName = $RRPNameIdsList | Where-Object name -eq $Object.name

                            If ($RRPName) {

                                $Object.Status = "Complete"
                                $Object.Details = "Resource restriction policy successfully deleted!"
                            }
                        }
                    }
        
                }
                catch {
    
                    if (-not $WhatIf) {

                        foreach ($Object in $ObjectStatusList) {

                            $RRPName = $RRPNameIdsList | Where-Object name -eq $Object.name

                            If ($RRPName) {
    
                                $Object.Status = "Failed"
                                $Object.Details = "Resource restriction policy cannot be deleted!"
                                $Object.Exception = $_.Exception.message 
                                
                            }
                        }
                    }
    
                }    
            }
            else {

                'Operation cancelled by user!' | Write-Verbose
    
                if (-not $Whatif) {
                    
                    foreach ($Object in $ObjectStatusList) {
                        
                        $RRPName = $RRPNameIdsList | Where-Object name -eq $Object.name
                        
                        If ($RRPName) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Operation cancelled by the user!"
                            $Object.Exception = $_.Exception.message 
                            
                        }
                    }
                }
                else {
                    
                    $ErrorMessage = "Operation cancelled by the user!"
                    Write-warning $ErrorMessage

                }
            }
        }        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more resource restriction policies failed the deletion attempt!"
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "Resource.Restriction.Policy.NSDE" 
            Return $ObjectStatusList
        }
    }
}


Function Get-HPEGLUserPreference {
    <#
    .SYNOPSIS
    Displays HPE GreenLake user preferences.

    .DESCRIPTION
    This Cmdlet returns the user profile preferences for HPE GreenLake, including settings such as language, session timeout, notification and multi-factor preferences.       

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLUserPreference

    Return the user profile preferences for HPE GreenLake.
    
   #>
    [CmdletBinding()]
    Param( 

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Uri = $UserPreferencesUri
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = [System.Collections.ArrayList]::new()

        try {
            [array]$UserPreferences = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

   
        if ($Null -ne $UserPreferences ) {

    
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserPreferences -ObjectName "User.Preference"    
    
            return $ReturnData  
        }
        else {
            
            return            
        }
 
    }
}


Function Set-HPEGLUserPreference {
    <#
    .SYNOPSIS
    Update HPE GreenLake user preferences.

    .DESCRIPTION
    Cmdlet can be used to update the HPE GreenLake user preferences such as session timeout and Language.  

    .PARAMETER Language 
    The Language directive can be used to set the language to use in the HPE GreenLake UI. 
    Supported languages: Chinese, English, French, German, Japanese, Korean, Portuguese, Russian, Spanish, ltalian

    .PARAMETER SessionTimeoutInMinutes 
    The SessionTimeoutInMinutes directive can be used to set the session timeout (in minutes). 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLUserPreference -Language French

    Sets the language of the HPE GreenLake user interface to French.

    .EXAMPLE
    Set-HPEGLUserPreference -SessionTimeout 120

    Set the session timeout of the HPE GreenLake user interface to 120 minutes.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - Email address of the user 
        * Status - Status of the modification attempt (Failed for http error return; Complete if the update of the user preferences is successful) 
        * Details - More information about the status         
        * Exception: Information about any exceptions generated during the operation.
    
   #>
    [CmdletBinding()]
    Param( 

        # Argument completer reqistered in library module 
        [ValidateScript({ 
                if ($HPESupportedLanguages[$_]   ) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid language name!"
                }
            })]
        [String]$Language,   
        
        [ValidateScript({
                if ($_ -ge 5 -and $_ -le 1440) {
                    $True
                }    
                else {
                    Throw "Input value must be at least 5 and cannot exceed 1440 minutes."
                }
            })]        
        [Int]$SessionTimeoutInMinutes,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $UserPreferencesUri

        $SetUserPreferenceStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $UserPreferences = Get-HPEGLUserPreference 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email     = $HPEGreenLakeSession.username
            Status    = $Null
            Details   = $Null
            Exception = $Null
                  
        }

               
        if ($Language) {

            $LanguageSet = $HPESupportedLanguages[$language]
            
            $UserPreferences.language = $LanguageSet
        }

 
        if ($SessionTimeoutInMinutes) {
                
            $UserPreferences.idle_timeout = $SessionTimeoutInMinutes * 60
        }

        if (-Not $Language -and -Not $SessionTimeoutInMinutes) {
            
            if ($Whatif) {
                $ErrorMessage = "At least one parameter must be provided!" 
                Write-warning $ErrorMessage
                return
            }
            else {
                
                $objStatus.Status = "Failed"
                $objStatus.Details = "At least one parameter must be provided!"
            }
            
        }
        else {
                
            # User Preferences modification
            try {
            
                $Response = Invoke-HPEGLWebRequest -Method 'PUT' -Body ($UserPreferences | ConvertTo-Json -Depth 5) -Uri $Uri -whatifBoolean $WhatIf
                            
                if (-not $WhatIf) {
    
                    $Global:HPEGreenLakeSession.userSessionIdleTimeout = $SessionTimeoutInMinutes

                    $objStatus.Status = "Complete"
                    $objStatus.Details = ($Response | ForEach-Object message)
                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = ($Response | ForEach-Object message)
                    $objStatus.Exception = $_.Exception.message 
                }
            }    
            
        }

        [void] $SetUserPreferenceStatus.add($objStatus)
            
    }

    end {

        if (-not $WhatIf) {

            if ($SetUserPreferenceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to update the user preferences!"
          
            }

            $SetUserPreferenceStatus = Invoke-RepackageObjectWithType -RawObject $SetUserPreferenceStatus -ObjectName "ObjStatus.ESDE" 
            Return $SetUserPreferenceStatus
        }



    }
}


Function Get-HPEGLUserAccountDetails {
    <#
    .SYNOPSIS
    Retrieves details of HPE GreenLake user accounts.

    .DESCRIPTION
    This Cmdlet fetches and displays HPE GreenLake user account details. The returned information includes personal details, organization name, address, time zone, language preferences, and phone numbers.
    
    .PARAMETER Raw
    Switch to return all available properties of the HPE GreenLake user account details in their raw, unprocessed form. 

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP without actually sending the request. This is useful for understanding the native REST API calls utilized by GLP.

    .EXAMPLE
    Get-HPEGLUserAccountDetails

    Retrieves and displays the details of your HPE GreenLake user account.
    
    .EXAMPLE
    Get-HPEGLUserAccountDetails -Raw
    
    Retrieves and displays all available properties of your HPE GreenLake user account details in their raw form.
    
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

#>


    [CmdletBinding()]
    Param( 

        [switch]$Raw,
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $HPEOnepassbaseURL + "/v2-get-user/" + $HPEGreenLakeSession.username
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # $ReturnData = @() #[System.Collections.ArrayList]::new()

        try {
            [array]$UserAccountDetails = Invoke-HPEGLWebRequest -Method POST -Uri $Uri -whatifBoolean $WhatIf 
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

   
        if ($Null -ne $UserAccountDetails ) {

            if ($raw) {
                $ReturnData = $UserAccountDetails
            }
            else {
                if ($UserAccountDetails.profile) {
                    $ReturnData = $UserAccountDetails.profile | Select-Object firstName, lastName, hpeCompanyName, streetAddress, hpeStreetAddress2, city, state, zipCode, hpeCountryCode, hpeTimezone, preferredLanguage, primaryPhone, mobilePhone
                    # $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserAccountDetails -ObjectName "User.AccountDetails"    
                }
                else {
                    # Required to get any error returned by invoke-HPEGLwebrequest
                    $ReturnData = $UserAccountDetails
                }
            }
    
            return $ReturnData  
        }
        else {
            
            return            
        }
 
    }
}

Function Set-HPEGLUserAccountDetails {
    <#
    .SYNOPSIS
    Set HPE GreenLake user account details.

    .DESCRIPTION
    This Cmdlet is used to update the HPE GreenLake user account details, such as first name, last name, address, time zone, language information, etc. If you omit any parameter, the cmdlet retains the current settings for those fields and only updates the provided parameters.
      
    .PARAMETER Language 
    Specifies the language to use in the HPE GreenLake UI. Supported languages include: Chinese, English, French, German, Japanese, Korean, Portuguese, Russian, Spanish, and Italian.

    .PARAMETER Street
    Sets the primary street address for the user.

    .PARAMETER Street2
    Sets the secondary address line for the user.

    .PARAMETER City
    Sets the city where the user resides.

    .PARAMETER State
    Sets the state or province where the user resides.

    .PARAMETER PostalCode
    Sets the postal code for the user's address.

    .PARAMETER Timezone
    Sets the time zone for the user's location.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of actually sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLUserAccountDetails `
    -Firstname Henri `
    -Lastname Poincar `
    -Organizationname "Celestial" `
    -Street "Theory of dynamical systems street" `
    -Street2 "Cosmos building" `
    -City Heaven `
    -PostalCode 77777 `
    -Country France `
    -Timezone Europe/Paris `
    -Language English `
    -PrimaryPhone +33123456789 `
    -Mobilephone +33612345678

    Set all parameter details of the HPE GreenLake user account for the currently connected user.

    .EXAMPLE
    Set-HPEGLUserAccountDetails -Timezone Europe/Paris -Language French 

    Sets the time zone and language details of the HPE GreenLake user account for the currently connected user. 
    
    .EXAMPLE
    Set-HPEGLUserAccountDetails -Firstname Albert -Lastname Einstein
    
    Updates the first name and last name of the HPE GreenLake user account while preserving all other existing settings.

    .EXAMPLE
    Set-HPEGLUserAccountDetails -State "" -Street2 ""

    Removes the state and the secondary address line details from the HPE GreenLake user account while preserving all other existing settings.
    
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    #>


    [CmdletBinding()]
    Param( 
        [String]$Firstname,
        [String]$Lastname,
        [String]$Organizationname,
        [String]$Street,
        [String]$Street2,        
        [String]$City,
        [String]$State,
        [String]$PostalCode,

        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country, 

        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeTimezone.enum -split "`n" -contains $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid timezone name!"
                }
            })]
        [String]$Timezone, 

        # Argument completer reqistered in library module 
        [ValidateScript({ 
                if ($HPESupportedLanguages[$_]   ) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid language name!"
                }
            })]
        [String]$Language,   

        [String]$PrimaryPhone,  
        [String]$Mobilephone,   
        [Switch]$WhatIf

    ) 

    Begin {
       
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $HPEOnepassbaseURL + "/v2-update-user-okta/" + $HPEGreenLakeSession.username
        
        $SetUserAccountDetailsStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $UserAccountDetails = Get-HPEGLUserAccountDetails -Raw 
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }



        # Build object for the output
        $objStatus = [pscustomobject]@{
        
            Email     = $HPEGreenLakeSession.username
            Status    = $Null
            Details   = $Null
            Exception = $Null
                
        }


        # Build payload

        $_Profile = @{ 
            email = $HPEGreenLakeSession.username
            login = $HPEGreenLakeSession.username
        }

        
        if ($Firstname) {
            $_Profile.firstName = $Firstname

        }

        if ($Lastname) {
            $_Profile.lastName = $Lastname

        }

        if ($PSBoundParameters.ContainsKey('Organizationname')) {
            $_Profile.hpeCompanyName = $Organizationname
            $_Profile.UserUpdatedGTSAttribute = "Y"

        }  

        if ($PSBoundParameters.ContainsKey('Street')) {
            $_Profile.streetAddress = $Street
            $_Profile.UserUpdatedGTSAttribute = "Y"

        }

        if ($PSBoundParameters.ContainsKey('Street2')) {
            $_Profile.hpeStreetAddress2 = $Street2
            $_Profile.UserUpdatedGTSAttribute = "Y"

        }

        if ($PSBoundParameters.ContainsKey('City')) {
            $_Profile.city = $City
            $_Profile.UserUpdatedGTSAttribute = "Y"
            
        }
        
        if ($PSBoundParameters.ContainsKey('State')) {
            $_Profile.state = $State
            $_Profile.UserUpdatedGTSAttribute = "Y"
            
        }
        
        if ($PSBoundParameters.ContainsKey('PostalCode')) {
            $_Profile.zipCode = $PostalCode
            $_Profile.UserUpdatedGTSAttribute = "Y"
            
        }
        
        if ($Country) {
            
            $CountryCode = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $Country | ForEach-Object const
        
            $_Profile.hpeCountryCode = $CountryCode
            $_Profile.countryCode = $CountryCode
            $_Profile.UserUpdatedGTSAttribute = "Y"

            if ($Language) {

                $LanguageSet = $HPESupportedLanguages[$language]
                $_Profile.locale = $LanguageSet + "_" + $CountryCode
            }
            else {
                $LanguageSet = $UserAccountDetails.profile.preferredLanguage
                $_Profile.locale = $LanguageSet + "_" + $CountryCode

            }

        
        }
        
        if ($Timezone) {
            $_Profile.hpeTimezone = $Timezone
            
        }
        
        if ($Language) {
            
            $LanguageSet = $HPESupportedLanguages[$language]
            $_Profile.preferredLanguage = $LanguageSet
            
            if ($CountryCode) {

                $_Profile.locale = $LanguageSet + "_" + $CountryCode
            }
            else {
                $CountryCode = $UserAccountDetails.profile.countryCode
                $_Profile.locale = $LanguageSet + "_" + $CountryCode

            }

        }

        if ($PSBoundParameters.ContainsKey('PrimaryPhone')) {
            $_Profile.primaryPhone = $PrimaryPhone

        }

        if ($PSBoundParameters.ContainsKey('Mobilephone')) {
            $_Profile.mobilePhone = $Mobilephone

        } 
        
        $payload = @{ 
            profile = $_Profile
            # sessionId = $HPEGreenLakesession.onepassSid  # Auto added by Invoke-HPEGLWebRequest
                    
        }

        $payload = ConvertTo-Json $payload -Depth 10 

             
        # User account details modification
        
        try {
            $Response = Invoke-HPEGLWebRequest -Method POST -Body $payload -Uri $Uri -whatifBoolean $WhatIf 
        
            if (-not $WhatIf) {
   
                $objStatus.Status = "Complete"
                $objStatus.Details = ($Response | ForEach-Object message)
            }
        
        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = ($Response | ForEach-Object message)
                $objStatus.Exception = $_.Exception.message 
            }
        }

        [void] $SetUserAccountDetailsStatus.add($objStatus)
   
    }

    end {

        if (-not $WhatIf) {

            if ($SetUserAccountDetailsStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to update the user preferences!"
          
            }

            $SetUserAccountDetailsStatus = Invoke-RepackageObjectWithType -RawObject $SetUserAccountDetailsStatus -ObjectName "ObjStatus.ESDE" 
            Return $SetUserAccountDetailsStatus

        }
    }
}


Function Set-HPEGLUserAccountPassword {
    <#
    .SYNOPSIS
    Set HPE GreenLake user account password.

    .DESCRIPTION
    This Cmdlet can be used to set the HPE GreenLake user account password.       
    
    .PARAMETER currentpassword
    Your current user account password as a secure string.

    .PARAMETER newpassword
    Your new password to set as a secure string. It must meet the following requirements:
    - Contains at least one upper case letter
    - Contains at least one lower case letter
    - Contains at east one number (0-9)
    - Contains at least one symbol (eg. !@#$%^&)
    - Does not contain part of email
    - Does not contain first name
    - Does not contain last name
    - Does not contain common passwords
    - Does not match any of your last 24 passwords

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    $currentpassord = Read-Host -AsSecureString -Prompt "Enter your current password"
    $newpassord = Read-Host -AsSecureString -Prompt "Enter the new password to set"

    Set-HPEGLUserAccountPassword -CurrentPassword $currentpassord -NewPassword $newpassord

    Change the HPE GreenLake user account password to a new one for the currently connected user.

    .EXAMPLE
    $plainTextCurrentpassord = "np$$rPKHK39cU3e9T%SzR!!L"
    $secureCurrentPassword = ConvertTo-SecureString $plainTextCurrentpassord -AsPlainText -Force
    $plainTextNewpassword = "kLi7@zvzt4DyhUXUE8^32keY"
    $secureNewPassword = ConvertTo-SecureString $plainTextNewpassword -AsPlainText -Force

    Set-HPEGLUserAccountPassword -CurrentPassword $secureCurrentPassword -NewPassword $secureNewPassword

    Change the HPE GreenLake user account password to a new one for the currently connected user.

  
   #>
    [CmdletBinding()]
    Param( 
        [Parameter(Mandatory)]
        [SecureString]$CurrentPassword,
        [Parameter(Mandatory)]
        [SecureString]$NewPassword,
        [Switch]$WhatIf

    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $userid = (Get-HPEGLUserAccountDetails -Raw).id
        $Uri = $HPEOnepassbaseURL + "/v2-change-password-okta/" + $userid 
        
        $UserPasswordChangeStatus = [System.Collections.ArrayList]::new()
        
        $_OldPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($CurrentPassword))
        $_NewPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($NewPassword))

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
        
            Email     = $HPEGreenLakeSession.username
            Status    = $Null
            Details   = $Null
            Exception = $Null
                
        }

        $upperCasePattern = '[A-Z]'
        $lowerCasePattern = '[a-z]'
        $numberPattern = '[0-9]'
        $symbolPattern = '[!@#$%^&*(),.?":{}|<>]'

        if ($_NewPassword -match $upperCasePattern -and `
                $_NewPassword -match $lowerCasePattern -and `
                $_NewPassword -match $numberPattern -and `
                $_NewPassword -match $symbolPattern) {
            
       
            $Payload = @{ 
                oldPassword = @{
                    value = $_oldPassword
                } 
                newPassword = @{
                    value = $_newPassword

                } 
            
            } | ConvertTo-Json -Depth 5


            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose

            # User password modification
            
            try {
                [array]$Response = Invoke-HPEGLWebRequest -Method POST -Body $Payload -Uri $Uri -whatifBoolean $WhatIf 
            
                if (-not $WhatIf) {
    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = ($Response | ForEach-Object message)
                }
            
            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = ($Response | ForEach-Object message)
                    $objStatus.Exception = $_.Exception.message 
                }
            }

            [void] $UserPasswordChangeStatus.add($objStatus)

        } 
        else {

            $errorMessage = "The new password does not meet the requirements, it should contain at least one upper case letter, at least one lower case letter, at least one number (0-9) and at least one symbol (eg. !@#$%^&)."
            
            throw $errorMessage
        }
   
    }
    end {

        if (-not $WhatIf) {

            if ($UserPasswordChangeStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to modify the user password!"
          
            }

            $UserPasswordChangeStatus = Invoke-RepackageObjectWithType -RawObject $UserPasswordChangeStatus -ObjectName "ObjStatus.ESDE" 
            Return $UserPasswordChangeStatus
        }
    }
}

    
#EndRegion


#Region --- WORKSPACE ---


Function Get-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Retrieve workspace resource(s) from HPE GreenLake.

    .DESCRIPTION
    This Cmdlet returns a collection of workspace resources available in HPE GreenLake. The "current" column indicates the workspace you are currently connected to.
    
    .PARAMETER Name
    Specifies the name of a workspace to retrieve.

    .PARAMETER ShowCurrent
    Retrieves details of the workspace you are currently connected to.
    
    .PARAMETER ShowActivationKey
    Fetches the activation key of the workspace you are presently connected to.
    The activation key is necessary for connecting iLOs to Compute Ops Management.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be executed, without actually sending the request. Useful for understanding the native REST API interactions with GLP.

    .EXAMPLE
    Get-HPEGLWorkspace

    Retrieves all workspaces available on the HPE GreenLake platform.

    .EXAMPLE
    Get-HPEGLWorkspace -ShowCurrent

    Retrieves general information about the current HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLWorkspace -ShowActivationKey

    Retrieves the activation key for the current HPE GreenLake workspace, required for connecting iLOs to Compute Ops Management.
    #>

    
    [CmdletBinding(DefaultParameterSetName = "Default")]
    Param( 

        [Parameter (ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [Parameter (ParameterSetName = "Current")]
        [ValidateNotNullOrEmpty()]
        [Switch]$ShowCurrent,

        [Parameter (ParameterSetName = "ActivationKey")]
        [ValidateNotNullOrEmpty()]
        [Switch]$ShowActivationKey,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command
    
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = [System.Collections.ArrayList]::new()
        # $AllAccounts = [System.Collections.ArrayList]::new()

        $AllCollection = [System.Collections.ArrayList]::new()
        
        # $Uri = $WorkspacesV2Uri 
        $Uri = $WorkspacesListUri + "?count_per_page=5"
        
        
        # GET WORKSPACES (if any) [Does not include the currently connected workspace]

        try {

            if ($HPEGreenLakeSession.workspaceId) {     

                [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf   
            }
            else {
                #  Skip parameter is only used by Get-HPEGLWorkspace when Connect-HPEGLWorkspace has not been executed yet (i.e. when no workspace session exists yet).
                [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -SkipSessionCheck -WhatIfBoolean $WhatIf
            }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if ($Collection.customers) {

            $Collection = $Collection.customers
                    
        }

        # Add current property
        $Collection | Add-Member -Type NoteProperty -Name "current" -Value $False

        $AllCollection += $Collection
            
        # "[{0}] Content of all workspaces except current one: `n {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($AllCollection | Out-String) | Write-Verbose

        # GET CURRENT WORKSPACE (if any)
        
        if ($HPEGreenLakeSession.workspace) {
        
            $uri = $CurrentWorkspaceUri    # /accounts/ui/v1/customer/profile/contact
            # $Uri = $UserLoadAccountUri                                                    # gives nothing
            # $Uri = $WorkspacesUri + "/" + $HPEGreenLakeSession.workspaceId + "/contact"   # gives not enough info
            # $Uri = $WorkspacesUri + "/" + $HPEGreenLakeSession.workspaceId                # gives not enough info

            try {
                
                [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf 
                
                # Add platform_customer_id property
                $Collection | Add-Member -Type NoteProperty -Name "platform_customer_id" -Value $HPEGreenLakeSession.workspaceId
                
                # Add account_type (MSP or SANDALONE) from $HPEGLworkspaces generated by 'Connect-HPEGLWorkspace'
                $_AccountType = $HPEGLworkspaces | Where-Object platform_customer_id -eq $HPEGreenLakeSession.workspaceId | ForEach-Object account_type
                $Collection | Add-Member -Type NoteProperty -Name "account_type" -Value $_AccountType
                $Collection | Add-Member -Type NoteProperty -Name "current" -Value $True
                               
                "[{0}] Content of current workspace: `n {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Collection | Out-String) | Write-Verbose

                $AllCollection += $Collection
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            
            # Add name and version properties
            foreach ($_workspace in $AllCollection) {

                $_workspace | Add-Member -Type NoteProperty -Name "name" -Value $_workspace.company_name

                if ($_workspace.PSObject.Properties | Where-Object { $_.Name -eq "iam_v2_workspace" }) {

                    if ($_workspace.iam_v2_workspace -eq $False){
                        $IsItaV2workspace = $False
                    } 
                    elseif ($_workspace.iam_v2_workspace -eq $Null) {
                        $IsItaV2workspace = $False
                    }
                    else {
                        $IsItaV2workspace = $True
                    }
                }
                else {
                    $IsItaV2workspace = $True
                }

                if ($IsItaV2workspace -eq $True){
                    $_workspace | Add-Member -Type NoteProperty -Name "version" -Value "v2"
                }
                elseif ($IsItaV2workspace -eq $False) {
                    $_workspace | Add-Member -Type NoteProperty -Name "version" -Value "v1"
                }
            }


            "[{0}] Content of all workspaces: `n {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($AllCollection | Out-String) | Write-Verbose


            $CurrentWorkspace = $AllCollection | Where-Object platform_customer_id -eq $HPEGreenLakeSession.workspaceId
        }

        if ($ShowActivationKey) {

            if ($HPEGreenLakeSession.workspaceId) {
                return $HPEGreenLakeSession.workspaceId
                
            }
            elseif ($HPEGreenLakeSession.workspacesCount -eq 0) {

                "[{0}] Error: No workspace found! Please execute New-HPEGLWorkspace first to create the initial workspace." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                Write-Warning "Error: No workspace found! Please execute New-HPEGLWorkspace first to create the initial workspace."
                return
            }
            elseif ($HPEGreenLakeSession.workspacesCount -ge 1) {
                
                "[{0}] Error: No workspace connection found! Please execute Connect-HPEGLWorkspace first to establish a connection to a workspace." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                Write-Warning "Error: No workspace connection found! Please execute Connect-HPEGLWorkspace first to establish a connection to a workspace."
                return
            }
            else {
        
                "[{0}] Error: No session found! Please execute Connect-HPEGL first to establish a session." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                Write-Warning "Error: No session found! Please execute Connect-HPEGL first to establish a session."
                return
            }


        }
        elseif ($ShowCurrent) {      

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CurrentWorkspace -ObjectName "Workspace"    
            return $ReturnData  
                    
        }
        else {

            if ($Null -ne $AllCollection ) {
   
                if ($Name) {
    
                    $AllCollection = $AllCollection | Where-Object company_name -eq $Name
                }
       
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $AllCollection -ObjectName "Workspace"    
    
                $ReturnData = $ReturnData | Sort-Object { $_.company_name }
        
                return $ReturnData  
            }
            else {
                
                return            
            }
        } 
    }
}


Function New-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Creates a workspace in HPE GreenLake.

    .DESCRIPTION
    This cmdlet creates a workspace in HPE GreenLake. If the cmdlet detects that this is the first workspace created, it terminates the current HPE GreenLake session by logging out the user.
    
    When you log in to HPE GreenLake for the first time with an HPE account, you must create a workspace for your organization.

    .PARAMETER Name
    The name of the workspace. The name must be unique across all workspaces on the HPE GreenLake platform.

    .PARAMETER Type
    Specifies the workspace type to create. There are two types of workspace in HPE GreenLake:
        - Standard enterprise workspace: This is the standard workspace for teams wanting to use GreenLake services.
        - Managed service provider workspace: MSP workspaces are for service providers who manage their customers' services, devices, and subscriptions.

    .PARAMETER Street
    Specifies the postal street address of the workspace (optional).

    .PARAMETER Street2
    Specifies the secondary postal street address (Apt, suite, building, floor, etc.) of the workspace (optional).

    .PARAMETER Country
    Specifies the country of origin for the company.

    .PARAMETER City
    Specifies the city of the workspace (optional).

    .PARAMETER State
    Specifies the state of the workspace (optional).

    .PARAMETER PostalCode
    Specifies the postal code of the workspace (optional).

    .PARAMETER PhoneNumber
    Specifies the contact phone number of the workspace (optional).

    .PARAMETER Email
    Specifies the contact email address of the workspace (optional).

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    # This example demonstrates how to create a first workspace in an HPE GreenLake console.

    New-HPEGLWorkspace -Name "My_first_workspace_name" -Type "Managed Service Provider workspace" -Country "United States"
    Connect-HPEGL -Credential $credentials -Workspace "My_first_workspace_name"

    The first command creates a new 'Managed Service Provider' workspace named "My_first_workspace_name" in the United States. 
    If the cmdlet detects that this workspace is the first one created, it terminates the current HPE GreenLake session by logging out the user. 
    The next step is to reconnect using the `Connect-HPEGL` cmdlet with the credentials and the newly created workspace name.

    .EXAMPLE
    New-HPEGLWorkspace `
        -Name Velocity  `
        -Type 'Standard enterprise workspace' `
        -Email 'HenriPoincar@Velocity.com' `
        -Street "Theory of dynamical systems street" `
        -Street2 "Cosmos building" `
        -City Paris `
        -PostalCode 75000 `
        -Country France `
        -PhoneNumber +33612345678

    Creates a new HPE GreenLake workspace named "Velocity" using the standard enterprise workspace type and various details.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the workspace object attempted to be created 
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if the creation is successful; Warning if no action is needed) 
        * Details - More information about the status         
        * Exception: Information about any exceptions generated during the operation.
    #>
    
    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)]
        [String]$Name,

        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Standard enterprise workspace', 'Managed Service Provider workspace')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Standard enterprise workspace', 'Managed Service Provider workspace')]
        [String]$Type,

        
        [String]$Street,
        [String]$Street2,
        [String]$City,
        [String]$State,
        [String]$PostalCode,
        
        [Parameter (Mandatory)]
        # Cannot use argument completer - pb when no workspace exists as the meta data $HPEGLSchemaMetadata are retrieved from onepass which requires a session cookie thus a workspace session
        [ValidateSet("Afghanistan", "Aland Islands", "Albania", "Algeria", "American Samoa", "Andorra", "Angola", "Anguilla", "Antarctica", "Antigua and Barbuda", "Argentina", "Armenia", "Aruba", "Australia", "Austria", "Azerbaijan", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belarus", "Belgium", "Belize", "Benin", "Bermuda", "Bhutan", "Bolivia", "Bonaire, Sint Eustatius and Saba", "Bosnia and Herzegovina", "Botswana", "Bouvet Island", "Brazil", "British Indian Ocean Territory", "British Virgin Islands", "Brunei", "Bulgaria", "Burkina Faso", "Burundi", "Cambodia", "Cameroon", "Canada", "Cape Verde", "Cayman Islands", "Central African Republic", "Chad", "Chile", "China", "Christmas Island", "Cocos Islands", "Colombia", "Comoros", "Cook Islands", "Costa Rica", "Croatia", "Cuba", "Curacao", "Cyprus", "Czech Republic", "Democratic Republic of the Congo", "Denmark", "Djibouti", "Dominica", "Dominican Republic", "East Timor", "Ecuador", "Egypt", "El Salvador", "Equatorial Guinea", "Eritrea", "Estonia", "Ethiopia", "Falkland Islands", "Faroe Islands", "Fiji", "Finland", "France", "French Polynesia", "Gabon", "Gambia", "Georgia", "Germany", "Ghana", "Gibraltar", "Greece", "Greenland", "Grenada", "Guadeloupe", "Guam", "Guatemala", "Guernsey", "Guinea", "Guinea-Bissau", "Guyana", "Haiti", "Honduras", "Hong Kong", "Hungary", "Iceland", "India", "Indonesia", "Iran", "Iraq", "Ireland", "Isle of Man", "Israel", "Italy", "Ivory Coast", "Jamaica", "Japan", "Jersey", "Jordan", "Kazakhstan", "Kenya", "Kiribati", "Kosovo", "Kuwait", "Kyrgyzstan", "Laos", "Latvia", "Lebanon", "Lesotho", "Liberia", "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Macau", "Macedonia", "Madagascar", "Malawi", "Malaysia", "Maldives", "Mali", "Malta", "Marshall Islands", "Martinique", "Mauritania", "Mauritius", "Mayotte", "Mexico", "Micronesia", "Moldova", "Monaco", "Mongolia", "Montenegro", "Montserrat", "Morocco", "Mozambique", "Myanmar", "Namibia", "Nauru", "Nepal", "Netherlands", "Netherlands Antilles", "New Caledonia", "New Zealand", "Nicaragua", "Niger", "Nigeria", "Niue", "North Korea", "Northern Mariana Islands", "Norway", "Oman", "Pakistan", "Palau", "Palestine", "Panama", "Papua New Guinea", "Paraguay", "Peru", "Philippines", "Pitcairn", "Poland", "Portugal", "Puerto Rico", "Qatar", "Republic of the Congo", "Reunion", "Romania", "Russia", "Rwanda", "Saint Barthelemy", "Saint Helena", "Saint Kitts and Nevis", "Saint Lucia", "Saint Martin", "Saint Pierre and Miquelon", "Saint Vincent and the Grenadine", "Samoa", "San Marino", "Sao Tome and Principe", "Saudi Arabia", "Senegal", "Serbia", "Seychelles", "Sierra Leone", "Singapore", "Sint Maarten", "Slovakia", "Slovenia", "Solomon Islands", "Somalia", "South Africa", "South Georgia and the South Sandwich Islands", "South Korea", "South Sudan", "Spain", "Sri Lanka", "Sudan", "Suriname", "Svalbard and Jan Mayen", "Swaziland", "Sweden", "Switzerland", "Syria", "Taiwan", "Tajikistan", "Tanzania", "Thailand", "The French Republic", "The Territory of Norfolk Island", "Togo", "Tokelau", "Tonga", "Trinidad and Tobago", "Tunisia", "Turkey", "Turkmenistan", "Turks and Caicos Islands", "Tuvalu", "U.S. Virgin Islands", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "United States Minor Outlying Islands", "Uruguay", "Uzbekistan", "Vanuatu", "Vatican", "Venezuela", "Vietnam", "Wallis and Futuna", "Western Sahara", "Yemen", "Zambia", "Zimbabwe")]
        [String]$Country,

        [String]$PhoneNumber,

        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,       

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
                
        # Workspace v1
        $Uri = $NewWorkspaceUri
        # Workspace v2 but it requires to be connected first to a v2 workspace !
        # $Uri = $WorkspacesV2Uri
        
        
        $WorkspaceCreationStatus = [System.Collections.ArrayList]::new()
        
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
            
            $WorkspaceFound = Get-HPEGLWorkspace

            $WorkspaceNameFound = $WorkspaceFound | Where-Object company_name -eq $Name

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
            
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
          
        }

        if ($WorkspaceNameFound) {
            
            # Must return a message if Workspace found
            "[{0}] Workspace '{1}' found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Workspace '{0}': Resource already exists in HPE GreenLake! No action needed." -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "This workspace already exists in HPE GreenLake! No action needed."
            }
            
        }
        else {

            # Set country code
            switch ($Country) {
                "Afghanistan" { $CountryCode = "AF" }
                "Aland Islands" { $CountryCode = "AX" }
                "Albania" { $CountryCode = "AL" }
                "Algeria" { $CountryCode = "DZ" }
                "American Samoa" { $CountryCode = "AS" }
                "Andorra" { $CountryCode = "AD" }
                "Angola" { $CountryCode = "AO" }
                "Anguilla" { $CountryCode = "AI" }
                "Antarctica" { $CountryCode = "AQ" }
                "Antigua and Barbuda" { $CountryCode = "AG" }
                "Argentina" { $CountryCode = "AR" }
                "Armenia" { $CountryCode = "AM" }
                "Aruba" { $CountryCode = "AW" }
                "Australia" { $CountryCode = "AU" }
                "Austria" { $CountryCode = "AT" }
                "Azerbaijan" { $CountryCode = "AZ" }
                "Bahamas" { $CountryCode = "BS" }
                "Bahrain" { $CountryCode = "BH" }
                "Bangladesh" { $CountryCode = "BD" }
                "Barbados" { $CountryCode = "BB" }
                "Belarus" { $CountryCode = "BY" }
                "Belgium" { $CountryCode = "BE" }
                "Belize" { $CountryCode = "BZ" }
                "Benin" { $CountryCode = "BJ" }
                "Bermuda" { $CountryCode = "BM" }
                "Bhutan" { $CountryCode = "BT" }
                "Bolivia" { $CountryCode = "BO" }
                "Bonaire, Sint Eustatius and Saba" { $CountryCode = "BQ" }
                "Bosnia and Herzegovina" { $CountryCode = "BA" }
                "Botswana" { $CountryCode = "BW" }
                "Bouvet Island" { $CountryCode = "BV" }
                "Brazil" { $CountryCode = "BR" }
                "British Indian Ocean Territory" { $CountryCode = "IO" }
                "British Virgin Islands" { $CountryCode = "VG" }
                "Brunei" { $CountryCode = "BN" }
                "Bulgaria" { $CountryCode = "BG" }
                "Burkina Faso" { $CountryCode = "BF" }
                "Burundi" { $CountryCode = "BI" }
                "Cambodia" { $CountryCode = "KH" }
                "Cameroon" { $CountryCode = "CM" }
                "Canada" { $CountryCode = "CA" }
                "Cape Verde" { $CountryCode = "CV" }
                "Cayman Islands" { $CountryCode = "KY" }
                "Central African Republic" { $CountryCode = "CF" }
                "Chad" { $CountryCode = "TD" }
                "Chile" { $CountryCode = "CL" }
                "China" { $CountryCode = "CN" }
                "Christmas Island" { $CountryCode = "CX" }
                "Cocos Islands" { $CountryCode = "CC" }
                "Colombia" { $CountryCode = "CO" }
                "Comoros" { $CountryCode = "KM" }
                "Cook Islands" { $CountryCode = "CK" }
                "Costa Rica" { $CountryCode = "CR" }
                "Croatia" { $CountryCode = "HR" }
                "Cuba" { $CountryCode = "CU" }
                "Curacao" { $CountryCode = "CW" }
                "Cyprus" { $CountryCode = "CY" }
                "Czech Republic" { $CountryCode = "CZ" }
                "Democratic Republic of the Congo" { $CountryCode = "CD" }
                "Denmark" { $CountryCode = "DK" }
                "Djibouti" { $CountryCode = "DJ" }
                "Dominica" { $CountryCode = "DM" }
                "Dominican Republic" { $CountryCode = "DO" }
                "East Timor" { $CountryCode = "TL" }
                "Ecuador" { $CountryCode = "EC" }
                "Egypt" { $CountryCode = "EG" }
                "El Salvador" { $CountryCode = "SV" }
                "Equatorial Guinea" { $CountryCode = "GQ" }
                "Eritrea" { $CountryCode = "ER" }
                "Estonia" { $CountryCode = "EE" }
                "Ethiopia" { $CountryCode = "ET" }
                "Falkland Islands" { $CountryCode = "FK" }
                "Faroe Islands" { $CountryCode = "FO" }
                "Fiji" { $CountryCode = "FJ" }
                "Finland" { $CountryCode = "FI" }
                "France" { $CountryCode = "FR" }
                "French Polynesia" { $CountryCode = "PF" }
                "Gabon" { $CountryCode = "GA" }
                "Gambia" { $CountryCode = "GM" }
                "Georgia" { $CountryCode = "GE" }
                "Germany" { $CountryCode = "DE" }
                "Ghana" { $CountryCode = "GH" }
                "Gibraltar" { $CountryCode = "GI" }
                "Greece" { $CountryCode = "GR" }
                "Greenland" { $CountryCode = "GL" }
                "Grenada" { $CountryCode = "GD" }
                "Guadeloupe" { $CountryCode = "GP" }
                "Guam" { $CountryCode = "GU" }
                "Guatemala" { $CountryCode = "GT" }
                "Guernsey" { $CountryCode = "GG" }
                "Guinea" { $CountryCode = "GN" }
                "Guinea-Bissau" { $CountryCode = "GW" }
                "Guyana" { $CountryCode = "GY" }
                "Haiti" { $CountryCode = "HT" }
                "Honduras" { $CountryCode = "HN" }
                "Hong Kong" { $CountryCode = "HK" }
                "Hungary" { $CountryCode = "HU" }
                "Iceland" { $CountryCode = "IS" }
                "India" { $CountryCode = "IN" }
                "Indonesia" { $CountryCode = "ID" }
                "Iran" { $CountryCode = "IR" }
                "Iraq" { $CountryCode = "IQ" }
                "Ireland" { $CountryCode = "IE" }
                "Isle of Man" { $CountryCode = "IM" }
                "Israel" { $CountryCode = "IL" }
                "Italy" { $CountryCode = "IT" }
                "Ivory Coast" { $CountryCode = "CI" }
                "Jamaica" { $CountryCode = "JM" }
                "Japan" { $CountryCode = "JP" }
                "Jersey" { $CountryCode = "JE" }
                "Jordan" { $CountryCode = "JO" }
                "Kazakhstan" { $CountryCode = "KZ" }
                "Kenya" { $CountryCode = "KE" }
                "Kiribati" { $CountryCode = "KI" }
                "Kosovo" { $CountryCode = "XK" }
                "Kuwait" { $CountryCode = "KW" }
                "Kyrgyzstan" { $CountryCode = "KG" }
                "Laos" { $CountryCode = "LA" }
                "Latvia" { $CountryCode = "LV" }
                "Lebanon" { $CountryCode = "LB" }
                "Lesotho" { $CountryCode = "LS" }
                "Liberia" { $CountryCode = "LR" }
                "Libya" { $CountryCode = "LY" }
                "Liechtenstein" { $CountryCode = "LI" }
                "Lithuania" { $CountryCode = "LT" }
                "Luxembourg" { $CountryCode = "LU" }
                "Macau" { $CountryCode = "MO" }
                "Macedonia" { $CountryCode = "MK" }
                "Madagascar" { $CountryCode = "MG" }
                "Malawi" { $CountryCode = "MW" }
                "Malaysia" { $CountryCode = "MY" }
                "Maldives" { $CountryCode = "MV" }
                "Mali" { $CountryCode = "ML" }
                "Malta" { $CountryCode = "MT" }
                "Marshall Islands" { $CountryCode = "MH" }
                "Martinique" { $CountryCode = "MQ" }
                "Mauritania" { $CountryCode = "MR" }
                "Mauritius" { $CountryCode = "MU" }
                "Mayotte" { $CountryCode = "YT" }
                "Mexico" { $CountryCode = "MX" }
                "Micronesia" { $CountryCode = "FM" }
                "Moldova" { $CountryCode = "MD" }
                "Monaco" { $CountryCode = "MC" }
                "Mongolia" { $CountryCode = "MN" }
                "Montenegro" { $CountryCode = "ME" }
                "Montserrat" { $CountryCode = "MS" }
                "Morocco" { $CountryCode = "MA" }
                "Mozambique" { $CountryCode = "MZ" }
                "Myanmar" { $CountryCode = "MM" }
                "Namibia" { $CountryCode = "NA" }
                "Nauru" { $CountryCode = "NR" }
                "Nepal" { $CountryCode = "NP" }
                "Netherlands" { $CountryCode = "NL" }
                "Netherlands Antilles" { $CountryCode = "AN" }
                "New Caledonia" { $CountryCode = "NC" }
                "New Zealand" { $CountryCode = "NZ" }
                "Nicaragua" { $CountryCode = "NI" }
                "Niger" { $CountryCode = "NE" }
                "Nigeria" { $CountryCode = "NG" }
                "Niue" { $CountryCode = "NU" }
                "North Korea" { $CountryCode = "KP" }
                "Northern Mariana Islands" { $CountryCode = "MP" }
                "Norway" { $CountryCode = "NO" }
                "Oman" { $CountryCode = "OM" }
                "Pakistan" { $CountryCode = "PK" }
                "Palau" { $CountryCode = "PW" }
                "Palestine" { $CountryCode = "PS" }
                "Panama" { $CountryCode = "PA" }
                "Papua New Guinea" { $CountryCode = "PG" }
                "Paraguay" { $CountryCode = "PY" }
                "Peru" { $CountryCode = "PE" }
                "Philippines" { $CountryCode = "PH" }
                "Pitcairn" { $CountryCode = "PN" }
                "Poland" { $CountryCode = "PL" }
                "Portugal" { $CountryCode = "PT" }
                "Puerto Rico" { $CountryCode = "PR" }
                "Qatar" { $CountryCode = "QA" }
                "Republic of the Congo" { $CountryCode = "CG" }
                "Reunion" { $CountryCode = "RE" }
                "Romania" { $CountryCode = "RO" }
                "Russia" { $CountryCode = "RU" }
                "Rwanda" { $CountryCode = "RW" }
                "Saint Barthelemy" { $CountryCode = "BL" }
                "Saint Helena" { $CountryCode = "SH" }
                "Saint Kitts and Nevis" { $CountryCode = "KN" }
                "Saint Lucia" { $CountryCode = "LC" }
                "Saint Martin" { $CountryCode = "MF" }
                "Saint Pierre and Miquelon" { $CountryCode = "PM" }
                "Saint Vincent and the Grenadine" { $CountryCode = "VC" }
                "Samoa" { $CountryCode = "WS" }
                "San Marino" { $CountryCode = "SM" }
                "Sao Tome and Principe" { $CountryCode = "ST" }
                "Saudi Arabia" { $CountryCode = "SA" }
                "Senegal" { $CountryCode = "SN" }
                "Serbia" { $CountryCode = "RS" }
                "Seychelles" { $CountryCode = "SC" }
                "Sierra Leone" { $CountryCode = "SL" }
                "Singapore" { $CountryCode = "SG" }
                "Sint Maarten" { $CountryCode = "SX" }
                "Slovakia" { $CountryCode = "SK" }
                "Slovenia" { $CountryCode = "SI" }
                "Solomon Islands" { $CountryCode = "SB" }
                "Somalia" { $CountryCode = "SO" }
                "South Africa" { $CountryCode = "ZA" }
                "South Georgia and the South Sandwich Islands" { $CountryCode = "GS" }
                "South Korea" { $CountryCode = "KR" }
                "South Sudan" { $CountryCode = "SS" }
                "Spain" { $CountryCode = "ES" }
                "Sri Lanka" { $CountryCode = "LK" }
                "Sudan" { $CountryCode = "SD" }
                "Suriname" { $CountryCode = "SR" }
                "Svalbard and Jan Mayen" { $CountryCode = "SJ" }
                "Swaziland" { $CountryCode = "SZ" }
                "Sweden" { $CountryCode = "SE" }
                "Switzerland" { $CountryCode = "CH" }
                "Syria" { $CountryCode = "SY" }
                "Taiwan" { $CountryCode = "TW" }
                "Tajikistan" { $CountryCode = "TJ" }
                "Tanzania" { $CountryCode = "TZ" }
                "Thailand" { $CountryCode = "TH" }
                "The French Republic" { $CountryCode = "GF" }
                "The Territory of Norfolk Island" { $CountryCode = "NF" }
                "Togo" { $CountryCode = "TG" }
                "Tokelau" { $CountryCode = "TK" }
                "Tonga" { $CountryCode = "TO" }
                "Trinidad and Tobago" { $CountryCode = "TT" }
                "Tunisia" { $CountryCode = "TN" }
                "Turkey" { $CountryCode = "TR" }
                "Turkmenistan" { $CountryCode = "TM" }
                "Turks and Caicos Islands" { $CountryCode = "TC" }
                "Tuvalu" { $CountryCode = "TV" }
                "U.S. Virgin Islands" { $CountryCode = "VI" }
                "Uganda" { $CountryCode = "UG" }
                "Ukraine" { $CountryCode = "UA" }
                "United Arab Emirates" { $CountryCode = "AE" }
                "United Kingdom" { $CountryCode = "GB" }
                "United States" { $CountryCode = "US" }
                "United States Minor Outlying Islands" { $CountryCode = "UM" }
                "Uruguay" { $CountryCode = "UY" }
                "Uzbekistan" { $CountryCode = "UZ" }
                "Vanuatu" { $CountryCode = "VU" }
                "Vatican" { $CountryCode = "VA" }
                "Venezuela" { $CountryCode = "VE" }
                "Vietnam" { $CountryCode = "VN" }
                "Wallis and Futuna" { $CountryCode = "WF" }
                "Western Sahara" { $CountryCode = "EH" }
                "Yemen" { $CountryCode = "YE" }
                "Zambia" { $CountryCode = "ZM" }
                "Zimbabwe" { $CountryCode = "ZW" }
            }
            

            if ($Type -eq "Managed Service Provider workspace") {
                $WorkspaceType = "MSP"
            }
            elseif ($Type -eq "Standard enterprise workspace") {
                $WorkspaceType = "STANDALONE"
                
            }

            # Create payload  

            $Payload = [PSCustomObject]@{
                workspace_type   = $WorkspaceType
                company_name     = $Name
                created_by       = $HPEGreenLakeSession.username
                email            = $Email
                phone_number     = $PhoneNumber
                iam_v2_workspace = $false   # $true to create a v2 workspace
                address          = @{
                    street_address   = $Street
                    street_address_2 = $Street2
                    city             = $City
                    state_or_region  = $State
                    zip              = $PostalCode
                    country_code     = $CountryCode
                }
            } | ConvertTo-Json -Depth 5


            # Create workspace

            try {
                            
                if ($HPEGreenLakeSession.workspaceId) {
                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -WhatIfBoolean $WhatIf 
                    
                } 
                # If this is the first workspace beeing created, the workspace session check must be skipped with Invoke-HPEGLWebRequest
                else {
                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -SkipSessionCheck -WhatIfBoolean $WhatIf 
                }

                if (-not $WhatIf) {

                    "[{0}] Workspace '{1}' successfully created!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    # When the first workspace is created, it is necessary to run 'Connect-HPEGL -workspace <workspace_name>' to access the first new workspace.
                    if (-not $HPEGreenLakeSession.workspaceId) {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Workspace successfully created! Session disconnected, you must run `Connect-HPEGL -workspace <workspace_name>` to access the new workspace."
                        
                    }
                    else {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Workspace successfully created!"
                    }

                }


            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Workspace cannot be created!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }
           
        }

        [void] $WorkspaceCreationStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($WorkspaceCreationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures during the attempt to create the workspace!"
          
            }
            else {
                
                # Must disconnect if this is the first workspace beeing created
                if (-not $WorkspaceFound) {
                    Disconnect-HPEGL
                }
                else {
                    $Global:HPEGreenLakeSession.workspacesCount++
                    
                }
            }

            $WorkspaceCreationStatus = Invoke-RepackageObjectWithType -RawObject $WorkspaceCreationStatus -ObjectName "ObjStatus.NSDE" 
            Return $WorkspaceCreationStatus
        }


    }
}


Function Set-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Updates the current workspace details.

    .DESCRIPTION
    Updates general information about the HPE GreenLake workspace to which you are currently connected. If you omit any parameter, the cmdlet retains the current settings for those fields and only updates the provided parameters.

    .PARAMETER NewName 
    Specifies the new name of the workspace. The new name must be unique across all workspaces on the HPE GreenLake platform.

    .PARAMETER Street
    Specifies the postal street address of the workspace.

    .PARAMETER Street2
    Specifies the secondary postal street address (Apt, suite, building, floor, etc.) of the workspace.

    .PARAMETER Country
    Specifies the country of origin for the company.

    .PARAMETER City
    Specifies the city of the workspace.

    .PARAMETER State
    Specifies the state of the workspace.

    .PARAMETER PostalCode
    Specifies the postal code of the workspace.

    .PARAMETER PhoneNumber
    Specifies the contact phone number of the workspace.

    .PARAMETER Email
    Specifies the contact email address of the workspace. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLWorkspace `
        -Street "Theory of Dynamical Systems Street" `
        -City Heaven `
        -PostalCode 77777 `
        -Country France `
        -PhoneNumber +33612345678

    Sets the street address, city, postal code, country, and phone number information of the currently connected HPE GreenLake workspace.

    .EXAMPLE
    Set-HPEGLWorkspace -State "" -Street2 ""

    Removes the state and the secondary address line details from the currently connected HPE GreenLake workspace while preserving all other existing settings.

    .INPUTS
    No pipeline input is supported.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the workspace object attempted to be updated.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if the workspace update is successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
        [ValidateNotNullOrEmpty()]
        [String]$NewName,

        [String]$Street,
        [String]$Street2,
        [String]$City,
        [String]$State,
        [String]$PostalCode,

        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,

        [String]$PhoneNumber,

        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,    

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetWorkspaceStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Check current workspace

        try {
            $WorkspaceDetails = Get-HPEGLWorkspace -ShowCurrent
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        $Uri = $CurrentWorkspaceUri

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $WorkspaceDetails.company_name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                  
        }

        # Conditionally add properties
        if ($NewName) {
            $Name = $NewName
        }
        else {
            $Name = $WorkspaceDetails.company_name
        }
       
        if (-not $PSBoundParameters.ContainsKey('Street')) {
	    
            if ($WorkspaceDetails.address.street_address) {
                          
                $Street = $WorkspaceDetails.address.street_address
            }
            else {
                $Street = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('Street2')) {
	    
            if ($WorkspaceDetails.address.street_address_2) {
                          
                $Street2 = $WorkspaceDetails.address.street_address_2

            }
            else {
                $Street2 = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('State')) {
	    
            if ($WorkspaceDetails.address.state_or_region) {
                          
                $State = $WorkspaceDetails.address.state_or_region

            }
            else {
                $State = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('PostalCode')) {
	    
            if ($WorkspaceDetails.address.zip) {
                          
                $PostalCode = $WorkspaceDetails.address.zip

            }
            else {
                $PostalCode = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('City')) {
	    
            if ($WorkspaceDetails.address.city) {
                          
                $City = $WorkspaceDetails.address.city

            }
            else {
                $City = $Null
            }
        }
 
        if (-not $PSBoundParameters.ContainsKey('Country')) {
	    
            if ($WorkspaceDetails.address.country_code) {
                          
                $CountryCode = $WorkspaceDetails.address.country_code

            }

        }
        else {
            $CountryCode = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $Country | ForEach-Object const
        }
        
        if (-not $PSBoundParameters.ContainsKey('PhoneNumber')) {
	    
            if ($WorkspaceDetails.phone_number) {
                          
                $PhoneNumber = $WorkspaceDetails.phone_number

            }
            else {
                $PhoneNumber = $Null
            }

        }

        if (-not $PSBoundParameters.ContainsKey('Email')) {
	    
            if ($WorkspaceDetails.email) {
                          
                $Email = $WorkspaceDetails.email

            }
            else {
                $Email = $Null
            }

        }

        $Payload = [PSCustomObject]@{
            company_name = $Name
            email        = $Email
            phone_number = $PhoneNumber
            address      = @{
                street_address   = $Street
                street_address_2 = $Street2
                city             = $City
                state_or_region  = $State
                zip              = $PostalCode
                country_code     = $CountryCode
            }
        } | ConvertTo-Json -Depth 5


        # Current workspace modification
        try {
        
            $Response = Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf
                         
            if (-not $WhatIf) {
                $objStatus.Status = "Complete"
                $objStatus.Details = ($Response | ForEach-Object message)
            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = ($Response | ForEach-Object message)
                $objStatus.Exception = $_.Exception.message 
            }
        }    

        [void] $SetWorkspaceStatus.add($objStatus)
        

    }

    end {

        if (-not $WhatIf) {

            if ($SetWorkspaceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to update the workspace details!"
          
            }

            $SetWorkspaceStatus = Invoke-RepackageObjectWithType -RawObject $SetWorkspaceStatus -ObjectName "ObjStatus.NSDE" 
            Return $SetWorkspaceStatus
        }


    }
}


Function Get-HPEGLWorkspaceSAMLSSODomain {
    <#
    .SYNOPSIS
    Retrieves details of the SAML SSO domain.

    .DESCRIPTION
    This function retrieves information about the SAML SSO domain configured in the workspace. It can return SAML attributes, download the metadata file for a specified domain, and extract the X509 certificate from the metadata file if requested.

    .PARAMETER DomainName
    Specifies the name of the SAML SSO domain.

    .PARAMETER ShowSAMLAttributes
    If specified, returns the SAML attributes for the specified domain.

    .PARAMETER ShowSPCertificate
    If specified, returns the Service Provider (SP, i.e., HPE GreenLake) X509 certificate.

    .PARAMETER ShowIDPCertificate
    If specified, returns the Identity Provider (IdP) X509 certificate.

    .PARAMETER DownloadServiceProviderMetadata
    If specified, downloads the SAML SSO metadata file of the Service Provider (SP, i.e., HPE GreenLake) to the specified file path. This metadata is used by Identity Providers (IdPs) like ADFS to establish trust and facilitate Single Sign-On (SSO) interactions.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be executed, without actually sending the request. Useful for understanding the native REST API interactions with GLP.

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain

    Retrieves all SAML SSO domains configured in the workspace.

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com"

    Returns the SAML SSO domain "example.com" details.

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -ShowSAMLAttributes

    Retrieves the SAML attributes for the SAML SSO domain "example.com".

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -ShowSPCertificate

    Returns the Service Provider (SP, i.e., HPE GreenLake) X509 certificate for the SAML SSO domain "example.com".

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -ShowIDPCertificate

    Returns the Identity Provider (IdP) X509 certificate for the SAML SSO domain "example.com".

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -DownloadServiceProviderMetadata "C:\path\to\metadata.xml"

    Downloads the metadata file for the SAML SSO domain "example.com" to the specified file path.

    #>

    [CmdletBinding(DefaultParameterSetName = "Default")]
    Param(
        [Parameter(ParameterSetName = "Default")]
        [Parameter(Mandatory, ParameterSetName = "DomainNameSAMLAttributes")]
        [Parameter(Mandatory, ParameterSetName = "DomainNameSP")]
        [Parameter(Mandatory, ParameterSetName = "DomainNameIDP")]
        [Parameter(Mandatory, ParameterSetName = "DomainNameMetadataDownload")]
        [String]$DomainName,

        [Parameter(ParameterSetName = "DomainNameSAMLAttributes")]
        [switch]$ShowSAMLAttributes,
        
        [Parameter(ParameterSetName = "DomainNameSP")]
        [switch]$ShowSPCertificate,

        [Parameter(ParameterSetName = "DomainNameIDP")]
        [switch]$ShowIDPCertificate,

        [Parameter(ParameterSetName = "DomainNameMetadataDownload")]
        [String]$DownloadServiceProviderMetadata,

        [Switch]$WhatIf
    )

    Begin {
        $Caller = (Get-PSCallStack)[1].Command
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = [System.Collections.ArrayList]::new()
        
        $Uri = $AuthnSAMLSSOUri 
        

        try {
          
            [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }


        if ($Collection.domains.count -gt 0) {

            $Collection = $Collection.domains
        }     
        else {
            $Collection = $Null
        }
        

        if ($Null -ne $Collection ) {

            if ($DomainName) {
                
                $DomainFound = $Collection | Where-Object domain -eq $DomainName

                if (($DomainFound -or ($DomainFound -and $ShowIDPCertificate)) -and -not $ShowSAMLAttributes -and -not $ShowSPCertificate -and -not $DownloadServiceProviderMetadata) {

                    $Uri = $AuthnSAMLSSOUri + "/" + $DomainName

                    [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf

                    if ($ShowIDPCertificate) {

                        $ReturnData = $Collection.saml_idp_config.signing_certificate

                    }
                    else {
                        
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Workspace.SAML.Domain.Details"    
                    }

                    return $ReturnData  

                }
                elseif ($DomainFound -and $ShowSAMLAttributes) {

                    $uri = $SAMLAttributesUri + $DomainFound.domain
                    
                    try {
                        $SAMLAttributes = (Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf)
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($SAMLAttributes) {

                        # Add the GLP application to the applications property as it does not exist
                        $GLP_object = [PSCustomObject]@{
                            application_id   = "00000000-0000-0000-0000-000000000000"
                            application_name = "HPE GreenLake platform"
                        }

                        $SAMLAttributes.applications += $GLP_object

                        # Add the missing properties to each applications item
                        foreach ($currentItemName in $SAMLAttributes.applications) {
                            $currentItemName | Add-Member -Type NoteProperty -Name "entity_id" -Value $SAMLAttributes.entity_id	
                            $currentItemName | Add-Member -Type NoteProperty -Name "sign_on_url" -Value $SAMLAttributes.sign_on_url		
                            $currentItemName | Add-Member -Type NoteProperty -Name "platform_customer_id" -Value $SAMLAttributes.platform_customer_id			
                        }

                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $SAMLAttributes.applications -ObjectName "Workspace.SAML.Attributes"    

                        return $ReturnData

                    }
                    else {

                        return

                    }

                }
                elseif ($DomainFound -and ($DownloadServiceProviderMetadata -or $ShowSPCertificate)) {

                    $Uri = $AuthnSAMLSSOMetadataUri + $DomainFound.domain
            
                    try {
                        [string]$MetadataURL = (Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf).metadata_url
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }
        
                    if ($MetadataURL) {
    
                        [xml]$MetadataFile = Invoke-WebRequest -Method GET -Uri $MetadataURL
        
                        if ($ShowSPCertificate) {
                            return $MetadataFile.EntityDescriptor.SPSSODescriptor.KeyDescriptor.KeyInfo.X509Data.X509Certificate
                        }
                        elseif ($DownloadServiceProviderMetadata) {
                            $MetadataFile.Save($DownloadServiceProviderMetadata)
                            Write-Output "Metadata file '$DownloadServiceProviderMetadata' successfully downloaded." 
                        }
                        else {
                            return $MetadataFile
                        }
                    }
                    else {
                        return
                    }
    
                }
                elseif (($DownloadServiceProviderMetadata -or $ShowSPCertificate -or $ShowSAMLAttributes -or $ShowIDPCertificate) -and -not $DomainFound) {

                    "[{0}] SAML SSO Domain '{1}' cannot be found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName | Write-Verbose
        
                    $ErrorMessage = "SAML SSO Domain '{0}': Resource cannot be found in the workspace!" -f $DomainName
                    Write-Warning $ErrorMessage
                    return
                }
                else {

                    return

                }
                
            }            
            else {
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Workspace.SAML.Domain"    
                
                $ReturnData = $ReturnData | Sort-Object { $_.domain }
                
                return $ReturnData  

            }
        }    
        else {
            Return
        } 
    }
}


Function New-HPEGLWorkspaceSAMLSSODomain {
    <#
    .SYNOPSIS
    Adds a SAML SSO domain to the workspace.

    .DESCRIPTION
    Configures a SAML SSO domain in the workspace to enable Single Sign-On (SSO). The SSO connection can be used for authentication only or can also provide role information via the SAML response.
    
    The SAML SSO domain must be a private domain that you own, such as example.com, mycompany.com, or mydomain.com. Public domains like facebook.com, gmail.com, outlook.com, or yahoo.com cannot be used to configure SSO. 
    
    The domain must have at least one verified user belonging to it defined in the workspace.
    
    .PARAMETER DomainName
    Specifies the name of the SAML SSO domain to create. There must be at least one verified user belonging to the domain.

    .PARAMETER AuthorizationMethod
    Specifies the authorization method for the SAML SSO domain. Supported values are "SAML" or "Locally-managed".
    - SAML: Use the SSO SAML response for session-based authorization.
    - Locally-managed: Manage authorization locally via the GreenLake Platform.

    .PARAMETER MetadataSource
    Specifies the source of the metadata file for the SAML SSO domain. The metadata file can be provided as a file path or a URL. The metadata file must be in XML format.

    .PARAMETER EmailAttribute
    Optional attribute to set the email mapping attribute. The default value is "NameId", which is commonly used by identity providers.

    .PARAMETER FirstNameAttribute
    Optional attribute to set the first name mapping attribute. The default value is "FirstName", which is commonly used by identity providers. Set this attribute if your identity provider uses a different attribute. If your identity provider does not have SAML attributes for these values, you can ignore this parameter.

    .PARAMETER LastNameAttribute
    Optional attribute to set the last name mapping attribute. The default value is "LastName", which is commonly used by identity providers. Set this attribute if your identity provider uses a different attribute. If your identity provider does not have SAML attributes for these values, you can ignore this parameter.

    .PARAMETER GreenLakeAttribute
    SAML attribute name for the HPE GreenLake attribute. This is required when SAML is being used for authorization. The default value is "hpe_ccs_attribute".

    .PARAMETER IdleSessionTimeout
    Specifies the amount of time in minutes a user can be inactive before a session ends. Idle time cannot exceed 1,440 minutes (24 hours).

    .PARAMETER RecoveryUserPassword
    Specifies the recovery user password. The password must be at least 8 characters long and include upper-case, lower-case, number, and symbol.

    .PARAMETER PointOfContactEmail
    Specifies the point of contact email that will be used to regain access to your account if you forget your password.

    .PARAMETER DisableRecoveryUser
    Disables the recovery user for the SAML SSO domain.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    $PlainTextPassword = "YourPlainTextPassword!10"
    $SecurePassword = ConvertTo-SecureString -String $PlainTextPassword -AsPlainText -Force
    New-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -AuthorizationMethod SAML -MetadataSource "C:\Documents\federationmetadata.xml" -RecoveryUserSecurePassword $SecurePassword -PointOfContactEmail leonhard.euler@mathematician.com
    
    Adds a new SAML SSO domain named "example.com" with a specified metadata file provided as a file path, a recovery user password, and a point of contact email. The SAML SSO domain is configured for SAML-based authorization, i.e., the SSO SAML response defines the session-based authorization.

    .EXAMPLE
    New-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -AuthorizationMethod Locally-managed -MetadataSource "https://example.com/federationmetadata/2007-06/federationmetadata.xml" -RecoveryUserSecurePassword $SecurePassword -PointOfContactEmail leonhard.euler@mathematician.com
    
    Adds a new SAML SSO domain named "example.com" with the specified metadata file provided as a URL, a recovery user password, and a point of contact email. The SAML SSO domain is configured for locally-managed authorization, i.e., authorization is managed locally via the GreenLake Platform.

    .EXAMPLE
    New-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -AuthorizationMethod Locally-managed -MetadataSource "https://example.com/federationmetadata/2007-06/federationmetadata.xml" -DisableRecoveryUser
    
    Adds a new SAML SSO domain named "example.com" with the specified metadata file provided as a URL and disables the recovery user for the SAML SSO domain. The SAML SSO domain is configured for locally-managed authorization, i.e., authorization is managed locally via the GreenLake Platform.

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the SAML SSO domain to add.
        * RecoveryUserEmail - The email of the generated recovery user (if not disabled).
        * Status - The status of the creation attempt (Failed for HTTP error return; Complete if deployment is successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
#>

    [CmdletBinding(DefaultParameterSetName = "MetadataFileEnableRecoveryUser")]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "MetadataFileEnableRecoveryUser")]
        [Parameter (Mandatory, ParameterSetName = "MetadataFileDisableRecoveryUser")]
        [String]$DomainName,

        [Parameter (Mandatory)]
        [ValidateSet("SAML", "Locally-managed")]
        [String]$AuthorizationMethod,

        [Parameter (Mandatory, ValueFromPipeline, ParameterSetName = "MetadataFileEnableRecoveryUser")]
        [Parameter (Mandatory, ValueFromPipeline, ParameterSetName = "MetadataFileDisableRecoveryUser")]
        [String]$MetadataSource,

        [String]$EmailAttribute = "NameId", 
        
        [String]$FirstNameAttribute = "FirstName",
        
        [String]$LastNameAttribute = "LastName",
        
        [String]$GreenLakeAttribute = "hpe_ccs_attribute",

        [ValidateScript({
                if ($_ -le 1440) {
                    $true
                }
                else {
                    throw "Idle time cannot exceed 1,440 minutes (24 hours)."
                }
            })]
        [Int]$IdleSessionTimeout = 60,

        [Parameter (Mandatory, ParameterSetName = "MetadataFileEnableRecoveryUser")]
        [SecureString]$RecoveryUserSecurePassword,

        [Parameter (Mandatory, ParameterSetName = "MetadataFileEnableRecoveryUser")]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$PointOfContactEmail,

        [Parameter (Mandatory, ParameterSetName = "MetadataFileDisableRecoveryUser")]
        [switch]$DisableRecoveryUser,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $ApplicationProvisioningUri  

        $AddSAMLSSODomainStatus = [System.Collections.ArrayList]::new()

        
        
    }
    
    Process {
        
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        if ($RecoveryUserSecurePassword) {

            # Convert SecureString to plain text
            $RecoveryUserPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($RecoveryUserSecurePassword))
            
            if ($RecoveryUserPassword -notmatch '^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[\W_]).{8,}$') {
                throw "The recovery user password must be at least 8 characters long and include upper-case, lower-case, number, and symbol."
            }
        }
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name              = $DomainName
            RecoveryUserEmail = $Null
            Status            = $Null
            Details           = $Null
            Exception         = $Null
                                  
        }      

        # Validate domain name
        try {

            "[{0}] Validating SAML SSO domain '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName | Write-Verbose

            $uri = $SAMLValidateDomainUri + $DomainName
            $ValidateDomain = Invoke-HPEGLWebRequest -Uri $Uri -method 'Get' 

        }
        catch { 

            if ($_ -match "Error status Code: 412") {

                if ($WhatIf) {
                    $ErrorMessage = "Domain {0} already claimed by the user for the workspace" -f $DomainName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Domain {0} already claimed by the user for the workspace" -f $DomainName
                    $objStatus.Exception = $_.Exception.message

                }
            }
        }
        
        if ($ValidateDomain.message -ne "Domain valid." -or $objStatus.Status -eq "Failed") {

            # Must return a message if domain is not valid 
            "[{0}] SAML SSO domain '{1}' is not valid!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "SAML SSO domain '{0}' is not valid! Error: {1}" -f $DomainName, $ValidateDomain.message
                Write-warning $ErrorMessage
                return
            }
            else {

                if ($objStatus.Status -ne "Failed") {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "SAML SSO domain is not valid!"
                    $objStatus.Exception = $ValidateDomain.message
                }
            }
        }
        else {

            $FileFound = $false

            # Check if the MetadataSource is a URL
            if ($MetadataSource -match '^https?://') {

                "[{0}] MetadataSource detected as a URL" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Read the XML file from the URL
                try {
                    [xml]$MetadataXMLFile = Invoke-WebRequest -Uri $MetadataSource -UseBasicParsing -Method Get -ContentType 'application/xml' | Select-Object -ExpandProperty Content
                    
                    "[{0}] MetadataSource file has been found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    $FileFound = $True
                }
                catch {
                    $MetadataXMLFile = $Null
                }

            }
            else {

                "[{0}] MetadataSource detected as a file" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Test the path of the XML file 
                $FileFound = Test-Path -Path $MetadataSource

                if ($FileFound -eq $True) {

                    "[{0}] MetadataSource file has been found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    [xml]$MetadataXMLFile = Get-Content $MetadataSource -Raw

                }
            }
        

            if ($FileFound -eq $False) {

                "[{0}] Error! MetadataSource cannot be found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Must return a message if Metadata file is not found
                if ($WhatIf) {
                    $ErrorMessage = "Metadata XML file cannot be found at '{0}'" -f $MetadataSource
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Metadata file cannot be found at $MetadataSource"
                }                

            } 
            else {
                
                "[{0}] Metadata file content: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $MetadataXMLFile | Write-Verbose
    
                $EntityID = $MetadataXMLFile.EntityDescriptor.entityID
                $LoginURL = $MetadataXMLFile.EntityDescriptor.IDPSSODescriptor.SingleSignOnService | Where-Object { $_.Binding -eq "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" } | Select-Object -ExpandProperty Location
                $LogoutURL = $MetadataXMLFile.EntityDescriptor.IDPSSODescriptor.SingleLogoutService | Where-Object { $_.Binding -eq "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect" } | Select-Object -ExpandProperty Location
                $SigningCertificate = $MetadataXMLFile.EntityDescriptor.IDPSSODescriptor.KeyDescriptor | Where-Object { $_.use -eq "signing" } | Select-Object -ExpandProperty KeyInfo | Select-Object -ExpandProperty X509Data | Select-Object -ExpandProperty X509Certificate

           
                # Valid metadata file
    
                $SamlIDPConfig = [PSCustomObject]@{
                    entity_id           = $EntityID
                    login_url           = $LoginURL
                    logout_url          = $LogoutURL
                    signing_certificate = $SigningCertificate
                   
                }
                
                $Payload = $SamlIDPConfig | ConvertTo-Json -Depth 5
    
                try {
    
                    $uri = $SAMLValidateMetadataUri + $DomainName
                    $ValidateMetadata = Invoke-HPEGLWebRequest -Uri $Uri -method 'Post' -ContentType application/json -Body $Payload
        
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
            
                }
    
                if ($ValidateMetadata.message -ne "Metadata Valid") {
                    # Must return a message if domain is not valid 
                    "[{0}] Metadata is not valid!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
                    if ($WhatIf) {
                        $ErrorMessage = "Metadata is not valid! Message: {1} - Error code: {2}" -f $ValidateMetadata.message, $ValidateMetadata.error_code
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Metadata is not valid! Message: {0}" -f $ValidateMetadata.message
                        $objStatus.Exception = $ValidateMetadata.error_code
                    }
                }
                else {
    
                    if ($AuthorizationMethod -eq "SAML") {
                        
                        $SSOMode = "AUTHORIZATION"
                    }
                    else {
                        $SSOMode = "AUTHENTICATION_ONLY"
                    }
    
    
                    if ($DisableRecoveryUser) {

                        if ($AuthorizationMethod -eq "Locally-Managed") {
                            
                            $Payload = [PSCustomObject]@{
                                domain               = $DomainName
                                authorization_method = $AuthorizationMethod
                                saml_idp_config      = $SamlIDPConfig
                                attribute_mapping    = @{
                                    email                = $EmailAttribute
                                    first_name           = $FirstNameAttribute
                                    last_name            = $LastNameAttribute
                                    idle_session_timeout = $IdleSessionTimeout
                                }
                                recovery_user        = $Null
                                sso_mode             = $SSOMode
        
                            } | ConvertTo-Json -Depth 5
                        }
                        else {

                            $Payload = [PSCustomObject]@{
                                domain               = $DomainName
                                authorization_method = $AuthorizationMethod
                                saml_idp_config      = $SamlIDPConfig
                                attribute_mapping    = @{
                                    email                = $EmailAttribute
                                    first_name           = $FirstNameAttribute
                                    last_name            = $LastNameAttribute
                                    idle_session_timeout = $IdleSessionTimeout
                                    hpe_ccs_attribute    = $GreenLakeAttribute
                                }
                                recovery_user        = $Null
                                sso_mode             = $SSOMode
        
                            } | ConvertTo-Json -Depth 5
                        }
                    }
                    else {
    
                        # Create recovery user email account using workspace ID       
                        $RecoveryUserEmail = "sso_re_" + $HPEGreenLakeSession.workspaceId + "@" + $DomainName
    
                        $objStatus.RecoveryUserEmail = $RecoveryUserEmail

                        if ($AuthorizationMethod -eq "Locally-Managed") {

                            $Payload = [PSCustomObject]@{
                                domain               = $DomainName
                                authorization_method = $AuthorizationMethod
                                saml_idp_config      = $SamlIDPConfig
                                attribute_mapping    = @{
                                    email                = $EmailAttribute
                                    first_name           = $FirstNameAttribute
                                    last_name            = $LastNameAttribute
                                    idle_session_timeout = $IdleSessionTimeout
                                }
                                recovery_user        = @{
                                    username       = $RecoveryUserEmail
                                    password       = $RecoveryUserPassword
                                    recovery_email = $PointOfContactEmail
                                    
                                }
                                sso_mode             = $SSOMode
                            } | ConvertTo-Json -Depth 5
                        }
                        else {
                            
                            $Payload = [PSCustomObject]@{
                                domain               = $DomainName
                                authorization_method = $AuthorizationMethod
                                saml_idp_config      = $SamlIDPConfig
                                attribute_mapping    = @{
                                    email                = $EmailAttribute
                                    first_name           = $FirstNameAttribute
                                    last_name            = $LastNameAttribute
                                    idle_session_timeout = $IdleSessionTimeout
                                    hpe_ccs_attribute    = $GreenLakeAttribute
                                }
                                recovery_user        = @{
                                    username       = $RecoveryUserEmail
                                    password       = $RecoveryUserPassword
                                    recovery_email = $PointOfContactEmail
                                    
                                }
                                sso_mode             = $SSOMode
                            } | ConvertTo-Json -Depth 5
                        }        
                    }
        
                    $Uri = $AuthnSAMLSSOConfigUri 
    
    
                    try {
    
                        $counter = 1
    
                        # Define the spinning cursor characters
                        $spinner = @('|', '/', '-', '\')
                        
                        # Get the current width of the terminal window                
                        $terminalWidth = (Get-Host).UI.RawUI.WindowSize.Width                    
                        
                        # Create a clear line string based on the terminal width to ensure the entire line is overwritten
                        if (-not $psISE) {
                            $clearLine = " " * ($terminalWidth - 1)
                        }   
    
                        $Response = Invoke-HPEGLWebRequest -Method 'POST' -Body $Payload -Uri $Uri -WhatIfBoolean $WhatIf

                        if (-not $WhatIf) {

                            $TaskTrackingId = $Response.task_tracking_id
        
                            $Uri = $AuthnSAMLSSOConfigTaskTrackerUri + $TaskTrackingId 
            
                            do {
            
                                $subcounter = 0
            
                                do {
            
                                    $TaskTrackingStatus = Invoke-HPEGLWebRequest -Uri $Uri -method GET 
            
                                    # Calculate the current spinner character
                                    $spinnerChar = $spinner[$subcounter % $spinner.Length]
                                    
                                    # Display the spinner character, replacing the previous content
                                    $output = "Adding SAML SSO domain '{0}' to the workspace: {1} {2}" -f $DomainName, $TaskTrackingStatus.Status, $spinnerChar
            
                                    if (-not $psISE) {
                                        Write-Host "`r$clearLine`r$output" -NoNewline -ForegroundColor Yellow
                                    }
                                    else {
                                        Write-Host "$output" -ForegroundColor Yellow
                                    }
            
                                    $subcounter++
                                    Start-Sleep -Seconds 1
                                    
                                    
                                } while (
                                    $TaskTrackingStatus.Status -eq "IN_PROGRESS"
                                )
            
                                # Increment counter
                                $counter++
            
                            } until ($TaskTrackingStatus.Status -eq "DONE" -or $counter -gt 10)       
        
                            # Clear the message after do/until is complete
                            if (-not $psISE) {
                                "`r$clearLine`r" | Write-Host -NoNewline                    
                            }
                            
                            if ($counter -gt 10) {
                                
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Failed to add the SAML SSO domain to the workspace."
        
                            }
                            else {
        
                                "[{0}] Adding SAML SSO domain '{1}' to the workspace... status: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName, $TaskTrackingStatus.Status | Write-Verbose
                                
                                if (-not $WhatIf) {
        
                                    $objStatus.Status = $TaskTrackingStatus.status
                                    $objStatus.Details = $TaskTrackingStatus.response.data.message
                                    
                                }
                            }
                        }    
                    }
                    catch {
    
                        if (-not $WhatIf) {
    
                            # Clear the message after do/until is complete
                            if (-not $psISE) {
                                "`r$clearLine`r" | Write-Host -NoNewline                    
                            }
        
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Failed to add the SAML SSO domain to the workspace."
                            $objStatus.Exception = $_.Exception.message 
                        }
                    }   
                }
            }
        }

        [void] $AddSAMLSSODomainStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($AddSAMLSSODomainStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "Failed to add one or more SAML SSO domains."
          
            }

            $AddSAMLSSODomainStatus = Invoke-RepackageObjectWithType -RawObject $AddSAMLSSODomainStatus -ObjectName "ObjStatus.NRSDE" 
            Return $AddSAMLSSODomainStatus
        }
    }
}


Function Set-HPEGLWorkspaceSAMLSSODomain {
    <#
    .SYNOPSIS
    Sets details of the SAML SSO domain.

    .DESCRIPTION
    This function modifies the SAML SSO information of a domain configured in the workspace. It can set the SAML attributes, upload the metadata file for a specified domain, and update the X509 certificate if requested.

    .PARAMETER DomainName
    Specifies the name of the SAML SSO domain to set.

    .PARAMETER X509Certificate
    Specifies the new X509 certificate for the specified domain.

    .PARAMETER EmailAttribute
    Specifies the new email address attribute for the specified domain.

    .PARAMETER FirstNameAttribute
    Specifies the new first name attribute for the specified domain.

    .PARAMETER LastNameAttribute
    Specifies the new last name attribute for the specified domain.

    .PARAMETER GreenLakeAttribute
    Specifies the new HPE GreenLake attribute for the specified domain.

    .PARAMETER IdleSessionTimeout
    Specifies the new idle session timeout attribute for the specified domain.

    .PARAMETER LoginURL
    Specifies the new login URL for the specified domain.

    .PARAMETER LogoutURL
    Specifies the new logout URL for the specified domain.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be executed, without actually sending the request. Useful for understanding the native REST API interactions with GLP.

    .EXAMPLE
    $certificate = "MIIE5DCCAsygAwIBAgIQUK3zqnGiHrNBkAvI5tS8bDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyN....xkUqNXSHY="
    Set-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -X509Certificate $certificate

    Sets the new X509 certificate for the SAML SSO domain "example.com".

    .EXAMPLE
    Set-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -EmailAttribute "email"

    Sets the new email address attribute for the SAML SSO domain "example.com".

    .EXAMPLE
    Set-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -FirstNameAttribute "FirstName"

    Sets the new first name attribute for the SAML SSO domain "example.com".

    .EXAMPLE
    Set-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -LastNameAttribute "LastName"

    Sets the new last name attribute for the SAML SSO domain "example.com".

    .EXAMPLE
    Set-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -GreenLakeAttribute "GreenLakeAttribute"

    Sets the new HPE GreenLake attribute for the SAML SSO domain "example.com".

    .EXAMPLE
    Set-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" -IdleSessionTimeout 30

    Sets the new idle session timeout attribute for the SAML SSO domain "example.com".

    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory)]
        [String]$DomainName,

        [String]$X509Certificate,

        [String]$EmailAttribute,

        [String]$FirstNameAttribute,

        [String]$LastNameAttribute,

        [String]$GreenLakeAttribute,

        [String]$LoginURL,

        [String]$LogoutURL,

        [Int]$IdleSessionTimeout,

        [Switch]$WhatIf
    )

    Begin {
       
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $DomainName
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }
        

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            
            $DomainFound = Get-HPEGLWorkspaceSAMLSSODomain -DomainName $DomainName
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        foreach ($Object in $ObjectStatusList) {
            
            $Uri = $AuthnSAMLSSOConfigUri

            if (-not $DomainFound) {

                # Must return a message if domain not found
                $Object.Status = "Failed"
                $Object.Details = "SAML SSO domain cannot be found in the workspace!"

                if ($WhatIf) {
                    $ErrorMessage = "SAML SSO domain '{0}': Resource cannot be found in the workspace!" -f $Object.Name
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {

                if ($PSBoundParameters.ContainsKey('EmailAttribute')) {

                    $DomainFound.attribute_mapping.email = $EmailAttribute
                
                }

                if ($PSBoundParameters.ContainsKey('FirstNameAttribute')) {

                    $DomainFound.attribute_mapping.first_name = $FirstNameAttribute
                
                }

                if ($PSBoundParameters.ContainsKey('LastNameAttribute')) {

                    $DomainFound.attribute_mapping.last_name = $LastNameAttribute
                
                }

                if ($PSBoundParameters.ContainsKey('GreenLakeAttribute')) {

                    $DomainFound.attribute_mapping.hpe_ccs_attribute = $GreenLakeAttribute
                
                }

                if ($PSBoundParameters.ContainsKey('IdleSessionTimeout')) {

                    $DomainFound.attribute_mapping.idle_session_timeout = $IdleSessionTimeout
                
                }

                if ($PSBoundParameters.ContainsKey('X509Certificate')) {

                    $DomainFound.saml_idp_config.signing_certificate = $X509Certificate
                
                }
      
                if ($PSBoundParameters.ContainsKey('LoginURL')) {

                    $DomainFound.saml_idp_config.login_url = $LoginURL
                
                }
      
                if ($PSBoundParameters.ContainsKey('LogoutURL')) {

                    $DomainFound.saml_idp_config.logout_url = $LogoutURL
                
                }

                
                $DomainFound | Add-Member -Type NoteProperty -Name "auth_method" -Value "SAML / SSO"
                $DomainFound | Add-Member -Type NoteProperty -Name "edited" -Value $True
                
                # Exclude the PSObject.TypeNames property
                $DomainFound = $DomainFound | Select-Object -Property * -ExcludeProperty PSObject.TypeNames

                $Payload = $DomainFound | ConvertTo-Json -Depth 5

                try {

                    $counter = 1
    
                    # Define the spinning cursor characters
                    $spinner = @('|', '/', '-', '\')
                    
                    # Get the current width of the terminal window                
                    $terminalWidth = (Get-Host).UI.RawUI.WindowSize.Width                    
                    
                    # Create a clear line string based on the terminal width to ensure the entire line is overwritten
                    if (-not $psISE) {
                        $clearLine = " " * ($terminalWidth - 1)
                    }   
                    
                    $Response = Invoke-HPEGLWebRequest -Method PUT -Uri $Uri -Body $Payload -WhatIfBoolean $WhatIf

                    if (-not $WhatIf) {

                        $TaskTrackingId = $Response.task_tracking_id
        
                        $Uri = $AuthnSAMLSSOConfigTaskTrackerUri + $TaskTrackingId 
        
                        do {
        
                            $subcounter = 0
        
                            do {
        
                                $TaskTrackingStatus = Invoke-HPEGLWebRequest -Uri $Uri -method GET 
        
                                # Calculate the current spinner character
                                $spinnerChar = $spinner[$subcounter % $spinner.Length]
                                
                                # Display the spinner character, replacing the previous content
                                $output = "Setting SAML SSO domain '{0}': {1} {2}" -f $DomainName, $TaskTrackingStatus.Status, $spinnerChar
        
                                if (-not $psISE) {
                                    Write-Host "`r$clearLine`r$output" -NoNewline -ForegroundColor Yellow
                                }
                                else {
                                    Write-Host "$output" -ForegroundColor Yellow
                                }
        
                                $subcounter++
                                Start-Sleep -Seconds 1
                                
                                
                            } while (
                                $TaskTrackingStatus.Status -eq "IN_PROGRESS"
                            )
        
                            # Increment counter
                            $counter++
        
                        } until ($TaskTrackingStatus.Status -eq "DONE" -or $counter -gt 10)       
    
                        # Clear the message after do/until is complete
                        if (-not $psISE) {
                            "`r$clearLine`r" | Write-Host -NoNewline                    
                        }
                        
                        if ($counter -gt 10) {
                            
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Failed to set the SAML SSO domain."
    
                        }
                        else {
    
                            "[{0}] SAML SSO domain '{1}' successfully updated. Status: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName, $TaskTrackingStatus.Status | Write-Verbose
                            
                            if (-not $WhatIf) {
    
                                $objStatus.Status = $TaskTrackingStatus.status
                                $objStatus.Details = $TaskTrackingStatus.response.data.message
                                
                            }
                        }
                    }
                }
                catch {

                    if (-not $WhatIf) {

                        # Clear the message after do/until is complete
                        if (-not $psISE) {
                            "`r$clearLine`r" | Write-Host -NoNewline                    
                        }

                        $Object.Status = "Failed"
                        $Object.Details = "SAML SSO domain cannot be updated!"
                        $Object.Exception = $_.Exception.message 
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more SAML SSO domain failed the modification attempt!"
          
            }

            $ObjectStatusList = Invoke-RepackageObjectWithType -RawObject $ObjectStatusList -ObjectName "ObjStatus.NSDE" 
            Return $ObjectStatusList
        }
    }
}


Function Remove-HPEGLWorkspaceSAMLSSODomain {
    <#
    .SYNOPSIS
    Removes a SAML SSO domain.

    .DESCRIPTION
    This function removes a SAML SSO domain from the workspace. It can remove the domain by name or by the domain object.

    .PARAMETER DomainName
    Specifies the name of the SAML SSO domain to remove.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be executed, without actually sending the request. Useful for understanding the native REST API interactions with GLP.

   .EXAMPLE
    Remove-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com"

    Removes the SAML SSO domain "example.com" from the workspace.

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain -DomainName "example.com" | Remove-HPEGLWorkspaceSAMLSSODomain 

    Removes the SAML SSO domain "example.com" from the workspace.
    
    .INPUTS
    System.Collections.ArrayList
        A list of domains obtained from 'Get-HPEGLWorkspaceSAMLSSODomain'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the SAML SSO domain attempted to be removed.
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if removal is successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.

    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [alias("domain")]
        [String]$DomainName,

        [Switch]$WhatIf
    )

    Begin {
       
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveSAMLSSODomainStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $DomainNameFound = Get-HPEGLWorkspaceSAMLSSODomain -DomainName $DomainName

        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
        
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $DomainName
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }

        if (-not $DomainNameFound) {
            # Must return a message if domain not present
            "[{0}] SAML SSO domain '{1}' cannot be found in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName | Write-Verbose
        
            if ($WhatIf) {
                $ErrorMessage = "SAML SSO domain '{0}': Resource cannot be found in the workspace!" -f $DomainName
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "SAML SSO domain cannot be found in the workspace!"
            }
        }
        else {
           
            $Uri = $AuthnSAMLSSOConfigUri + "/" + $DomainName 

            try {

                $counter = 1

                # Define the spinning cursor characters
                $spinner = @('|', '/', '-', '\')
                
                # Get the current width of the terminal window                
                $terminalWidth = (Get-Host).UI.RawUI.WindowSize.Width                    
                
                # Create a clear line string based on the terminal width to ensure the entire line is overwritten
                if (-not $psISE) {
                    $clearLine = " " * ($terminalWidth - 1)
                }


                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                $TaskTrackingId = $Response.task_tracking_id

                $Uri = $AuthnSAMLSSOConfigTaskTrackerUri + $TaskTrackingId 

                do {

                    $subcounter = 0

                    do {

                        $TaskTrackingStatus = Invoke-HPEGLWebRequest -Uri $Uri -method GET 

                        # Calculate the current spinner character
                        $spinnerChar = $spinner[$subcounter % $spinner.Length]
                        
                        # Display the spinner character, replacing the previous content
                        $output = "Removing SAML SSO domain '{0}' from the workspace: {1} {2}" -f $DomainName, $TaskTrackingStatus.Status, $spinnerChar

                        if (-not $psISE) {
                            Write-Host "`r$clearLine`r$output" -NoNewline -ForegroundColor Yellow
                        }
                        else {
                            Write-Host "$output" -ForegroundColor Yellow
                        }

                        $subcounter++
                        Start-Sleep -Seconds 1
                        
                        
                    } while (
                        $TaskTrackingStatus.Status -eq "IN_PROGRESS"
                    )

                    # Increment counter
                    $counter++

                } until ($TaskTrackingStatus.Status -eq "DONE" -or $counter -gt 10)       
                
                # Clear the message after do/until is complete
                if (-not $psISE) {
                    "`r$clearLine`r" | Write-Host -NoNewline                    
                }
                
                if ($counter -gt 10) {
                    
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Failed to remove the SAML SSO domain from the workspace."

                }
                else {

                    "[{0}] Removing SAML SSO domain '{1}' from the workspace... status: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName, $TaskTrackingStatus.Status | Write-Verbose
                    
                    if (-not $WhatIf) {

                        $objStatus.Status = $TaskTrackingStatus.status
                        $objStatus.Details = $TaskTrackingStatus.response.data.message
                        
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    # Clear the message after do/until is complete
                    if (-not $psISE) {
                        "`r$clearLine`r" | Write-Host -NoNewline                    
                    }

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Failed to remove the SAML SSO domain from the workspace."
                    $objStatus.Exception = $_.Exception.message 
                }
            
            }   
        } 

        [void] $RemoveSAMLSSODomainStatus.add($objStatus)



    }

    end {


        if (-not $WhatIf) {

            if ($RemoveSAMLSSODomainStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "Failed to delete one or more SAML SSO domains."
          
            }

            $RemoveSAMLSSODomainStatus = Invoke-RepackageObjectWithType -RawObject $RemoveSAMLSSODomainStatus -ObjectName "ObjStatus.NSDE" 
            Return $RemoveSAMLSSODomainStatus
        }
    }
}


Function Send-HPEGLWorkspaceSAMLSSODomainNotifications {
    <#
    .SYNOPSIS
    Send a notification to all active users part of the SAML SSO domain that has been enabled in the workspace. 

    .DESCRIPTION
    This function sends an email to notify all active users part of a configured SAML SSO Domain that Single sign-on (SSO) has been enabled for the workspace in HPE GreenLake.
    
    .PARAMETER DomainName
    Specifies the name of the SAML SSO domain to send the notification.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be executed, without actually sending the request. Useful for understanding the native REST API interactions with GLP.

   .EXAMPLE
    Send-HPEGLWorkspaceSAMLSSODomainNotifications -DomainName "example.com"

    Sends a notification to all active users part of the SAML SSO domain "example.com" that SSO has been enabled for the workspace.

    .EXAMPLE
    Get-HPEGLWorkspaceSAMLSSODomain | Send-HPEGLWorkspaceSAMLSSODomainNotifications

    Sends a notification to all active users in the various SAML SSO domains, informing them that SSO has been enabled for the workspace.

    .INPUTS
    System.Collections.ArrayList
        List of domains retrieved using 'Get-HPEGLWorkspaceSAMLSSODomain'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the SAML SSO domain where the notification was sent.
        * Status - The status of the notification attempt (Failed for HTTP error return; Complete if successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.

    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
        [alias("domain")]
        [String]$DomainName,

        [Switch]$WhatIf
    )

    Begin {
       
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SAMLSSODomainNotificationStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $DomainNameFound = Get-HPEGLWorkspaceSAMLSSODomain -DomainName $DomainName

        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
        
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $DomainName
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }

        if (-not $DomainNameFound) {
            # Must return a message if domain not present
            "[{0}] SAML SSO domain '{1}' cannot be found in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DomainName | Write-Verbose
        
            if ($WhatIf) {
                $ErrorMessage = "SAML SSO domain '{0}': Resource cannot be found in the workspace!" -f $DomainName
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "SAML SSO domain cannot be found in the workspace!"
            }
        }
        else {
           
            $Uri = $AccountSAMLNotifyUsersUri + $DomainName 

            try {

                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method POST -WhatIfBoolean $WhatIf 

                if ($HPEGLInvokeReturnData.StatusCode -eq 204) {
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Notification sent successfully to users of the SAML SSO domain."
                } 
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Unexpected response code: $($HPEGLInvokeReturnData.StatusCode)"
                }
                
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Failed to send the notification to users of the SAML SSO domain."
                    $objStatus.Exception = $_.Exception.message 
                }            
            }   
        } 

        [void] $SAMLSSODomainNotificationStatus.add($objStatus)



    }

    end {

        if (-not $WhatIf) {

            if ($SAMLSSODomainNotificationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "Failed to send the notification to users of the SAML SSO domain."
          
            }

            $SAMLSSODomainNotificationStatus = Invoke-RepackageObjectWithType -RawObject $SAMLSSODomainNotificationStatus -ObjectName "ObjStatus.NSDE" 
            Return $SAMLSSODomainNotificationStatus
        }
    }
}


#EndRegion


#Region --- LOGS ---

Function Get-HPEGLAuditLog {
    <#
    .SYNOPSIS
    Retrieve the list of audit logs from the HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet returns a collection of the last seven days audit logs from the HPE GreenLake platform by default or from a service instance. 
    
    The audit logs can be filered by category, service name, service region, user with or without limit. Additionally, you can use a search string to further narrow down the audit logs.

   .PARAMETER ServiceName 
    An optional parameter to filter audit logs for a specific service name. A service name can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER ServiceRegion
    An optional parameter to filter audit logs for a specific region of a service. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

   .PARAMETER WorkspaceName
    An optional parameter to filter audit logs for a specific workspace. A workspace name can be retrieved using 'Get-HPEGLWorkspace'.

   .PARAMETER UserEmail
    An optional parameter to filter audit logs for a specific user email address. User email address can be retrieved using 'Get-HPEGLUser'.
    
    .PARAMETER Category 
    An optional parameter to filter audit logs by category. A predefined incomplete list of HPE GreenLake and Compute Ops Management categories is provided via completion tab.
    
    .PARAMETER SearchString 
    An optional parameter to filter audit logs using a free-text search to perform a comprehensive search across all properties for audit logs.

    .PARAMETER ShowLastMonth 
    An optional parameter to retrieve the last thirty days audit logs.

    .PARAMETER ShowLastThreeMonths
    An optional parameter to retrieve the last ninety days audit logs.
    
    .PARAMETER ShowAll
    A parameter to return all audit logs without any limit. Be aware, however, that this may take some time, depending on your audit log history.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
  
    .EXAMPLE
    Get-HPEGLAuditLog 

    Retrieves the last seven days audit logs from the HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLAuditLog -SearchString "CZJ3100GD9"

    Retrieves the last seven days audit logs with the search string 'CZJ3100GD9'.
    
    .EXAMPLE
    Get-HPEGLAuditLog -Category 'Subscription Management'
    
    Retrieves the last seven days audit logs for the 'Subscription Management' category.
    
    .EXAMPLE
    Get-HPEGLAuditLog -Category Authorization -ShowLastMonth
    
    Retrieves the last thirty days audit logs for the "Authorization" category.

    .EXAMPLE
    Get-HPEGLAuditLog -Category Authorization -ShowAll

    Retrieves all audit logs for the "Authorization" category.
    
    .EXAMPLE
    Get-HPEGLAuditLog -UserEmail Leonhard.Euler@mathematician.com -Category 'Customer Management'
    
    Retrieves the last seven days audit logs for Leonhard Euler in the "Customer Management" category.
    
    .EXAMPLE
    Get-HPEGLAuditLog -ServiceName 'Compute Ops Management' -ServiceRegion 'eu-central'

    Retrieves the last seven days audit logs for the 'Compute Ops Management' service in the 'eu-central' region.
    
    .EXAMPLE
    Get-HPEGLAuditLog -ServiceName 'Compute Ops Management' -ServiceRegion 'eu-central' -ShowLastMonth -SearchString ESX

    Retrieves the last thirty days audit logs for the 'Compute Ops Management' service in the 'eu-central' region with t+he search string 'ESX'.

    .EXAMPLE
    Get-HPEGLAuditLog -WorkspaceName "DreamCompany" -ShowLastMonth 

    Retrieves the last thirty days audit logs for the 'DreamCompany' workspace.

    .EXAMPLE
    Get-HPEGLAuditLog -WorkspaceName "HPE Mougins" -UserEmail Leonhard.Euler@mathematician.com -Category 'Customer Management'

    Retrieves the last seven days audit logs for the 'HPE Mougins' workspace for the user 'Leonhard.Euler@mathematician.com' in the 'Customer Management' category.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned | Get-HPEGLAuditLog 

    Retrieves the last seven days audit logs for all provisioned services.

    .EXAMPLE
    Get-HPEGLWorkspace | Select-Object -first 2 | Get-HPEGLAuditLog -ShowLastMonth

    Retrieves the last thirty days audit logs for the first two workspaces.

    .INPUTS
    System.Collections.ArrayList
        List of services from 'Get-HPEGLService'.
        List of workspaces from 'Get-HPEGLWorkspace'.
        List of users from 'Get-HPEGLUser'.
    
 
    #>

    [CmdletBinding(DefaultParameterSetName = 'Workspace')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Service')]
        [Parameter (ParameterSetName = 'Workspace')]
        [Parameter (ParameterSetName = 'Email')]
        [Alias("name")]
        [String]$ServiceName,
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Service')]
        [Parameter (ParameterSetName = 'Workspace')]
        [Parameter (ParameterSetName = 'Email')]
        [Alias("Region")]
        [String]$ServiceRegion,

        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'Workspace')]
        [Parameter (ParameterSetName = 'Email')]
        [Alias("company_name")]
        [String]$WorkspaceName,

        [Parameter (ParameterSetName = 'Workspace')]
        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'Email')]
        [Alias("email")]
        [String]$UserEmail,
        
        [validateSet(
            "API Gateway",
            "App Management",
            "Authorization",
            "Configuration",
            "Credential Management",
            "Customer Management",
            "Delete Device",
            "Delete Fingerprint",
            "Device Direct",
            "Device Management",
            "External Services",
            "Federated User Activity",
            "Firmware",
            "Firmware Registry",
            "Gateway Management",
            "General Settings",
            "Global Trade Export License Check",
            "Groups",
            "Inventory",
            "Lifecycle",
            "Licensing",
            "Location Management",
            "Management",
            "Network Device",
            "Notifications Service",
            "Order Processor",
            "Orders",
            "Organization",        
            "Others",
            "Power",
            "Rbac",
            "Reboot",
            "Report Management",
            "Reports",
            "SAML SSO",
            "Schedules",
            "Server Settings",
            "Settings",
            "Subscription",
            "Subscription Management",
            "System Setup",
            "User Activity",
            "User and Customer Account",
            "User Management",
            "User Personalisation"
        )]
        [String]$Category,
        
        [String]$SearchString,
        
        [Switch]$ShowLastMonth,

        [Switch]$ShowLastThreeMonths,
        
        [switch]$ShowAll,
            
        [Switch]$WhatIf

    ) 
            

    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
            
        $todayMinusSevenDays = (Get-Date).AddDays(-7).ToUniversalTime().ToString("yyyy-MM-dTHH:mm:ss.0Z")
        $todayMinusThirtyDays = (Get-Date).AddMonths(-1).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.0Z")
        $todayMinusThreeMonths = (Get-Date).AddMonths(-3).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.0Z")

        # Construct the filter query
        $filterSevenDays = "createdAt ge '$todayMinusSevenDays'"
        $filterThirtyDays = "createdAt ge '$todayMinusThirtyDays'"
        $filterThreeMonths = "createdAt ge '$todayMinusThreeMonths'"
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ServiceName -and $ServiceRegion) {
            try {
                $ServiceID = Get-HPEGLService -Name $ServiceName -Region $ServiceRegion -ShowProvisioned | Select-Object -ExpandProperty application_id
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }

            if (-not $ServiceID) {
                Write-Error "Service '$ServiceName' is not provisioned in $ServiceRegion!"
                return
            }
        }

        $Uri = $AuditLogsUri

        # Helper function to add a filter to the URI
        function Add-FilterToUri {
            param (
                [string]$Uri,
                [string]$Filter
            )
            if ($Uri -match "\?") {
                if ($Uri -match "filter") {
                    $Uri + " and $Filter"
                }
                else {
                    $Uri + "&filter=$Filter"
                }
            }
            else {
                $Uri + "?filter=$Filter"
            }
        }

        
        # Add filters based on the parameters
        if ($ServiceID) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "application/id eq '$ServiceID'"
        }

        if ($ServiceRegion) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "region eq '$ServiceRegion'"
        }

        if ($WorkspaceName) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "workspace/workspaceName eq '$WorkspaceName'"
        }

        if ($UserEmail) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "user/username eq '$UserEmail'"
        }

        if ($category) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter "category eq '$Category'"
        }

        
        if ($ShowLastMonth) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterThirtyDays
        }
        elseif($ShowLastThreeMonths){
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterThreeMonths
        }
        elseif (-not $ShowAll) {
            $Uri = Add-FilterToUri -Uri $Uri -Filter $filterSevenDays
        }

        if ($SearchString) {
            
            if ($Uri -match "\?") {
                
                $Uri += "&all=$SearchString"
                
            }
            else {
                $Uri += "?all=$SearchString"
            }
        }
            

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
   
   
        if ($Null -ne $Collection.items) {

            $CollectionList = $Collection.items 
            
            if ($PSBoundParameters.ContainsKey('ServiceName')) {

                $CollectionList = $CollectionList | Where-Object { $_.application.applicationName -eq $ServiceName }
            }
          
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Auditlog"    

            return $ReturnData 
        }
        else {

            return
            
        }
 
    }
}




#EndRegion
#EndRegion
#EndRegion



#Region ---------------------------- LIBRARY GLOBAL VARIABLE -------------------------------------------------------------------------------------------------------------------------------------------  

# Set $HPEGLLibraryVersion global variable

# $versionMajorMinorBuild = "{0}.{1}.{2}" -f $ModuleVersion.Major, $ModuleVersion.Minor, $ModuleVersion.Build

$LibraryVersion = New-Object -TypeName PSObject -Property @{
    LibraryVersion = $ModuleVersion
    
}

$LibraryVersion = Invoke-RepackageObjectWithType -RawObject $LibraryVersion -ObjectName "Library.Version"     

New-Variable -Name HPEGLLibraryVersion -Scope Global -Value $LibraryVersion -ErrorAction SilentlyContinue



# ------------------------------------------------------------------------------------------------------------------------------------------------


#EndRegion



# SIG # Begin signature block
# MIItngYJKoZIhvcNAQcCoIItjzCCLYsCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCDV1io+8YP4ZwNn
# pvQY3u4x/SbqabzRzyDyjAq6UTOfVqCCEXYwggVvMIIEV6ADAgECAhBI/JO0YFWU
# jTanyYqJ1pQWMA0GCSqGSIb3DQEBDAUAMHsxCzAJBgNVBAYTAkdCMRswGQYDVQQI
# DBJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAOBgNVBAcMB1NhbGZvcmQxGjAYBgNVBAoM
# EUNvbW9kbyBDQSBMaW1pdGVkMSEwHwYDVQQDDBhBQUEgQ2VydGlmaWNhdGUgU2Vy
# dmljZXMwHhcNMjEwNTI1MDAwMDAwWhcNMjgxMjMxMjM1OTU5WjBWMQswCQYDVQQG
# EwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMS0wKwYDVQQDEyRTZWN0aWdv
# IFB1YmxpYyBDb2RlIFNpZ25pbmcgUm9vdCBSNDYwggIiMA0GCSqGSIb3DQEBAQUA
# A4ICDwAwggIKAoICAQCN55QSIgQkdC7/FiMCkoq2rjaFrEfUI5ErPtx94jGgUW+s
# hJHjUoq14pbe0IdjJImK/+8Skzt9u7aKvb0Ffyeba2XTpQxpsbxJOZrxbW6q5KCD
# J9qaDStQ6Utbs7hkNqR+Sj2pcaths3OzPAsM79szV+W+NDfjlxtd/R8SPYIDdub7
# P2bSlDFp+m2zNKzBenjcklDyZMeqLQSrw2rq4C+np9xu1+j/2iGrQL+57g2extme
# me/G3h+pDHazJyCh1rr9gOcB0u/rgimVcI3/uxXP/tEPNqIuTzKQdEZrRzUTdwUz
# T2MuuC3hv2WnBGsY2HH6zAjybYmZELGt2z4s5KoYsMYHAXVn3m3pY2MeNn9pib6q
# RT5uWl+PoVvLnTCGMOgDs0DGDQ84zWeoU4j6uDBl+m/H5x2xg3RpPqzEaDux5mcz
# mrYI4IAFSEDu9oJkRqj1c7AGlfJsZZ+/VVscnFcax3hGfHCqlBuCF6yH6bbJDoEc
# QNYWFyn8XJwYK+pF9e+91WdPKF4F7pBMeufG9ND8+s0+MkYTIDaKBOq3qgdGnA2T
# OglmmVhcKaO5DKYwODzQRjY1fJy67sPV+Qp2+n4FG0DKkjXp1XrRtX8ArqmQqsV/
# AZwQsRb8zG4Y3G9i/qZQp7h7uJ0VP/4gDHXIIloTlRmQAOka1cKG8eOO7F/05QID
# AQABo4IBEjCCAQ4wHwYDVR0jBBgwFoAUoBEKIz6W8Qfs4q8p74Klf9AwpLQwHQYD
# VR0OBBYEFDLrkpr/NZZILyhAQnAgNpFcF4XmMA4GA1UdDwEB/wQEAwIBhjAPBgNV
# HRMBAf8EBTADAQH/MBMGA1UdJQQMMAoGCCsGAQUFBwMDMBsGA1UdIAQUMBIwBgYE
# VR0gADAIBgZngQwBBAEwQwYDVR0fBDwwOjA4oDagNIYyaHR0cDovL2NybC5jb21v
# ZG9jYS5jb20vQUFBQ2VydGlmaWNhdGVTZXJ2aWNlcy5jcmwwNAYIKwYBBQUHAQEE
# KDAmMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5jb21vZG9jYS5jb20wDQYJKoZI
# hvcNAQEMBQADggEBABK/oe+LdJqYRLhpRrWrJAoMpIpnuDqBv0WKfVIHqI0fTiGF
# OaNrXi0ghr8QuK55O1PNtPvYRL4G2VxjZ9RAFodEhnIq1jIV9RKDwvnhXRFAZ/ZC
# J3LFI+ICOBpMIOLbAffNRk8monxmwFE2tokCVMf8WPtsAO7+mKYulaEMUykfb9gZ
# pk+e96wJ6l2CxouvgKe9gUhShDHaMuwV5KZMPWw5c9QLhTkg4IUaaOGnSDip0TYl
# d8GNGRbFiExmfS9jzpjoad+sPKhdnckcW67Y8y90z7h+9teDnRGWYpquRRPaf9xH
# +9/DUp/mBlXpnYzyOmJRvOwkDynUWICE5EV7WtgwggXhMIIESaADAgECAhEA83w3
# gf2o8H0GHWXSUybisjANBgkqhkiG9w0BAQwFADBUMQswCQYDVQQGEwJHQjEYMBYG
# A1UEChMPU2VjdGlnbyBMaW1pdGVkMSswKQYDVQQDEyJTZWN0aWdvIFB1YmxpYyBD
# b2RlIFNpZ25pbmcgQ0EgUjM2MB4XDTIyMDYwNzAwMDAwMFoXDTI1MDYwNjIzNTk1
# OVowdzELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVRleGFzMSswKQYDVQQKDCJIZXds
# ZXR0IFBhY2thcmQgRW50ZXJwcmlzZSBDb21wYW55MSswKQYDVQQDDCJIZXdsZXR0
# IFBhY2thcmQgRW50ZXJwcmlzZSBDb21wYW55MIIBojANBgkqhkiG9w0BAQEFAAOC
# AY8AMIIBigKCAYEA3nXTSeo4pVdKrf7RlSd2tDEbwbNsAuOo9sKzn6H1kVFshc5b
# ALe9NHmnAsdDFhmcriSrlCPsKekOpmBzUY+hjMTv7eF99bR1rA5tvQQvEdkGkzyN
# 2ZpFc2h7WiImjuGapcXXu8YpSm9seDgSbKnLtS/WAer5K/x30t4BBXm4j7nScY6E
# 0V3ZwkueiVNq0uiUjmGXxqzDgPQmP4H9Gt5mfrQdmpFMccfv9KC4TbbT0m0WHZte
# ebUIBJCWyJQHNJZES9oytn10QoSeBxclInXGzG7q6PIkyXSds7RsBm25gmBRvrm8
# Uf33JnfBEyyd6AH0nfSUVylOYlrLexniH5Kdrq96spk9Wj+7pq5fSXcjULZSunMN
# 6gIrQG+d7NvxuaUkjwDx+3k/A0daJc4hiHcOJa4kjK2SmQ3e27Z4FsiTUWk88C+t
# 1yya6Q/KmT8DcTfHOBpyF0mDEPJYsU5X/jquFRNrG6fzDuKkse3MEbc641HDap/n
# Ldwm7gztHt/IFc4JAgMBAAGjggGJMIIBhTAfBgNVHSMEGDAWgBQPKssghyi47G9I
# ritUpimqF6TNDDAdBgNVHQ4EFgQU9ol95gfMeTfyaXeTTny+MR/YG/UwDgYDVR0P
# AQH/BAQDAgeAMAwGA1UdEwEB/wQCMAAwEwYDVR0lBAwwCgYIKwYBBQUHAwMwSgYD
# VR0gBEMwQTA1BgwrBgEEAbIxAQIBAwIwJTAjBggrBgEFBQcCARYXaHR0cHM6Ly9z
# ZWN0aWdvLmNvbS9DUFMwCAYGZ4EMAQQBMEkGA1UdHwRCMEAwPqA8oDqGOGh0dHA6
# Ly9jcmwuc2VjdGlnby5jb20vU2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nQ0FSMzYu
# Y3JsMHkGCCsGAQUFBwEBBG0wazBEBggrBgEFBQcwAoY4aHR0cDovL2NydC5zZWN0
# aWdvLmNvbS9TZWN0aWdvUHVibGljQ29kZVNpZ25pbmdDQVIzNi5jcnQwIwYIKwYB
# BQUHMAGGF2h0dHA6Ly9vY3NwLnNlY3RpZ28uY29tMA0GCSqGSIb3DQEBDAUAA4IB
# gQAdJNlWSujYBAZ1mdIy0Q66db+4YWP+FbaUiQWNqbfi30s7Ctg70/2t0n1QDDkg
# hWHFM2kcdy1PGh4fOMeRSfIhsTre54YcsNe5wELSJQbvN8lfPYXMThb3n4/BXxoD
# 1zx5rmcwGPXVF5oIZJub5FzMNVpECjy8C42skTFXv4eB/yEHKI/BWsjvnkldkNEG
# 3v8Y/23gGHruFy2qVW50xyH8zsjd+gIStVojyhPJ0jgtZvXgxwVJYwBGJwgYOO+q
# pRnuUp4Bse+KlA8Ttm+Q4Nx8qOJYBE44Qi8BUXwoEDs26pFIyNuszBFuzeyL4Wkx
# y7srdCWYCIyLbD5b7WFbhd2ieK2Mg+WtZJNB3t8ZpdLLkH4vPmZGIo4FkeAST1I1
# XtKp5PqLhzPEZbsY9JL8i6XvedCL8cHe1zVX3eM9EPL/jxw9kLcFrFN+DQ1wIHCc
# gEH7/RYXc9abuGcC2XpP4YbzSMWbff8X/Pgw8HA8aSRhctF+bz7dI+/REmlDJtdP
# T6wwggYaMIIEAqADAgECAhBiHW0MUgGeO5B5FSCJIRwKMA0GCSqGSIb3DQEBDAUA
# MFYxCzAJBgNVBAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxLTArBgNV
# BAMTJFNlY3RpZ28gUHVibGljIENvZGUgU2lnbmluZyBSb290IFI0NjAeFw0yMTAz
# MjIwMDAwMDBaFw0zNjAzMjEyMzU5NTlaMFQxCzAJBgNVBAYTAkdCMRgwFgYDVQQK
# Ew9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMTIlNlY3RpZ28gUHVibGljIENvZGUg
# U2lnbmluZyBDQSBSMzYwggGiMA0GCSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCb
# K51T+jU/jmAGQ2rAz/V/9shTUxjIztNsfvxYB5UXeWUzCxEeAEZGbEN4QMgCsJLZ
# UKhWThj/yPqy0iSZhXkZ6Pg2A2NVDgFigOMYzB2OKhdqfWGVoYW3haT29PSTahYk
# wmMv0b/83nbeECbiMXhSOtbam+/36F09fy1tsB8je/RV0mIk8XL/tfCK6cPuYHE2
# 15wzrK0h1SWHTxPbPuYkRdkP05ZwmRmTnAO5/arnY83jeNzhP06ShdnRqtZlV59+
# 8yv+KIhE5ILMqgOZYAENHNX9SJDm+qxp4VqpB3MV/h53yl41aHU5pledi9lCBbH9
# JeIkNFICiVHNkRmq4TpxtwfvjsUedyz8rNyfQJy/aOs5b4s+ac7IH60B+Ja7TVM+
# EKv1WuTGwcLmoU3FpOFMbmPj8pz44MPZ1f9+YEQIQty/NQd/2yGgW+ufflcZ/ZE9
# o1M7a5Jnqf2i2/uMSWymR8r2oQBMdlyh2n5HirY4jKnFH/9gRvd+QOfdRrJZb1sC
# AwEAAaOCAWQwggFgMB8GA1UdIwQYMBaAFDLrkpr/NZZILyhAQnAgNpFcF4XmMB0G
# A1UdDgQWBBQPKssghyi47G9IritUpimqF6TNDDAOBgNVHQ8BAf8EBAMCAYYwEgYD
# VR0TAQH/BAgwBgEB/wIBADATBgNVHSUEDDAKBggrBgEFBQcDAzAbBgNVHSAEFDAS
# MAYGBFUdIAAwCAYGZ4EMAQQBMEsGA1UdHwREMEIwQKA+oDyGOmh0dHA6Ly9jcmwu
# c2VjdGlnby5jb20vU2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nUm9vdFI0Ni5jcmww
# ewYIKwYBBQUHAQEEbzBtMEYGCCsGAQUFBzAChjpodHRwOi8vY3J0LnNlY3RpZ28u
# Y29tL1NlY3RpZ29QdWJsaWNDb2RlU2lnbmluZ1Jvb3RSNDYucDdjMCMGCCsGAQUF
# BzABhhdodHRwOi8vb2NzcC5zZWN0aWdvLmNvbTANBgkqhkiG9w0BAQwFAAOCAgEA
# Bv+C4XdjNm57oRUgmxP/BP6YdURhw1aVcdGRP4Wh60BAscjW4HL9hcpkOTz5jUug
# 2oeunbYAowbFC2AKK+cMcXIBD0ZdOaWTsyNyBBsMLHqafvIhrCymlaS98+QpoBCy
# KppP0OcxYEdU0hpsaqBBIZOtBajjcw5+w/KeFvPYfLF/ldYpmlG+vd0xqlqd099i
# ChnyIMvY5HexjO2AmtsbpVn0OhNcWbWDRF/3sBp6fWXhz7DcML4iTAWS+MVXeNLj
# 1lJziVKEoroGs9Mlizg0bUMbOalOhOfCipnx8CaLZeVme5yELg09Jlo8BMe80jO3
# 7PU8ejfkP9/uPak7VLwELKxAMcJszkyeiaerlphwoKx1uHRzNyE6bxuSKcutisqm
# KL5OTunAvtONEoteSiabkPVSZ2z76mKnzAfZxCl/3dq3dUNw4rg3sTCggkHSRqTq
# lLMS7gjrhTqBmzu1L90Y1KWN/Y5JKdGvspbOrTfOXyXvmPL6E52z1NZJ6ctuMFBQ
# ZH3pwWvqURR8AgQdULUvrxjUYbHHj95Ejza63zdrEcxWLDX6xWls/GDnVNueKjWU
# H3fTv1Y8Wdho698YADR7TNx8X8z2Bev6SivBBOHY+uqiirZtg0y9ShQoPzmCcn63
# Syatatvx157YK9hlcPmVoa1oDE5/L9Uo2bC5a4CH2Rwxght+MIIbegIBATBpMFQx
# CzAJBgNVBAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMT
# IlNlY3RpZ28gUHVibGljIENvZGUgU2lnbmluZyBDQSBSMzYCEQDzfDeB/ajwfQYd
# ZdJTJuKyMA0GCWCGSAFlAwQCAQUAoHwwEAYKKwYBBAGCNwIBDDECMAAwGQYJKoZI
# hvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEOMAwGCisGAQQBgjcC
# ARUwLwYJKoZIhvcNAQkEMSIEILXY5xg9M/99Ewg3YKk6pH/M7TqBjCl2jehfKRKN
# FDgLMA0GCSqGSIb3DQEBAQUABIIBgKpji/juUY/dn/HfsdPu69OSECgkrdW0r22k
# /mawo2GwMdzuE1vVC1/DoFpZfFVq/dikv/8voB2U2ojHSJ+QeJKx9ExFV9didf6j
# S2CZFGkZtqg0X1mjdpL/K2nDiJJNgBfqQZxNzWo1BSmGy+hTz98f8CkosD/ni9iT
# t/PtjntuYK8tAGkfgGrpYJfTHVh85W0uLZQ5KQTSkmyDhBg9R4M9COlI2pxZrksN
# RI3hOq+SNpB5U1tQAdQZjwayKsQxt03I3th+QOnDWjAlowtp3ZV8RxJffM/BmH5c
# VJ/fOhw55XZdPGi5GKvYqzwKaw7Wqe6DdR44SqTv2fvOv+DL65EVTQvlAxKu5572
# LkkHEiYtV9L1MIPuKXZQRKQmFlyV7d+Z4WQDgYtRK4YJpNmSGnBfNfQxlAw39abs
# rY+arfFkeQmEIPhmTo8+zS5eA8QjIqtUhMXXTHG6ETk8EWzvaNG6AUNfr8JPmRV5
# C+NUK5tL3KYVJb0bvLfabY+9XdDPK6GCGOgwghjkBgorBgEEAYI3AwMBMYIY1DCC
# GNAGCSqGSIb3DQEHAqCCGMEwghi9AgEDMQ8wDQYJYIZIAWUDBAICBQAwggEHBgsq
# hkiG9w0BCRABBKCB9wSB9DCB8QIBAQYKKwYBBAGyMQIBATBBMA0GCWCGSAFlAwQC
# AgUABDBC7Ko2yHJN6+ao7A1UqivtmJZffr/jVTc5++JAMfmmWroeiqUenhytvaSs
# 7aCODeACFBmiJVbNXemWmiu0egEEoKigD1bCGA8yMDI1MDQxODE4MDA0MFqgdqR0
# MHIxCzAJBgNVBAYTAkdCMRcwFQYDVQQIEw5XZXN0IFlvcmtzaGlyZTEYMBYGA1UE
# ChMPU2VjdGlnbyBMaW1pdGVkMTAwLgYDVQQDEydTZWN0aWdvIFB1YmxpYyBUaW1l
# IFN0YW1waW5nIFNpZ25lciBSMzagghMEMIIGYjCCBMqgAwIBAgIRAKQpO24e3den
# NAiHrXpOtyQwDQYJKoZIhvcNAQEMBQAwVTELMAkGA1UEBhMCR0IxGDAWBgNVBAoT
# D1NlY3RpZ28gTGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJsaWMgVGltZSBT
# dGFtcGluZyBDQSBSMzYwHhcNMjUwMzI3MDAwMDAwWhcNMzYwMzIxMjM1OTU5WjBy
# MQswCQYDVQQGEwJHQjEXMBUGA1UECBMOV2VzdCBZb3Jrc2hpcmUxGDAWBgNVBAoT
# D1NlY3RpZ28gTGltaXRlZDEwMC4GA1UEAxMnU2VjdGlnbyBQdWJsaWMgVGltZSBT
# dGFtcGluZyBTaWduZXIgUjM2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKC
# AgEA04SV9G6kU3jyPRBLeBIHPNyUgVNnYayfsGOyYEXrn3+SkDYTLs1crcw/ol2s
# wE1TzB2aR/5JIjKNf75QBha2Ddj+4NEPKDxHEd4dEn7RTWMcTIfm492TW22I8LfH
# +A7Ehz0/safc6BbsNBzjHTt7FngNfhfJoYOrkugSaT8F0IzUh6VUwoHdYDpiln9d
# h0n0m545d5A5tJD92iFAIbKHQWGbCQNYplqpAFasHBn77OqW37P9BhOASdmjp3Ii
# jYiFdcA0WQIe60vzvrk0HG+iVcwVZjz+t5OcXGTcxqOAzk1frDNZ1aw8nFhGEvG0
# ktJQknnJZE3D40GofV7O8WzgaAnZmoUn4PCpvH36vD4XaAF2CjiPsJWiY/j2xLsJ
# uqx3JtuI4akH0MmGzlBUylhXvdNVXcjAuIEcEQKtOBR9lU4wXQpISrbOT8ux+96G
# zBq8TdbhoFcmYaOBZKlwPP7pOp5Mzx/UMhyBA93PQhiCdPfIVOCINsUY4U23p4KJ
# 3F1HqP3H6Slw3lHACnLilGETXRg5X/Fp8G8qlG5Y+M49ZEGUp2bneRLZoyHTyynH
# vFISpefhBCV0KdRZHPcuSL5OAGWnBjAlRtHvsMBrI3AAA0Tu1oGvPa/4yeeiAyu+
# 9y3SLC98gDVbySnXnkujjhIh+oaatsk/oyf5R2vcxHahajMCAwEAAaOCAY4wggGK
# MB8GA1UdIwQYMBaAFF9Y7UwxeqJhQo1SgLqzYZcZojKbMB0GA1UdDgQWBBSIYYyh
# KjdkgShgoZsx0Iz9LALOTzAOBgNVHQ8BAf8EBAMCBsAwDAYDVR0TAQH/BAIwADAW
# BgNVHSUBAf8EDDAKBggrBgEFBQcDCDBKBgNVHSAEQzBBMDUGDCsGAQQBsjEBAgED
# CDAlMCMGCCsGAQUFBwIBFhdodHRwczovL3NlY3RpZ28uY29tL0NQUzAIBgZngQwB
# BAIwSgYDVR0fBEMwQTA/oD2gO4Y5aHR0cDovL2NybC5zZWN0aWdvLmNvbS9TZWN0
# aWdvUHVibGljVGltZVN0YW1waW5nQ0FSMzYuY3JsMHoGCCsGAQUFBwEBBG4wbDBF
# BggrBgEFBQcwAoY5aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# VGltZVN0YW1waW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5z
# ZWN0aWdvLmNvbTANBgkqhkiG9w0BAQwFAAOCAYEAAoE+pIZyUSH5ZakuPVKK4eWb
# zEsTRJOEjbIu6r7vmzXXLpJx4FyGmcqnFZoa1dzx3JrUCrdG5b//LfAxOGy9Ph9J
# trYChJaVHrusDh9NgYwiGDOhyyJ2zRy3+kdqhwtUlLCdNjFjakTSE+hkC9F5ty1u
# xOoQ2ZkfI5WM4WXA3ZHcNHB4V42zi7Jk3ktEnkSdViVxM6rduXW0jmmiu71ZpBFZ
# Dh7Kdens+PQXPgMqvzodgQJEkxaION5XRCoBxAwWwiMm2thPDuZTzWp/gUFzi7iz
# CmEt4pE3Kf0MOt3ccgwn4Kl2FIcQaV55nkjv1gODcHcD9+ZVjYZoyKTVWb4VqMQy
# /j8Q3aaYd/jOQ66Fhk3NWbg2tYl5jhQCuIsE55Vg4N0DUbEWvXJxtxQQaVR5xzhE
# I+BjJKzh3TQ026JxHhr2fuJ0mV68AluFr9qshgwS5SpN5FFtaSEnAwqZv3IS+mlG
# 50rK7W3qXbWwi4hmpylUfygtYLEdLQukNEX1jiOKMIIGFDCCA/ygAwIBAgIQeiOu
# 2lNplg+RyD5c9MfjPzANBgkqhkiG9w0BAQwFADBXMQswCQYDVQQGEwJHQjEYMBYG
# A1UEChMPU2VjdGlnbyBMaW1pdGVkMS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBU
# aW1lIFN0YW1waW5nIFJvb3QgUjQ2MB4XDTIxMDMyMjAwMDAwMFoXDTM2MDMyMTIz
# NTk1OVowVTELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDEs
# MCoGA1UEAxMjU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBDQSBSMzYwggGi
# MA0GCSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQDNmNhDQatugivs9jN+JjTkiYzT
# 7yISgFQ+7yavjA6Bg+OiIjPm/N/t3nC7wYUrUlY3mFyI32t2o6Ft3EtxJXCc5MmZ
# QZ8AxCbh5c6WzeJDB9qkQVa46xiYEpc81KnBkAWgsaXnLURoYZzksHIzzCNxtIXn
# b9njZholGw9djnjkTdAA83abEOHQ4ujOGIaBhPXG2NdV8TNgFWZ9BojlAvflxNMC
# OwkCnzlH4oCw5+4v1nssWeN1y4+RlaOywwRMUi54fr2vFsU5QPrgb6tSjvEUh1EC
# 4M29YGy/SIYM8ZpHadmVjbi3Pl8hJiTWw9jiCKv31pcAaeijS9fc6R7DgyyLIGfl
# mdQMwrNRxCulVq8ZpysiSYNi79tw5RHWZUEhnRfs/hsp/fwkXsynu1jcsUX+HuG8
# FLa2BNheUPtOcgw+vHJcJ8HnJCrcUWhdFczf8O+pDiyGhVYX+bDDP3GhGS7TmKmG
# nbZ9N+MpEhWmbiAVPbgkqykSkzyYVr15OApZYK8CAwEAAaOCAVwwggFYMB8GA1Ud
# IwQYMBaAFPZ3at0//QET/xahbIICL9AKPRQlMB0GA1UdDgQWBBRfWO1MMXqiYUKN
# UoC6s2GXGaIymzAOBgNVHQ8BAf8EBAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADAT
# BgNVHSUEDDAKBggrBgEFBQcDCDARBgNVHSAECjAIMAYGBFUdIAAwTAYDVR0fBEUw
# QzBBoD+gPYY7aHR0cDovL2NybC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGlt
# ZVN0YW1waW5nUm9vdFI0Ni5jcmwwfAYIKwYBBQUHAQEEcDBuMEcGCCsGAQUFBzAC
# hjtodHRwOi8vY3J0LnNlY3RpZ28uY29tL1NlY3RpZ29QdWJsaWNUaW1lU3RhbXBp
# bmdSb290UjQ2LnA3YzAjBggrBgEFBQcwAYYXaHR0cDovL29jc3Auc2VjdGlnby5j
# b20wDQYJKoZIhvcNAQEMBQADggIBABLXeyCtDjVYDJ6BHSVY/UwtZ3Svx2ImIfZV
# VGnGoUaGdltoX4hDskBMZx5NY5L6SCcwDMZhHOmbyMhyOVJDwm1yrKYqGDHWzpwV
# kFJ+996jKKAXyIIaUf5JVKjccev3w16mNIUlNTkpJEor7edVJZiRJVCAmWAaHcw9
# zP0hY3gj+fWp8MbOocI9Zn78xvm9XKGBp6rEs9sEiq/pwzvg2/KjXE2yWUQIkms6
# +yslCRqNXPjEnBnxuUB1fm6bPAV+Tsr/Qrd+mOCJemo06ldon4pJFbQd0TQVIMLv
# 5koklInHvyaf6vATJP4DfPtKzSBPkKlOtyaFTAjD2Nu+di5hErEVVaMqSVbfPzd6
# kNXOhYm23EWm6N2s2ZHCHVhlUgHaC4ACMRCgXjYfQEDtYEK54dUwPJXV7icz0rgC
# zs9VI29DwsjVZFpO4ZIVR33LwXyPDbYFkLqYmgHjR3tKVkhh9qKV2WCmBuC27pIO
# x6TYvyqiYbntinmpOqh/QPAnhDgexKG9GX/n1PggkGi9HCapZp8fRwg8RftwS21L
# n61euBG0yONM6noD2XQPrFwpm3GcuqJMf0o8LLrFkSLRQNwxPDDkWXhW+gZswbai
# ie5fd/W2ygcto78XCSPfFWveUOSZ5SqK95tBO8aTHmEa4lpJVD7HrTEn9jb1EGvx
# Ob1cnn0CMIIGgjCCBGqgAwIBAgIQNsKwvXwbOuejs902y8l1aDANBgkqhkiG9w0B
# AQwFADCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNV
# BAcTC0plcnNleSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsx
# LjAsBgNVBAMTJVVTRVJUcnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkw
# HhcNMjEwMzIyMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjBXMQswCQYDVQQGEwJHQjEY
# MBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMS4wLAYDVQQDEyVTZWN0aWdvIFB1Ymxp
# YyBUaW1lIFN0YW1waW5nIFJvb3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
# MIICCgKCAgEAiJ3YuUVnnR3d6LkmgZpUVMB8SQWbzFoVD9mUEES0QUCBdxSZqdTk
# dizICFNeINCSJS+lV1ipnW5ihkQyC0cRLWXUJzodqpnMRs46npiJPHrfLBOifjfh
# pdXJ2aHHsPHggGsCi7uE0awqKggE/LkYw3sqaBia67h/3awoqNvGqiFRJ+OTWYmU
# CO2GAXsePHi+/JUNAax3kpqstbl3vcTdOGhtKShvZIvjwulRH87rbukNyHGWX5tN
# K/WABKf+Gnoi4cmisS7oSimgHUI0Wn/4elNd40BFdSZ1EwpuddZ+Wr7+Dfo0lcHf
# lm/FDDrOJ3rWqauUP8hsokDoI7D/yUVI9DAE/WK3Jl3C4LKwIpn1mNzMyptRwsXK
# rop06m7NUNHdlTDEMovXAIDGAvYynPt5lutv8lZeI5w3MOlCybAZDpK3Dy1MKo+6
# aEtE9vtiTMzz/o2dYfdP0KWZwZIXbYsTIlg1YIetCpi5s14qiXOpRsKqFKqav9R1
# R5vj3NgevsAsvxsAnI8Oa5s2oy25qhsoBIGo/zi6GpxFj+mOdh35Xn91y72J4RGO
# JEoqzEIbW3q0b2iPuWLA911cRxgY5SJYubvjay3nSMbBPPFsyl6mY4/WYucmyS9l
# o3l7jk27MAe145GWxK4O3m3gEFEIkv7kRmefDR7Oe2T1HxAnICQvr9sCAwEAAaOC
# ARYwggESMB8GA1UdIwQYMBaAFFN5v1qqK0rPVIDh2JvAnfKyA2bLMB0GA1UdDgQW
# BBT2d2rdP/0BE/8WoWyCAi/QCj0UJTAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/
# BAUwAwEB/zATBgNVHSUEDDAKBggrBgEFBQcDCDARBgNVHSAECjAIMAYGBFUdIAAw
# UAYDVR0fBEkwRzBFoEOgQYY/aHR0cDovL2NybC51c2VydHJ1c3QuY29tL1VTRVJU
# cnVzdFJTQUNlcnRpZmljYXRpb25BdXRob3JpdHkuY3JsMDUGCCsGAQUFBwEBBCkw
# JzAlBggrBgEFBQcwAYYZaHR0cDovL29jc3AudXNlcnRydXN0LmNvbTANBgkqhkiG
# 9w0BAQwFAAOCAgEADr5lQe1oRLjlocXUEYfktzsljOt+2sgXke3Y8UPEooU5y39r
# AARaAdAxUeiX1ktLJ3+lgxtoLQhn5cFb3GF2SSZRX8ptQ6IvuD3wz/LNHKpQ5nX8
# hjsDLRhsyeIiJsms9yAWnvdYOdEMq1W61KE9JlBkB20XBee6JaXx4UBErc+YuoSb
# 1SxVf7nkNtUjPfcxuFtrQdRMRi/fInV/AobE8Gw/8yBMQKKaHt5eia8ybT8Y/Ffa
# 6HAJyz9gvEOcF1VWXG8OMeM7Vy7Bs6mSIkYeYtddU1ux1dQLbEGur18ut97wgGwD
# iGinCwKPyFO7ApcmVJOtlw9FVJxw/mL1TbyBns4zOgkaXFnnfzg4qbSvnrwyj1Ni
# urMp4pmAWjR+Pb/SIduPnmFzbSN/G8reZCL4fvGlvPFk4Uab/JVCSmj59+/mB2Gn
# 6G/UYOy8k60mKcmaAZsEVkhOFuoj4we8CYyaR9vd9PGZKSinaZIkvVjbH/3nlLb0
# a7SBIkiRzfPfS9T+JesylbHa1LtRV9U/7m0q7Ma2CQ/t392ioOssXW7oKLdOmMBl
# 14suVFBmbzrt5V5cQPnwtd3UOTpS9oCG+ZZheiIvPgkDmA8FzPsnfXW5qHELB43E
# T7HHFHeRPRYrMBKjkb8/IN7Po0d0hQoF4TeMM+zYAJzoKQnVKOLg8pZVPT8xggSS
# MIIEjgIBATBqMFUxCzAJBgNVBAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0
# ZWQxLDAqBgNVBAMTI1NlY3RpZ28gUHVibGljIFRpbWUgU3RhbXBpbmcgQ0EgUjM2
# AhEApCk7bh7d16c0CIetek63JDANBglghkgBZQMEAgIFAKCCAfkwGgYJKoZIhvcN
# AQkDMQ0GCyqGSIb3DQEJEAEEMBwGCSqGSIb3DQEJBTEPFw0yNTA0MTgxODAwNDBa
# MD8GCSqGSIb3DQEJBDEyBDCFucP8hdtKwwtHmS3rH5VopeC+EdWJJMuzesnXWNAc
# PGKFlE2U0wbSwflleLC04FgwggF6BgsqhkiG9w0BCRACDDGCAWkwggFlMIIBYTAW
# BBQ4yRSBEES03GY+k9R0S4FBhqm1sTCBhwQUxq5U5HiG8Xw9VRJIjGnDSnr5wt0w
# bzBbpFkwVzELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDEu
# MCwGA1UEAxMlU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBSb290IFI0NgIQ
# eiOu2lNplg+RyD5c9MfjPzCBvAQUhT1jLZOCgmF80JA1xJHeksFC2scwgaMwgY6k
# gYswgYgxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpOZXcgSmVyc2V5MRQwEgYDVQQH
# EwtKZXJzZXkgQ2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMS4w
# LAYDVQQDEyVVU0VSVHJ1c3QgUlNBIENlcnRpZmljYXRpb24gQXV0aG9yaXR5AhA2
# wrC9fBs656Oz3TbLyXVoMA0GCSqGSIb3DQEBAQUABIICAGLR7GVcgPBdJFV5y6GD
# NYpGNYENEqLRktcxgCBrYdmw78eHmxK94/cI+AZn+882eM/YrsJxQGpx95s4ZrBQ
# Vc9d4cZdKyUSjVxtbQHW36cnF/xk/t4+cyffX9Oqrh+3QwzIiayritzAn0hGu8CT
# UYVhhswQjFx7BbG+r2V7VUHRMHUKdTpEf0jX2omVw7aDWETLq7/K0xIaAEjK53mx
# 49UMkw+e/NwyADsRBjJ/4CVXHoMhIK5n+BGK81O648lQC6t25mE0bH38ly7rf/Nx
# BwKL/3hFe0wcf6QE7d3gz6+hCrVNlmTA/UQkJXZTMJ5poPAl1Wvl5NR8+yJX4n1L
# 858CU74LTMX6hH30qebUYsKtOjN3ubysjWhS51jyk2hCTdxPhmoPuano1mE+oi4t
# JCYfXqNpl9FXylkLCXu/0tIiwPtWzwdhm/Z9ZyGPqoJxV4ygpl/6PztzcYyNxgnL
# 0FbDSctwDr9nBqrjzME6RMUk9dXSuvHZpte9DXUTbHanBv6a3CJeVF3pJBUQ/7YF
# cn5WQVbX+aI9MhQ+CQDMQTy3t/Vvm/94hNoy48t0cQAy6ZlxbHsA19pAJVETRRfn
# nBN8fD/UBWNyXa7ZqkclSIZ+C27GNnJZ3RYTpdhOxa8SEQbSTt9u8hPhLKZ+WFPP
# xGmCmdMqCG1c6fE3jFgrewSU
# SIG # End signature block
