##############################################################################
# HPE GreenLake for Compute Ops Management PowerShell Library
##############################################################################
##############################################################################
## (C) Copyright 2013-2024 Hewlett Packard Enterprise Development LP
##############################################################################
<#

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

#>

# Set HPE GreenLake PowerShell Library Version
[Version]$ModuleVersion = '1.0.0'


# Load format files
Get-ChildItem -path $PSScriptRoot -recurse -include *.Format.PS1XML | Foreach-Object {
    Update-FormatData -AppendPath $_.FullName
}


#---------------------------------------------------------
#Region Argument completer


# Define the list of HTTP methods commonly used in Invoke-HPEGLWebRequest
$httpMethods = 'GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS', 'PATCH', 'TRACE', 'CONNECT'

# Register an argument completer for Invoke-WebRequest and Invoke-RestMethod methods
Register-ArgumentCompleter -CommandName Invoke-HPEGLWebRequest, Invoke-HPECOMWebRequest -ParameterName Method -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)

    # Filter methods based on user input (if any)
    $httpMethods | Where-Object { $_.StartsWith($wordToComplete) } |
    ForEach-Object {
        # Create a new completion result for each method
        [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
    }
}

# Define the list of HPE GreenLake languages commonly used in Set-HPEGLUserAccountDetails and Set-HPEGLUserPreference

# Fetch the supported HPE GreenLake languages details
$languageUrl = 'https://auth.hpe.com/messages/supportedLanguagesList.json'

try {
    $response = Invoke-RestMethod -Uri $languageUrl -Method Get 
    
}
catch {
    Throw "The website auth.hpe.com is currently unreachable. Please ensure that you have an active internet connection and try again."
}

$global:HPESupportedLanguages = @{}

foreach ($langDetail in $response.supportedLanguagesListDetails) {
    $HPESupportedLanguages[$langDetail.label] = $langDetail.value
}


# Register an argument completer for the Language parameter using language labels (support quotes for language names containing spaces)
Register-ArgumentCompleter -CommandName Set-HPEGLUserAccountDetails, Set-HPEGLUserPreference -ParameterName Language -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)

    # Filter languages based on the input label and create completions
    $HPESupportedLanguages.Keys | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
        # Check if the language name contains spaces
        if ($_ -match "\s") {
            # Wrap the language name in single quotes
            $completionText = "'$_'"
        }
        else {
            $completionText = $_
        }

        [System.Management.Automation.CompletionResult]::new($completionText, $completionText, 'ParameterValue', $_)
    }
}

#EndRegion


#---------------------------------------------------------
#Region Variables

$HPEGLAPIbaseURL = 'https://global.api.greenlake.hpe.com'

$HPEGLUIbaseURL = 'https://aquila-user-api.common.cloud.hpe.com'

$HPEOnepassbaseURL = 'https://onepass-enduserservice.it.hpe.com'

[string]$APIClientCredentialTemplateName = "PowerShell_Library_Temporary_Credential"

# $DefaultTimeout timeout variable for Wait-HPECOMJobComplete
# New-Variable -Name DefaultTimeout -Value (New-Timespan -Minutes 20) -Option Constant



#Region ------- HPE GLP -------

[uri]$ccsSettingsUrl = 'https://common.cloud.hpe.com/settings.json'
[uri]$ccsRedirecturi = 'https://common.cloud.hpe.com/authentication/callback'
[uri]$AuthRedirecturi = 'https://auth.hpe.com/profile/login/callback'
[uri]$SchemaMetadataURI = 'https://onepass-enduserservice.it.hpe.com/v2-get-user-schema-metadata'

[String]$OpenidConfiguration = '/.well-known/openid-configuration'
[String]$SessionLoadAccountUri = $HPEGLUIbaseURL + '/authn/v1/session/load-account/'
[String]$LoadAccountUri = $HPEGLUIbaseURL + '/accounts/ui/v1/user/load-account/'
[String]$AuthnUri = '/api/v1/authn'
[String]$AuthnSessionUri = $HPEGLUIbaseURL + '/authn/v1/session'
[String]$AuthnEndSessionUri = $HPEGLUIbaseURL + '/authn/v1/session/end-session'
[String]$AuditLogsUri = $HPEGLUIbaseURL + '/auditlogs/ui/v1/search?app_slug=CCS'

#  Accounts 

[String]$WorkspacesUri = $HPEGLAPIbaseURL + '/workspaces/v1/workspaces'

[String]$NewWorkspaceUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/signup'
[String]$UserLoadAccountUri = $HPEGLUIbaseURL + '/accounts/ui/v1/user/load-account/'
[String]$WorkspacesListUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/list-accounts'
[String]$CurrentWorkspaceUri = $HPEGLUIbaseURL + '/accounts/ui/v1/customer/profile/contact'

#  Users - Roles - Permissions

[String]$UsersUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/users'
[string]$UsersStatsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/stats'
[string]$UsersRolesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/customers/roles'
[string]$AuthzUsersRolesUri = $HPEGLUIbaseURL + "/authorization/ui/v2/customers/users/"
[String]$AuthzRolesUri = $HPEGLUIbaseURL + "/authorization/ui/v2/customers/"
[string]$AuthzUsersRolesAssignmentsUri = $HPEGLUIbaseURL + "/authorization/ui/v2/customers/"
[string]$InviteUserUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/invite-user'
[string]$ReInviteUserUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/resend-invite'
[string]$UserPreferencesUri = $HPEGLUIbaseURL + '/accounts/ui/v1/user/profile/preferences'

#  Devices 

[String]$DevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices'
[String]$DevicesAddUri = $HPEGLAPIbaseURL + '/devices/v1beta1/devices'
[String]$DevicesStatsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices/stats'
[String]$DevicesApplicationInstanceUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices/application-instance'
[String]$DevicesATagsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/devices/tags'
[String]$DevicesLocationUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/locations'
[String]$LocalGatewayUri = $HPEGLUIbaseURL + '/platform/acpmgr/getGateways'
[String]$LocalGatewayAppUri = $HPEGLUIbaseURL + '/opg-proxy/v1/gateways/'

#  License - Subscription

[String]$LicenseDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/devices'
[String]$AddLicenseDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/customers/license'
[String]$LicenseDevicesProductTypeDeviceUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license?product_type=DEVICE'
[String]$ServiceSubscriptionsListUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/service-subscriptions'
[String]$AutoLicenseDevicesUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/license/autolicense'

#  Services - Assignment 

# [String]$ApplicationsUri = '/ui-doorway/ui/v1/applications'
# [String]$ApplicationsCatalogPerRegionUri = '/app-catalog/ui/v1/per-region-applications'
# [String]$ApplicationsProvisioned = '/ui-doorway/ui/v1/applications/provisioned'
[String]$ApplicationsProvisionsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/applications/provisions'
[String]$RegionsUri = $HPEGLUIbaseURL + '/geo/ui/v1/regions'
[String]$ApplicationsScopeAssignmentsUri = $HPEGLUIbaseURL + '/ui-doorway/ui/v1/um/scope-assignments'
[String]$ApplicationsAPICredentialsUri = $HPEGLUIbaseURL + '/authn/v1/token-management/credentials'
[string]$ResourceRestrictionsPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/resource_restrictions"
[string]$ResourceRestrictionsPolicyUsersUri = $HPEGLUIbaseURL + "/authorization/ui/v2/resource_restriction/"
[string]$AuthZApplicationsUri = $HPEGLUIbaseURL + "/authorization/ui/v1/applications/"
[string]$ResourceRestrictionPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/resource_restriction/"
[string]$SetResourceRestrictionPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/customers/applications"
[string]$DeleteResourceRestrictionPolicyUri = $HPEGLUIbaseURL + "/authorization/ui/v1/resource_restriction/delete"
[string]$ApplicationInstancesUri = $HPEGLUIbaseURL + "/authorization/ui/v1/application_instances"
[string]$ApplicationProvisioningUri = $HPEGLUIbaseURL + "/app-provision/ui/v1/provisions"

[String]$ServiceManagersUri = $HPEGLAPIbaseURL + '/service-catalog/v1beta1/service-managers'

#EndRegion

#Region ------- HPE COM -------  
[uri]$COMSidebarUrl = 'https://developer.greenlake.hpe.com/_auth/sidebar/__alternative-sidebar__-data-glcp-doc-portal-docs-greenlake-services-compute-ops-mgmt-sidebars.yaml'

#  Job-Templates 

[String]$COMJobTemplatesUri = '/compute-ops-mgmt/v1beta2/job-templates'

#  Activities

[String]$COMActivitiesUri = '/compute-ops-mgmt/v1beta2/activities'


#  Appliance Firmware Bundles

[String]$COMApplianceFirmwareBundlesUri = '/compute-ops-mgmt/v1beta1/appliance-firmware-bundles'


#   External Services

[String]$COMExternalServicesUri = '/compute-ops-mgmt/v1beta1/external-services'

# Filters

[String]$COMFiltersUri = '/compute-ops-mgmt/v1beta1/filters'

# Firmware bundles

[String]$COMFirmwareBundlesUri = '/compute-ops-mgmt/v1beta2/firmware-bundles'

# Groups

# [String]$COMGroupsUri = '/compute-ops-mgmt/v1/groups'
[String]$COMGroupsUri = '/compute-ops-mgmt/v1beta3/groups'
# [String]$COMGroupsUri = '/compute-ops-mgmt/v1beta2/groups'

# Job templates

[String]$COMJobTemplatesUri = '/compute-ops-mgmt/v1beta2/job-templates'

# Jobs

[String]$COMJobsUri = '/compute-ops-mgmt/v1beta3/jobs'

# Metrics Configurations

[String]$COMMetricsConfigurationsUri = '/compute-ops-mgmt/v1beta1/metrics-configurations'

# OneView appliances

[String]$COMOneViewAppliancesUri = '/compute-ops-mgmt/v1beta1/oneview-appliances'

# Reports

[String]$COMReportsUri = '/compute-ops-mgmt/v1beta2/reports'

# Schedules

[String]$COMSchedulesUri = '/compute-ops-mgmt/v1beta2/schedules'

# Server locations

[String]$COMServerLocationsUri = '/compute-ops-mgmt/v1beta1/server-locations'

# Settings

[String]$COMSettingsUri = '/compute-ops-mgmt/v1beta1/settings'
# [String]$COMSettingsUri = '/compute-ops-mgmt/v1beta1/server-settings'

#  Servers

[String]$COMServersUri = '/compute-ops-mgmt/v1beta2/servers'
[String]$COMServersUIDoorwayUri = '/ui-doorway/compute/v2/servers'

# User preferences

[String]$COMUserPreferencesUri = '/compute-ops-mgmt/v1beta1/user-preferences'

# Webhooks

[String]$COMWebhooksUri = '/compute-ops-mgmt/v1beta1/webhooks'


#EndRegion
#EndRegion


#Region Class definitions

Add-Type @"
using System;

public class HtmlContentDetectedException : Exception
{
    public HtmlContentDetectedException() : base() { }
    
    public HtmlContentDetectedException(string message) : base(message) { }

    public HtmlContentDetectedException(string message, Exception innerException) : base(message, innerException) { }
}
"@

#EndRegion


#---------------------------------------------------------
#Region Private functions


function NewObject {

    [CmdletBinding ()]
    Param
    (

        [Object]$InputObject,
        [Switch]$AddComputeDevice,
        [Switch]$AddStorageDevice,
        [Switch]$AddNetworkDevice

    )

    Process {

        switch ($PSBoundParameters.Keys) {
           
            'AddComputeDevice' {

                Return [PSCustomObject]@{
                    SerialNumber = $null;
                    PartNumber   = $null;
                    Tags         = [System.Collections.Hashtable]::new()

                }

            }


            'AddStorageDevice' {

                Return [PSCustomObject]@{
                    SerialNumber    = $null;
                    SubscriptionKey = $null;

                }

            }


            'AddNetworkDevice' {

                Return [PSCustomObject]@{
                    SerialNumber       = $null;
                    MacAddress         = $null;
                    CloudActivationKey = $null;

                }

            }

        }

    }

}


function Test-HPEGLConnection {   
    [CmdletBinding()] 
    Param   (     
    )
    process {
        
        # Get progress bar actual settings 
        $OriginalProgressPreference = $Global:ProgressPreference
        # Disable progress bar
        $Global:ProgressPreference = 'SilentlyContinue'


        # 1 - Test DNS resolution

        $CCServer = $ccsSettingsUrl.Authority
        
        try {
            ([System.Net.Dns]::GetHostAddresses($CCServer)) | Out-Null
            "[{0}] '{1}' is DNS resolvable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $CCServer | Write-Verbose
        }
        catch {
            
            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
            Throw "$($CCServer) is not DNS resolvable. Fix your network environment and try again."
        }


        # 1 - common.cloud.hpe.com

        if ( (New-Object System.Net.Sockets.TcpClient).ConnectAsync($CCServer, 443).Wait(1000) ) {   

            "[{0}] '{1}' is reachable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $CCServer | Write-Verbose
     
        }
        else {
            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
            throw "$($CCServer) is currently unreachable. Please ensure that you have an active internet connection and try again."


        }


        # 2 - sso.common.cloud.hpe.com

        # Get HPE GreenLake Common Cloud Services Settings
        $response = Invoke-RestMethod $ccsSettingsUrl -Method 'GET' 

        "[{0}] Response content of GET '{1}' request: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSettingsUrl, $response | Write-Verbose

        [uri]$Global:HPEGLauthorityURL = $response.authorityURL
        "[{0}] HPEGLauthorityURL variable set: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLauthorityURL | Write-Verbose

        New-Variable -Name HPEGLoktaURL -Scope Global -Value $response.oktaURL -Option ReadOnly -ErrorAction SilentlyContinue -Force
        "[{0}] HPEGLoktaURL variable set: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLoktaURL | Write-Verbose
        New-Variable -Name HPEGLclient_id -Scope Global -Value $response.client_id -Option ReadOnly -ErrorAction SilentlyContinue -Force
        "[{0}] HPEGLclient_id variable set: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLclient_id | Write-Verbose
        $SsoServer = $HPEGLauthorityURL.Authority 


        if (  (New-Object System.Net.Sockets.TcpClient).ConnectAsync($SsoServer, 443).Wait(1000) ) {   

            "[{0}] '{1}' is reachable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $SsoServer | Write-Verbose

     
        }
        else {
            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
            throw "$($SsoServer) is currently unreachable. Please ensure that you have an active internet connection and try again."

        }
      

        # 3 - auth.hpe.com

        $AuthServer = ([uri]$HPEGLoktaURL).Authority
    
        if (  (New-Object System.Net.Sockets.TcpClient).ConnectAsync($AuthServer, 443).Wait(1000)) {   
 
            "[{0}] '{1}' is reachable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $AuthServer | Write-Verbose
            

        }
        else {
            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
            throw "$($AuthServer) is currently unreachable. Please ensure that you have an active internet connection and try again."

        }


        # 4 - aquila-user-api.common.cloud.hpe.com

        $AquilaServer = ([uri]$HPEGLUIbaseURL).Authority
        
        if (  (New-Object System.Net.Sockets.TcpClient).ConnectAsync($AquilaServer, 443).Wait(1000) ) {   
 
            "[{0}] '{1}' is reachable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $AquilaServer | Write-Verbose

            
        }
        else {

            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
            throw "$($AquilaServer) is currently unreachable. Please ensure that you have an active internet connection and try again."

        }

        # 5 -  onepass-enduserservice.it.hpe.com

        $OnepassServer = ([uri]$SchemaMetadataURI).Authority
        
        if (  (New-Object System.Net.Sockets.TcpClient).ConnectAsync($OnepassServer, 443).Wait(2000) ) {   
 
            "[{0}] '{1}' is reachable." -f $MyInvocation.InvocationName.ToString().ToUpper(), $OnepassServer | Write-Verbose

              
        }
        else {
  
            # Return to original progress bar global settings
            $Global:ProgressPreference = $OriginalProgressPreference
            throw "$($OnepassServer) is currently unreachable. Please ensure that you have an active internet connection and try again."
  
        }

        
        # Return to original progress bar global settings
        $Global:ProgressPreference = $OriginalProgressPreference
    }   
}


function Invoke-RepackageObjectWithType {   
    Param   (   
        $RawObject,
        $ObjectName,
        [boolean]   $WhatIf = $false
    )
    process {
        if ( $RawObject ) {
            $OutputObject = @()
            if ( $WhatIf ) {
                Return 
            }
            foreach ( $RawElementObject in $RawObject ) {

                # "[{0}] Element: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject | out-string) | write-verbose

                $DataSetType = "HPEGreenLake.$ObjectName"
                $RawElementObject.PSTypeNames.Insert(0, $DataSetType)
                # "[{0}] Element PSTypeName set: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject.PSTypeNames[0] | out-string)| write-verbose
                # "[{0}] Element PSObject TypeNames set: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject.PSObject.TypeNames[0] | out-string)| write-verbose
                
                $RawElementObject.PSObject.TypeNames.Insert(0, $DataSetType)
                # "[{0}] Element PSObject TypeNames set: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($RawElementObject.PSObject.TypeNames[0] | out-string)| write-verbose

                $OutputObject += $RawElementObject
            }

            # "[{0}] Object typenames : `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($OutputObject.PSObject.TypeNames | Out-String) | write-verbose

            if ($OutputObject.PSObject.TypeNames -notcontains $DataSetType) {

                # "[{0}] Object typenames added using Add-Member as the object is read only" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-verbose

                foreach ($item in $OutputObject) {
                    [void]($item | Add-Member -MemberType NoteProperty -Name PSObject.TypeNames -Value @( $DataSetType) -Force)
                }
            }

            return $OutputObject
        }
        else {
 
            # "[{0}] Null value sent to create object type." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            
            return
        }
    }   
}



function Invoke-RestMethodWhatIf {   
    Param   (   
        $Uri,
        $Method,
        $Headers,
        $Websession,
        $ContentType,
        $Body,
        [ValidateSet ('Invoke-HPEGLWebRequest', 'Invoke-HPECOMWebRequest', 'Invoke-RestMethod')]
        $Cmdlet
    )
    process {
        if ( -not $Body ) {
            $Body = 'No Body'
        }
        write-warning "You have selected the 'What-If' option; therefore, the call will not be made. Instead, you will see a preview of the REST API call."
        Write-host "The cmdlet executed for this call will be:" 
        write-host  "$Cmdlet" -foregroundcolor green
        Write-host "The URI for this call will be:" 
        write-host  "$Uri" -foregroundcolor green
        Write-host "The Method of this call will be:"
        write-host -foregroundcolor green $Method

        if ($headers) {
            Write-host "The Header for this call will be:"
            write-host -foregroundcolor green ($Headers | ConvertTo-JSON | Out-String)  
        }
        if ($websession) {
            Write-host "The Websession for this call will be:"
            write-host -foregroundcolor green ($websession.headers | ConvertTo-JSON | Out-String)  
        }
        if ( $ContentType ) {
            write-host "The Content-Type is set to:"
            write-host -foregroundcolor green $ContentType
        }  
        if ( $Body ) {
            write-host "The Body of this call will be:"
            write-host -foregroundcolor green ($Body | Out-String)
        }
    }
}


Function Get-HPEGLRegion {
    <#
    .SYNOPSIS
    Retrieve HPE GreenLake regions.

    .DESCRIPTION
    This Cmdlet returns a collection of regions to assign to services.    

    .PARAMETER Name 
    Optional parameter that can be used to display all regions instances by name.

    .PARAMETER Code
    Optional parameter that can be used to display all regions instances by code.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLRegion

    Return all available regions.

    .EXAMPLE
    Get-HPEGLRegion -Name "AP AusNZ" 

    Return the region named "AP AusNZ".

    .EXAMPLE
    Get-HPEGLRegion -Code "us-central " 

    Return the region whose code is "us-central".

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Provisioned')]
    Param( 
        
        [Parameter (ParameterSetName = 'Name')]
        [String]$Name,   
        
        [Parameter (ParameterSetName = 'Code')]
        [String]$Code,     

        [Switch]$WhatIf

    ) 
    
    Begin {
    
        $Uri = $RegionsUri
  
    }

    Process {

        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
        
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       
        

        if ($Null -ne $Collection.regions) {
              
            $CollectionList = $Collection.regions 

            if ($Name) {
                $CollectionList = $CollectionList | Where-Object name -eq $name
          
            }

            if ($Code) {
                $CollectionList = $CollectionList | Where-Object code -eq $code
          
            }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Region"         
                               
            return $ReturnData 
  
        }
        else {

            return 
            
        }
    }
}


function Set-HPECOMAPIversionsVariable {
    <#
    .SYNOPSIS
        Retrieve COM resource API versions.
    .DESCRIPTION
        The cmdlet retrieves and stores the API version for each COM resource in the $HPECOMresourceversions global variable.
    .EXAMPLE
        Get-HPECOMresourceAPIversions
        
        Retreive the API version of each COM resources and save them in the $HPECOMresourceversions global variable
    #>
    [CmdletBinding()]
    param (

    )


    try {
        $response = Invoke-RestMethod -Uri $comSidebarUrl -Method GET
    }
    catch {
        throw "COM API resource versions cannot be captured. Please ensure that you have an active internet connection and try again."    
    }


    $items = ($response.items | Where-Object label -eq "API reference").items

    $items = ($items | Where-Object items -ne $Null | Sort-Object -Property label -Descending)

    $HPECOMresourceversionsList = [System.Collections.ArrayList]::new()

    "[{0}] Capture COM API resources variables" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

    for ($i = 0; $i -lt ($items.Count); $i++) {
        
        $object = @{
            name    = $null
            version = $Null
        }
  
        $APIresourcename = $items[$i].label.Substring(0, $items[$i].label.length - 10).replace('-', '_')
        $Object.name = $APIresourcename

        $APIversion = $items[$i].label.Substring($items[$i].label.length - 7)
        $object.version = $APIversion
  
        "Resource: '{0}' = '{1}'" -f $APIresourcename, $APIversion | Write-Verbose

        
        if (-not ($HPECOMresourceversionsList | Where-Object name -eq $APIresourcename )) {
            
            [void]$HPECOMresourceversionsList.add($Object)
        }

    } 

    $Global:HPECOMresourceversions = $HPECOMresourceversionsList

    "[{0}] Global variable set to: `$global:HPECOMresourceversions: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($HPECOMresourceversions | ConvertTo-Json) | Write-Verbose

}


function Set-HPECOMJobTemplatesVariable {
    <#
    .SYNOPSIS
    Retrieve COM job templates URI.

    .DESCRIPTION
    The cmdlet retrieves and stores the URI for each COM job template in the $HPECOMjobtemplatesUris global variable.
    The Cmdlet is automatically executed the first time Invoke-HPECOMWebRequest is run.

    To get the URI of a job template, you can use:
    $HPECOMjobtemplatesUris | Where-Object name -eq PowerOn.New | ForEach-Object resourceuri

    .EXAMPLE
    Set-HPECOMJobTemplatesVariable -Region us-west
    
    Retreive the API version of each COM resources in the us-west region and save them in the $HPECOMjobtemplatesUris global variable
#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region
    )

    $HPECOMjobtemplatesUrisList = [System.Collections.ArrayList]::new()

    
    "[{0}] Region selected: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
    
    if ($HPECOMAPICredentialRegions | Where-Object { $_ -eq $Region }) {

        $ConnectivityEndPoint = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).connectivity_endpoint
        $credentialname = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).name
        $comApiAccessToken = ($HPEGreenLakeSession.comApiAccessToken | Where-Object name -eq $credentialname).access_token

        $url = $ConnectivityEndPoint + $COMJobTemplatesUri
         
        $headers = @{} 
        $headers["Accept"] = "application/json"
        $headers["Content-Type"] = "application/json"
        $headers["Authorization"] = "Bearer $($comApiAccessToken)"

        "[{0}] About to run a GET request to '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
        "[{0}] Headers used: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | ConvertTo-Json) | Write-Verbose

        try {
            [array]$JobTemplates = (Invoke-RestMethod -Uri $url -Method 'GET' -Headers $Headers ).items
            # "[{0}] Response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($JobTemplates | Out-String ) | Write-Verbose

        }   
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        foreach ($JobTemplate in $JobTemplates) {

            $_Name = $JobTemplate.name 
            $_Value = $JobTemplate.resourceUri
            $_ID = $JobTemplate.id


            $object = @{
                name        = $_Name
                resourceUri = $_Value
                Id          = $_ID
            }
            
        
            [void]$HPECOMjobtemplatesUrisList.add($object)

        }

        $Global:HPECOMjobtemplatesUris = $HPECOMjobtemplatesUrisList

        "[{0}] Global variable set to: `$global:HPECOMjobtemplatesUris: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($HPECOMjobtemplatesUris | ConvertTo-Json) | Write-Verbose
    }
    else {
        "[{0}] Global variable `$global:HPECOMjobtemplatesUris cannot be set as no COM API client credential can be found for '{1}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $region | Write-Verbose
    }

}


# Function to get the current time difference between GMT and the local computer time zone
function Get-GMTTimeDifferenceInHours {

    [CmdletBinding()]
    Param(

        [switch]$InMinutes

    )

    # Get current date and time in UTC (GMT)
    $utcNow = [DateTime]::UtcNow

    # Define TimeZoneInfo objects for GMT and Local Time Zone
    $localTimeZone = [System.TimeZoneInfo]::Local                        # Local Computer Time Zone

    # Convert UTC to Local Time
    $localTime = [System.TimeZoneInfo]::ConvertTimeFromUtc($utcNow, $localTimeZone)

    # Calculate the time difference
    $timeDifferenceinHours = ($localTime - $utcNow).TotalHours
    $timeDifferenceinMinutes = ($localTime - $utcNow).TotalMinutes

    # Check if the current date/time falls within Daylight Saving Time
    $isDaylightSaving = $localTimeZone.IsDaylightSavingTime($localTime)

    # Display the detected local time zone, DST status, and the time difference
    "[{0}] Detected local time zone: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $localTimeZone.Id | Write-Verbose
    "[{0}] Is the current time in Daylight Saving Time? '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $isDaylightSaving | Write-Verbose
    "[{0}] Current time difference between GMT and local time: '{1}' hour(s)" -f $MyInvocation.InvocationName.ToString().ToUpper(), [Math]::Round($timeDifferenceinHours, 0) | Write-Verbose
    "[{0}] Current time difference between GMT and local time: '{1}' minutes(s)" -f $MyInvocation.InvocationName.ToString().ToUpper(), [Math]::Round($timeDifferenceinMinutes, 0) | Write-Verbose
       
    if ($InMinutes) {
        Return $timeDifferenceinMinutes
    }
    else {
        Return $timeDifferenceinHours
    }

}




#EndRegion


#---------------------------------------------------------
#Region Public functions
 
  
#Region ------------------- GENERICs -------------------

function Invoke-HPEGLWebRequest {  
    <#
    .SYNOPSIS
    Cmdlet to run web requests to the HPE Greenlake APIs. 

    .DESCRIPTION
    The `Invoke-HPEGLWebRequest` cmdlet sends HTTPS requests to the HPE Greenlake APIs. It adds the required headers, session, parses the response and returns the response.

    .PARAMETER Uri
    The absolute uri that identifies the required HPE GreenLake resource (eg. '/ui-doorway/ui/v1/license/devices').

    .PARAMETER Body
    Body for the request. Required if the method is POST or PUT.

    .PARAMETER Method
    The request HTTP Method.

            * "GET" (default) to get a resource from the appliance (read)
            * "POST" to create a new resource
            * "PUT" to modify a resource (write)
            * "PATCH" to modify a resource (write), with specific attributes set to values, other attributes should be set to $null.
            * "DELETE" to delete a resource

    .PARAMETER WebSession
    Web session object containing information about the HPE GreenLake session, including cookies and credentials.
    Default uses $HPEGreenLakeSession.session global variable.

    .PARAMETER WhatIfBoolean
    Switch parameter to show the user what would happen if the cmdlet was to run without actually running it.

    .EXAMPLE
    Invoke-HPEGLWebRequest -Uri 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/license/devices' 

    Run a GET web request on 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/license/devices' using the web session object
    $HPEGreenLakeSession.session containing information about the HPE GreenLake session. 

    .EXAMPLE
    Invoke-HPEGLWebRequest 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/um/users' -WhatIfBoolean $True

    Run a GET web request on 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/um/users' with the WhatIfBoolean parameter to see 
    the potential effects of the command before committing to it.

    .EXAMPLE
    $Uri = 'https://aquila-user-api.common.cloud.hpe.com' + '/ui-doorway/ui/v1/um/users'

    $Payload = @"
    {
    "usernames": [
        "email1@gmail.com", 
        "email@yahoo.com"
    ]
    }
    "@

    Invoke-HPEGLWebRequest -Method Delete -Uri $Uri -Body $Payload

    Run a DELETE web request on 'https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/um/users' with the provided payload. 

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    The output of the cmdlet depends upon the format of the content that is retrieved.
    If the request returns JSON strings, Invoke-HPEGLWebRequest returns a PSObject that represents the strings.
        
         
    #>
    Param   (   
        [Parameter (Mandatory)]
        [String]$Uri,

        $Body, 

        [String]$Method = "GET",

        [String]$ContentType = 'application/json',

        $WebSession = $HPEGreenLakeSession.session, 

        $WhatIfBoolean = $false,

        [int]$MaxRetries = 5,
        [int]$InitialDelaySeconds = 1

    )
   
    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            get-item variable:HPEGLclient_id -ErrorAction Stop | Out-Null
    
        }
        catch {
            Throw "Error - No session found! Connect-HPEGL must be executed first!"
    
        }

        # Check if a reconnection is required
        try {

            "[{0}] Running Invoke-HPEGLAutoReconnect to check if refresh token is required..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            Invoke-HPEGLAutoReconnect

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
      
        Clear-Variable -Name InvokeReturnData -ErrorAction SilentlyContinue
        
        if ( $WhatIfBoolean ) {

            if ($uri -match $HPEGLUIbaseURL) {

                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Body -WebSession $WebSession -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"

            }
            elseif ($uri -match $HPEOnepassbaseURL) {
                      
                if ($null -ne $Body) {

                    try {
                        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Body | Write-Verbose
                        $BodyObject = ConvertFrom-Json -InputObject $Body -ErrorAction Stop
                        "[{0}] Payload content after convertion: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $BodyObject | Write-Verbose
                        # Add sessionId to the object
                        $BodyObject | Add-Member -MemberType NoteProperty -Name 'sessionId' -Value $HPEGreenLakeSession.onepassSid
                        "[{0}] Payload content after adding sid: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $BodyObject | Write-Verbose

                    }
                    catch {
                        Write-Error "The provided JSON body is not valid."
                        return
                    }
                }
                else {
                    $BodyObject = @{ sessionId = $HPEGreenLakeSession.onepassSid }
                }


                # Convert the body hashtable to a JSON string
                $Payload = $BodyObject | ConvertTo-Json
                        
                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Payload -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"

            }
            else {
                
                $headers = @{} 
                $headers["Accept"] = "application/json"
                $headers["Content-Type"] = $ContentType
                $headers["Authorization"] = "Bearer $($HPEGreenLakeSession.glpApiAccessToken.access_token)"

                invoke-RestMethodWhatIf -Uri $Uri -Method $Method -Body $Body -Headers $headers -ContentType 'application/json' -Cmdlet "Invoke-HPEGLWebRequest"
                
            }
        }
        
        else {

            $retries = 0

            while ($retries -lt $MaxRetries) {

                # When using a UI Doorway URI
                if ($uri -match $HPEGLUIbaseURL) {

                    "[{0}] Detected URI: UI Doorway ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # Process pagination for GET 
                    if ($Method -eq "GET" -or $Method -eq "POST") {
                        # if ($Method -eq "GET" -or ($Method -eq "POST" -and -not $Body)) {

                        $AllCollection = [System.Collections.ArrayList]::new()

                        # Get 100 items pagination
                        $pagination = 100

                        # Detect if $uri contains a query parameter
                        $uriobj = [System.Uri]::new($uri)

                        # uriobj content:           https://aquila-user-api.common.cloud.hpe.com/ui-doorway/ui/v1/license?product_type=DEVICE
                        # uriobj.query content:     ?product_type=DEVICE
                        # queryParameters content:  product_type=DEVICE
                       
                        # "[{0}] uriobj content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $uriobj | Write-Verbose
                        # "[{0}] uriobj.query content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $uriobj.Query | Write-Verbose
                        
                        # Parse the query parameters into a dictionary
                        $queryParameters = [System.Web.HttpUtility]::ParseQueryString($uriobj.Query)
                        # "[{0}] Query parameters content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $queryParameters | Write-Verbose
                        
                        
                        # URI modification to support pagination
                        if ($queryParameters["limit"]) {

                            $url = $uri
                        }
                        # If contains another query parameter
                        elseif ($uriobj.Query -ne "") {

                            $url = $uri + "&limit=$pagination&offset=0"

                        }
                        # If not contains any query parameter
                        else {
                            
                            $url = $uri + "?limit=$pagination&offset=0"
                        }
                       
                        
                    }
                    else {

                        $url = $uri

                    }

                    "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Url | Write-Verbose

                    if ($HPEGreenLakeSession.session.headers) {
                        "[{0}] Request headers: `n'{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($HPEGreenLakeSession.session.headers | Out-String) | Write-Verbose
                    }

                    # if ($Body) {
                    #     "[{0}] Request payload: `n'{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Body | Out-String) | Write-Verbose
                    # }

                      
                    if ($body) {
                        # If body is JSON
                        if ($body.Trim().StartsWith('{') -and $body.Trim().EndsWith('}')) {
                            $Payload = $Body 
                        }
                        else {
                            # Convert the body hashtable to a JSON string
                            $Payload = $Body | ConvertTo-Json -Depth 10
                    
                        }
                        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                
                    }


                    try {

                        $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Body $Body -WebSession $WebSession -ContentType $ContentType #-ErrorAction Stop
 
                        if ($InvokeReturnData -match "doctype html") {      
                            
                            "[{0}] HTML doctype response detected ! Throwing exception!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                            throw [HtmlContentDetectedException]::new("Error! HTML content detected! Throwing exception!")
                        }
                        
                      
                    }
                    # Handle exceptions related to network operations
                    catch [System.Net.WebException] {

                        "[{0}] System.Net.WebException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose                     
    
                        # Service Unavailable error
                        if ($_.Exception.Response.StatusCode -eq 503) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            "[{0}] Received 503. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            Start-Sleep -Seconds $waitTime
                        }
                        else {
                        
                            "[{0}] Exception thrown!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                            # Get Exception type
                            $exception = $_.Exception
                            do {
                                "[{0}] Exception Type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $exception.GetType().Name | Write-Verbose
                                $exception = $exception.InnerException
                            } while ($exception)
    
                            # Get exception stream
                            $result = $_.Exception.Response.GetResponseStream()
                            $reader = New-Object System.IO.StreamReader($result)
                            $reader.BaseStream.Position = 0
                            $reader.DiscardBufferedData()
                            $responseBody = $reader.ReadToEnd() 
    
                            # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseBody | Write-Verbose
                    
    
                            if ($HPEGreenLakeSession.session.headers) {
                                "[{0}] Request headers: " -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                                foreach ($Param in $HPEGreenLakeSession.session.headers.Keys) { 
                        
                                    Write-Verbose "`t`t$Param : $($HPEGreenLakeSession.session.headers[$Param])" 
                         
                                }
                            }
    
                            $response = $responseBody | ConvertFrom-Json
                        
                            $ResponseCode = $response.code
                            $ResponseDetail = $response.detail
                            $ResponseStatus = $Response.Status
    
                            if ($ResponseCode) {
                                "[{0}] Request failed with the following Status: `n`tHTTPS Return Code = '{1}' `n`tHTTPS Return Code Description = '{2}' `n`tHTTPS Return Code Details = '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResponseStatus, $ResponseCode, $ResponseDetail | write-verbose
                            }  
                    
                            $StatusCode = [int]$_.Exception.Response.StatusCode
                            $ExceptionCode = $_.Exception.Response.StatusCode.value__
                    
                            if ($StatusCode -and -not $ResponseCode) {
                                "[{0}] HTTPS Return Code = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $StatusCode | Write-Verbose
                            }
                            elseif ($ExceptionCode -and -not $ResponseCode) {
                                "[{0}] HTTPS Return Code = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode | Write-Verbose
                            }
    
    
                            if ($ResponseStatus -and $ResponseCode -and $ResponseDetail) {
                                Throw "Error '{0}' - '{1}' : '{2}'" -f $ResponseCode, $ResponseStatus, $ResponseDetail
                            }
                            elseif ($ResponseStatus -and $ResponseCode -and -not $ResponseDetail) {
                                Throw "Error '{0}' - '{1}'" -f $ResponseCode, $ResponseStatus
                            }
                            elseif ($ResponseStatus -and -not $ResponseCode -and -not $ResponseDetail) {
                                Throw "Error '{0}'" -f $ResponseStatus
                            }
                            elseif ($responseBody -match "Unauthorized" ) {
               
                                Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
    
                            }
                            elseif ($response.message ) {
               
                                Throw "Error - $($response.message)"
    
                            }
                            elseif ($response.detail ) {
    
                                if ($response.detail.msg) {
    
                                    $Detailmsg = ($response.detail | ForEach-Object { $_.msg + ": " + $_.type }) -join " AND "
    
                                    Throw "Error - $Detailmsg"
                                }
                                else {
    
                                    Throw "Error - $($response.detail)"
                                }
    
                            }
                            else {
    
                                Throw "Error - $($response | Out-String)"
     
                            }
                        }
                   
                    }
                    # Handle general runtime exceptions
                    catch [System.Management.Automation.RuntimeException] {

                        "[{0}] System.Management.Automation.RuntimeException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose

                        # 'Request Timeout' error
                        if ($_.Exception.Response.StatusCode -eq 408) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            "[{0}] Received 408. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            Start-Sleep -Seconds $waitTime
                        }
                        # When 'Forbidden' error are not expected (issue with GLP?)
                        elseif ($_.Exception.Response.StatusCode -eq 403) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            "[{0}] Received 403. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            Start-Sleep -Seconds $waitTime
                        }
                         # When 'Internal Server Error' error 
                         elseif ($_.Exception.Response.StatusCode -eq 500) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            "[{0}] Received 500. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            Start-Sleep -Seconds $waitTime
                        }
                        else {

                            # Convert JSON string to object
                            try {
                                
                                $response = $_ | ConvertFrom-Json
        
                                $_ExceptionMessageDetails = [System.Collections.ArrayList]::new()
                                $_ExceptionMessage = [System.Collections.ArrayList]::new()
                    
                                if ($response.detail) {
        
                                    foreach ($detail in $response.detail) {
        
                                        # Capture the 'msg' property
                                        $message = $detail.msg
                                        $type = $detail.type
        
                                        $Info = [System.Collections.HashTable]@{
                                            message = $message
                                            type    = $type
                                        }
        
                                        [void]$_ExceptionMessageDetails.Add($Info)
        
                                    }
        
                                    if ($_ExceptionMessageDetails) {
                                        
                                        "[{0}] Exception Message Details: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_ExceptionMessageDetails | out-String) | Write-Verbose
                                    }
        
                                }
        
                                if ($response.message) {
        
                                    [void]$_ExceptionMessage.add($response.message)
                                }

                                if ($response.errorDetails.length -ge 1 ) {

                                    foreach ($error in $response.errorDetails) {
                                    
                                        if ($error.metadata.error) {
                                            [void]$_ExceptionMessage.add($error.metadata.error)

                                        }
                                    }
                                    
                                }
                                
                            }
                            catch {}


                            $ExceptionCode = $_.Exception.Response.StatusCode.value__
                            $ExceptionText = $_.Exception.Response.StatusDescription + $_.Exception.Response.ReasonPhrase 
                            


                            if ( $_ExceptionMessage) {
                                "[{0}] Request failed with the following Status:`r`n`tHTTPS Return Code = '{1}' `r`n`tHTTPS Return Code Description = '{2}' `r`n`tHTTPS Return Message = '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode, $ExceptionText, ($_ExceptionMessage -join " - ") | write-verbose
                            }
                            else {
                                "[{0}] Request failed with the following Status:`r`n`tHTTPS Return Code = '{1}' `r`n`tHTTPS Return Code Description = '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode, $ExceptionText | write-verbose


                            }
                        
                            $StatusCode = [int]$_.Exception.Response.StatusCode
        
        
                            if ($_ExceptionMessage) {

                                Throw "Error status Code: {0} ({1}) - {2}" -f $StatusCode, $ExceptionText, ($_ExceptionMessage -join " - ")

                            }
                            elseif ( $StatusCode -eq 400 ) {
                                Throw "Error status Code: 400 (Bad Request)"
                            
                            } 
                
                            elseif ( $StatusCode -eq 401 ) {
                                Throw "Error status Code: 401 (Unauthorized) - Your session with HPE GreenLake doorway API has expired, please log in again!"
                                
                            } 
                            
                            elseif ( $StatusCode -eq 403 ) {
                                Throw "Error status Code: 403 (Forbidden) - Your session with HPE GreenLake doorway API has expired or you do not have sufficient rights to perform this action!"
                                
                            } 
                            
                            elseif ( $StatusCode -eq 412 ) {
                                Throw "Error status Code: 412 (Precondition failed) - Please verify the content of the payload request!"
                                
                            } 
                            
                            elseif ( $StatusCode -eq 408 ) {
                                Throw "Error status Code: 408 (Request Timeout) - Please try again!"
                                
                            }
                            
                            else {
                                Throw "Error status Code: {0} ({1})" -f $StatusCode, $ExceptionText

                            }
                        }
                    }  

                    catch [HtmlContentDetectedException] {

                        "[{0}] HtmlContentDetectedException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose                     
                        
                        # When HTML is detected, it means the session has expired or been closed
                        Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                    }
                    
                    catch {

                        "[{0}] Catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose                     

                        # Any other non-web-related exception will be caught here
                        Throw "An unexpected error occurred: $_"
                    }

                    finally {
                        $retries++
                    }
                    
                    
                }

                # When using an HPEOnepass URI
                elseif ($uri -match $HPEOnepassbaseURL) {

                    "[{0}] Detected URI: HPE Onepass ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    if ($null -ne $Body) {

                        try {
                            $BodyObject = ConvertFrom-Json -InputObject $Body -ErrorAction Stop
                            # "Payload content after convertion: `n{0}" -f $BodyObject | Write-Verbose
                            # Add sessionId to the object
                            $BodyObject | Add-Member -MemberType NoteProperty -Name 'sessionId' -Value $HPEGreenLakeSession.onepassSid                   
                            # "Payload content after adding HPEOnePass sessionId: `n{0}" -f $BodyObject | Write-Verbose

                        }
                        catch {
                            Write-Error "The provided JSON body is not valid."
                            return
                        }
                    }
                    else {
                        $BodyObject = @{ sessionId = $HPEGreenLakeSession.onepassSid }

                    }

                    "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Uri | Write-Verbose

                    # Convert the body hashtable to a JSON string
                    $Payload = $BodyObject | ConvertTo-Json
                    
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                    
                    Try {

                        $InvokeReturnData = Invoke-WebRequest -Uri $Uri -Method $Method -Body $Payload -ContentType $ContentType #-ErrorAction Stop

                    }
                    catch [System.Net.WebException] {

                        "[{0}] System.Net.WebException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose     

                        # Service Unavailable error
                        if ($_.Exception.Response.StatusCode -eq 503) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            Write-Host "Received 503. Retrying in $waitTime seconds..."
                            Start-Sleep -Seconds $waitTime
                        }
                        else {
                            # A WebException will be caught here if the web request fails
                            Write-Warning "A Web Exception occurred: $_"
                
                            # To access more detailed information about the error:
                            if ($_.Exception.Response) {
                                $responseStream = $_.Exception.Response.GetResponseStream()
                                $streamReader = New-Object System.IO.StreamReader($responseStream)
                                $errorResponse = $streamReader.ReadToEnd()
                                Write-Warning "Error Response: $errorResponse"
                            }
                        }
                    }
                    catch {

                        "[{0}] Catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose    

                        # Any other non-web-related exception will be caught here
                        Write-Error "An unexpected error occurred: $_"
                    }
                    finally {
                        $retries++
                    }
                }
                
                # When using an HPE GLP API URI
                elseif ($uri -match $HPEGLAPIbaseURL) {

                    "[{0}] Detected URI: GLP API URI ------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose            

                    if ($Null -eq $HPEGreenLakeSession.glpApiAccessToken) {
          
                        Throw "Error - No API Access Token found in `$HPEGreenLakeSession! Connect-HPEGL must be executed first!"
                   
                    }            

                    "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Uri | Write-Verbose

                    $headers = @{} 
                    $headers["Accept"] = "application/json"
                    $headers["Content-Type"] = "application/json"
                    $headers["Authorization"] = "Bearer $($HPEGreenLakeSession.glpApiAccessToken.access_token)"

                    "[{0}] Request headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | out-string) | Write-Verbose

                    if ($body) {
                        # If body is JSON
                        if ($body.Trim().StartsWith('{') -and $body.Trim().EndsWith('}')) {
                            $Payload = $Body 
                        }
                        else {
                            # Convert the body hashtable to a JSON string
                            $Payload = $Body | ConvertTo-Json -Depth 10
                    
                        }
                        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
                
                    }


                    try {
              
                        $InvokeReturnData = Invoke-WebRequest -Uri $Uri -Method $Method -Headers $headers -Body $Body -ContentType $ContentType
                    
                    }
                    catch [System.Net.WebException] {

                        "[{0}] System.Net.WebException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose     
                        
                        # Service Unavailable error
                        if ($_.Exception.Response.StatusCode -eq 503) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            Write-Host "Received 503. Retrying in $waitTime seconds..."
                            Start-Sleep -Seconds $waitTime
                        }
                        else {

                            if ($_.Exception.Response) {

                                $PSCmdlet.ThrowTerminatingError($_).Exception.Response
                                
                               
                            }
                            else {
                                Throw "No Response Received."
                            }
                        }
                    }
                    catch {

                        "[{0}] Catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                        "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose     
                        
                        # 'Request Timeout' error
                        if ($_.Exception.Response.StatusCode -eq 408) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            "[{0}] Received 408. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            Start-Sleep -Seconds $waitTime
                        }
                        # When 'Internal Server Error' error 
                        elseif ($_.Exception.Response.StatusCode -eq 500) {
                            $retries++
                            # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                            $waitTime = 2
                            "[{0}] Received 500. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            Start-Sleep -Seconds $waitTime
                        }
                        else {

                            if ($_.ErrorDetails) {
    
                                "[{0}] Error Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose
        
                                $errorResponse = $_.ErrorDetails.Message | ConvertFrom-Json
        
                                # Write-Verbose  $errorResponse
        
                                $httpStatusCode = $errorResponse.httpStatusCode
                                $Message = $errorResponse.message
                               
                                if ($errorResponse -and $errorResponse.errorDetails -and $errorResponse.errorDetails.Count -gt 0 -and 
                                    $errorResponse.errorDetails[0].issues -and $errorResponse.errorDetails[0].issues.Count -gt 0 -and 
                                    $errorResponse.errorDetails[0].issues[0].description) {
                                
                                    $Description = $errorResponse.errorDetails[0].issues[0].description
                                    $Subject = $errorResponse.errorDetails[0].issues[0].subject
        
                                }                    
        
                                if ($errorResponse -and $errorResponse.errorDetails -and $errorResponse.errorDetails.Count -gt 0 -and 
                                    $errorResponse.errorDetails[0].metadata -and $errorResponse.errorDetails[0].metadata.details) {
                                
                                    $Description = $errorResponse.errorDetails[0].metadata.details
                                }                       
                                       
                            }                       
    
                            if ($httpStatusCode -eq 404) {
    
                                Write-Error $errorResponse
                                Throw "Resource not found (404) -  $message"
                                
                            }
                            elseif ($Message -eq "Unauthorized") {
    
                                "[{0}] Error response message: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $message | Write-Verbose
                                Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
    
    
                            }
                            elseif ($Message) {
    
                                "[{0}] Error response message: '{1}' - HTTP status code: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Message, $httpStatusCode | Write-Verbose
    
                                if ($Description -and $Subject) {
                                    
                                    "[{0}] Error subject: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Subject | Write-Verbose
                                    "[{0}] Error description: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Description | Write-Verbose
                                    Throw "Error: '$message' - HTTP status code: '$httpStatusCode' - Subject: '$Subject' - Description: '$Description'"
    
                                }
                                elseif ($Description) {
    
                                    "[{0}] Error description: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Description | Write-Verbose
                                    Throw "Error: '$message' - HTTP status code: '$httpStatusCode' - Description: '$Description'"
    
                                }
                                else {
                                    Throw "Error: '$message' - HTTP status code: '$httpStatusCode'"
                                    
                                }
    
    
                            }
                            else {
    
                                "[{0}] Error: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose
                                Throw $_

                            }
                        }

                    }
                    finally {
                        $retries++
                    }
                    
                }
                else {
                    Throw "Error - Invalid URI! The URI must be a valid HPE GreenLake API URI!"
                }
            
              
                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose                    
    
                if ($InvokeReturnData) {

                    # if ($InvokeReturnData -match "doctype html") {
                    
                    #     Write-verbose "HTML doctype response detected ! Throwing exception!"
                    
                    #     Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
                    
                    # }                   
            
                    # Convert from JSON if possible
                    try {

                        $InvokeReturnData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop

                        if ($InvokeReturnData -eq "OK") {

                            "[{0}] Response Detected with an 'OK' response!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            
                            return           
                        }   

                        # HPEOnepass URI expiration detection
                        if ($InvokeReturnData.message -match "expired") {
                            write-error "Session gets expired! You must run 'Connect-HPEGL' again!"
                        }


                        "[{0}] Response detected as JSON content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        # "[{0}] Response detected as JSON content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(),  ( $InvokeReturnData | out-string) | Write-Verbose


                        if ($InvokeReturnData.pagination.total_count -gt 0) {
               
                            "[{0}] Response detected with a pagination content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($InvokeReturnData.pagination | out-string) | Write-Verbose
                            
                            # Get all paginated pages (if any)
                            if (($Method -eq "GET" -or $Method -eq "POST") -and -not $queryParameters["limit"]) {
                                #    if (($Method -eq "GET" -or ($Method -eq "POST" -and -not $Body)) -and -not $queryParameters["limit"]) {
    
                                # "[{0}] Pagination found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                                   
                                $AllCollection = $InvokeReturnData

                                "[{0}] Total of items: '{1}' - Number of items per page: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.pagination.total_count, $InvokeReturnData.pagination.count_per_page | Write-Verbose
                            
                                $Numberofpages = [System.Math]::Ceiling(($InvokeReturnData.pagination.total_count / $InvokeReturnData.pagination.count_per_page))
                            
                                "[{0}] Number of pages found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofpages | Write-Verbose
                            
                                if ($Numberofpages -gt 1) {

                                    for ($i = 1; $i -lt $Numberofpages; $i++) {
                                    
                                        $Offset += $pagination

                                        if ($uriobj.Query -ne "") {
                                            
                                            $url = $uri + "&limit=$pagination&offset=$Offset"
                                            
                                        }
                                        else {
                                            
                                            $url = $uri + "?limit=$pagination&offset=$Offset"
                                        }

                                        "[{0}] Request URI for page '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $url | Write-Verbose
                                    
                                        try {
                                   
                                            $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Body $Body -WebSession $WebSession -ContentType $ContentType #-ErrorAction Stop

                                            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                                            "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   

                                            $InvokeReturnMoreData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop 
                                            "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                                            # Initialize an empty hashtable
                                            $dictionary = @{}

                                            # Iterate through the properties of the returned object
                                            $InvokeReturnMoreData.PSObject.Properties | ForEach-Object {
                                                $propertyName = $_.Name
                                                $propertyValue = $_.Value

                                                # Check if the property value is a list of objects (array or collection) and not a hashtable
                                                if ($propertyValue -is [System.Collections.IEnumerable] -and $propertyValue -ne $null -and $propertyValue.GetType().Name -ne "String" -and -not ($propertyValue -is [hashtable])) {
                                                    $dictionary[$propertyName] = $propertyValue
                                                }
                                            }

                                            "[{0}] Content of the list property that needs to be added: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($dictionary | Out-String) | Write-Verbose

                                            # "[{0}] `$dictionary: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($dictionary.GetEnumerator() | gm  | Out-String) | Write-Verbose

                                            # Iterate through the dictionary entries
                                            foreach ($entry in $dictionary.GetEnumerator()) {
                                                $_Item = $entry.Key
                                                $_Value = $entry.Value
                                             
                                            }
                                            
                                            # "[{0}] Adding item '{1}' with content: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Item, ($_Value | out-String)  | Write-Verbose
                                            
                                            if ($AllCollection.PSObject.Properties.Match('$_Item')) {
                                                
                                                "[{0}] Content of `$AllCollection matches with {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Item | Write-Verbose
                                                
                                                "[{0}] Adding page '{1}' to the result" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1) | Write-Verbose
                                                $AllCollection.($_Item) += $_Value
                                            }

                                        }
                                        catch {    
                                            $PSCmdlet.ThrowTerminatingError($_)
                                        
                                        }
                                    }
                                }

                                $InvokeReturnData = $AllCollection
                            }

                            if ($Null -ne $InvokeReturnData.content) {

                                "[{0}] Response Detected with a Content property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                                "[{0}] $InvokeReturnData content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($InvokeReturnData | out-String) | Write-Verbose

                                $InvokeReturnData = $InvokeReturnData.content
            
                            }

                        }

                        return $InvokeReturnData   

                    }

                    catch {

                        throw $InvokeReturnData
                    }                    
            
                }  
            }
           
            throw "Max retries exceeded after receiving multiple exception errors."
        }          
    }         
}


function Invoke-HPECOMWebRequest {  
    <#
     .SYNOPSIS
    Cmdlet to run web requests to the Compute Ops Management API. 

    .DESCRIPTION
    The `Invoke-HPECOMWebRequest` cmdlet sends HTTPS requests to the Compute Ops Management API. It adds the required headers, parses the response and returns the response.

    .PARAMETER Region
    Mandatory parameter that defines the Compute Ops Management region instance for the request.

    .PARAMETER Uri
    The uri that identifies the required Compute Ops Management resource (eg. /compute-ops/v1beta2/job-templates').

    .PARAMETER Body
    Body for the request. Required if the method is POST or PUT.

    .PARAMETER Method
    The request HTTP Method.

            * "GET" (default) to get a resource from the appliance (read)
            * "POST" to create a new resource
            * "PUT" to modify a resource (write)
            * "PATCH" to modify a resource (write), with specific attributes set to values, other attributes should be set to $null.
            * "DELETE" to delete a resource

    .PARAMETER WebSession
    Web session object containing information about the HPE GreenLake session, including cookies and credentials.
    Default uses $HPEGreenLakeSession.session global variable.

    .PARAMETER WhatIfBoolean
    Switch parameter to show the user what would happen if the cmdlet was to run without actually running it.

    .EXAMPLE
   

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    The output of the cmdlet depends upon the format of the content that is retrieved.
    If the request returns JSON strings, Invoke-HPEGLWebRequest returns a PSObject that represents the strings.
        
         
    #>
    Param   (   
        [Parameter (Mandatory)]
        [String]$Uri,

        $Body, 

        [String]$Method = "GET",

        [Parameter(Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$ContentType = 'application/json',

        $WhatIfBoolean = $false,

        [int]$MaxRetries = 5,
        [int]$InitialDelaySeconds = 1

    )
   
    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        #Region Check if HPEGreenLakeSession variable is available
        try {
            Get-Variable -Name HPEGreenLakeSession -Scope Global -ErrorAction Stop | Out-Null
        }
        catch {
            Throw "Error - No COM API credential found! Connect-HPEGL must be executed first!"
    
        }
        #EndRegion


        #Region Check if a reconnection is required
        try {
            Invoke-HPEGLAutoReconnect 
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        #EndRegion


        #Region Retrieve $HPECOMjobtemplatesUris if not available
        if (-not $HPECOMjobtemplatesUris) {
            "[{0}] About to retrieve the URIs of each job templates in '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $region | Write-Verbose
            Set-HPECOMJobTemplatesVariable -region $Region
        }
        #EndRegion
      

        #Region Check if COM API variable for the region is available + construct $url and pagination
        Clear-Variable -Name InvokeReturnData -ErrorAction SilentlyContinue

        "[{0}] Region selected: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
    
        $credentialname = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).name

        "[{0}] Credential found in `$HPEGreenLakeSession.apiCredentials: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $credentialname | Write-Verbose

        if ($Null -eq $credentialName) {

            Throw "Error! No COM API credential found for '$Region' in `$HPEGreenLakeSession.apiCredentials! 'Connect-HPEGL' must be executed first or make sure you have selected the correct region!"

        }
        else {

            $ConnectivityEndPoint = ($HPEGreenLakeSession.apiCredentials | Where-Object region -eq $Region).connectivity_endpoint
            
            if ($ConnectivityEndPoint ) {
                "[{0}] Connectivitiy EndPoint found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ConnectivityEndPoint | Write-Verbose
                
            }
            else {
                    
                Throw "Error - No COM API Access Token found in `$HPEGreenLakeSession! Connect-HPEGL must be executed !"
                    
            }
            
            $comApiAccessToken = ($HPEGreenLakeSession.comApiAccessToken | Where-Object name -eq $credentialname).access_token
    

            # Process pagination for GET 
            if ($Method -eq "GET") {

                $AllCollection = [System.Collections.ArrayList]::new()

                # Get 100 items pagination
                $pagination = 100

                # Detect if $uri contains a query parameter
                $url = $ConnectivityEndPoint + $uri
                $uriobj = [System.Uri]::new($url)

                # Parse the query parameters into a dictionary
                $queryParameters = [System.Web.HttpUtility]::ParseQueryString($uriobj.Query)
                
                # If contains a query limit parameter
                if ($queryParameters["limit"]) {

                    $Url = $ConnectivityEndPoint + $uri
                }
                # If contains another query parameter
                elseif ($uriobj.Query -ne "") {

                    $Url = $ConnectivityEndPoint + $uri + "&limit=$pagination&offset=0"

                }
                # If not contains any query parameter
                else {
                    
                    $Url = $ConnectivityEndPoint + $uri + "?limit=$pagination&offset=0"
                }
                
            }
            else {

                $url = $ConnectivityEndPoint + $uri

            }

            if ($comApiAccessToken ) {
                "[{0}] COM API Access token found" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
            }
            else {
                    
                Throw "Error - No COM API Access Token found in `$HPEGreenLakeSession! Connect-HPEGL must be executed !"
                    
            }


        }
        #EndRegion

       
        #Region Construction for WhatIf
        if ( $WhatIfBoolean ) {
               
            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Authorization"] = "Bearer $($comApiAccessToken)"

            Invoke-RestMethodWhatIf -Uri $Url -Method $Method -Body $Body -Headers $headers -ContentType $ContentType -Cmdlet "Invoke-HPECOMWebRequest"
                
        }
        #EndRegion
        

        #Region Construction for Invoke-Webrequest
        else {

            $retries = 0

            "[{0}] About to make a '{1}' call to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $Url | Write-Verbose      
            
            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Authorization"] = "Bearer $($comApiAccessToken)"
            
            "[{0}] Request headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | ConvertTo-Json) | Write-Verbose
            # "[{0}] Content-Type is set to '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ContentType | Write-Verbose      
           
            if ($body) {
                # If body is JSON
                if ($body.Trim().StartsWith('{') -and $body.Trim().EndsWith('}')) {
                    $Payload = $Body 
                }
                else {
                    # Convert the body hashtable to a JSON string
                    $Payload = $Body | ConvertTo-Json -Depth 10
                
                }
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose
            
            }


            while ($retries -lt $MaxRetries) {

                try {
              
                    $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Headers $headers -Body $Body -ContentType $ContentType
                    
                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose    

                    
                }
                catch [System.Net.WebException] {

                    "[{0}] System.Net.WebException catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                    "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 

                    # 'Service Unavailable' error
                    if ($_.Exception.Response.StatusCode -eq 503) {
                        $retries++
                        # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                        $waitTime = 2
                        Write-Host "Received 503. Retrying in $waitTime seconds..."
                        Start-Sleep -Seconds $waitTime
                    }
                    else {

                        if ($_.Exception.Response) {

                            $PSCmdlet.ThrowTerminatingError($_).Exception.Response
                            
                           
                        }
                        else {
                            Throw "No Response Received."
                        }
                    }
                }
                catch {

                    "[{0}] Catch triggered!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    "[{0}] Exception type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_.Exception.GetType().Name | Write-Verbose

                    "[{0}] Exception raw content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose 

                    # 'Request Timeout' error
                    if ($_.Exception.Response.StatusCode -eq 408) {
                        $retries++
                        # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                        $waitTime = 2
                        "[{0}] Received 408. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Start-Sleep -Seconds $waitTime
                    }
                    # When 'Internal Server Error' error 
                    elseif ($_.Exception.Response.StatusCode -eq 500) {
                        $retries++
                        # $waitTime = [math]::Pow(2, $retries) * $InitialDelaySeconds
                        $waitTime = 2
                        "[{0}] Received 500. Retrying in $waitTime seconds..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        Start-Sleep -Seconds $waitTime
                    }
                    else {

                        if ($_.ErrorDetails) {
    
                            $errorResponse = $_.ErrorDetails.Message | ConvertFrom-Json
    
                            # Write-Verbose  $errorResponse
    
                            $httpStatusCode = $errorResponse.httpStatusCode
                            $Message = $errorResponse.message
                           
                            if ($errorResponse -and $errorResponse.errorDetails -and $errorResponse.errorDetails.Count -gt 0 -and 
                                $errorResponse.errorDetails[0].issues -and $errorResponse.errorDetails[0].issues.Count -gt 0 -and 
                                $errorResponse.errorDetails[0].issues[0].description) {
                            
                                $Description = $errorResponse.errorDetails[0].issues[0].description
                                $Subject = $errorResponse.errorDetails[0].issues[0].subject
    
                            }                    
    
                            if ($errorResponse -and $errorResponse.errorDetails -and $errorResponse.errorDetails.Count -gt 0 -and 
                                $errorResponse.errorDetails[0].metadata -and $errorResponse.errorDetails[0].metadata.details) {
                            
                                $Description = $errorResponse.errorDetails[0].metadata.details
                            }                       
                                   
                        }
                       
    
                        if ($httpStatusCode -eq 404) {
    
                            Write-Error $errorResponse
                            Throw "Resource not found (404) -  $message"
                            
                        }
                        elseif ($Message -eq "Unauthorized") {
    
                            "[{0}] Error response message: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $message | Write-Verbose
                            Throw "Error - Session has expired or been closed! Connect-HPEGL must be executed again!"
    
    
                        }
                        elseif ($Message) {
    
                            "[{0}] Error response message: '{1}' - HTTP status code: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Message, $httpStatusCode | Write-Verbose
    
                            if ($Description -and $Subject) {
                                
                                "[{0}] Error subject: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Subject | Write-Verbose
                                "[{0}] Error description: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Description | Write-Verbose
                                Throw "Error: '$message' - HTTP status code: '$httpStatusCode' - Subject: '$Subject' - Description: '$Description'"
    
                            }
                            elseif ($Description) {
    
                                "[{0}] Error description: '{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Description | Write-Verbose
                                Throw "Error: '$message' - HTTP status code: '$httpStatusCode' - Description: '$Description'"
    
                            }
                            else {
                                Throw "Error: '$message' - HTTP status code: '$httpStatusCode'"
                                
                            }
    
    
                        }
                        else {
    
                            "[{0}] Error: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose
                            Throw $_
    
    
                        }
                    }
                }    
                finally {
                    $retries++
                }       
            
                if ($InvokeReturnData) {
            
                    try {

                        $InvokeReturnData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop
                        "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose   
    
                        if ($InvokeReturnData -eq "OK") {
    
                            "[{0}] Response detected with an 'OK' response!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return           
                        }   
    
                    
                        # If the 'items' property exists with an empty array, return nothing 
                        if ($InvokeReturnData.count -eq 0 -and $InvokeReturnData.items -is [System.Collections.IEnumerable]) {
    
                            "[{0}] Response detected with an items property but most probably with an empty array" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            "[{0}] Leaving Invoke-HPECOMWebRequest and returning no content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return
                        
                        }
                        # If the 'items' property exists, return the content of items 
                        elseif ($InvokeReturnData.items ) {
    
                            "[{0}] Response detected with an items property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            # Get all paginated pages
                            if ($Method -eq "GET" -and -not $queryParameters["limit"] ) {
                                    
                                $AllCollection = $InvokeReturnData

                                "[{0}] Total of items: '{1}' - Number of items per page: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.total, $InvokeReturnData.items.count | Write-Verbose
                            
                                $Numberofpages = [System.Math]::Ceiling(($InvokeReturnData.total / $InvokeReturnData.items.count))
                            
                                "[{0}] Number of pages found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofpages | Write-Verbose
                            
                                if ($Numberofpages -gt 1) {

                                    for ($i = 1; $i -lt $Numberofpages; $i++) {
                                    
                                        $Offset += $pagination
                            
                                        if ($uriobj.Query -ne "") {
                                            
                                            $Url = $ConnectivityEndPoint + $uri + "&limit=$pagination&offset=$Offset"
                                            
                                        }
                                        else {
                                            
                                            $Url = $ConnectivityEndPoint + $uri + "?limit=$pagination&offset=$Offset"
                                        }
                                    
                                        "[{0}] Request URI for page '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1), $Url | Write-Verbose
                                    
                                        try {
                                            $InvokeReturnData = Invoke-WebRequest -Uri $Url -Method $Method -Headers $headers -Body $Body -ContentType $ContentType

                                            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                                            "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose   

                                            $InvokeReturnMoreData = ConvertFrom-Json $InvokeReturnData -ErrorAction Stop
                                            "[{0}] Response detected as JSON content!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                                            "[{0}] Adding page '{1}' to the result" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($i + 1) | Write-Verbose
                                            $AllCollection.items += $InvokeReturnMoreData.items

                                        }
                                        catch {    
                                            $PSCmdlet.ThrowTerminatingError($_)
                                        
                                        }
                                    }
                                }

                                $InvokeReturnData = $AllCollection

                            }


                            "[{0}] Leaving Invoke-HPECOMWebRequest and returning the items content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return $InvokeReturnData.items
        
                        }
                        else {
    
                            "[{0}] Response detected with no items property!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            "[{0}] Leaving Invoke-HPECOMWebRequest and returning the response content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            return $InvokeReturnData   
                        }
                    }
                    catch {
                        "[{0}] Convert response from json exception due to case sensitive keys! Reformatting data..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                        
                        # When using ConvertFrom-Json in PowerShell, case sensitivity can be an issue because PowerShell has case-insensitive hash table keys by default. 
                        # This means if your JSON object contains keys with different casing (e.g., Description and description), it will cause a conflict.
                        # To handle this issue, use the -AsHashTable switch to convert the JSON string into a hash table where key casing is preserved.
                        $_InvokeReturnData = ConvertFrom-Json $InvokeReturnData -AsHashtable

                        # "[{0}] Convertion to JSON as a hastable to fix same case sensitive properties... Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($_InvokeReturnData | out-string) | Write-Verbose
                        
                        # Output the newly formatted data to [PSCustomObject] (removes Name / Value column names)

                        $customObject = [PSCustomObject]$_InvokeReturnData

                        "[{0}] Convertion to [customObject]: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($customObject | out-string) | Write-Verbose
                        
                        return [PSCustomObject]$customObject

                        
                    }                    
                }  
            }

            throw "Max retries exeeced after receiving Error 503 - Service Unavailable"
                
        }
        #EndRegion
                 
    }         
}


# Thanks to Darren Robinson for this function!
# https://github.com/darrenjrobinson/JWTDetails
# https://blog.darrenjrobinson.com
function Get-HPEGLJWTDetails {
    [cmdletbinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [string]$token
    )
  
    <#
  
  .SYNOPSIS
  Decode a JWT Access Token and convert to a PowerShell Object.
  JWT Access Token updated to include the JWT Signature (sig), JWT Token Expiry (expiryDateTime) and JWT Token time to expiry (timeToExpiry).
  
  .DESCRIPTION
  Decode a JWT Access Token and convert to a PowerShell Object.
  JWT Access Token updated to include the JWT Signature (sig), JWT Token Expiry (expiryDateTime) and JWT Token time to expiry (timeToExpiry).
  
  Thanks to Darren Robinson for this function!
  https://github.com/darrenjrobinson/JWTDetails
  https://blog.darrenjrobinson.com

  .PARAMETER token
  The JWT Access Token to decode and update with expiry time and time to expiry
  
  .INPUTS
  Token from Pipeline 
  
  .OUTPUTS
  PowerShell Object
  
  .EXAMPLE
  Get-HPEGLJWTDetails
  
  .EXAMPLE
  PS> Get-HPEGLJWTDetails($myAccessToken)
  or 
  PS> $myAccessToken | Get-JWTDetails
  tenant_id             : cd988f3c-710c-43eb-9e25-123456789
  internal              : False
  pod                   : uswest2
  org                   : myOrd
  identity_id           : 1c818084624f8babcdefgh9a4
  user_name             : adminDude
  strong_auth_supported : True
  user_id               : 100666
  scope                 : {read, write}
  exp                   : 1564474732
  jti                   : 1282411c-ffff-1111-a9d0-f9314a123c7a
  sig                   : SWPhCswizzleQWdM4K8A8HotX5fP/PT8kBWnaaAf2g6k=
  expiryDateTime        : 30/07/2019 6:18:52 PM
  timeToExpiry          : -00:57:37.4457299
  
  #>
  
    if (!$token.Contains(".") -or !$token.StartsWith("eyJ")) { Write-Error "Invalid token" -ErrorAction Stop }
  
    # Token
    foreach ($i in 0..1) {
        $data = $token.Split('.')[$i].Replace('-', '+').Replace('_', '/')
        switch ($data.Length % 4) {
            0 { break }
            2 { $data += '==' }
            3 { $data += '=' }
        }
    }
  
    $decodedToken = [System.Text.Encoding]::UTF8.GetString([convert]::FromBase64String($data)) | ConvertFrom-Json 
    "[{0}] JWT Token: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $decodedToken | Write-Verbose

  
    # Signature
    foreach ($i in 0..2) {
        $sig = $token.Split('.')[$i].Replace('-', '+').Replace('_', '/')
        switch ($sig.Length % 4) {
            0 { break }
            2 { $sig += '==' }
            3 { $sig += '=' }
        }
    }
    "[{0}] JWT Signature: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $sig | Write-Verbose

    $decodedToken | Add-Member -Type NoteProperty -Name "sig" -Value $sig
  
    # Convert Expiry time to PowerShell DateTime
    $orig = (Get-Date -Year 1970 -Month 1 -Day 1 -hour 0 -Minute 0 -Second 0 -Millisecond 0)
    $timeZone = Get-TimeZone
    $utcTime = $orig.AddSeconds($decodedToken.exp)
    $offset = $timeZone.GetUtcOffset($(Get-Date)).TotalMinutes #Daylight saving needs to be calculated
    $localTime = $utcTime.AddMinutes($offset)     # Return local time,
      
    $decodedToken | Add-Member -Type NoteProperty -Name "expiryDateTime" -Value $localTime
      
    # Time to Expiry
    $timeToExpiry = ($localTime - (get-date))
    $decodedToken | Add-Member -Type NoteProperty -Name "timeToExpiry" -Value $timeToExpiry
  
    return $decodedToken
}

Function Connect-HPEGL { 
<#
.SYNOPSIS
Initiates a connection to the HPE GreenLake platform.

.DESCRIPTION
This cmdlet initiates and manages your connection to the HPE GreenLake platform. Upon successful connection, it creates a persistent session for all subsequent module cmdlet requests through the 
`${Global:HPEGreenLakeSession}` connection tracker variable. Additionally, the cmdlet generates temporary API client credentials for both HPE GreenLake and any Compute Ops Management service instances provisioned in the workspace.

The global variable `$HPEGreenLakeSession` stores session information, API client credentials, API access tokens, and other relevant details for both HPE GreenLake and Compute Ops Management APIs.

To use this cmdlet, you need an HPE Account. If you do not have an HPE Account, you can create one at https://common.cloud.hpe.com.

Note: To learn how to create an HPE account, see https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&page=GUID-497192AA-FDC2-49C5-B572-0D2F58A23745.html

Note: To interact with an HPE GreenLake workspace and a Compute Ops Management instance using this library, you must have at least the 'Observer' role for both 'HPE GreenLake Platform' and 'Compute Ops Management' service managers. 
      This role grants view-only privileges. For modification capabilities, you need either the 'Operator' (view and edit privileges) or the 'Administrator' (view, edit, and delete privileges) role. 
      Alternatively, you can create a custom role that meets your specific access requirements.

Note: The library supports only single-factor authentication. Multi-factor authentication (MFA) and SAML Single Sign-On are not supported. 
      Users who use SAML Single Sign-On with HPE GreenLake cannot use their corporate email credentials when logging in via the 'Connect-HPEGL' cmdlet. 
      The workaround is to create a specific user in HPE GreenLake for this library. To do this, go to the HPE GreenLake GUI, click on 'User Management' in the quick links panel 
      and press the 'Invite Users' button to send an invitation to a non-corporate email address. Once you receive the email, accept the invitation, 
      and you will be directed to the HPE GreenLake interface to set a password. You can then use this email address and password to log in with 'Connect-HPEGL'.

Note: You do not need an existing HPE GreenLake workspace to connect. You can create a new workspace after your first connection using the 'New-HPEGLWorkspace' cmdlet.


.PARAMETER Credential 
Set of security credentials such as a username and password to establish a connection to the HPE GreenLake platform.

.PARAMETER Workspace 
Name of a workspace available in HPE GreenLake (can be retrieved using 'Get-HPEGLWorkspace'). 
        
This parameter must be omitted if you have not yet created any workspace in HPE GreenLake.
When you have more than one workspace, you can define the workspace name you want to connect to.

.INPUTS
None. You cannot pipe objects to this cmdlet.

.OUTPUTS
HPEGreenLakeSession

When a valid connection is established with the HPE GreenLake platform, several properties are added to the 
`${Global:HPEGreenLakeSession}` connection tracker variable. The object returned will contain the following public properties:
        
     ====================================================================================================================
     | Name                      | Type               | Value                                                           |
     --------------------------------------------------------------------------------------------------------------------
     | session                   | WebrequestSession  | Web request session object                                      | 
     --------------------------------------------------------------------------------------------------------------------
     | oauth2AccessToken         | String             | OAuth2 access token string returned from API                    | 
     --------------------------------------------------------------------------------------------------------------------
     | oauth2IdToken             | String             | OAuth2 ID Token string returned from API                        |
     --------------------------------------------------------------------------------------------------------------------
     | oauth2RefreshToken        | String             | OAuth2 refresh token string returned from API                   |
     --------------------------------------------------------------------------------------------------------------------
     | userName                  | String             | Name of the user used for authentication                        |
     --------------------------------------------------------------------------------------------------------------------
     | workspaceId               | String             | ID of the workspace                                             |
     --------------------------------------------------------------------------------------------------------------------
     | workspace                 | String             | Name of the workspace                                           |
     --------------------------------------------------------------------------------------------------------------------
     | oauth2TokenCreation       | Datetime           | OAuth2 token creation datetime value                            |
     --------------------------------------------------------------------------------------------------------------------
     | oauth2TokenCreationEpoch  | String             | Unix time since creation of the OAuth2 token                    |    
     --------------------------------------------------------------------------------------------------------------------
     | userSessionIdleTimeout    | String             | User session timeout in minutes                                 |    
     --------------------------------------------------------------------------------------------------------------------
     | apiCredentials            | ArrayList          | Collection of API client credentials created during the session |
     --------------------------------------------------------------------------------------------------------------------
     | glpApiAccessToken         | String             | Collection of GreenLake API access token for the bearer AuthN   |    
     --------------------------------------------------------------------------------------------------------------------
     | comApiAccessToken         | ArrayList          | Collection of COM APIs access tokens for the bearer AuthN       |    
     --------------------------------------------------------------------------------------------------------------------
     | ccsSid                    | String             | Session ID of the CCS API AuthN                                 |    
     --------------------------------------------------------------------------------------------------------------------
     | onepassSid                | String             | Session ID of the HPE Onepass API AuthN                         |    
     ====================================================================================================================

API client credentials are stored in `${Global:HPEGreenLakeSession.apiCredentials}` and contains the following properties:
     
     ====================================================================================================================
     | Name                       | Type               | Value                                                           |
     --------------------------------------------------------------------------------------------------------------------
     | name                       | String             | Name of the API Client credential                               | 
     --------------------------------------------------------------------------------------------------------------------
     | workspace_name             | String             | Name of the workspace                                           | 
     --------------------------------------------------------------------------------------------------------------------
     | workspace_id               | String             | ID of the workspace                                             |
     --------------------------------------------------------------------------------------------------------------------
     | application_name           | String             | Name of the service                                             |
     --------------------------------------------------------------------------------------------------------------------
     | region                     | String             | Name of the region where the service is provisioned             |
     --------------------------------------------------------------------------------------------------------------------
     | application_instance_id    | String             | ID of the service instaance                                     |
     --------------------------------------------------------------------------------------------------------------------
     | secure_client_secret       | SecureString       | Encrypted client secret of the API client credential            |
     --------------------------------------------------------------------------------------------------------------------
     | client_id                  | String             | Client ID of the API client credential                          |
     --------------------------------------------------------------------------------------------------------------------
     | connectivity_endpoint      | String             | Connectivity endpoint of the API                                |
     ====================================================================================================================

API access tokens are stored in the following global variables:
 - ${Global:HPEGreenLakeSession.comApiAccessToken} 
 - ${Global:HPEGreenLakeSession.glpApiAccessToken}

 The tokens contain the following properties:
     
     ====================================================================================================================
     | Name                       | Type               | Value                                                           |
     --------------------------------------------------------------------------------------------------------------------
     | name                       | String             | Name of the API Client credential                               | 
     --------------------------------------------------------------------------------------------------------------------
     | access_token               | String             | Access token of the API client credential                       |
     --------------------------------------------------------------------------------------------------------------------
     | expires_in                 | String             | Time in seconds until the token expires                         |
     --------------------------------------------------------------------------------------------------------------------
     | creation_time              | Datetime           | Date and time of when the token was created                     |
     ====================================================================================================================

.EXAMPLE
Connect-HPEGL  

Connect to HPE GreenLake when you have not yet created any workspace. The user will be prompted for username and password.

In this example, no parameters are passed to the `Connect-HPEGL` cmdlet, which will prompt the user for their HPE GreenLake 
username and password. This is useful when connecting to HPE GreenLake when no workspace exists yet.

.EXAMPLE
$Username = "Sean@gmail.com"
$Secpasswd = read-host "Please enter your HPE GreenLake password" -AsSecureString
$Credentials = New-Object System.Management.Automation.PSCredential ($Username, $Secpasswd)
Connect-HPEGL -Credential $Credentials 

Connect the user Sean@gmail.com to HPE GreenLake using a PSCredential object. 

In this example, the username and password are collected first, and then a PSCredential object is created. The credential 
object is subsequently passed to the `Connect-HPEGL` cmdlet to establish the connection.

.EXAMPLE
Connect-HPEGL -Credential $Credentials -Workspace "My_workspace_name" 

Connect the user Sean@gmail.com to an existing workspace named "My_workspace_name" in HPE GreenLake using a PSCredential object. 
Temporary HPE GreenLake and COM API client credentials are generated in the newly connected 'My_workspace_name' workspace.
'$HPEGreenLakesession' is updated with the new API credentials and workspace details.

Here, the previously created PSCredential object is used again, but this time with an additional `-Workspace` parameter 
to specify which workspace in HPE GreenLake to connect to.

.EXAMPLE
$GLP_Username = "lio@domain.com"
$GLP_EncryptedPassword = "...01000000d08c9ddf0115d1118c7a00c04fc297eb01000000ea1f94d2f2dc2b40af7a0adaeeae84b1f349432b32a730af3b80567e2378c570b3a111d627d70ac9eb6f281..."
$GLP_SecurePassword = ConvertTo-SecureString $GLP_EncryptedPassword
$credentials = New-Object System.Management.Automation.PSCredential ($GLP_Username, $GLP_SecurePassword)

Connect-HPEGL -Credential $credentials -Workspace "HPE Workspace" 

Connect the user lio@domain.com to an existing workspace named "HPE Workspace" using an encrypted password.

In this example, the secure password string is first converted to a SecureString, and then a PSCredential object is created 
using an encrypted password and username. This credential object is then used to connect to a specific workspace named "HPE Workspace".

Using an encrypted password like $GLP_EncryptedPassword in a script enhances security by preventing unauthorized access to plaintext credentials, 
and follows best practices for secure coding. It also reduces the risk of human error and accidental exposure during code sharing or review processes.

To generate an encrypted password, you can use:
ConvertTo-SecureString -String "<Your_HPE_GreenLake_Password>" -AsPlainText -Force |  ConvertFrom-SecureString 

.LINK
If you do not have an HPE Account, you can create one at https://common.cloud.hpe.com.
To learn how to create an HPE account, see https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&page=GUID-497192AA-FDC2-49C5-B572-0D2F58A23745.html

#>


    [CmdletBinding(DefaultParameterSetName = "PSCredential" )]
    Param( 
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [Alias('PSCredential')]
        [PSCredential]$Credential,

        [Parameter(Mandatory = $False)]        
        [ValidateNotNullOrEmpty()]
        [String]$Workspace
        
    )

    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command
  
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        # Changing default TLS to 1.2 from 1.0
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        
        # Test connectivity with HPE GreenLake servers
        try {
            "About to test connection to HPE GreenLake resources" | Write-Verbose

            Test-HPEGLConnection
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
 
        $Username = $Credential.UserName
        $decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password))


        # Get Compute GMT time difference in hours
        $GMTTimeDifferenceInHour = Get-GMTTimeDifferenceInHours
        # Set a global variable
        $Global:HPEGLGMTTimeDifferenceInHour = $GMTTimeDifferenceInHour 

        
    }

    Process { 

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Define the total number of operations/steps
        $totalSteps = 8

        # Initialize a counter for completed steps
        $completedSteps = 0

        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id
            )

            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Connecting to HPE GreenLake, please wait..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -Id $Id
        }

       
        #-----------------------------------------------------------Authentication to HPE GreenLake Common Cloud Services-----------------------------------------------------------------------------

        #Region 1-Get HPE GreenLake Common Cloud Services Authorization endpoint  

        $url = $HPEGLauthorityURL.OriginalString + $OpenidConfiguration

        "[{0}] ------------------------------------- STEP 1 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 1 / 8" -Id 0

        "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose

        try {
            $response = Invoke-RestMethod $url -Method 'GET' 

            $authEndpoint = $response.authorization_endpoint 
            $Global:HPEGLtokenEndpoint = $response.token_endpoint

        }
        catch {
            Write-Progress -Id 0 -Completed
            $PSCmdlet.ThrowTerminatingError($PSitem)

        }

        $completedSteps++
        #EndRegion

        #Region 2-Generate PKCE code verifier and code challenge
        
        "[{0}] ------------------------------------- STEP 2 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 8" -Id 0
        "About to generate PKCE verifier and challenge codes" | Write-Verbose

        $pkceTemplate = [pscustomobject][ordered]@{  
            code_verifier  = $null  
            code_challenge = $null   
        }  

        $codeVerifier = -join (((48..57) * 4) + ((65..90) * 4) + ((97..122) * 4) | Get-Random -Count 128 | ForEach-Object { [char]$_ })

        $hashAlgo = [System.Security.Cryptography.HashAlgorithm]::Create('sha256')
        $hash = $hashAlgo.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($codeVerifier))
        $b64Hash = [System.Convert]::ToBase64String($hash)
        $code_challenge = $b64Hash.Substring(0, 43)
      
        $code_challenge = $code_challenge.Replace("/", "_")
        $code_challenge = $code_challenge.Replace("+", "-")
        $code_challenge = $code_challenge.Replace("=", "")

        $pkceChallenges = $pkceTemplate.PsObject.Copy()
        $pkceChallenges.code_challenge = $code_challenge
        $pkceChallenges.code_verifier = $codeVerifier 

        $codeChallenge = $pkceChallenges.code_challenge
        $codeVerifier = $pkceChallenges.code_verifier

        "[{0}] Code verifier: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $codeVerifier | Write-Verbose
        "[{0}] Code challenge: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $codeChallenge | write-Verbose

            
        $completedSteps++

        #EndRegion

        #Region 3-Get statetoken using code challenge to https://sso.common.cloud.hpe.com/as/authorization.oauth2  
         
        $headers = @{} 
        $headers["Content-Type"] = "application/json"

        $url = "{0}?client_id={1}&redirect_uri={2}&response_type=code&scope=openid%20profile%20email&code_challenge={3}&code_challenge_method=S256" -f $authEndpoint, $HPEGLclient_id, $ccsRedirecturi, $codeChallenge
        
        "[{0}] ------------------------------------- STEP 3 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 3 / 8" -Id 0
        "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
        
        do {  
    
            try {
                $response = Invoke-webrequest $url -Method 'GET' -Headers $headers -SessionVariable 'SsoSession' 
           
            }
            catch {
                Write-Progress -Id 0 -Completed
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
  
            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
            # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
         
            # Capturing state token
            $stateToken = ($response.tostring() -split "[`r`n]" | select-string -Pattern '(?:"stateToken":")(.*?)(?:")').Matches | ForEach-Object { $_.groups[1].Value }
            Start-Sleep -Milliseconds 500

        } until ( -not $stateToken.Contains("\") )

        "[{0}] State token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $stateToken | Write-Verbose

        $completedSteps++

        #EndRegion
 
        #Region 4-Authenticate and consent to https://auth.hpe.com/api/v1/authn

        $payload = @{}
        $payload["options"] = @{multiOptionalFactorEnroll = $True; warnBeforePasswordExpired = $True }
        $payload["password"] = $decryptPassword
        $payload["stateToken"] = $stateToken
        $payload["username"] = $UserName
        $payload = $payload | ConvertTo-Json

        $url = $HPEGLoktaURL + $AuthnUri 

        "[{0}] ------------------------------------- STEP 4 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 4 / 8" -Id 0
        "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $payload | Write-Verbose


        try {
            $responseccsauthclient = Invoke-webrequest $url -Method 'POST' -Body $payload -ContentType 'application/json' -ErrorAction stop -SessionVariable auth_session
            
            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
            "[{0}] Raw response for `$responseccsauthclient: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseccsauthclient | Write-verbose
           
        }
        catch {
            Write-Progress -Id 0 -Completed
            throw "Connection error! Invalid username or password!"
             
        }

        if (($responseccsauthclient.Content | Convertfrom-Json).status -ne "SUCCESS") {

            Write-Progress -Id 0 -Completed
            $_status = ($responseccsauthclient.Content | Convertfrom-Json).Status
            throw "Connection error due to $_status"
        }

        # Capture authentication issuer data

        $Global:Oath2IssuerId = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.authentication.issuer.id
        "[{0}] Oath2 Issuer Id: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Oath2IssuerId | write-Verbose
        $Global:Oath2IssuerUri = ($responseccsauthclient.Content | Convertfrom-Json)._embedded.authentication.issuer.uri
        "[{0}] Oath2 Issuer Uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Oath2IssuerUri | write-Verbose
      
        # Capture href redirection

        $href = ($responseccsauthclient.Content | Convertfrom-Json)._links.next.href
        # href is usually like: "https://auth.hpe.com/login/token/redirect?stateToken=00kJygvJiy92zrYIXhROhpXMiF2NsC6zAT3SjF5XhF"

        $completedSteps++

        #EndRegion

        #Region 5-Acquire authorization code and HPE Onepass SID (session ID) to https://auth.hpe.com/login/token/redirect?stateToken=00Boz5zcMdQPC6yxKr8mT2WVR0HZuaqMaoz3vxL19e

        "[{0}] ------------------------------------- STEP 5 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 5 / 8" -Id 0
        "[{0}] About to execute HEAD request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $href | Write-Verbose

        try {
            
            "[{0}] Acquiring authorization code in response1..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $response1 = Invoke-WebRequest $href -Method Head -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected1 
         
            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response1.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
            "[{0}] Raw response for `$response1: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response1 | Write-verbose
         

        }
        # Not using catch as entering the catch block when encountering a 302 (false error as we have a redirection)
        catch {
            #     Write-Progress -Id 0 -Completed
            #     $PSCmdlet.ThrowTerminatingError($_)
        }
    
        # Capture HPE Onepass SID from response1 headers Set-Cookies

        If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {
            if ($response1.StatusCode -eq 302) {

                # Retrieve the 'Location' header value
                $redirecturl1 = $response1.Headers.Location
                
                # Retrieve the SID from 'Set-Cookie' header values
                $setCookie = $response1.Headers['Set-Cookie'] | Where-Object { $_ -match '^SID' }
                "[{0}] Set-Cookie content from response headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($setCookie | Out-String) | Write-Verbose

                $onepassSid = ($setCookie -split ';')[0].Split('=')[1]
                
            }
        }
        else {
            if ($redirected1.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                
                # Retrieve the 'Location' header value
                $redirecturl1 = $redirected1.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri
                
                # Retrieve the SID from 'Set-Cookie' header values
                $cookies = $redirected1.ErrorRecord.Exception.Response.Headers
                
                "[{0}] Cookies from response headers: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $cookies | Write-Verbose

                foreach ($cookie in $cookies) {
                                        
                    if ($cookie.value -match "sid=" ) {
                        
                        $onepassSid = ($cookie.value -split ';')[0].Split('=')[1]
                        
                    }                    
                }
                
            }
        }
        
        "[{0}] HPE Onepass SID capture from response headers Set-Cookies: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $onepassSid | Write-Verbose
        
        # $redirecturl1 = https://sso.common.cloud.hpe.com/sp/eyJpc3MiOiJodHRwczpcL1wvYXV0aC5ocGUuY29tXC9vYXV0aDJcL2F1czQzcGYwZzhtdmg0bnR2MzU3In0/cb.openid?code=saapfsSV5QY7fAOte3pUycmuCQjBw_wMOOvAxmOdnnQ&state=UJsI5pLgrFl4EGhK0sRrfgIRNrUEqi

        "[{0}] ------------------------------------- First redirection -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        "[{0}] About to execute Get request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl1 | Write-Verbose

        try {  
            "[{0}] Acquiring authorization code in response2..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $response2 = Invoke-WebRequest $redirecturl1 -Method Get -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected2 -WebSession $SsoSession 

            # "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response2.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
            # "[{0}] Raw response fpr `$response2: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response2 | Write-verbose

        }
        # Not using catch as entering the catch block when encountering a 302 (false error as we have a redirection)
        catch {
            #     Write-Progress -Id 0 -Completed
            #     $PSCmdlet.ThrowTerminatingError($_)
        }
   

        If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {
            if ($response2.StatusCode -eq 302) {
                $redirecturl2 = $response2.Headers.Location
            }
        }
        else {
            if ($redirected2.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                $redirecturl2 = $redirected2.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri

            }
        }


        # $redirecturl2 = "https://sso.common.cloud.hpe.com/as/LLzJ7/resume/as/authorization.ping"

        "[{0}] ------------------------------------- Second redirection -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $redirecturl2 | Write-Verbose

        $tries = 0
        $maxTries = 10
        $redirecturl3 = $False

        do {
            
            # Increment the counter
            $tries++
  
            try {
                "[{0}] Acquiring authorization code response3..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                $response3 = Invoke-WebRequest $redirecturl2 -Method Get -MaximumRedirection 0 -ErrorAction SilentlyContinue -ErrorVariable redirected3 -WebSession $SsoSession
            
                # "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response3.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                # "[{0}] Raw response for `$response3: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response3 | Write-verbose
            

            }
            # Not using catch as entering the catch block when encountering a 302 (false error as we have a redirection)
            catch {
                # Write-Progress -Id 0 -Completed
                # $PSCmdlet.ThrowTerminatingError($_)
            }
   
            If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {
                if ($response3.StatusCode -eq 302) {
                    $redirecturl3 = $response3.Headers.Location

                }
            }
            else {
                if ($redirected3.ErrorRecord.Exception.Response.StatusCode.value__ -eq 302) {
                    $redirecturl3 = $redirected3.ErrorRecord.Exception.Response.Headers.Location.AbsoluteUri

                }
            }

            Start-Sleep -Seconds 1
          
        } until ($redirecturl3 -or $tries -ge $maxTries)

        if (-not  $redirecturl3) {
            Write-Progress -Id 0 -Completed
            Throw "Check your HPE GreenLake username and password!"
        }
        
        # Code is found in $redirecturl3
        # $redirecturl3 =  https://common.cloud.hpe.com/authentication/callback?code=QgtvNW7vwcIqqXL5H_SOn3EFRqbxPTjqP8oGmXJ_

        $code = ($redirecturl3 | select-string -Pattern '(?<=code=)(.*)').Matches | ForEach-Object Value 
        
        "[{0}] Authorization Code: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $code | Write-Verbose

        $completedSteps++       

        #EndRegion

        #Region 6-Post Authorization code + code verifier to  https://sso.common.cloud.hpe.com/as/token.oauth2

        $tokenParams = @{
            'client_id'     = $HPEGLclient_id
            'redirect_uri'  = $ccsRedirecturi
            'code'          = $code
            'code_verifier' = $codeVerifier
            'grant_type'    = 'authorization_code'
        }


        "[{0}] ------------------------------------- STEP 6 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 6 / 8" -Id 0    
        "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
        "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($tokenParams | convertto-json) | Write-Verbose


        try {

            "[{0}] Posting authorization code + code verifier..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $response4 = Invoke-WebRequest -Method Post -Uri $HPEGLtokenEndpoint -Body $tokenParams -ContentType 'application/x-www-form-urlencoded' 
        
            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response4.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
            "[{0}] Raw response for `$response4: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response4 | Write-verbose
        
        }
        catch {
      
            "[{0}] Create CCS session payload content: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($tokenParams | Out-String) | Write-Verbose

            if ($_.ErrorDetails.Message) {
                Write-Warning $_.ErrorDetails
            }

            Write-Progress -Id 0 -Completed
            $PSCmdlet.ThrowTerminatingError($_).Exception.Message
   
        }


        # Get HPE GreenLake Common Cloud Services Access token, ID token and Refresh token
        $Oauth2AccessToken = ($response4.content | ConvertFrom-Json).access_token
        "[{0}] OAuth2 Access Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oauth2AccessToken | Write-Verbose
        
        $Oauth2IdToken = ($response4.content | ConvertFrom-Json).id_token
        "[{0}] OAuth2 ID Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oauth2IdToken | Write-Verbose
        
        $Oauth2RefreshToken = ($response4.content | ConvertFrom-Json).refresh_token
        "[{0}] OAuth2 Refresh Token: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $oauth2RefreshToken | Write-Verbose

        $completedSteps++
        #EndRegion

        #Region 7-Set HPEGreenLakeSession global variable  

        "[{0}] ------------------------------------- STEP 7 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 7 / 8" -Id 0 
        "About to Set HPEGreenLakeSession global variable" | Write-Verbose
     
        $Global:HPEGreenLakeSession = [System.Collections.ArrayList]::new()
        
        $SessionInformation = [PSCustomObject]@{
            session                  = $Null
            oauth2AccessToken        = $Oauth2AccessToken
            oauth2IdToken            = $Oauth2IdToken
            oauth2RefreshToken       = $Oauth2RefreshToken
            username                 = $UserName
            workspaceId              = $Null
            workspace                = $Null
            oauth2TokenCreation      = [datetime]$(Get-Date)
            oauth2TokenCreationEpoch = $((New-TimeSpan -Start (Get-Date "01/01/1970") -End (Get-Date)).TotalSeconds) 
            userSessionIdleTimeout   = $Null
            apiCredentials           = [System.Collections.ArrayList]::new()
            glpApiAccessToken        = [System.Collections.ArrayList]::new()
            comApiAccessToken        = [System.Collections.ArrayList]::new()
            ccsSid                   = $Null
            onepassSid               = $onepassSid
        }
        
        [void]$global:HPEGreenLakeSession.add($SessionInformation)
        
        $Global:HPEGreenLakeSession = Invoke-RepackageObjectWithType -RawObject $HPEGreenLakeSession -ObjectName 'Connection'
        # $global:HPEGreenLakeSession.apiCredentials = [System.Collections.ArrayList]::new()
        
        "`$HPEGreenLakeSession global variable set!" | Write-Verbose

        $completedSteps++        
                
        #EndRegion

        #Region 8-Create session with workspace (acquire CCS SID) to https://aquila-user-api.common.cloud.hpe.com/authn/v1/session

        
        
        "[{0}] ------------------------------------- STEP 8 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 8 / 8"  -Id 0    
        
        try {
            
            if ($Workspace) {
                "[{0}] Create session with workspace '{1}' using Connect-HPEGLWorkspace" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Workspace | Write-Verbose
                $CCSSession = Connect-HPEGLWorkspace -Name $Workspace -Oauth2IdToken  $oauth2IdToken -Oauth2AccessToken $oauth2AccessToken
            }
            else {

                "[{0}] Create session without workspace using Connect-HPEGLWorkspace" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                $CCSSession = Connect-HPEGLWorkspace -Oauth2IdToken  $oauth2IdToken -Oauth2AccessToken $oauth2AccessToken
            }

                                   
        }
        catch {
            Write-Progress -Id 0 -Completed
            Write-Progress -Id 1 -Completed # progress bar from 'Connect-HPEGLWorkspace' 
            $PSCmdlet.ThrowTerminatingError($_)
        }
                

        $completedSteps++

        #EndRegion
        
        "[{0}] Connection to HPE GreenLake successful!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
        # Clear the progress bar upon completion
        Write-Progress -Id 0 -Completed

        return $HPEGreenLakeSession 

    }
    
}


Function Disconnect-HPEGL { 
    <#
.SYNOPSIS
Log off from the HPE GreenLake platform.

.DESCRIPTION
This cmdlet terminates the current HPE GreenLake session by logging out the user and purging all variables and temporary API credentials established through 'Connect-HPEGL'.

.EXAMPLE
Disconnect-HPEGL

Terminates the current HPE GreenLake session. 

.INPUTS
None. You cannot pipe objects to this cmdlet.

.OUTPUTS
System.String
    Returns "<email address> session disconnected!"

#>

    [CmdletBinding()]
    Param() 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
        # Define the total number of operations/steps
        $totalSteps = 3

        # Initialize a counter for completed steps
        $completedSteps = 0

        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id
            )

            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Disconnecting from HPE GreenLake, please wait..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -Id $Id
        }
      
        if (-not $HPEGreenLakeSession) {
            Throw "Error - No HPE GreenLake session found!"
    
        }
        else {       

            #Region 1 - Remove library API client credentials    

            
            "[{0}] ------------------------------------- STEP 1 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 1 / 3 - Removing all library API Client credentials..." -Id 3
            "[{0}] About to remove all temporary API Client credentials using the template '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $APIClientCredentialTemplateName | Write-Verbose
            
            if ($HPEGreenLakeSession.apiCredentials) {


                try {

                    $APIcredentials = Get-HPEGLAPICredential | Where-Object name -match $APIClientCredentialTemplateName 
            
                    if ($APIcredentials) {
        
                        $APIcredentials | Remove-HPEGLAPICredential | Out-Null
        
                    }
                    else {
                        "[{0}] No library API Client credential found using the template '{1}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $APIClientCredentialTemplateName | Write-Verbose
                    }

                }
                catch {
                    Write-Progress -Id 3 -Completed 
                    Write-Warning "The session has already been disconnected due to expiration!"
                    return
                    # $PSCmdlet.ThrowTerminatingError($_)
                }    
            
            }

            $completedSteps++

            #endregion


            #Region 2 - Remove HPE GreenLake workspace session   
            "[{0}] ------------------------------------- STEP 2 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 3 - Removing HPE GreenLake workspace session..." -Id 3

            "[{0}] About to remove HPE GreenLake workspace session" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            
            $url = $AuthnEndSessionUri
            
            "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
       
            try {

                $InvokeReturnData = Invoke-WebRequest -Method GET -Uri $url -WebSession $HPEGreenLakeSession.session -ContentType 'application/json' 
            
                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose
            
                "[{0}] Workspace '{1}' session removed successfully!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

            }
            catch {

                $Response = $_.Exception.Response | convertto-json -depth 10 

                $ExceptionCode = $_.Exception.Response.StatusCode.value__
                $ExceptionText = $_.Exception.Response.StatusDescription + $_.Exception.Response.ReasonPhrase 
            
                "[{0}] Request payload: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Payload | Out-String) | Write-Verbose

                "[{0}] Request failed with the following Status:`r`n`tHTTPS Return Code = '{1}' `r`n`tHTTPS Return Code Description = '{2}' `n" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ExceptionCode, $ExceptionText | write-verbose

                # "[{0}] Raw response  = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-verbose


                Write-Progress -Id 3 -Completed
                $PSCmdlet.ThrowTerminatingError($_)
           
            }

            $completedSteps++

            #endregion


            #Region 3 - Revoke CCS OAuth2 token
            "[{0}] ------------------------------------- STEP 3 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 3 - Revoking OAuth2 tokens..." -Id 3

            "[{0}] About to revoke CCS OAuth2 token" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $url = $HPEGLauthorityURL.OriginalString + $OpenidConfiguration
            "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
        
            
            try {
                $response = Invoke-RestMethod $url -Method 'GET' 
           
            }
            catch {                
                Write-Progress -Id 3 -Completed
                $PSCmdlet.ThrowTerminatingError($_)
            }

            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $response.StatusDescription | Write-verbose
            "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
            
            $payload = @{
                'client_id'       = 'aquila-user-auth'
                'token'           = $HPEGreenLakeSession.oauth2AccessToken
                'token_type_hint' = 'access_token'
                
            } 
                
            $RevocationEndpoint = $response.revocation_endpoint

            "[{0}] About to execute POST request to revoke CCS OAuth2 token to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RevocationEndpoint | Write-Verbose
            
            try {
                "[{0}] Request payload: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | Out-String) | Write-Verbose

                $InvokeReturnData = Invoke-webrequest -Uri $RevocationEndpoint -Method 'POST' -Body $payload -ContentType "application/x-www-form-urlencoded" -ErrorAction stop -WebSession $HPEGreenLakeSession.session
                
                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                # "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose
            
                "[{0}] CCS OAuth2 token '{1}' revoked!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.username | Write-Verbose

                $_username = $HPEGreenLakeSession.username
                 
                # Remove $HPEGreenLakeSession global variable
                Remove-Variable HPEGreenLakeSession -Scope Global
                "[{0}] Global variable `$HPEGreenLakeSession has been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
                # Clear all HPEGL global variables
                Get-Variable -Scope global | Where-Object name -match HPEGL | Remove-Variable -Force -Scope Global
                "[{0}] All global variable starting with HPEGL have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Clear all HPECOM global variables
                Get-Variable -Scope global | Where-Object name -match HPECOM | Remove-Variable -Force -Scope Global
                "[{0}] All global variable starting with HPECOM have been removed" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                
            }
            
            catch {

                "[{0}] Exception thrown!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Get Exception type
                $exception = $_.Exception

                do {
                    "[{0}] Exception Type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $exception.GetType().Name | Write-Verbose
                    $exception = $exception.InnerException
                } while ($exception)

                # Get exception stream
                $result = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($result)
                $reader.BaseStream.Position = 0
                $reader.DiscardBufferedData()
                $responseBody = $reader.ReadToEnd() 


                "[{0}] Raw response `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseBody | Write-Verbose
            
                $response = $responseBody | ConvertFrom-Json
                    
                if ($Body) {
                    "[{0}] Request payload: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Body | Out-String) | Write-Verbose
                }
                if ($Headers) {
                    "[{0}] Request headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | Out-String) | Write-Verbose
                }

                Write-Progress -Id 3 -Completed
                Throw "Error -  $responseBody"          
            }
            
            $completedSteps++
            
            #endregion
            
            # Clear the progress bar upon completion
            Write-Progress -Id 3 -Completed
            
            return ("{0} session disconnected!" -f $_username )

        }
    }
    
}


Function Connect-HPEGLWorkspace { 

<#
.SYNOPSIS
Switch between HPE GreenLake workspaces.

.DESCRIPTION
When you have multiple HPE GreenLake workspaces, you can use this cmdlet to switch between them and manage them independently.

During the switching/connection process, the cmdlet removes the temporary HPE GreenLake and COM API client credentials from the departing workspace and generates the necessary new ones in the newly connected workspace. 
These API credentials are required for this library to interact with the various service APIs. The credentials are updated in `$HPEGreenLakesession` and securely stored using encryption.
API client credentials for COM are created for each provisioned COM instance found in the newly connected workspace.

Note: This cmdlet is also used in the background by 'Connect-HPEGL' to initiate a session with an HPE GreenLake workspace and automatically generate the HPE GreenLake and COM API client credentials.

.PARAMETER Name 
Name of your workspace in HPE GreenLake. This is an optional parameter that can be used when you have more than one HPE GreenLake workspaces.
By default, the cmdlet uses the first available workspace linked to your email address.

.PARAMETER Oauth2IdToken 
OAuth2 access token value.   

.PARAMETER Oauth2AccessToken 
OAuth2 access token value.   

.PARAMETER Force
Parameter to force reconnection to the current workspace and generate new temporary API credentials. 
This option is commonly utilized by Invoke-HPEGLRefreshtoken during the OAuth2 refresh token process.

.EXAMPLE
Connect-HPEGLWorkspace -Name 'DreamCompany' 

Switch from the current workspace to the 'DreamCompany' HPE GreenLake workspace.
Temporary HPE GreenLake and COM API client credentials are deleted from the departing workspace and regenerated in the newly connected 'DreamCompany' workspace.
'$HPEGreenLakesession' is updated with the new API credentials and workspace details.

.INPUTS
None. You cannot pipe objects to this Cmdlet.

.OUTPUTS     
System.Collections.ArrayList
    ${Global:HPEGreenLakeSession}

When a new valid connection is established with a workspace, ${Global:HPEGreenLakeSession} connection tracker variable is
updated with the new customer id, workspace name properties and API credentials and is returned by the cmdlet.

#>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param(

        [Parameter (ParameterSetName = 'Name')]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (ParameterSetName = 'Force')]
        [ValidateNotNullOrEmpty()]
        [String]$Oauth2IdToken = $HPEGreenLakeSession.oauth2IdToken,  

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (ParameterSetName = 'Force')]
        [ValidateNotNullOrEmpty()]
        [String]$Oauth2AccessToken = $HPEGreenLakeSession.oauth2AccessToken,
        
        [Parameter (ParameterSetName = 'Force')]
        [ValidateNotNullOrEmpty()]
        [Switch]$Force
        
    ) 
        
    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
      
        # SET PROGRESS BAR
        # Initialize a counter for completed steps
        $completedSteps = 0
        
        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id

            )
        
            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Connecting to workspace..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -Id $Id 
        }

        # Access_token expiration date
        $AccessTokenExpirationDate = $HPEGreenLakeSession.oauth2TokenCreation.AddMinutes(120)
    
        # Number of minutes before expiration of the Access_token expiration date
        $BeforeExpirationinMinutes = [math]::Round(((New-TimeSpan -Start (Get-Date) -End ($AccessTokenExpirationDate)).TotalHours ) * 60)
    
        if ( $BeforeExpirationinMinutes -gt 0) { 
            $Expiration = $BeforeExpirationinMinutes 
            "[{0}] Session expiration in '{1}' minutes" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Expiration | Write-Verbose
        }
        else { 
            $Expiration = 0 
        }

        
        if (-not $HPEGreenLakeSession) {

            "[{0}] No session found! 'Connect-HPEGL' must be executed first!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            Write-Warning "No session found! 'Connect-HPEGL' must be executed first!" 
            Return

        }  
        # Return if session expired
        elseif ($Expiration -eq 0) {

            "[{0}] The session has expired! 'Connect-HPEGL' must be executed again!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            Write-Warning "The session has expired! 'Connect-HPEGL' must be executed again!" 
            Return 

        }    
        # If already connected to the workspace $Name
        elseif ($HPEGreenLakeSession.workspace -eq $Name -and -not $force) {
            Return "You are already connected to this workspace!" 
        }

      

        #Region - If not connected to GLP, create a session (condition is met when 'Connect-HPEGL' is executed)
        # Steps:
        #  1- Create CCS session and capture ccs SID (session ID) cookie value 
        #  2- Load workspace
        elseif (-not $HPEGreenLakeSession.workspaceId -and -not $force) {

            #Region 1 - Create CCS session and capture ccs SID (session ID) cookie value 
            # ccs-session cookie value is used for CCS API authentication 
            
            if (-Not $Name) {
                "[{0}] ------------------------------------- STEP 1 - Create CCS session -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step  1 / 3 - Creating session" -Id 1
    
            }
            else {
                "[{0}] ------------------------------------- STEP 1 - Create CCS session -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step 1 / 7 - Creating session" -Id 1
            }

            # Set a variable to update/complete the Connect-HPEGL progress bar
            $Connect_HPEGL_ProgressBar = $True


            $url = $AuthnSessionUri

            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Content-Type"] = "application/json"
            $headers["Authorization"] = "Bearer $Oauth2AccessToken"

            $tokenParams = @{
                'id_token' = $Oauth2IdToken
            } | ConvertTo-Json

            
            try {
                # Create CCS workspace session
                "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $tokenParams | Write-Verbose

                $response = Invoke-RestMethod -Method Post -Uri $url -Headers $headers -Body $tokenParams -SessionVariable CCSSession

                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $response.StatusDescription | Write-verbose
                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($response | convertto-json -Depth 10 ) | Write-verbose

                # Set global variables for all workspaces if any
                if ($response.accounts) {
                    $Global:HPEGLworkspaces = $response.accounts
                }
                
                $cookies = $CCSSession.Cookies.GetCookies($url)

                "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                foreach ($cookie in $cookies) { 
                    Write-Verbose "$($cookie.name) = $($cookie.value)"
                    # Extract the 'ccs-session' cookie value
                    if ($cookie.name -match 'ccs-session') {
                        $ccsSessionValue = $cookie.Value 
                    }
                }

                "[{0}] HPE GreenLake CCS first-session captured from response headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSessionValue | Write-Verbose

                # Set HPEGreenLakeSession.session global variable
                $Global:HPEGreenLakeSession.session = $CCSSession
                $Global:HPEGreenLakeSession.ccsSid = $ccsSessionValue
        
            }
            catch {
                Write-Progress -Id 0 -Completed
                Write-Progress -Id 1 -Completed
                $PSCmdlet.ThrowTerminatingError($_)               
            }

            # Capture workspace ID and name
            if ($Name) {

                $MyWorkspaceName = $HPEGLworkspaces | Where-Object company_name -eq $Name
                $Global:HPEGreenLakeSession.workspaceId = $MyWorkspaceName.platform_customer_id
                $Global:HPEGreenLakeSession.workspace = $Name

            }
            else {
                $Global:HPEGreenLakeSession.workspace = "<Need to be created>"

            }

            
            "[{0}] HPE GreenLake Workspace ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspaceId | Write-Verbose
            "[{0}] HPE GreenLake Workspace: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

            if ($Name -and $Null -eq $HPEGreenLakeSession.workspaceId) {

                Write-Progress -Id 1 -Completed
                Write-Progress -Id 0 -Completed

                $ErrorMsg = "Workspace name '{0}' cannot be found in HPE GreenLake with '{1}'" -f $HPEGreenLakeSession.workspace, $HPEGreenLakeSession.username
                Throw $ErrorMsg
            }

            $completedSteps++
            #EndRegion

            #Region 2 - Load workspace to capture ccs SID (session ID) cookie value       
            
            if ($Name) {

                "[{0}] ------------------------------------- STEP 2 - Load workspace to capture CCS SID (session ID) cookie value ---------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step 2 / 7 - Loading workspace" -Id 1

                # ccs-session cookie value is used for CCS API authentication 

                
                $url = $SessionLoadAccountUri + $HPEGreenLakeSession.workspaceId

                try {         

                    # "Load CCS workspace account" | Write-Verbose
                    "[{0}] About to make GET rest call to URL $url" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                    $Timeout = 1

                    do {
                        try {
                            
                            $useraccount = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -WebSession $CCSSession

                            "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount.StatusCode, $useraccount.StatusDescription | Write-verbose
                            "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount | Write-verbose   
                            
                            # Check if the status code is 200 (HTTP OK)
                            if ($useraccount.StatusCode -eq 200) {
                                $success = $true
                            }
                            else {
                                $success = $false
                            }
                        }
                        catch {
                            $success = $false
                        }

                        if (-not $success) {
                            Start-Sleep -Seconds 1
                            $Timeout++
                        }
                                            
                    } until ($success -or $Timeout -eq 60)

                    if ($Timeout -ge 60) {
                        Write-Progress -Id 0 -Completed
                        Write-Progress -Id 1 -Completed
                        throw "Error ! Cannot load workspace at the current time!" 
                    }
            
                }
                catch {

                    if ($_.ErrorDetails.Message) {
                        $ErrorMsg = "Error: '{0}' - Error details: '{1}'" -f $_.Exception.Message, $_.ErrorDetails 

                    }
                    else {
                        $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message 

                    }

                    Write-Progress -Id 0 -Completed
                    Write-Progress -Id 1 -Completed
                    throw $ErrorMsg 
                    # $PSCmdlet.ThrowTerminatingError($PSitem)
                }
            }

            $completedSteps++

            #EndRegion
          
        }
        #EndRegion


        #Region -  If -Force is used to enforce a reconnection to the current workspace (condition is met when 'Invoke-HPEGLRefreshToken' is executed).
        # Steps:
        #  - Load workspace to get cookies session values for CCS API authentication 
        elseif ($Force) {

            #Region 1 - Load ccs-session cookie value
            "[{0}] ------------------------------------- STEP 1 - Load workspace to capture CCS SID (ccs-session cookie value) -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            # Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step 1 / 6 - Loading workspace" -Id 1
            $NoProgressBar = $True
            # ccs-session cookie value is used for CCS API authentication 

            if ($Null -eq $HPEGreenLakeSession.workspaceId) {
                # Write-Progress -Id 1 -Completed
                # Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshToken'
                throw "Error ! Workspace ID not found !" 
            }

            $url = $SessionLoadAccountUri + $HPEGreenLakeSession.workspaceId

            $headers = @{} 
            $headers["Accept"] = "application/json"
            $headers["Content-Type"] = "application/json"
            $headers["Authorization"] = "Bearer $Oauth2AccessToken"
            
            $session = New-Object Microsoft.PowerShell.Commands.WebRequestSession
            [void] $session.Cookies.Add((New-Object System.Net.Cookie("ccs-session", $HPEGreenLakeSession.ccsSid, "/", "aquila-user-api.common.cloud.hpe.com")))
            
            # $HPEGreenLakeSession.session.Cookies.getcookies("https://aquila-user-api.common.cloud.hpe.com")

            try {         

                "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose
                "[{0}] Headers content: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | out-String) | Write-Verbose
                "[{0}] Session cookie content: `nccs-session = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.ccsSid | Write-Verbose

                $Timeout = 1

                do {
                    $useraccount = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -WebSession $session
                    
                    #  Check if the status code is 200 (HTTP OK)
                    if ($useraccount.StatusCode -eq 200) {
                        $success = $true
                    }
                    else {
                        $success = $false
                    }
            

                    if (-not $success) {
                        Start-Sleep -Seconds 1
                        $Timeout++

                    }                                 

                } until ($success -or $Timeout -eq 60)
                
                if ($Timeout -ge 60) {
                    Write-Progress -Id 1 -Completed
                    Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshToken'
                    throw "Error ! Cannot load workspace at the current time!" 
                }

                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount.StatusCode, $useraccount.StatusDescription | Write-verbose
                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount | Write-verbose                

                $cookies = $session.Cookies.GetCookies($url)
                
                "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                
                # Check and keep only the first instance of 'ccs-session' cookie
                $uniqueCookies = @{}

                foreach ($cookie in $cookies) { 
                    Write-Verbose "$($cookie.name) = $($cookie.value)"
                    # Extract the 'ccs-session' cookie value
                    if ($cookie.name -eq 'ccs-session') {
                        # $ccsSessionValue = $cookie.Value 
                        # Only add the ccs-session cookie if it hasn't been added before
                        
                        #if (-not $uniqueCookies.ContainsKey($cookie.name)) {
                        $uniqueCookies[$cookie.name] = $cookie
                        #}
                    } 
                    else {
                        # For other cookies, just add or replace as necessary
                        $uniqueCookies[$cookie.Name] = $cookie
                    }
                }

                "[{0}] CCS-session cookie to keep: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($uniqueCookies | Out-String) | Write-Verbose

                # Create a cookie object with the new values
                $newCookieContainer = New-Object System.Net.CookieContainer

                foreach ($cookieName in $uniqueCookies.Keys) {
                    $originalCookie = $uniqueCookies[$cookieName]
                    $newCookie = New-Object System.Net.Cookie
                    $newCookie.Name = $originalCookie.Name
                    $newCookie.Value = $originalCookie.Value
                    $newCookie.Domain = $originalCookie.Domain
                    $newCookie.Path = $originalCookie.Path
                    $newCookie.Expires = $originalCookie.Expires
                    $newCookie.Secure = $originalCookie.Secure
                    $newCookie.HttpOnly = $originalCookie.HttpOnly
                
                    [void]$newCookieContainer.Add($newCookie)
                }
                
                $Session.Cookies = $newCookieContainer

                $cookies = $session.Cookies.GetCookies($url)
                
                "[{0}] New cookies content after cleaning up duplicates:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                foreach ($cookie in $cookies) { 
                    Write-Verbose "$($cookie.name) = $($cookie.value)"
                    if ($cookie.name -eq 'ccs-session') {
                        $ccsSessionValue = $cookie.Value 
                    }
                }

                "[{0}] HPE GreenLake CCS final-session captured from response headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSessionValue | Write-Verbose
                
                # Set HPEGreenLakeSession.session global variable
                           
                $Global:HPEGreenLakeSession.session = $Session
                $Global:HPEGreenLakeSession.ccsSid = $ccsSessionValue
        
            }
            catch {       

                if ($_.Exception.Response.StatusCode -eq "Unauthorized") {

                    # $ErrorMsg = "Error: '{0}' - Error details: '{1}'" -f $_.Exception.Message, $_.Exception.Response.StatusDescription
                    Write-Warning "GLP session refresh was unsuccessful. To use HPEGL cmdlets, you will need to reconnect using 'Connect-HPEGL'!"

                }
                elseif ($_.ErrorDetails.Message) {
                    $ErrorMsg = "Error: '{0}' - Error details: '{1}' - Code: '{2}'" -f $_.Exception.Message, $_.ErrorDetails , $_.Exception.Response.StatusCode
                    Write-Warning $ErrorMsg 
                }
                
                else {
                    $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message 
                    Write-Warning $ErrorMsg 
                }
              
                # Write-Progress -Id 1 -Completed
                # Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshToken'
                # Write-Progress -Id 3 -Completed # progress bar from 'Disconnect-HPEGL'
                # break
                # throw $ErrorMsg 
                # $PSCmdlet.ThrowTerminatingError($PSitem)
            }

            # $completedSteps++
            #EndRegion

        }
        #EndRegion


        #Region - If you are currently connected to GLP and wish to connect to another workspace
        # Steps:
        #  - Remove library API client credentials from the workspace being exited
        #  - Load workspace to get cookies session values for CCS API authentication 
        else {           
            
            #Region 1 - Remove library API client credentials from the workspace being exited
            "[{0}] ------------------------------------- STEP 1 - Remove library API client credentials from the workspace being exited -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step 1 / 7 - Removing library API credentials from current workspace" -Id 1

            # Set a variable to update/complete the Connect-HPEGL progress bar
            $Another_Workspace_Connection_ProgressBar = $True


            if (! $Name) {
                $name = $HPEGreenLakeSession.workspace
            }

            try {
                
                $Workspace = Get-HPEGLWorkspace -Name $Name
            }
            catch {

                Write-Progress -Id 1 -Completed
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $Workspace) {

                Write-Progress -Id 1 -Completed

                $ErrorMessage = "Workspace '{0}' cannot be found in HPE GreenLake!" -f $Name
                $ErrorRecord = New-ErrorRecord WorkspaceNotFoundInCOM ObjectNotFound -TargetObject 'Workspace' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)


            }
            else {
           
                $WorkspaceId = $Workspace.platform_customer_id

                if (-not $WorkspaceId) {

                    Write-Progress -Id 1 -Completed
                
                    $ErrorMessage = "Workspace '{0}' ID cannot be found in HPE GreenLake!" -f $Name
                    $ErrorRecord = New-ErrorRecord WorkspaceIDNotFoundInCOM ObjectNotFound -TargetObject 'Workspace' -Message $ErrorMessage -TargetType $Name.GetType().Name
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                }

                
                try {
                    $APIcredentials = Get-HPEGLAPICredential | Where-Object name -match $APIClientCredentialTemplateName 
                }
                catch {
        
                    "[{0}] Session gets expired! Connect-HPEGL must be executed!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    Write-Progress -Id 1 -Completed
                    Throw "Session gets expired! You must reconnect using 'Connect-HPEGL'!" 
                    # Write-Warning "Session gets expired! You must reconnect using 'Connect-HPEGL'!" 
                    # Return
                }

            
                if ($APIcredentials) {

                    try {
                        $APIcredentials | Remove-HPEGLAPICredential | Out-Null
                        
                    }
                    catch {
                        Write-Progress -Id 1 -Completed
                        $PSCmdlet.ThrowTerminatingError($_)
                    }
                }

                $completedSteps++
                #EndRegion

                  
                #Region 2 - Load ccs-session cookie value
                "[{0}] ------------------------------------- STEP 2 - Load workspace to capture CCS SID (ccs-session cookie value) -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                # ccs-session cookie value is used for CCS API authentication 
                
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step 2 / 7 - Loading workspace" -Id 1

                try {         

                    $url = $LoadAccountUri + $WorkspaceId
                    
                    "[{0}] About to execute GET request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $url | Write-Verbose

                    $useraccount = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -WebSession $HPEGreenLakeSession.session 

                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount.StatusCode, $useraccount.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $useraccount | Write-verbose
                
                    $cookies = $HPEGreenLakeSession.session.Cookies.GetCookies($url)
                    "[{0}] Cookies content from response headers:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                    foreach ($cookie in $cookies) { 
                        Write-Verbose "$($cookie.name) = $($cookie.value)"
                        # Extract the 'ccs-session' cookie value
                        if ($cookie.name -match 'ccs-session') {
                            $ccsSessionValue = $cookie.Value 
                        }
                    }
    
                    "[{0}] HPE GreenLake CCS session captured from response headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ccsSessionValue | Write-Verbose
            

                    $Global:HPEGreenLakeSession.ccsSid = $ccsSessionValue
                     
                    $Global:HPEGreenLakeSession.workspaceId = $WorkspaceId
                    $Global:HPEGreenLakeSession.workspace = $Name

           
                    "[{0}] HPE GreenLake CCS Workspace ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Global:HPEGreenLakeSession.workspaceId | Write-Verbose
                    "[{0}] HPE GreenLake CCS Workspace name: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Global:HPEGreenLakeSession.workspace | Write-Verbose
        
                }
                catch {

                    if ($_.ErrorDetails.Message) {
                        $ErrorMsg = "Error: '{0}' - Error details: '{1}'" -f $_.Exception.Message, $_.ErrorDetails 

                    }
                    else {
                        $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message 

                    }

                    Write-Progress -Id 1 -Completed
                    $ErrorRecord = New-ErrorRecord LoadWorkspaceError AuthenticationError -TargetObject 'Workspace' -Message $ErrorMsg -TargetType $WorkspaceId.GetType().Name
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                }

                #EndRegion

                $completedSteps++

            }
        }
        #EndRegion


        #Region - Generate new temporary API client credentials (COM and GLP) for this library using template $APIClientCredentialTemplateName 
        "[{0}] Generate new API client credentials in '{1}' workspace" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose
        
        if ($Name) {
            
            if ( $Connect_HPEGL_ProgressBar -or $Another_Workspace_Connection_ProgressBar) {
                "[{0}] ------------------------------------- STEP 3 - Generate new API client credentials -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step 3 / 7 - Generating new library API credentials" -Id 1
                
            }
            else {
                "[{0}] ------------------------------------- STEP 2 - Generate new API client credentials -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step 2 / 6 - Generating new library API credentials" -Id 1
            }

            # Clear $HPEGreenLakeSession.comApiAccessToken global variable
            $global:HPEGreenLakeSession.comApiAccessToken = [System.Collections.ArrayList]::new()
            # Clear $HPECOMAPICredentialRegions global variable
            $Global:HPECOMAPICredentialRegions = [System.Collections.ArrayList]::new()

            "[{0}] Cookies content of `$HPEGreenLakeSession.session before running Get-HPEGLAPICredential: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), (($HPEGreenLakeSession.session.Cookies.getcookies("https://aquila-user-api.common.cloud.hpe.com")) | Out-String) | Write-Verbose

            # Remove library API client credentials if any
            try {
                $APIcredentials = Get-HPEGLAPICredential | Where-Object name -match $APIClientCredentialTemplateName 
                
            }
            catch {
                
                "[{0}] Get-HPEGLAPICredential error ! Cannot get the API client credentials..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                Write-Progress -id 1 -Completed
                
                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Completed
                    
                }

                $ErrorMessage = "API client credentials cannot be retrieved from COM!"
                $ErrorRecord = New-ErrorRecord GetGLAPICredentialError InvalidOperation -TargetObject 'APICredential' -Message $ErrorMessage 
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }
        
            if ($APIcredentials) {

                try {
                    
                    $APIcredentials | Remove-HPEGLAPICredential | Out-Null
                }
                catch {

                    Write-Progress -Id 1 -Completed 

                    if ($Connect_HPEGL_ProgressBar) {
                        Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'
                        
                    }
            
                    $PSCmdlet.ThrowTerminatingError($_)
                }
            }

            "[{0}] Cookies content of `$HPEGreenLakeSession.session after running Get-HPEGLAPICredential: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), (($HPEGreenLakeSession.session.Cookies.getcookies("https://aquila-user-api.common.cloud.hpe.com")) | Out-String) | Write-Verbose

            "[{0}] ------- Create HPE GreenLake temporary API client credential" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            # Save access token into $HPEGreenLakesession.glpApiAccessToken
            # It will save client_id / client_secret into $HPEGreenLakesession.apiCredentials.GLP-PowerShell_Library_Temporary_Credential
            
            try {
                $GLPAPICreationTask = New-HPEGLAPIcredential -HPEGreenLake -TemplateName $APIClientCredentialTemplateName -ErrorAction SilentlyContinue #| Out-Null
                    
            }
            catch {
                
                Write-Progress -Id 1 -Completed 

                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'
                    
                }
        
                $PSCmdlet.ThrowTerminatingError($_)
            }

        
            if ($GLPAPICreationTask.status -eq "Complete") {

                "[{0}] ------- Create HPE COM temporary API client credentials" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                # Create temporary API client credential for the HPE COM APIs for all regions
                # Save access token into $HPEGreenLakesession.glpApiAccessToken
                # It will Save client_id / client_secret into $HPEGreenLakesession.apiCredentials.COM-<region>-PowerShell_Library_Temporary_Credential
                
                try {
                    
                    $COMAPICreation = Get-HPEGLService -ShowProvisioned -Name 'Compute Ops Management' | New-HPEGLAPIcredential -TemplateName $APIClientCredentialTemplateName #-ErrorAction SilentlyContinue #| out-Null
            
                }
                catch {
        
                    Write-Progress -Id 1 -Completed 

                    if ($Connect_HPEGL_ProgressBar) {
                        Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'
                        
                    }
        
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
        
            }
            else {

                Write-Progress -Id 1 -Completed 

                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'

                }

                # Throw "{0} API Credential cannot be created! '{1}' Any HPEGL cmdlets designed to interact with the official GLP APIs will not function!" -f ($GLPAPICreationTask.Name.substring(0, ($GLPAPICreationTask.Name.length - ($APIClientCredentialTemplateName.Length + 1))))  , $GLPAPICreationTask.Exception #| Write-Host -f Red
                $ErrorMessage = "{0} API Credential cannot be created! '{1}' Any HPEGL cmdlets designed to interact with the official GLP APIs will not function!" -f ($GLPAPICreationTask.Name.substring(0, ($GLPAPICreationTask.Name.length - ($APIClientCredentialTemplateName.Length + 1))))  , $GLPAPICreationTask.Exception
                $ErrorRecord = New-ErrorRecord GLAPICredentialCreationError InvalidOperation -TargetObject 'APICredential' -Message $ErrorMessage 
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }

            $completedSteps++
        }

            
        #EndRegion


        #Region - Create sessions with GLP and COM APIs at https://sso.common.cloud.hpe.com/as/token.oauth2 and capture access tokens
        
        if ($Name) {

            if ($Connect_HPEGL_ProgressBar) {
                "[{0}] ------------------------------------- STEP 4 - Create sessions with HPE GreenLake and COM APIs to capture access tokens -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step  4 / 7 - Creating session" -Id 1

            }
            else {
                "[{0}] ------------------------------------- STEP 3 - Create sessions with HPE GreenLake and COM APIs to capture access tokens -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step 3 / 6 - Creating session" -Id 1
            }

            $TemporaryCredentialsList = $HPEGreenLakeSession.apiCredentials | Where-Object name -match $APIClientCredentialTemplateName

            "[{0}] Credentials found: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $TemporaryCredentialsList.length | Write-Verbose

            foreach ($CurrentCredential in $TemporaryCredentialsList) {

                $SecureClientSecret = $CurrentCredential.secure_client_secret | ConvertTo-SecureString
                $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
                $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr) 

                $Payload = @{
                    'client_id'     = $CurrentCredential.client_id
                    'client_secret' = $ClientSecret
                    'grant_type'    = 'client_credentials'
                }

                "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
                "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | convertto-json) | Write-Verbose

                try {

                    $response = Invoke-RestMethod -Method Post -Uri $HPEGLtokenEndpoint -Body $Payload -ContentType 'application/x-www-form-urlencoded' 

                    "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                    "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose


                    if ($CurrentCredential.name -match "COM" -and $CurrentCredential.name -match $APIClientCredentialTemplateName) {

                        $ServiceAPICredential = [PSCustomObject]@{
                            name         = $CurrentCredential.name
                            access_token = $response.access_token 
                            expires_in   = $response.expires_in
                            creation_time = (Get-Date)

                        }
                
                        [void]$global:HPEGreenLakeSession.comApiAccessToken.add($ServiceAPICredential)
                        "[{0}] COM API access token has been set in `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    }

                    if ($CurrentCredential.name -match "GLP-$APIClientCredentialTemplateName") {

                        $ServiceAPICredential = [PSCustomObject]@{
                            name         = $CurrentCredential.name
                            access_token = $response.access_token 
                            expires_in   = $response.expires_in
                            creation_time = (Get-Date)

                        }

                        [void]$global:HPEGreenLakeSession.glpApiAccessToken.add($ServiceAPICredential)                        
                        "[{0}] GLP API access token has been set in `$HPEGreenLakeSession.glpApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    }
            
                }
                catch {

                    "[{0}] Exception caught: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ | Write-Verbose

                    if ($_.ErrorDetails.Message) {
                        Write-Warning $_.ErrorDetails
                    }

                    Write-Progress -Id 1 -Completed 

                    if ($Connect_HPEGL_ProgressBar) {
                        Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'
        
                    }
                
                    $PSCmdlet.ThrowTerminatingError($_) #.Exception.Message

                }
            }

            $completedSteps++
        }

        #endregion

        
        #Region - Generate $HPECOMjobtemplatesUris if not available and if COM instance to store the URIs of each COM job templates 
        if (-not $HPECOMjobtemplatesUris -and ($HPEGreenLakeSession.apiCredentials | Where-Object application_name -eq "COM" )) {
            
            if ($Connect_HPEGL_ProgressBar) {
                "[{0}] ------------------------------------- STEP 5 - Generate $HPECOMjobtemplatesUris if not available to store the URIs of each COM job templates  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step  5 / 7 - Generating $HPECOMjobtemplatesUris" -Id 1

            }
            else {
                "[{0}] ------------------------------------- STEP 4 - Generate $HPECOMjobtemplatesUris if not available to store the URIs of each COM job templates  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step 4 / 6 - Generating $HPECOMjobtemplatesUris" -Id 1
            }

            $FirstProvisionedCOMRegion = $HPEGreenLakeSession.apicredentials | Where-Object application_name -eq COM | select -first 1 | ForEach-Object region
            "[{0}] About to retrieve the URIs of each COM job templates in '{1}' COM region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $FirstProvisionedCOMRegion | Write-Verbose
            
            try {
                Set-HPECOMJobTemplatesVariable -region $FirstProvisionedCOMRegion
                
            }
            catch {
                Write-Progress -Id 1 -Completed 
                
                if ($Connect_HPEGL_ProgressBar) {
                    Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'
                    
                }
                
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            $completedSteps++        
        }

        #endregion


        #Region - Set the user session idle timeout to 2 hours to prevent disconnection due to inactivity, and save it in the global variable.
    
        if (-Not $Name -and -not $NoProgressBar) {
            "[{0}] ------------------------------------- STEP 2 - Set user session idle timeout in global variable  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step  2 / 3 - Setting user session idle timeout" -Id 1

        }
        elseif ($Connect_HPEGL_ProgressBar) {
            "[{0}] ------------------------------------- STEP 6 - Set user session idle timeout in global variable  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step  6 / 7 - Setting user session idle timeout" -Id 1

        }
        elseif ($NoProgressBar) {
            "[{0}] ------------------------------------- STEP 2 - Set user session idle timeout in global variable  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

        }
        else {
            "[{0}] ------------------------------------- STEP 5 - Set user session idle timeout in global variable  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step 5 / 6 - Setting user session idle timeout" -Id 1
        }

        "[{0}] Set user session idle timeout in `$HPEGLworkspaces" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        # Get user session idle timeout 
        
        try {
            # Set the user session idle timeout to 2 hours (7200 seconds) to prevent disconnection due to inactivity if less than 2 hours

            $UserSessionTimeout = ((Get-HPEGLUserPreference).idle_timeout) / 60

            if ( $UserSessionTimeout -lt '120'){

                Set-HPEGLUserPreference -SessionTimeoutInMinutes 120 
                "[{0}] 120 minutes session idle timeout has been set in `$HPEGreenLakeSession global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            }
            else{

                $Global:HPEGreenLakeSession.userSessionIdleTimeout = $UserSessionTimeout
                "[{0}] '{1}' minutes session idle timeout has been set in `$HPEGreenLakeSession global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $UserSessionTimeout | Write-Verbose
            }
          
            
        }
        catch {
            Write-Progress -Id 1 -Completed 
            
            if ($Connect_HPEGL_ProgressBar) {
                Write-Progress -id 0 -Completed # progress bar from 'Connect-HPEGL'
                
            }
            $PSCmdlet.ThrowTerminatingError($_)
        }

        $completedSteps++ 
        
        #endregion


        #Region - Get HPE GreenLake schema meta data to get HPE GL supported timezones and countries at https://onepass-enduserservice.it.hpe.com/v2-get-user-schema-metadata

        if (-not $Name) {
            "[{0}] ------------------------------------- STEP 3 - Get HPE GreenLake schema meta data to get HPE GL supported timezones and countries  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 3 -CurrentActivity "Running Step  3 / 3 - Getting HPE GreenLake schema meta data" -Id 1

        }
        elseif ($Connect_HPEGL_ProgressBar) {
            "[{0}] ------------------------------------- STEP 7 - Get HPE GreenLake schema meta data to get HPE GL supported timezones and countries  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 7 -CurrentActivity "Running Step  7 / 7 - Getting HPE GreenLake schema meta data" -Id 1

        }
        elseif ($NoProgressBar) {
            "[{0}] ------------------------------------- STEP 3 - Get HPE GreenLake schema meta data to get HPE GL supported timezones and countries  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

        }
        else {
            "[{0}] ------------------------------------- STEP 6 - Get HPE GreenLake schema meta data to get HPE GL supported timezones and countries  -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps 6 -CurrentActivity "Running Step 6 / 6 - Getting HPE GreenLake schema meta data" -Id 1
        }

        "[{0}] About to make call to fetch HPE GreenLake schema meta data at: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SchemaMetadataURI | Write-Verbose
        
        try {
            $Global:HPEGLSchemaMetadata = Invoke-HPEGLWebRequest -Uri $SchemaMetadataURI -Method Post 
           
        }
        catch {
            Write-Progress -Id 0 -Completed
            $PSCmdlet.ThrowTerminatingError($_)
        }


        # Register an argument completer for the TimeZone parameter
        Register-ArgumentCompleter -CommandName 'Set-HPEGLUserAccountDetails' -ParameterName TimeZone -ScriptBlock {
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)

            # Get all available time zone IDs
            $timeZoneIds = $HPEGLSchemaMetadata.definitions.custom.properties.hpeTimezone.enum

            # Filter time zone IDs based on input and create completions
            $timeZoneIds | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        }

        # Register an argument completer for the Country parameter
        Register-ArgumentCompleter -CommandName 'Set-HPEGLUserAccountDetails', 'New-HPEGLWorkspace', 'Set-HPEGLWorkspace', 'New-HPEGLLocation', 'Set-HPEGLLocation' -ParameterName Country -ScriptBlock {
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)

            # Get all available country codes
            $Countries = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf.title[1..($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf.title.length - 1)]

            # Filter country codes based on input and create completions
            $Countries | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                $countryName = $_
        
                # Check if the country name contains spaces
                if ($countryName -match "\s") {
                    # Wrap the country name in single quotes
                    $completionText = "'$countryName'"
                }
                else {
                    $completionText = $countryName
                }
        
                [System.Management.Automation.CompletionResult]::new($completionText, $completionText, 'ParameterValue', $countryName)
            }
        }

        $completedSteps++ 
        
        #endregion

            
        # Clear the progress bar upon completion
        Write-Progress -Id 1 -Completed

        return $HPEGreenLakeSession

    }

}


Function Invoke-HPEGLAutoReconnect { 
    [CmdletBinding()]
    Param(
        # An access token is valid for 2 hours (120 minutes) - GLP Session idle timeout is 30 minutes by default 
        # Default: reconnect 30 minutes before expiration
        # Timeout in minutes, 
        $Timeout = 30,
        [switch]$Force
    ) 

    # Access_token expiration date
    $AccessTokenExpirationDate = $HPEGreenLakeSession.oauth2TokenCreation.AddMinutes(120)
    
    # Number of minutes before expiration of the Access_token expiration date
    $BeforeExpirationinMinutes = [math]::Round(((New-TimeSpan -Start (Get-Date) -End ($AccessTokenExpirationDate)).TotalHours ) * 60)
    
    if ( $BeforeExpirationinMinutes -gt 0) { $Expiration = $BeforeExpirationinMinutes }
    else { $Expiration = 0 }
        
    if ( $Force ) {
            
        "[{0}] Forcing Access Token refresh ! $Expiration minute(s) before expiration - Token refresh in progress..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

        try {
            Invoke-HPEGLRefreshtoken | out-null
            
        }
        catch {
            Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshtoken'
            $PSCmdlet.ThrowTerminatingError($_)
        }
            
        "[{0}] Refresh token successful!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        # Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshtoken'


    }
    elseif ($Expiration -eq 0) {

        "[{0}] Expiration={1} - Access Tokens refresh required but session gets expired! Connect-HPEGL must be executed!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Expiration | Write-Verbose

        Write-Warning "Access tokens refresh required, but the session has expired! Please reconnect using 'Connect-HPEGL'." 
        Break

    }
    elseif ( $Expiration -le $Timeout ) {

        # write-host "Access tokens refresh required ! $Expiration minute(s) before expiration - Tokens refresh in progress..."
            
        "[{0}] Access Tokens refresh required ! $Expiration minute(s) before expiration - Tokens refresh in progress..." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        try {
            Invoke-HPEGLRefreshtoken | out-null
            
        }
        catch {
            Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshtoken'
            $PSCmdlet.ThrowTerminatingError($_)
        }
            
            
        "[{0}] Refresh tokens successful!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        # Write-Progress -Id 2 -Completed # progress bar from 'Invoke-HPEGLRefreshtoken'
    }
    else {
        
        "[{0}] No Access Tokens refresh required ! $Expiration minute(s) before expiration - Allowable time to refresh/reconnect is {1} minutes." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Timeout | Write-Verbose

    }  
}


Function Invoke-HPEGLRefreshtoken { 
    <#
    .SYNOPSIS
    Refreshes the HPE GreenLake OATH2 access token, refresh token, and ID token.
    Create a new session with the HPE GreenLake workspace and capture session cookie value in the $HPEGreenLakeSession global variable.
    Create new sessions with GLP and COM APIs at https://sso.common.cloud.hpe.com/as/token.oauth2 and capture access tokens in the $HPEGreenLakeSession global variable.

    .DESCRIPTION
    
    #>
    [CmdletBinding()]
    Param() 

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Define the total number of operations/steps
        $totalSteps = 3

        # Initialize a counter for completed steps
        $completedSteps = 0
 
        function Update-ProgressBar {
            param (
                [int]$CompletedSteps,
                [int]$TotalSteps,
                [string]$CurrentActivity,
                [int]$Id

            )
 
            $percentComplete = ($CompletedSteps / $TotalSteps) * 100
            Write-Progress `
                -Activity "Refreshing HPE GreenLake tokens, please wait..." `
                -Status $CurrentActivity `
                -PercentComplete $percentComplete `
                -id $Id
        }
        
        if (-not $HPEGreenLakeSession) {

            Throw "Error - No HPE GreenLake session found!"
    
        }
        else {   

            #Region 1-Generate new access_token/refresh_token/id_token

            "[{0}] ------------------------------------- STEP 1 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] Generate new access_token/refresh_token/id_token with '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 1 / 3" -Id 2

    
            $Body = @{
                'grant_type'    = 'refresh_token'
                'client_id'     = 'aquila-user-auth'
                'refresh_token' = $HPEGreenLakeSession.oauth2RefreshToken
            } 
    
            "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
    
            try {

                $InvokeReturnData = Invoke-webrequest -Uri $HPEGLtokenEndpoint -Method 'POST' -ContentType "application/x-www-form-urlencoded" -Body $Body -WebSession $HPEGreenLakeSession.session 
         
                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InvokeReturnData | Write-verbose
                
                $InvokeReturnData = $InvokeReturnData | ConvertFrom-Json

                # Set new global variables

                $NewAccessToken = $InvokeReturnData.access_token
                "[{0}] New access token = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $NewAccessToken | Write-verbose
                $global:HPEGreenLakeSession.oauth2AccessToken = $NewAccessToken 

                $NewRefreshToken = $InvokeReturnData.refresh_token
                "[{0}] New refresh token = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $NewRefreshToken | Write-verbose
                $global:HPEGreenLakeSession.oauth2RefreshToken = $NewRefreshToken

                $NewIdToken = $InvokeReturnData.id_token
                "[{0}] New ID token = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $NewIdToken | Write-verbose
                $global:HPEGreenLakeSession.oauth2IdToken = $NewIdToken 

                $global:HPEGreenLakeSession.oauth2TokenCreation = [datetime]$( Get-Date -Format g )
                "[{0}] `$HPEGreenLakeSession has been updated with new token creation date!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                $global:HPEGreenLakeSession.oauth2TokenCreationEpoch = $( (New-TimeSpan -Start (Get-Date "01/01/1970") -End (Get-Date)).TotalSeconds ) 
                "[{0}] `$HPEGreenLakeSession has been updated with new token creation epoch!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
    
                "[{0}] `$HPEGreenLakeSession has been updated with new access_token/refresh_token/id_token!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Cookies?
                $allCookies = $HPEGreenLakeSession.session.Cookies.GetCookies($HPEGLtokenEndpoint)
                # Output all cookies
                foreach ($cookie in $allCookies) {
                    Write-Verbose "Session cookie content: `n$($cookie.Name) = $($cookie.Value)"
                }

            }
            
            catch {

                "[{0}] Exception thrown!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                # Get Exception type
                $exception = $_.Exception
                do {
                    "[{0}] Exception Type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $exception.GetType().Name | Write-Verbose
                    $exception = $exception.InnerException
                } while ($exception)

                # Get exception stream
                $result = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($result)
                $reader.BaseStream.Position = 0
                $reader.DiscardBufferedData()
                $responseBody = $reader.ReadToEnd() 


                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $responseBody | Write-Verbose
            
                # $response = $responseBody | ConvertFrom-Json

                    
                    
                if ($Body) {
                    "[{0}] Request payload: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Body | Out-String) | Write-Verbose
                }
                if ($Headers) {
                    "[{0}] Request headers: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | Out-String) | Write-Verbose
                }

                Write-Progress -Completed -Id 2
                Write-Progress -Completed -Id 1 # progress bar from 'Connect-HPEGLWorkspace'
                Throw "Error -  $responseBody"          
             
            }    

            $completedSteps++

            #endRegion


            #Region 2-Create a session with workspace + capture CCS SID (ccs-session cookie value)
            
            "[{0}] ------------------------------------- STEP 2 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            "[{0}] Create new session with workspace '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

            Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 2 / 3" -Id 2

            try {
                
                $CCSSession = Connect-HPEGLWorkspace -force 
            }
            catch {

                # Write-Progress -Completed -Id 2
                # Write-Progress -Completed -Id 1 # progress bar from 'Connect-HPEGLWorkspace'
                $_
                # $PSCmdlet.ThrowTerminatingError($_)
                
            }
            
            "[{0}] Connect to workspace response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CCSSession | Write-Verbose

            $completedSteps++

            #endRegion

            
            #Region 3- Create sessions with GLP and COM APIs at https://sso.common.cloud.hpe.com/as/token.oauth2 and capture access tokens, creation date, etc.
        
            if ($HPEGreenLakeSession.apiCredentials) {
                "[{0}] ------------------------------------- STEP 3 -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                "[{0}] Create sessions with HPE GreenLake and COM APIs to capture access tokens '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGreenLakeSession.workspace | Write-Verbose

                Update-ProgressBar -CompletedSteps $completedSteps -TotalSteps $totalSteps -CurrentActivity "Running Step 3 / 3" -Id 2


                $TemporaryCredentialsList = $HPEGreenLakeSession.apiCredentials | Where-Object name -match $APIClientCredentialTemplateName

                "[{0}] Credentials found: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $TemporaryCredentialsList.length | Write-Verbose

                foreach ($CurrentCredential in $TemporaryCredentialsList) {

                    $SecureClientSecret = $CurrentCredential.secure_client_secret | ConvertTo-SecureString
                    $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
                    $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr) 

                    $Payload = @{
                        'client_id'     = $CurrentCredential.client_id
                        'client_secret' = $ClientSecret
                        'grant_type'    = 'client_credentials'
                    }

                    "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
                    "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | convertto-json) | Write-Verbose

                    try {

                        $response = Invoke-WebRequest -Method Post -Uri $HPEGLtokenEndpoint -Body $Payload -ContentType 'application/x-www-form-urlencoded' 

                        # Capturing API Access Token
                        
                        "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $response.StatusDescription | Write-Verbose
                        "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
                        
                        $response = ($response.Content | Convertfrom-Json)
                        
                        if ($CurrentCredential.name -match "COM" -and $CurrentCredential.name -match $APIClientCredentialTemplateName) {

                            ($global:HPEGreenLakeSession.comApiAccessToken | ? name -eq $CurrentCredential.name).access_token = $response.access_token
                            ($global:HPEGreenLakeSession.comApiAccessToken | ? name -eq $CurrentCredential.name).creation_Time = Get-Date
                            ($global:HPEGreenLakeSession.comApiAccessToken | ? name -eq $CurrentCredential.name).expires_in = $response.expires_in

                            "[{0}] API access token for '{1}' has been set in `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CurrentCredential.name | Write-Verbose

                        }

                        if ($CurrentCredential.name -match "GLP-$APIClientCredentialTemplateName") {

                            $Global:HPEGreenLakeSession.glpApiAccessToken[0].access_token = $response.access_token 
                            $Global:HPEGreenLakeSession.glpApiAccessToken[0].creation_Time = Get-Date 
                            $Global:HPEGreenLakeSession.glpApiAccessToken[0].expires_in = $response.expires_in

                            "[{0}] GLP API access token has been set in `$HPEGreenLakeSession.glpApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        }
                
                    }
                    catch {

                        if ($_.ErrorDetails.Message) {
                            Write-Warning $_.ErrorDetails
                        }

                        Write-Progress -Completed -Id 2
                        Write-Progress -Completed -Id 1 # progress bar from 'Connect-HPEGLWorkspace'
                   
                        $PSCmdlet.ThrowTerminatingError($_).Exception.Message

                    }
                }

            }
    
            $Global:HPEGreenLakeSession = Invoke-RepackageObjectWithType -RawObject $HPEGreenLakeSession -ObjectName 'Connection'

            # Clear the progress bar upon completion
            Write-Progress -Completed -Id 2 

            # return $HPEGreenLakeSession 
            return


        }
    }

} 


function New-ErrorRecord {
    <#
        .Synopsis
        Creates an custom ErrorRecord that can be used to report a terminating or non-terminating error.

        .Description
        Creates an custom ErrorRecord that can be used to report a terminating or non-terminating error.

        .Parameter Exception
        The Exception that will be associated with the ErrorRecord. Uses RuntimeException by default.

        .Parameter ErrorID
        A scripter-defined identifier of the error. This identifier must be a non-localized string for a specific error type.

        .Parameter ErrorCategory
        An ErrorCategory enumeration that defines the category of the error.  The supported Category Members are (from: http://msdn.microsoft.com/en-us/library/system.management.automation.errorcategory(v=vs.85).aspx) :

            * AuthenticationError - An error that occurs when the user cannot be authenticated by the service. This could mean that the credentials are invalid or that the authentication system is not functioning properly.
            * CloseError - An error that occurs during closing.
            * ConnectionError - An error that occurs when a network connection that the operation depEnds on cannot be established or maintained.
            * DeadlockDetected - An error that occurs when a deadlock is detected.
            * DeviceError - An error that occurs when a device reports an error.
            * FromStdErr - An error that occurs when a non-Windows PowerShell command reports an error to its STDERR pipe.
            * InvalidArgument - An error that occurs when an argument that is not valid is specified.
            * InvalidData - An error that occurs when data that is not valid is specified.
            * InvalidOperation - An error that occurs when an operation that is not valid is requested.
            * InvalidResult - An error that occurs when a result that is not valid is returned.
            * InvalidType - An error that occurs when a .NET Framework type that is not valid is specified.
            * LimitsExceeded - An error that occurs when internal limits prevent the operation from being executed.
            * MetadataError - An error that occurs when metadata contains an error.
            * NotEnabled - An error that occurs when the operation attempts to use functionality that is currently disabled.
            * NotImplemented - An error that occurs when a referenced application programming interface (API) is not implemented.
            * NotInstalled - An error that occurs when an item is not installed.
            * NotSpecified - An unspecified error. Use only when not enough is known about the error to assign it to another error category. Avoid using this category if you have any information about the error, even if that information is incomplete.
            * ObjectNotFound - An error that occurs when an object cannot be found.
            * OpenError - An error that occurs during opening.
            * OperationStopped - An error that occurs when an operation has stopped. For example, the user interrupts the operation.
            * OperationTimeout - An error that occurs when an operation has exceeded its timeout limit.
            * ParserError - An error that occurs when a parser encounters an error.
            * PermissionDenied - An error that occurs when an operation is not permitted.
            * ProtocolError An error that occurs when the contract of a protocol is not being followed. This error should not happen with well-behaved components.
            * QuotaExceeded An error that occurs when controls on the use of traffic or resources prevent the operation from being executed.
            * ReadError An error that occurs during reading.
            * ResourceBusy An error that occurs when a resource is busy.
            * ResourceExists An error that occurs when a resource already exists.
            * ResourceUnavailable An error that occurs when a resource is unavailable.
            * SecurityError An error that occurs when a security violation occurs. This field is introduced in Windows PowerShell 2.0.
            * SyntaxError An error that occurs when a command is syntactically incorrect.
            * WriteError An error that occurs during writing.

        .Parameter TargetObject
        The object that was being Processed when the error took place.

        .Parameter Message
        Describes the Exception to the user.

        .Parameter InnerException
        The Exception instance that caused the Exception association with the ErrorRecord.

        .Parameter TargetType
        To customize the TargetType value, specify the appropriate Target object type.  Values can be "Array", "PSObject", "HashTable", etc.  Can be provided by ${ParameterName}.GetType().Name.

        .Example
        $errorMessage = "Timeout reached waiting for job to complete."
        $errorRecord = New-ErrorRecord TimeoutError OperationTimeout -Message $ErrorMessage
        $PSCmdlet.ThrowTerminatingError($ErrorRecord )

        .EXAMPLE
        $ErrorMessage = "Filter '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
        $ErrorRecord = New-ErrorRecord FilterNotFoundInCOM ObjectNotFound -TargetObject 'Filter' -Message $ErrorMessage -TargetType $Name.GetType().Name
        $PSCmdlet.ThrowTerminatingError($ErrorRecord )

    #>

    [CmdletBinding ()]
    Param
    (        
        
        [Parameter (Mandatory, Position = 0)]
        [Alias ('ID')]
        [System.String]$ErrorId,
        
        [Parameter (Mandatory, Position = 1)]
        [Alias ('Category')]
        [ValidateSet ('AuthenticationError', 'ConnectionError', 'NotSpecified', 'OpenError', 'CloseError', 'DeviceError',
            'DeadlockDetected', 'InvalidArgument', 'InvalidData', 'InvalidOperation',
            'InvalidResult', 'InvalidType', 'MetadataError', 'NotImplemented',
            'NotInstalled', 'ObjectNotFound', 'OperationStopped', 'OperationTimeout',
            'SyntaxError', 'ParserError', 'PermissionDenied', 'ResourceBusy',
            'ResourceExists', 'ResourceUnavailable', 'ReadError', 'WriteError',
            'FromStdErr', 'SecurityError')]
        [System.Management.Automation.ErrorCategory]$ErrorCategory,
            
        [Parameter (Position = 2)]
        [System.Object]$TargetObject,
            
        [System.String]$Exception = "System.Management.Automation.RuntimeException",
        
        # [Parameter (Mandatory)]
        [System.String]$Message,
        
        [System.Exception]$InnerException,
        
        [System.String]$TargetType = "String"

    )

    Process {

        # ...build and save the new Exception depending on present arguments, if it...
        $_exception = if ($Message -and $InnerException) {
            # ...includes a custom message and an inner exception
            New-Object $Exception $Message, $InnerException
        }
        elseif ($Message) {
            # ...includes a custom message only
            New-Object $Exception $Message
        }
        else {
            # ...is just the exception full name
            New-Object $Exception
        }

        # now build and output the new ErrorRecord
        "[{0}] Building ErrorRecord object" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

        $record = [Management.Automation.ErrorRecord]::new($_exception, $ErrorID, $ErrorCategory, $TargetObject)

        $record.CategoryInfo.TargetType = $TargetType

        Return $record
    }


}

#EndRegion
#EndRegion



#Region ------------------- COM -------------------

#Region --- ACTIVITIES ---

Function Get-HPECOMActivity {
    <#
    .SYNOPSIS
    Retrieve the list of activities.

    .DESCRIPTION
    This Cmdlet returns a collection of the last 50 activities that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER ServerName 
    Optional parameter that can be used to display the activities of a specific server name.

    .PARAMETER GroupName 
    Optional parameter that can be used to display the activities of a specific group name.

    .PARAMETER SourceType 
    Optional parameter that can be used to display the activities of a specific source type such as OneView Appliance, 
    Schedule, Firmware, Report, Job, Setting, Server, Group, External service, User Preferences and Subscription.

    .PARAMETER SettingsName 
    Optional parameter that can be used to display the activities of a specific settings name.
 
    .PARAMETER Limit 
    This parameter allows you to define the number of activities to be displayed.

    .PARAMETER NoLimit
    This switch parameter can be used to display the total number of activities. Be aware, however, that this may take some time, depending on your history.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central

    Return the last 50 activities data for all servers in the central european region. 

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -ServerName CZJ11105MV -limit 1

    Retrieve the last activity data for a server specified by its name.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -GroupName RHEL92-1_server_group -nolimit

    Retrieve all activities data for a group specified by its name.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SettingsName RAID1

    Retrieve the last 50 activities data for a server settings specified by its name.

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -SourceType Server

    Retrieve the last 50 activities data for all server source type.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1 | Get-HPECOMActivity 

    This example demonstrates how to retrieve last 50 activities data for a server named 'ESX-1' in the "eu-central" region.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ11105MV | Get-HPECOMActivity 

    This example demonstrates how to retrieve last 50 activities data for a server with the serial number 'CZJ11105MV' in the "eu-central" region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model 'ProLiant DL385 Gen10 Plus' -ConnectedState True -PowerState ON | Get-HPECOMActivity -Limit 10

    This example demonstrates how to retrieve the last 10 activities data for all "ProLiant DL385 Gen10 Plus" servers in the "us-west" region that are currently powered on and connected.
       
    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name Production_AI_Systems | Get-HPECOMActivity -NoLimit

    This example demonstrates how to retrieve all activities data for a group named 'Production_AI_Systems' in the "us-west" region.
    
    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name RAID1 | Get-HPECOMActivity -Limit 10

    This example demonstrates how to retrieve the last 10 activities data for the server settings named 'RAID1' in the "eu-central" region.

    .EXAMPLE
    'HOL11', 'HOL21' | Get-HPECOMActivity -Region  us-west -Limit 10 

    This example demonstrates how to retrieve the last 10 activities data for the servers named 'HOL11' and 'HOL21' in the "us-west" region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's names.
    System.Collections.ArrayList
        List of server, group or setting resources retrieved using 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber' or 'Get-HPECOMGroup' or 'Get-HPECOMSetting'.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ServerName')]
    Param( 
    
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'ServerName', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias("Name")]
        [String]$ServerName,

        [Parameter (ParameterSetName = 'GroupName', ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ParameterSetName = 'SourceType')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('"OneView Appliance"', 'Schedule', 'Firmware', 'Report', 'Job', 'Setting', 'Server', 'Group', '"External service"', '"User Preferences"', 'Subscription')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('"OneView Appliance"', 'Schedule', 'Firmware', 'Report', 'Job', 'Setting', 'Server', 'Group', '"External service"', '"User Preferences"', 'Subscription')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]
        [String]$SourceType,

        [Parameter (ParameterSetName = 'Settings', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$SettingsName,

        [ValidateScript({ $_ -le 1000 })]
        [int]$Limit,

        [switch]$NoLimit,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      

        
        if ($serverName) {

            $Uri = $COMActivitiesUri + "?filter=source/displayName eq '$ServerName'"

        }
        elseif ($GroupName) {

            $Uri = $COMActivitiesUri + "?filter=groupDisplayName eq '$GroupName'"

        }
        elseif ($SettingsName) {

            $Uri = $COMActivitiesUri + "?filter=serverSettingsName eq '$SettingsName'"

        }
        elseif ($SourceType) {

            $Uri = $COMActivitiesUri + "?filter=source/type eq '$SourceType'"

        }
        else {

            $Uri = $COMActivitiesUri 
        }
        
        
        if ($Limit) {
            
            if ($Uri -match "\?") {
                
                $Uri = $Uri + "&limit=$Limit"

            }
            else {
            
                $Uri = $Uri + "?limit=$Limit"

            }

        }
        elseif ($NoLimit) {

            $Uri = $Uri 
        }   
        else {

            if ($Uri -match "\?") {
                
                $Uri = $Uri + "&limit=50"

            }
            else {
            
                $Uri = $Uri + "?limit=50"

            }

        }
        
        

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }

       
        if ($Null -ne $CollectionList) {     

            if ($ServerName) {
                
                $CollectionList = $CollectionList | Where-Object associatedServerUri -match $serverUri
                
            }   



            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            # Add job uri to object
            $CollectionList | % {$_ | Add-Member -type NoteProperty -name sourceResourceUri -value $_.source.resourceUri}

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Activities"    
    
            # $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- APPLIANCE-FIRMWARE-BUNDLES ---

Function Get-HPECOMApplianceFirmwareBundle {
    <#
    .SYNOPSIS
    Retrieve the list of appliance firmware bundles in the specified region.

    .DESCRIPTION
    This Cmdlet returns a collection of appliance firmware bundles that are available to update an appliance.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Version 
    Optional parameter that can be used to display the appliance firmware bundles of a specific version such as 8.6, 8.60 or 8.60.01.

    .PARAMETER LatestVersion 
    Optional parameter that can be used to display the latest appliance firmware bundles version.

    .PARAMETER Type 
    Optional parameter that can be used to display the appliance firmware bundles of a specific type such as VM or Synergy.

    .PARAMETER SupportedUpgrades 
    Optional parameter that works with both -version and -type to show the supported upgrade paths for upgrading an appliance 
    to the specified version.
 
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central 

    Return all appliance firmware bundles data in the central european region. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -Version "8.9" 

    Return all appliance firmware bundles data for a specified version. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -Version "8.9" -Type Synergy

    Return all Synergy appliance firmware bundles data for a specified version. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -LatestVersion

    Return the latest appliance firmware bundles version. 

    .EXAMPLE
    Get-HPECOMApplianceFirmwareBundle -Region eu-central -LatestVersion -Type VM -SupportedUpgrades

    Return the supported upgrade paths for upgrading a VM appliance to the latest version.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Version')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'SupportedUpgrades')]
        [Parameter (ParameterSetName = 'Version', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias("Name")]
        [String]$Version,

        [Parameter (ParameterSetName = 'Latest')]
        [Switch]$LatestVersion,

        [Parameter (ParameterSetName = 'Latest')]
        [Parameter (Mandatory, ParameterSetName = 'SupportedUpgrades')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('Synergy', 'VM')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('Synergy', 'VM')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]
        [String]$Type,

        [Parameter (ParameterSetName = 'Latest')]
        [Parameter (ParameterSetName = 'SupportedUpgrades')]
        [Switch]$SupportedUpgrades,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose    

        $Uri = $COMApplianceFirmwareBundlesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     
                

            if ($Version) {

                $CollectionList = $CollectionList | Where-Object applianceVersion -match $Version

            }   

            if ($Type) {

                $CollectionList = $CollectionList | Where-Object applianceType -match $Type

            }  

            if ($LatestVersion) {


                $Latestversionitems = @()
                $maxNumber = [int]::MinValue

                foreach ($item in $CollectionList) {
                    if ($item.applianceVersion -gt $maxNumber) {
                        $maxNumber = $item.applianceVersion
                        $Latestversionitems.Clear()
                        $Latestversionitems += $item
                    } 
                    elseif ($item.applianceVersion -eq $maxNumber) {
                        # If current number matches the max number, add it to the list
                        $Latestversionitems += $item
                    }
                }

                $CollectionList = $Latestversionitems

            }  

            
            if ($SupportedUpgrades) {

                $CollectionList = $CollectionList.supportedUpgrades

            } 

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.ApplianceFirmwareBundles"    
    
            $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- EXTERNAL-SERVICES ---

Function Get-HPECOMExternalService {
    <#
    .SYNOPSIS
    Retrieve the list of external services configured.

    .DESCRIPTION
    This Cmdlet returns a collection of external services configured that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Name of an external services resource.
   
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central

    Return all external services configured in the central european region. 

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central -name MyServiceNow

    Return the external services 'MyServiceNow' configured in the central european region. 

    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$Name,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $Uri = $COMExternalServicesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            if ($Name) {
                $CollectionList = $CollectionList | Where-Object name -eq $Name

            }
                
            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.ExternalServices"    
    
            $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

Function Add-HPECOMExternalService {
    <#
    .SYNOPSIS
    Deploy the ServiceNow application in a region.

    .DESCRIPTION
    This Cmdlet can be used to deploy the ServiceNow application in a region so that COM will automatically create
    incidents in ServiceNow when iLOs indicate hardware related service events.    
        
    .PARAMETER Name 
    Name of the external web service to deploy. 
    
    .PARAMETER Region 
    Name of the region to deploy the external web service. 

    .PARAMETER ServiceType
    Name of the service type to deploy. Currently only 'SERVICE_NOW' is supported

    .PARAMETER AuthenticationType  
    Parameter to specify which authentication method is used for authenticating the external service. Default value is 'OAUTH'.

    .PARAMETER Description 
    Parameter to specify a description. 

    .PARAMETER Credential 
    Parameter to specify the credential (clientID and client secret) of the external web service. 

    .PARAMETER RefreshToken 
    Parameter to specify the refresh token of the external web service. 
 
    .PARAMETER OauthUrl 
    Authentication URL of the external web service to obtain OAuth tokens. 

    .PARAMETER IncidentUrl 
    Incident URL of the external web service that is used to create incidents.
    
    .PARAMETER RefreshTokenExpiryInDays 
    Parameter to specify the number of days after which the refresh token will expire.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Add-HPECOMExternalService -Name MyServiceNow -Region eu-central -Description "This is my description" -Credential $credential -RefreshToken "541646646434684343" -OauthUrl "https://example.service-now.com/oauth_token.do" -IncidentUrl "https://example.service-now.com/api/now/import/u_demo_incident_inbound_api" -refreshTokenExpiryInDays 100 
    
    Create a ServiceNow integration in the central EU region. 

    .INPUTS
    Pipeline input is not supported

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be deployed
        * Region - Name of the region where the external service is deployed
        * Status - Status of the deployment attempt (Failed for http error return; Complete if deployment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [String]$ServiceType = "SERVICE_NOW",

        [String]$AuthenticationType = "OAUTH",

        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Description,

        [Parameter (Mandatory)]
        [PSCredential]$Credential,

        [Parameter (Mandatory)]
        [String]$RefreshToken,

        [Parameter (Mandatory)]
        [String]$OauthUrl,

        [Parameter (Mandatory)]
        [String]$IncidentUrl,

        [Parameter (Mandatory)]
        [ValidateRange(100, 365)]
        [Int]$RefreshTokenExpiryInDays,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMExternalServicesUri  
        $DeployExternalServiceStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $ExternalServiceResource = Get-HPECOMExternalService -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($ExternalServiceResource) {
            Throw "Error! '$Name' external service already exists in '$Region' region!"

        }
                     
        $ClientID = $Credential.UserName
        $clientSecret = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password))

        $Authentication = @{
            clientId     = $ClientID
            clientSecret = $clientSecret
            refreshToken = $RefreshToken
        }

        $ServiceData = @{
            oauthUrl                 = $OauthUrl
            incidentUrl              = $IncidentUrl
            refreshTokenExpiryInDays = $refreshTokenExpiryInDays
        }

        # Build payload
        $payload = ConvertTo-Json @{
            name               = $Name
            serviceType        = $ServiceType 
            authenticationType = $authenticationType
            description        = $Description
            authentication     = $Authentication
            serviceData        = $ServiceData
        }

        # Deploy the external service. 
        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 

            
            if (-not $WhatIf) {

                "[{0}] External service creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                do {
                    $ExternalService_status = (Get-HPECOMExternalService -Region $Region | Where-Object name -eq $Name ).status
                    Start-Sleep 1
                } until ($ExternalService_status -eq "ENABLED")
                
                "[{0}] External service '{1}' successfully deployed in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "External service successfully deployed in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be deployed!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           


        [void] $DeployExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($DeployExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more external services failed the deployment attempt!"
          
            }
            
            Return $DeployExternalServiceStatus
        }


    }
}

Function Remove-HPECOMExternalService {
    <#
    .SYNOPSIS
    Remove a ServiceNow application in a region.

    .DESCRIPTION
    This Cmdlet can be used to remove the ServiceNow application in a region.    
        
    .PARAMETER Name 
    Name of the ServiceNow application to remove. 
    
    .PARAMETER Region 
    Name of the region where to remove ServiceNow. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMExternalService -Region eu-central -Name 'MyServiceNow_Name' 
    
    Remove the ServiceNow integration from the central EU region. 

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name  | Remove-HPECOMExternalService 

    Remove the ServiceNow integration 'MyServiceNow_Name' from the central EU region. 

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central | Remove-HPECOMExternalService 

    Remove from the central EU region all external services returned by the 'Get-HPECOMExternalService' cmdlet. 

    .INPUTS
    System.Collections.ArrayList
        List of external service(s) from 'Get-HPECOMExternalService'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be removed
        * Region - Name of the region where the external service is removed
        * Status - Status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveExternalServiceStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
            $ExternalServicesResource = Get-HPECOMExternalService -Region $Region -Name $Name
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $ExternalServiceID = $ExternalServicesResource.id
        
        if (-not $ExternalServiceID) {
            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "External service '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be found in the Compute Ops Management instance!"
            }
        }
        else {
            
            $Uri = $COMExternalServicesUri + "/" + $ExternalServiceID

            # Deploy the external service. 
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] External service removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] External service '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External service successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External service cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more external services has failed!"

          
            }
            
            Return $RemoveExternalServiceStatus
        }


    }
}

Function Set-HPECOMExternalService {
    <#
    .SYNOPSIS
    Updates an external services item in a specified region.

    .DESCRIPTION
    This Cmdlet modifies the ServiceNow application settings in a specified region. If a parameter is not provided, the cmdlet retains the current setting and only updates the provided parameters.
            
    .PARAMETER Name 
    Specifies the name of the external web service to update. 

    .PARAMETER NewName
    Specifies the new name for the external web service.
        
    .PARAMETER Region 
    Specifies the name of the region where the external web service is located. 

    .PARAMETER Description 
    Specifies a description for the external web service. 

    .PARAMETER Credential 
    Specifies the credentials (clientID and client secret) of the external web service. 

    .PARAMETER RefreshToken 
    Specifies the refresh token of the external web service. 
    
    .PARAMETER OauthUrl 
    Specifies the authentication URL of the external web service used to obtain OAuth tokens. 

    .PARAMETER IncidentUrl 
    Specifies the incident URL of the external web service that is used to create incidents.
        
    .PARAMETER RefreshTokenExpiryInDays 
    Specifies the number of days after which the refresh token will expire.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request, useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name -NewName MyServiceNow_for_COM -Description "This is my new description" -Credential $credentials -RefreshToken "541646646434684343" 

    Updates the external service 'MyServiceNow_Name' in the 'eu-central' region with a new name 'MyServiceNow_for_COM' and a new description.
    
    .EXAMPLE
    Set-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name -Description "This is my new description" -Credential $credential -RefreshToken "541646646434684343" -OauthUrl "https://example.service-now.com/oauth_token.do" -IncidentUrl "https://example.service-now.com/api/now/import/u_demo_incident_inbound_api" -RefreshTokenExpiryInDays 200
        
    Updates the external service 'MyServiceNow_Name' in the central EU region with new parameters.

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name | Set-HPECOMExternalService -Description "This is my new description" -Credential $credential -RefreshToken "541646646434684343" -OauthUrl "https://example.service-now.com/oauth_token.do" -IncidentUrl "https://example.service-now.com/api/now/import/u_demo_incident_inbound_api" -RefreshTokenExpiryInDays 150

    Updates the external service 'MyServiceNow_Name' in the central EU region with new parameters.

    .INPUTS
    System.Collections.ArrayList
        List of external service(s) from 'Get-HPECOMExternalService'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be updated
        * Region - Name of the region where the external service is updated
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if modification is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,

        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Description,

        [Parameter (Mandatory)]
        [PSCredential]$Credential,

        [Parameter (Mandatory)]
        [String]$RefreshToken,

        # [Parameter (Mandatory)]
        [String]$OauthUrl,

        # [Parameter (Mandatory)]
        [String]$IncidentUrl,

        # [Parameter (Mandatory)]
        [ValidateRange(100, 365)]
        [Int]$RefreshTokenExpiryInDays,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetExternalServiceStatus = [System.Collections.ArrayList]::new()

        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
            
            $ExternalServicesResource = Get-HPECOMExternalService -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        $ExternalServiceID = $ExternalServicesResource.id

        
        if (-not $ExternalServiceID) {
            # Must return a message if not found
            if ($WhatIf) {
                            
                $ErrorMessage = "External service '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord ExternalServiceNotFoundInCOM ObjectNotFound -TargetObject 'ExternalService' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be found in the HPE GreenLake workspace!"
            }
        }
        else {
            
            $Uri = $COMExternalServicesUri + "/" + $ExternalServiceID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }
                       
            if (-not $PSBoundParameters.ContainsKey('Description')) {
	
                if ($ExternalServicesResource.description) {
                       
                    $Description = $ExternalServicesResource.description

                }
                else {
                    $Description = $Null
                }
            }


            if (-not $OauthUrl) {
                $OauthUrl = $ExternalServicesResource.serviceData.oauthUrl
            }

            if (-not $IncidentUrl) {
                $IncidentUrl = $ExternalServicesResource.serviceData.incidentUrl
            }

            if (-not $refreshTokenExpiryInDays) {
                $refreshTokenExpiryInDays = $ExternalServicesResource.serviceData.refreshTokenExpiryInDays
            }

            # Deploy the external service. 
                     
            $ClientID = $Credential.UserName
            $clientSecret = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Credential.Password))

            $Authentication = @{
                clientId     = $ClientID
                clientSecret = $clientSecret
                refreshToken = $RefreshToken
            }



            $ServiceData = @{
                oauthUrl                 = $OauthUrl
                incidentUrl              = $IncidentUrl
                refreshTokenExpiryInDays = $refreshTokenExpiryInDays
            }

            # Build payload
            $payload = ConvertTo-Json @{
                name           = $Name
                state          = "ENABLED"
                description    = $Description
                authentication = $Authentication
                serviceData    = $ServiceData
            }

        

            # Deploy the external service. 
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] External service update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] External service '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External service successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External service cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $SetExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more external service failed the update attempt!"
          
            }
            
            Return $SetExternalServiceStatus
        }


    }
}

Function Test-HPECOMExternalService {
    <#
    .SYNOPSIS
    Generate a test incident for ServiceNow in a region.

    .DESCRIPTION
    This Cmdlet can be used to generate a test incident for ServiceNow in a region. 
    An activity will be generated as a result of this test and indicates the success or failure of creating the test incident.   
        
    .PARAMETER Name 
    Name of the external web service to update. 
    
    .PARAMETER Region 
    Name of the region to update the external web service. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Test-HPECOMExternalService -Region eu-central -Name MyServiceNow_Name
    
    Generate a test incident for ServiceNow.

    .EXAMPLE
    Get-HPECOMExternalService -Region eu-central | Test-HPECOMExternalService -Region eu-central 

    Generate a test incident for ServiceNow.

    .INPUTS
    System.Collections.ArrayList
        List of external service(s) from 'Get-HPECOMExternalService'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the external service attempted to be tested
        * Region - Name of the region where the external services is tested
        * Status - Status of the testing attempt (Failed for http error return; Complete if testing is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $TestExternalServiceStatus = [System.Collections.ArrayList]::new()

        $ExternalServicesList = Get-HPECOMExternalService -Region $Region

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        $ExternalServiceID = ($ExternalServicesList | Where-Object name -eq $Name).id

        
        if (-not $ExternalServiceID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "External service '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord ExternalServiceNotFoundInCOM ObjectNotFound -TargetObject 'ExternalService' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "External service cannot be found in the Compute Ops Management instance!"
            }

        }
        else {
            
            $Uri = $COMExternalServicesUri + "/" + $ExternalServiceID + "/test"

            # Generate a test incident 
                     
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] External service test raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Test incident '{1}' has been successfully generated for ServiceNow in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Test incident has been successfully generated for ServiceNow in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Test incident cannot be generated for ServiceNow"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $TestExternalServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($TestExternalServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more ServiceNow test attempts failed!"
          
            }
            
            Return $TestExternalServiceStatus
        }


    }
}

#EndRegion


#Region --- FILTERS ---

Function Get-HPECOMFilter {
    <#
    .SYNOPSIS
    Retrieve the list of saved filter resources.

    .DESCRIPTION
    This Cmdlet returns a collection of saved filters that have been saved in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name 
    Optional parameter that can be used to specify the name of a saved filter to display.

    .PARAMETER MatchingResources 
    Optional switch parameter that can be used with -Name to get ressources matching a saved filter.

    .PARAMETER Filterableproperties 
    Optional switch parameter that can be used to get information about resource properties usable in saved filters.
   
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMFilter -Region eu-central

    Return all saved filter resources located in the central european region. 

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name gen11 

    Return the saved filter resource named 'gen11' located in the Central European region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name gen11 -MatchingResources 

    Return all ressources matching the saved filter named 'gen11'.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Filterableproperties 

    Return information about resource properties usable in saved filters. 

    .INPUTS
    No pipeline support

   
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (Mandatory, ParameterSetName = 'MatchingResources')]
        [String]$Name,

        [Parameter (ParameterSetName = 'MatchingResources')]
        [Switch]$MatchingResources,

        [Parameter (ParameterSetName = 'Filterableproperties')]
        [Switch]$Filterableproperties,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      
        
        if ($Filterableproperties) {
            $Uri = $COMFiltersUri + "/properties"
            
        }
        elseif ($MatchingResources) {

            $Uri = $COMFiltersUri

            try {
                [Array]$FilterList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                $FilterID = $FilterList | Where-Object { $_.name -eq $Name } | ForEach-Object id

                "[{0}] ID found for filter '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $FilterID | Write-Verbose

                if ($Null -eq $FilterID) { Throw "Filter with this name cannot be found!" }

                $Uri = $COMFiltersUri + "/" + $FilterID + "/matches"


            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        else {
            $Uri = $COMFiltersUri
            
        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            if ($name -and -not $MatchingResources) {

                $CollectionList = $CollectionList | Where-Object name -eq $Name

            }   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
          
            if ($MatchingResources) {
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Filters.MatchingResources"    
                
            }
            elseif ($Filterableproperties) {
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Filters.Filterableproperties"    
                
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Filters"    
    
                $ReturnData = $ReturnData | Sort-Object name
            }

            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function New-HPECOMFilter {
    <#
    .SYNOPSIS
    Create a new saved filter resource in a region.

    .DESCRIPTION
    This Cmdlet can be used to create a new saved filter.    
        
    .PARAMETER Name 
    Name of the external web service to deploy. 
    
    .PARAMETER Region 
    Name of the region to deploy the external web service. 

    .PARAMETER Filter  
    Parameter to specify a server filter expression such as "serverGeneration eq 'GEN_11'", "state/connected eq 'false"
    The filter grammar is a subset of OData 4.0 using 'eq', 'ne', 'gt', 'ge', 'lt', 'le' and 'in' operations 
    and 'and', 'or' logics.

    Servers can be filtered by:
        - biosFamily
        - createdAt
        - firmwareBundleUri
        - hardware and all nested properties
        - host and all nested properties
        - id
        - name
        - oneview and all nested properties
        - platformFamily
        - processorVendor
        - resourceUri
        - serverGeneration
        - state and all nested properties
    
        See https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/openapi/compute-ops-mgmt-latest/operation/get_v1beta2_servers/#tag/servers-v1beta2/operation/get_v1beta2_servers!in=query&path=filter&t=request

    
    .PARAMETER FilterTags 
    Parameter to specify a tag filter expression such as 'Location' eq 'Houston', 'App' eq 'RHEL'.
    
    .PARAMETER Description 
    Optional parameter to describe the filter. 
    
    .PARAMETER EnabledForRRP
    Parameter to Flag the filter for use with scope-based access control (SBAC) used by resource restriction policies in HPE GreenLake.
    Only administrators with full access to all scopes can create, edit, or delete RRP-enabled filters. The use of some resource properties may be disallowed in RBAC-enabled filters.
 
    .PARAMETER DryRun 
    Switch parameter to not create the saved filter but instead to perform validation of the filter name and syntax as if creating the filter.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMFilter -Region us-west -Name Gen11 -EnabledForRRP -Description "Filter for Gen11 servers" -Filter "serverGeneration eq 'GEN_11'"
    
    Create a new saved filter named 'Gen11' in the central western US region using the property 'serverGeneration' equal to 'GEN_11'" to create the filter. 
    Also flags the filter for use with resource restriction policies used by scope-based access control (SBAC) (can be created using New-HPEGLResourceRestrictionPolicy).

    .EXAMPLE
    New-HPECOMFilter -Region us-west -Name Gen11-RHEL-Workload-Dev -Filter "serverGeneration in ('GEN_11') and host/osName in ('Red Hat Enterprise Linux')" -FilterTags "'Workload' eq 'Dev' and 'Location' eq 'Paris'" 
    
    Create a new saved filter named 'Gen11-RHEL-Workload-Dev' in the central western US region using multiple filters properties and multiple filter tags properties to create the filter. 
    
    .EXAMPLE
    New-HPECOMFilter -Region us-west -Name Powered-Off-servers -Filter "hardware/powerState eq 'OFF'" -DryRun

    Perform validation of the filter name and syntax of a new filter using the property 'hardware/powerState' equal to 'OFF'". 

    .INPUTS
    Pipeline input is not supported

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the filter attempted to be created
        * Region - Name of the region where to create the filter
        * Status - Status of the creation attempt (Failed for http error return; Complete if creation is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,
        
        [Parameter (Mandatory)] 
        [String]$Filter,
        
        [String]$FilterTags,
        
        [String]$Description,
        
        [switch]$EnabledForRRP,
     
        [switch]$DryRun,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $CreateFilterStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($DryRun) {
            $Uri = $COMFiltersUri + "?dry-run=true"
        }
        else {
            $Uri = $COMFiltersUri
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $FilterResource = Get-HPECOMFilter -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($FilterResource) {
            Throw "Error! '$Name' filter already exists in the COM '$Region' region!"

        }

                     
        # Build payload
        if ($FilterTags -and -not $Filter) {

            $payload = ConvertTo-Json @{
                name               = $Name
                description        = $Description
                filterResourceType = "compute-ops-mgmt/server"
                enabledForRRP      = [bool]$EnabledForRRP
                filterTags         = $FilterTags
            }
        }
        elseif ($FilterTags -and $Filter) {

            $payload = ConvertTo-Json @{
                name               = $Name
                description        = $Description
                filterResourceType = "compute-ops-mgmt/server"
                enabledForRRP      = [bool]$EnabledForRRP
                filterTags         = $FilterTags
                filter             = $Filter
            }
        }
        else {

            $payload = ConvertTo-Json @{
                name               = $Name
                description        = $Description
                filterResourceType = "compute-ops-mgmt/server"
                enabledForRRP      = [bool]$EnabledForRRP
                filter             = $Filter
            }
            
        }

        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 

            
            if (-not $WhatIf) {

                "[{0}] Filter creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Filter '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Filter successfully created in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Filter cannot be created!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           


        [void] $CreateFilterStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($CreateFilterStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more filters failed the creation attempt!"
          
            }
            
            Return $CreateFilterStatus
        }


    }
}


Function Remove-HPECOMFilter {
    <#
    .SYNOPSIS
    Removes a saved filter resource from a specified region.

    .DESCRIPTION
    This Cmdlet removes a saved filter resource from a specific region using its name property.

    .PARAMETER Name 
    The name of the saved filter to remove. 

    .PARAMETER Region 
    The name of the region where the saved filter should be removed.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of executing the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMFilter -Region eu-central -Name 'Gen11' 
    
    Removes the saved filter named 'Gen11' from the central EU region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name 'Gen-11-Filter' | Remove-HPECOMFilter 

    Removes the filter 'Gen-11-Filter' from the western US region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west | Where-Object {$_.name -eq 'Gen10-Workload-Dev' -or $_.name -eq 'Gen11-Workload-Dev'} | Remove-HPECOMFilter 

    Removes the filters 'Gen10-Workload-Dev' and 'Gen11-Workload-Dev' from the western US region.

    .EXAMPLE
    Get-HPECOMFilter -Region eu-central | Remove-HPECOMFilter 

    Removes all filters from the central EU region.

    .INPUTS
    System.Collections.ArrayList
        A list of filters retrieved from 'Get-HPECOMFilter'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following properties:  
        * Name - The name of the filter attempted to be removed.
        * Region - The name of the region where the filter was removed.
        * Status - The status of the removal attempt (Failed for HTTP error; Complete if removal is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveFilterStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
              

        try {
            $FiltersResource = Get-HPECOMFilter -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $FilterID = $FiltersResource.id

        
        if (-not $FilterID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Filter '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Filter cannot be found in the Compute Ops Management instance!"
            }

        }
        else {
            
            $Uri = $COMFiltersUri + "/" + $FilterID

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Filter removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Filter '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Filter successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveFilterStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveFilterStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more filters has failed!"

          
            }
            
            Return $RemoveFilterStatus
        }


    }
}


Function Set-HPECOMFilter {
    <#
    .SYNOPSIS
    Update a filter resource in a specified region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.

    .DESCRIPTION
    This cmdlet modifies a filter resource in a specific region.

    .PARAMETER Name 
    The name of the filter to update. 

    .PARAMETER Region 
    The name of the region where the filter will be updated.

    .PARAMETER NewName 
    Specifies the new name of the filter.

    .PARAMETER Filter  
    Specifies a filter expression such as "serverGeneration eq 'GEN_11'" or "state/connected eq 'false'".
    The filter grammar is a subset of OData 4.0 using 'eq', 'ne', 'gt', 'ge', 'lt', 'le' and 'in' operations,
    and 'and', 'or' logics.

    Servers can be filtered by:
    - `biosFamily`
    - `createdAt`
    - `firmwareBundleUri`
    - `hardware` and all nested properties
    - `host` and all nested properties
    - `id`
    - `name`
    - `oneview` and all nested properties
    - `platformFamily`
    - `processorVendor`
    - `resourceUri`
    - `serverGeneration`
    - `state` and all nested properties

    For more information, see [HPE GreenLake Documentation](https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/openapi/compute-ops-mgmt-latest/operation/get_v1beta2_servers/#tag/servers-v1beta2/operation/get_v1beta2_servers!in=query&path=filter&t=request).

    .PARAMETER FilterTags 
    Optional. Specifies a filter expression for tags such as "'Location' eq 'Houston'", "'App' eq 'RHEL'", or "'OS' eq 'Linux'".

    .PARAMETER Description 
    Optional. Describes the filter.

    .PARAMETER EnabledForRRP
    Boolean. Flags the filter for use with resource restriction policies used by scope-based access control (SBAC). Only administrators with full access to all scopes can create, edit, or delete RRP-enabled filters. The use of some resource properties may be disallowed in RRP-enabled filters.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMFilter -Region us-west -Name Gen11 -EnabledForRRP:$True -NewName Gen11-servers

    Changes the name of the filter named 'Gen11' to 'Gen11-servers' in the western US region and enables it for resource restriction policy.

    .EXAMPLE
    Set-HPECOMFilter -Region us-west -Name Gen11-Workload-Dev -FilterTags "'Workload-Dev' eq 'Dev' and 'Discover' eq 'Demo'"

    Changes the filter expression for tags of a filter named 'Gen11-Workload-Dev' in the western US region.

    .EXAMPLE
    Get-HPECOMFilter -Region us-west -Name Gen11-Workload-Dev | Set-HPECOMFilter -Filter "hardware/powerState eq 'OFF'" -Description "My filter for Gen11 servers"

    Gets the filter named 'Gen11-Workload-Dev' in the western US region and modifies its filter and description properties.

    .INPUTS
    System.Collections.ArrayList
    List of filter(s) from 'Get-HPECOMFilter'.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
    - **Name**: Name of the filter attempted to be updated.
    - **Region**: Name of the region where the filter is updated.
    - **Status**: Status of the modification attempt (`Failed` for HTTP error return; `Complete` if modification is successful; `Warning` if no action is needed).
    - **Details**: More information about the status.
    - **Exception**: Information about any exceptions generated during the operation.

    #>


    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,

        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 2000 })]
        [String]$Filter,
        
        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 2000 })]
        [String]$FilterTags,
        
        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 10000 })]
        [String]$Description,

        [Parameter (ValueFromPipelineByPropertyName)] 
        [bool]$EnabledForRRP,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetFilterStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $FilterResource = Get-HPECOMFilter -Region $Region -Name $Name
            $FilterID = $FilterResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        "[{0}] Filter ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $FilterID | Write-Verbose
       
        if (-not $FilterID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Filter '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord FilterNotFoundInCOM ObjectNotFound -TargetObject 'Filter' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Filter cannot be found in the Compute Ops Management instance!"
            }
        }
        else {
            
            $Uri = $COMFiltersUri + "/" + $FilterID
            
            $Payload = @{}
            $Payload.filterResourceType = "compute-ops-mgmt/server"


            # Conditionally add properties
            if ($NewName) {
                $Payload.name = $NewName
            }
            else {
                $Payload.name = $Name
                
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
                if ($FilterResource.description) {
                    $Payload.description = $FilterResource.description

                }
                else {
                    $Payload.description = $Null
                }
            }
            else {
                $Payload.description = $Description
            }


            if (-not $PSBoundParameters.ContainsKey('EnabledForRRP')) {
                $Payload.enabledForRRP = $FilterResource.enabledForRRP
            }
            else {
                $Payload.enabledForRRP = [bool]$EnabledForRRP
            }


            if (-not $PSBoundParameters.ContainsKey('FilterTags')) {
                if ($FilterResource.filterTags) {
                    $Payload.filterTags = $FilterResource.filterTags
                }
                # No need to add 'FilterTags' with a null value if not set
                # else {
                #     $Payload.filterTags = $Null
                # }
            }
            else {
                $Payload.filterTags = $FilterTags
            }


            if (-not $PSBoundParameters.ContainsKey('Filter')) {
                if ($FilterResource.filter) {
                    $Payload.filter = $FilterResource.filter
                }
                # Filter cannot be $Null
            }
            else {
                $Payload.filter = $Filter
                
            }
            

            # Convert the hashtable to JSON
            $jsonPayload = $Payload | ConvertTo-Json


            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $jsonPayload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Filter update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Filter '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Filter successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $SetFilterStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetFilterStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more filter failed the update attempt!"
          
            }
            
            Return $SetFilterStatus
        }


    }
}

#EndRegion


#Region --- FIRMWARE BUNDLES ---

Function Get-HPECOMFirmwareBundle {
    <#
    .SYNOPSIS
    Retrieve the list of firmware bundles.

    .DESCRIPTION
    This Cmdlet returns a collection of firmware bundles that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER ReleaseVersion 
    Optional parameter that can be used to specify the release version of firmware bundles to display such as '2024', '2023', '2023.10'.

    .PARAMETER IsActive 
    Optional switch parameter that can be used to only get the supported firmware bundles.

    .PARAMETER BundleType 
    Optional parameter parameter that can be used to specify the bundle type of firmware bundles to display such as 'BASE', 'PATCH' and 'HOTFIX'. 

    .PARAMETER Generation 
    Optional parameter parameter that can be used to specify the server generation of firmware bundles to display such as '10', '11'... 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region us-west 

    Return all firmware bundles resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region us-west -BundleType BASE  

    Return all firmware bundles type base resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMFirmwareBundle -Region us-west -ReleaseVersion 2023 -IsActive

    Return all firmware bundles resources that are active (supported) from 2023. 

    .INPUTS
    No pipeline support

   
    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$ReleaseVersion,

        [Switch]$IsActive,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('BASE', 'PATCH', 'HOTFIX')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('BASE', 'PATCH', 'HOTFIX')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]            
        [String]$BundleType,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @('10', '11', '12')
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('10', '11', '12')]
        [String]$Generation,


        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      
        
        $Uri = $COMFirmwareBundlesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            if ($ReleaseVersion) {

                $CollectionList = $CollectionList | Where-Object releaseVersion -eq $ReleaseVersion

            }   
            if ($IsActive) {

                $CollectionList = $CollectionList | Where-Object isActive -match $IsActive

            }   
            if ($Generation) {

                $CollectionList = $CollectionList | Where-Object bundleGeneration -match $Generation

            }   
            if ($BundleType) {

                $CollectionList = $CollectionList | Where-Object bundleType -match $BundleType

            }   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
          
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.FirmwareBundles"    
    
            # $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- GROUPS ---

Function Get-HPECOMGroup {
    <#
    .SYNOPSIS
    Retrieve the list of groups.

    .DESCRIPTION
    This Cmdlet returns a collection of groups that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Optional parameter that can be used to specify the name of a group to display.

    .PARAMETER ShowCompliance
    Optional switch parameter that can be used to get a specific device compliance detail of a group.

    .PARAMETER ShowMembers
    Optional parameter that can be used to obtain a list of servers that are members of the designated group. 

    .PARAMETER ShowPolicies
    Optional parameter that can be used to obtain a list of policies that are assigned to the designated group.
    
    .PARAMETER ShowSettings
    Optional parameter that can be used to obtain a list of server settings that are assigned to the designated group. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMGroup -Region us-west

    Return all groups resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name DLV24-ESX8-Mgmt-Cluster

    Return the group resource named 'DLV24-ESX8-Mgmt-Cluster' located in the western US region. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name DLV24-ESX8-Mgmt-Cluster -ShowCompliance

    Return the device compliance details of the group resource named 'DLV24-ESX8-Mgmt-Cluster'. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name Hypervisors -ShowMembers

    Return the list of servers that are members of the group 'Hypervisors'.

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name Hypervisors -ShowSettings

    Return the list of server settings that are assigned to the group 'Hypervisors'.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_group -ShowPolicies

    Return the list of policies that are assigned to the group 'ESXi_group'.
    
    .INPUTS
    No pipeline support   
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (Mandatory, ParameterSetName = 'ShowMembers')]
        [Parameter (Mandatory, ParameterSetName = 'Compliance')]
        [Parameter (Mandatory, ParameterSetName = 'ShowSettings')]
        [Parameter (Mandatory, ParameterSetName = 'ShowPolicies')]
        [String]$Name,

        [Parameter (ParameterSetName = 'Compliance')]
        [Switch]$ShowCompliance,

        [Parameter (ParameterSetName = 'ShowMembers')]
        [Switch]$ShowMembers,
        
        [Parameter (ParameterSetName = 'ShowPolicies')]
        [Switch]$ShowPolicies,
                
        [Parameter (ParameterSetName = 'ShowSettings')]
        [Switch]$ShowSettings,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
        if ($Filterableproperties) {
            $Uri = $COMGroupsUri + "/properties"
            
        }
        elseif ($ShowMembers -or $ShowCompliance) {

            $Uri = $COMGroupsUri + "?filter=name eq '$name'"

            try {
                $GroupID = (Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region).id

                "[{0}] ID found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $GroupID | Write-Verbose

                if ($Null -eq $GroupID) { 
                    # Write-warning "Group '$name' cannot be found in the Compute Ops Management instance!" 
                    return
                }

                if ($ShowCompliance) {
                    $Uri = $COMGroupsUri + "/" + $GroupID + "/compliance"
                }

                if ($ShowMembers) {
                    $Uri = $COMGroupsUri + "/" + $GroupID + "/devices"
                }
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        elseif ($Name) {

            $Uri = $COMGroupsUri + "?filter=name eq '$name'" 
        }
        else {
            $Uri = $COMGroupsUri
            
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
      
        if ($Null -ne $CollectionList) {   
            
            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
                       
            if ($ShowCompliance) {
                
                # Add groupName, servername and serialNumber (only serial is provided)
                # groupName is used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. 
                Foreach ($Item in $CollectionList) {

                    try {
                        $ServerName = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serial                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    $Item | Add-Member -type NoteProperty -name groupName -value $Name
                    $Item | Add-Member -type NoteProperty -name serialNumber -value $Item.serial
                    $item | Add-Member -Type NoteProperty -Name serverName -Value $ServerName.name
                    
                }

                $CollectionList = $CollectionList | sort serverName
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance"    

            }
            elseif ($ShowMembers) {

                # Add groupName, servername and serialNumber (only serial is provided)
                # groupName is used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. 
                Foreach ($Item in $CollectionList) {

                    try {
                        $ServerName = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serial                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    $Item | Add-Member -type NoteProperty -name groupName -value $Name
                    $Item | Add-Member -type NoteProperty -name serialNumber -value $Item.serial
                    $item | Add-Member -Type NoteProperty -Name serverName -Value $ServerName.name
                    
                }

                $CollectionList = $CollectionList | sort serverName
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Members"    

            }
            elseif ($ShowSettings) {

                $_CollectionList = [System.Collections.ArrayList]::new()

                $_Settings = Get-HPECOMSetting -Region $Region 

                foreach ($SettingUri in $CollectionList.settingsUris) {

                    "[{0}] Setting uri found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $SettingUri | Write-Verbose

                    $_serversetting = $_Settings | Where-Object resourceUri -eq $SettingUri

                    "[{0}] Setting found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serversetting.name | Write-Verbose

                    [void]$_CollectionList.add($_serversetting)
                }

                # Add groupName to object (used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. )
                $_CollectionList | Add-Member -type NoteProperty -name groupName -value $Name

                $_CollectionList = $_CollectionList | sort name
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $_CollectionList -ObjectName "COM.Settings"    

            }
            elseif ($ShowPolicies) {

                $ListOfGroupSettingCategories = [System.Collections.ArrayList]::new()

                $_Settings = Get-HPECOMSetting -Region $Region 

                foreach ($SettingUri in $CollectionList.settingsUris) {

                    "[{0}] Setting uri found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $SettingUri | Write-Verbose

                    $_serversetting = $_Settings | Where-Object resourceUri -eq $SettingUri

                    "[{0}] Setting found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serversetting.name | Write-Verbose

                    $SettingCategoryFound = $_serversetting.category
                        
                    [void]$ListOfGroupSettingCategories.add($SettingCategoryFound)

                    "[{0}] List of category settings found: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ListOfGroupSettingCategories | out-string) | Write-Verbose

                }

                # Removing the firmwareDowngrade property (deprecated) as it is now in OnDeviceApply policy
                $ReturnData = $CollectionList.policies
  
                $PoliciesList = [System.Collections.ArrayList]::new()

                # BIOS
                if ($ListOfGroupSettingCategories -like 'BIOS') {      

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {    
                        if ($item.name -eq "biosApplySettings") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply BIOS setting when server is added to the group"
                                Setting  = $item.value
                                Category = "BIOS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -eq "biosFactoryReset") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Reset BIOS configuration settings to defaults"
                                Setting  = $item.value
                                Category = "BIOS"
                            }
                        
                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # EXTERNAL_STORAGE
                if ($ListOfGroupSettingCategories -like 'EXTERNAL_STORAGE') {
                    
                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {

                        if ($item.name -eq "externalStorageConfiguration") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply external storage setting when server is added to the group"
                                Setting  = $item.value
                                Category = "EXTERNAL_STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # FIRMWARE
                if ($ListOfGroupSettingCategories -like 'FIRMWARE') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {
                        if ($item.name -eq "firmwareUpdate") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply firmware baseline when server is added to the group"
                                Setting  = $item.value
                                Category = "FIRMWARE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -eq "firmwarePowerOff") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Power off server after firmware update"
                                Setting  = $item.value
                                Category = "FIRMWARE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                    foreach ($item in $ReturnData.onDeviceApply.psobject.properties) {

                        if ($item.name -eq "firmwareDowngrade") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Downgrade components to match baseline"
                                Setting  = $item.value
                                Category = "FIRMWARE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # ILO
                if ($ListOfGroupSettingCategories -like 'ILO_SETTINGS') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {

                        if ($item.name -eq "iloApplySettings") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply iLO settings when server is added to the group"
                                Setting  = $item.value
                                Category = "ILO_SETTINGS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                # OS
                if ($ListOfGroupSettingCategories -like 'OS') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {
                        
                        if ($item.name -like "osInstall") {
                      
                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto install operating system when a server is added to the group"
                                Setting  = $item.value
                                Category = "OS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -like "osCompletionTimeoutMin") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "OS install completion timeout"
                                Setting  = $item.value
                                Category = "OS"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
                
                if ($ListOfGroupSettingCategories -like 'STORAGE') {

                    foreach ($item in $ReturnData.onDeviceAdd.psobject.properties) {
                        if ($item.name -like "storageConfiguration") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Auto apply storage setting when server is added to the group"
                                Setting  = $item.value
                                Category = "STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -like "storageVolumeDeletion") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Erase existing internal storage configuration when server is added to the group"
                                Setting  = $item.value
                                Category = "STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                        if ($item.name -like "storageVolumeName") {

                            $Policy = [PSCustomObject]@{
                                Policy   = "Volume label name when server is added to the group"
                                Setting  = $item.value
                                Category = "STORAGE"
                            }

                            [void]$PoliciesList.add($Policy)
                        }
                    }
                }
               
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $PoliciesList -ObjectName "COM.Groups.Policies"    
                $ReturnData = $ReturnData | Sort-Object Category, policy
               
            }
            else {

                # Add groupName to object (used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. )
                foreach ($item in $CollectionList) {
                    $item | Add-Member -MemberType NoteProperty -Name groupName -Value $item.name
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups"    
                $ReturnData = $ReturnData | Sort-Object name
            }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function New-HPECOMGroup {
    <#
    .SYNOPSIS
    Create a new group resource in a region.

    .DESCRIPTION
    This Cmdlet can be used to create a new group. Alternatively, it can create a new group using the settings and group policies of an existing group.
        
    .PARAMETER Name 
    Name of the group to create. 
    
    .PARAMETER Region 
    Name of the region where to create the group. 

    .PARAMETER Description 
    Optional parameter to describe the group. 

    .PARAMETER DeviceType
    Specifies the type of device to be added to the group. Servers is the only supported device type at the moment.

    .PARAMETER SettingsObject
    Specifies the server settings to assign to the group. The settings object must be retrieved from 'Get-HPECOMSetting -Region $Region'.

    .PARAMETER BiosSettingName
    Name of a bios server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Bios'.

    .PARAMETER ExternalStorageSettingName
    Name of an external storage server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category ExternalStorage'.

    .PARAMETER FirmwareSettingName
    Name of a firmware server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Firmware'.

    .PARAMETER OSSettingName
    Name of an OS server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Os'.

    .PARAMETER StorageSettingName
    Name of a storage server settings resource to assign to the group from 'Get-HPECOMSetting -Region $Region -Category Storage'.

    .PARAMETER EnableiLOSettingsForSecurity 
    Switch to enable iLO settings in the group that reduce the overall security risk of a server. This switch applies the HPE-recommended security settings for iLOs.
    
    .PARAMETER AutoBiosApplySettingsOnAdd
    Enable automatic application of BIOS settings when a server is added to a group. 
    A server group must have one of the HPE pre-defined BIOS/Workload profiles to allow the auto apply of BIOS settings.
    Note: This parameter is effective only when a bios server setting is defined in the group.

    .PARAMETER ResetBIOSConfigurationSettingsToDefaultsonAdd
    Reset BIOS configuration settings to defaults when a server is added to a group.
    Note: This parameter is effective only when a bios server setting is defined in the group.

    .PARAMETER AutoFirmwareUpdateOnAdd
    Enable automatic firmware updates to the configured baseline when a server is added to a group. 
    Note: This parameter is effective only when a firmware server setting is defined in the group.
    
    .PARAMETER PowerOffServerAfterFirmwareUpdate
    Power off server after firmware update is performed.
    Note: This parameter is effective only when a firmware server setting is defined in the group.

    .PARAMETER FirmwareDowngrade
    Allow or forbid downgrade of a firmware when firmware update is performed.
    Note: This parameter is effective only when a firmware server setting is defined in the group.

    .PARAMETER AutoOsImageInstallOnAdd
    When a server is added to the group, install the operating system image immediately if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when an OS server setting is defined in the group.
    
    .PARAMETER OsCompletionTimeoutMin
    When a server is added to the group and automatic install of operating system is enabled, this property sets the amount of time (in minutes) the operating system 
    installation will be allowed to continue before it times out. The timeout specified is applicable for each individual server in the group.
    Note: This parameter is effective only when an OS server setting is defined in the group.
    
    .PARAMETER AutoStorageVolumeCreationOnAdd
    When server is added to the group, the OS volume will be created immediately if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when an OS server setting is defined in the group.
    
    .PARAMETER AutoStorageVolumeDeletionOnAdd
    When server is added to the group, any existing internal storage configuration will be erased prior to creating the new OS volume if the server 
    is activated or when the server is activated at a later time.
    Note: This parameter is effective only when a storage server setting is defined in the group.
    
    .PARAMETER StorageVolumeName
    When a server is added to the group, associate a name with the created volume if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when a storage server setting is defined in the group.
    
    .PARAMETER AutoIloApplySettingsOnAdd
    Enable automatic application of iLO settings when a server is added to a group. A server group must have HPE pre-defined 
    iLO settngs to allow the auto apply of iLO settings.
    Note: This parameter is effective only when an iLO settings server setting is defined in the group.

    .PARAMETER AutoExternalStorageConfigurationOnAdd
    When a server is added to the group, apply the external storage configuration immediately if the server is activated or when the server is activated at a later time.
    Note: This parameter is effective only when an external storage server setting is defined in the group.

    .PARAMETER TagUsedForAutoAddServer    
    Associates a case-insensitive tag with a group to automatically add servers to the group when they are activated. 
    
    The tag must meet the following string format <Name>=<Value> and can contain any alphaneumeric characters, any Unicode space separators, and the following characters: _ . : + - @ such as:
     - "Country=US"
     - "App=ESX-8"
     - "Site=Houston site"
     - "Domain=my.lab@domain.com"
    
    Note: 
        - A group can have a maximum of one tag and multiple groups can not have the same tag.
        - Automatic addition to groups can only occur before server activation. If a servers tags match more than one group, it wont be added to any group, and will need to be added using a different method.
        - When a server is onboarded or has its tags changed, the server's tags will be checked against the group's autoAddServerTags. 
        - If at least one of the server tags matches one group's autoAddServerTags, the server will be placed into the associated group. 
        - Once a server has been connected, the server becomes ineligible for automatically being placed into groups, even if it is later disconnected.
        - If a server is in a group, any further tag changes will not move it to another group. 
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE    
    New-HPECOMGroup -Name Hypervisors_Group -Region eu-central `
    -Description "My group for hypervisors"  `
    -BiosSettingName "Virtualization - Power Efficient" -FirmwareSettingName "ESXi_firmware_baseline_24_04_Gen10" -StorageSettingName "RAID1" `
    -AutoBiosApplySettingsOnAdd -AutoFirmwareUpdateOnAdd -AutoStorageVolumeCreationOnAdd `
    -FirmwareDowngrade -StorageVolumeName "OS_Boot_Volume" `
    -TagUsedForAutoAddServer "App=ESXi-802"
    
    Create a new server group named "Hypervisors_Group" in the "eu-central" region and provides a description for the group. 
    The command specifies settings for BIOS, firmware, and storage configurations. 
    It includes options to automatically apply BIOS, storage volume creation and firmware updates whenever a server is added to the group. 
    The command also allows for firmware downgrades when firmware update is performed in the group. 
    Additionally, it uses a specific tag for auto-adding servers to the group and specifies a storage volume name for the OS boot volume.
        
    .EXAMPLE
    $Settings = Get-HPECOMSetting -Region us-west | Where-Object {$_.name -eq "Firmware_Baseline" -or $_.name -eq "Virtualization - Power Efficient"}
    
    New-HPECOMGroup -Region us-west -Name Hypervisors_Group `
    -Description "My group for hypervisors" -SettingsObject $Settings `
    -AutoFirmwareUpdateOnAdd -AutoBiosApplySettingsOnAdd `
    -PowerOffServerAfterFirmwareUpdate -FirmwareDowngrade `
    -TagUsedForAutoAddServer "App=ESXi"

    Create a new group named 'Hypervisors_Group' in the central western US region using a list of bios and firmware settings URIs.  
    Set the group with automatic firmware update and Bios apply settings when a server is added to the group.
    Set also the group to power off server after firmware update is performed and allow firmware downgrade. 
    Set the "App=ESXi" tag so that any server defined with this tag during onboarding will automatically be added to this group.    

    .EXAMPLE
    $Settings = Get-HPECOMSetting -Region eu-central | ? { $_.name -eq "ESXi_firmware_baseline_24_04_Gen10" -or $_.name -eq "Virtualization - Power Efficient" -or $_.name -eq "iLO settings enabled for security" }
    $Settings | New-HPECOMGroup -Region eu-central -Name Hypervisors_Group -Description "My group for hypervisors" `
     -AutoFirmwareUpdateOnAdd -AutoBiosApplySettingsOnAdd -PowerOffServerAfterFirmwareUpdate -FirmwareDowngrade -TagUsedForAutoAddServer "Domain=lab@lab.net" 

    Create a new group named 'Hypervisors_Group' in the central European region using a list of bios, firmware, and iLO settings URIs.
    Set the group with automatic firmware update and Bios apply settings when a server is added to the group.
    Set also the group to power off server after firmware update is performed and allow firmware downgrade.
    Set the "Domain=lab@lab.net" tag so that any server defined with this tag during onboarding will automatically be added to this group.    
    
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name "RHEL_group" | New-HPECOMGroup -Name K8s_group 

    This command creates a new group named 'K8s_group' in the central European region using the settings and group policies of the existing 'RHEL_group', except for the autoAddServerTag, as an autoAddServerTag can only be associated with one group at a time.

    .INPUTS
    System.Collections.ArrayList
        List of server settings from 'Get-HPECOMSetting'.
        or
        A single group obtained from 'Get-HPECOMGroup -Name <GroupName>' if you want to copy an existing group to a new one.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the group attempted to be created
        * Region - Name of the region
        * Status - Status of the creation attempt (Failed for http error return; Complete if creation is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
            if ($HPECOMAPICredentialRegions -contains $_) {
                $true
            }
            else {
                Throw "The COM region '$_' is not provisioned in this workspace!"
            }
        })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,
        
        # [Parameter (ValueFromPipelineByPropertyName)] # Removed to avoid taking it from Get-HPECOMSetting pipeline object
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,

        [Parameter (ValueFromPipelineByPropertyName)] 
        [ArgumentCompleter({
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
            $Items = @('Servers') #, 'OneView Synergy appliances', 'OneView VM appliances')
            $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
            return $filteredItems | ForEach-Object {
               [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        })]
        # [ValidateSet ('Servers')] # , 'OneView Synergy appliances', 'OneView VM appliances')]
        [String]$DeviceType = "Servers",

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "SettingsObject")] 
        [Alias("settingsUris", "resourceuri")]
        [object]$SettingsObject,

        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = "SettingsObject")] 
        [Alias("policies")]
        [object]$PoliciesObject,

        [Parameter (ParameterSetName = "Settings")] 
        [String]$BiosSettingName,        
       
        [Parameter (ParameterSetName = "Settings")] 
        [String]$ExternalStorageSettingName,

        [Parameter (ParameterSetName = "Settings")] 
        [string]$FirmwareSettingName,
                
        [Parameter (ParameterSetName = "Settings")] 
        [String]$OSSettingName,
        
        [Parameter (ParameterSetName = "Settings")] 
        [String]$StorageSettingName,
        
        [Parameter (ParameterSetName = "Settings")] 
        [Switch]$EnableiLOSettingsForSecurity,

        # BIOS settings
        [switch]$AutoBiosApplySettingsOnAdd,
        [switch]$ResetBIOSConfigurationSettingsToDefaultsonAdd,  

        # Firmware settings
        [switch]$AutoFirmwareUpdateOnAdd,
        [switch]$PowerOffServerAfterFirmwareUpdate,
        [switch]$FirmwareDowngrade,

        # OS settings
        [switch]$AutoOSImageInstallOnAdd,
        [ValidateScript({ $_ -ge 60 -and $_ -le 720 })]
        [Int]$OsCompletionTimeoutMin = 240,

        # Storage settings
        [switch]$AutoStorageVolumeCreationOnAdd,
        [switch]$AutoStorageVolumeDeletionOnAdd,
        [String]$StorageVolumeName,

        # iLO settings
        [switch]$AutoIloApplySettingsOnAdd,

        # External storage settings       
        [switch]$AutoExternalStorageConfigurationOnAdd,

        # Tags settings
        # [Parameter (ValueFromPipelineByPropertyName)] # Removed as an autoAddServerTag can only exist in one group
        [ValidateScript({
                # Allows empty strings to pass the validation when a group without tag is provided in the pipeline
                # if (($_.psobject.properties | Where-Object { $_.MemberType -eq 'NoteProperty' }).count -eq 0) {
                #     $True
                # }   
                # Checks if the input string matches a specific pattern that starts with '@{' and ends with '}', 
                # containing letters, digits, underscores, spaces, dots, colons, plus signs, hyphens, and at signs.
                if ($_ -match '^@\{[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+\}$') {
                    $True
                }
                elseif (($_ -split '=').Count -gt 2) {
                    throw "Input '$_' is not in a valid tag format. Only one tag is expected such as <Name>=<Value>"
                }
                elseif ($_ -match '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') { 
                    $True
                }
                elseif ($_ -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                    throw "Input '$_' is not in a valid tag format. Expected format is <Name>=<Value> and can only contain alphanumeric characters, Unicode space separators, and the following: _ . : + - @"
                }
            })] 
        # [alias("autoAddTags")]
        [Object]$TagUsedForAutoAddServer,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMGroupsUri  
        $CreateGroupStatus = [System.Collections.ArrayList]::new()
        $ListOfSettingURIs = [System.Collections.ArrayList]::new()
        $ListOfSettingURIsFromSetting = [System.Collections.ArrayList]::new()
        $ListOfSettingURIsFromGroup = [System.Collections.ArrayList]::new()
        $ListOfPoliciesFromGroup = [System.Collections.ArrayList]::new()

        $count = 0

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $GroupResource = Get-HPECOMGroup -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($GroupResource) {
            Throw "Error! '$Name' group already exists in the Compute Ops Management instance!"

        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }


        if ($PSCmdlet.MyInvocation.ExpectingInput) {
            
            # If pipeline is Get-HPECOMGroup, add to list group object
            if ($PSBoundParameters.ContainsKey('SettingsObject') -and $SettingsObject.GetType().baseType -eq [System.Array]) {
                [void]$ListOfSettingURIsFromGroup.add($SettingsObject)
                [void]$ListOfPoliciesFromGroup.add($PoliciesObject)
                $count++ 
            }
            # If pipeline is Get-HPECOMSettings, add to list group object
            elseif ($PSBoundParameters.ContainsKey('SettingsObject')) {
                [void]$ListOfSettingURIsFromSetting.add($SettingsObject)

            }
        }     

    }

    end {


        if ($count -gt 1) {
            
            Throw "Error: The group pipeline input contains more than one group. Please refine your query to filter to only one group."
           
        }

        if (-not $ListOfSettingURIsFromSetting -and -not $ListOfSettingURIsFromGroup -and -not $SettingsObject) {

            "[{0}] Detected no ListOfSettingURIs and no SettingsObject" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            try {
                $Settings = Get-HPECOMSetting -Region $Region -ErrorAction Stop

            }
            catch {

                $PSCmdlet.ThrowTerminatingError($_)
            }

            if ($BiosSettingName) {
                
                $resourceUri = ($Settings | Where-Object category -eq "BIOS" | Where-Object name -eq $BiosSettingName).resourceUri

                if (-not $resourceUri) {
                    
                    # Throw "Bios setting '$BiosSettingName' cannot be found in the Compute Ops Management instance!"   
                    $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $BiosSettingName, "BIOS"
                    $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $BiosSettingName.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                }
                else {

                    [void]$ListOfSettingURIs.add($resourceUri) 
                }
            }
            if ($ExternalStorageSettingName) {
                
                $resourceUri = ($Settings | Where-Object category -eq "EXTERNAL_STORAGE" | Where-Object name -eq $ExternalStorageSettingName).resourceUri

                if (-not $resourceUri) {
                    
                    # Throw "External storage setting '$ExternalStorageSettingName' cannot be found in the Compute Ops Management instance!"
                    $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $ExternalStorageSettingName, "EXTERNAL_STORAGE"
                    $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $ExternalStorageSettingName.GetType().Name
                    
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)


                }
                else {

                    [void]$ListOfSettingURIs.add($resourceUri) 
                }
            }
            if ($FirmwareSettingName) {
                
                $resourceUri = ($Settings | Where-Object category -eq "FIRMWARE" | Where-Object name -eq $FirmwareSettingName).resourceUri

                if (-not $resourceUri) {
                    
                    # Throw "Firmware setting '$FirmwareSettingName' cannot be found in the Compute Ops Management instance!"
                    $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $FirmwareSettingName, "FIRMWARE"
                    $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $FirmwareSettingName.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)       


                }
                else {

                    [void]$ListOfSettingURIs.add($resourceUri) 
                }
            }
            if ($EnableiLOSettingsForSecurity) {
                
                $resourceUri = ($Settings | Where-Object category -eq "ILO_SETTINGS" | Where-Object name -eq "iLO settings enabled for security").resourceUri

                if (-not $resourceUri) {
                    
                    Throw "HPE pre-defined 'iLO settings enabled for security' cannot be found!"

                }
                else {

                    [void]$ListOfSettingURIs.add($resourceUri) 
                }
            }
            if ($OSSettingName) {
                
                $resourceUri = ($Settings | Where-Object category -eq "OS" | Where-Object name -eq $OSSettingName).resourceUri

                if (-not $resourceUri) {
                    
                    # Throw "OS setting '$OSSettingName' cannot be found in the Compute Ops Management instance!"
                    $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $OSSettingName, "OS"
                    $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $OSSettingName.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)   


                }
                else {

                    [void]$ListOfSettingURIs.add($resourceUri) 
                }
            }
            if ($StorageSettingName) {
                
                $resourceUri = ($Settings | Where-Object category -eq "STORAGE" | Where-Object name -eq $StorageSettingName).resourceUri

                if (-not $resourceUri) {
                    
                    # Throw "Storage setting '$StorageSettingName' cannot be found in the Compute Ops Management instance!"
                    $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $StorageSettingName, "STORAGE"
                    $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $StorageSettingName.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)        

                }
                else {

                    [void]$ListOfSettingURIs.add($resourceUri) 
                }
            }

            $SettingsObject = $ListOfSettingURIs
            
        }
        # Pipeline is Get-HPECOMGroup 
        elseif ($ListOfSettingURIsFromGroup) {

            "[{0}] Detected SettingURIs from Get-HPECOMGroup in pipeline: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ListOfSettingURIsFromGroup | out-string) | Write-Verbose
            # Need top flatten the list of lists
            $SettingsObject = ($ListOfSettingURIsFromGroup | out-string) -split '\r\n' | Where-Object { $_ -ne "" }
        }
        # Pipeline is Get-HPECOMSetting
        elseif ($ListOfSettingURIsFromSetting) {
    
            "[{0}] Detected SettingURIs from Get-HPECOMSetting in pipeline: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ListOfSettingURIsFromSetting | out-string) | Write-Verbose

            $SettingsObject = $ListOfSettingURIsFromSetting

        }
        # Direct (when -SettingsObject $Settings is used with $Settings = Get-HPECOMSetting)
        elseif ($SettingsObject.GetType().baseType -eq [System.Array]) {

            "[{0}] Detected SettingURIs in direct from -SettingsObject: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($SettingsObject.resourceuri | out-string) | Write-Verbose

            $SettingsObject = $SettingsObject.resourceuri
        }
        else {
            "[{0}] Detected nothing!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $SettingsObject = @{}
        }


        if ($TagUsedForAutoAddServer) {
       
            if ($TagUsedForAutoAddServer -is [string]) {
           
                # Remove space at the end of the string if any
                $AutoAddServerTag = $TagUsedForAutoAddServer.TrimEnd()
    
                # Check for more than one '=' character (if more than one tag is provided)
                if (($AutoAddServerTag -split '=').Count -gt 2) {
    
                    "[{0}] Tag '{1}' is not supported! Only one tag is expected such as <tagname>=<value>" -f $MyInvocation.InvocationName.ToString().ToUpper(), $TagUsedForAutoAddServer | Write-Verbose
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Tag not supported! Only one tag is expected such as <tagname>=<value>"
                    [void] $CreateGroupStatus.add($objStatus)
                    return  
                }
    
                # Check tag format, if format is not <tagname>=<value>, return error
                if ($AutoAddServerTag -notmatch "^[A-Za-z0-9_-]+=[A-Za-z0-9_-][^=]*$") {
    
                    "[{0}] Tag '{1}' format not supported! Expected format is <tagname>=<value>" -f $MyInvocation.InvocationName.ToString().ToUpper(), $TagUsedForAutoAddServer | Write-Verbose
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Tag format not supported! Expected format is <tagname>=<value>"
                    [void] $CreateGroupStatus.add($objStatus)
                    return  
                }
    
                $tagname = $AutoAddServerTag.split('=')[0]
                $tagvalue = $AutoAddServerTag.split('=')[1]
                
                $TagList = @{
                    $tagname = $tagvalue 
                }
                
            }
            else {
                $TagList = $TagUsedForAutoAddServer 
            }

        }
        else {
            $TagList = @{}
        }

            
        If ($ListOfPoliciesFromGroup) {

            $AutoBiosApplySettingsOnAdd                     = $ListOfPoliciesFromGroup.onDeviceAdd.biosApplySettings
            $ResetBIOSConfigurationSettingsToDefaultsonAdd  = $ListOfPoliciesFromGroup.onDeviceAdd.biosFactoryReset
            $AutoExternalStorageConfigurationOnAdd          = $ListOfPoliciesFromGroup.onDeviceAdd.externalStorageConfiguration
            $PowerOffServerAfterFirmwareUpdate              = $ListOfPoliciesFromGroup.onDeviceAdd.firmwarePowerOff
            $AutoFirmwareUpdateOnAdd                        = $ListOfPoliciesFromGroup.onDeviceAdd.firmwareUpdate
            $AutoIloApplySettingsOnAdd                      = $ListOfPoliciesFromGroup.onDeviceAdd.iloApplySettings
            $osCompletionTimeoutMin                         = $ListOfPoliciesFromGroup.onDeviceAdd.osCompletionTimeoutMin
            $AutoOsImageInstallOnAdd                        = $ListOfPoliciesFromGroup.onDeviceAdd.osInstall
            $AutoStorageVolumeCreationOnAdd                 = $ListOfPoliciesFromGroup.onDeviceAdd.storageConfiguration
            $AutoStorageVolumeDeletionOnAdd                 = $ListOfPoliciesFromGroup.onDeviceAdd.storageVolumeDeletion
            $storageVolumeName                              = $ListOfPoliciesFromGroup.onDeviceAdd.storageVolumeName

            $firmwareDowngrade                              = $ListOfPoliciesFromGroup.onDeviceApply.firmwareDowngrade
        }


        $onDeviceAdd = @{
            biosApplySettings            = [bool]$AutoBiosApplySettingsOnAdd
            biosFactoryReset             = [bool]$ResetBIOSConfigurationSettingsToDefaultsonAdd
            externalStorageConfiguration = [bool]$AutoExternalStorageConfigurationOnAdd
            firmwarePowerOff             = [bool]$PowerOffServerAfterFirmwareUpdate
            firmwareUpdate               = [bool]$AutoFirmwareUpdateOnAdd
            iloApplySettings             = [bool]$AutoIloApplySettingsOnAdd
            osCompletionTimeoutMin       = [int]$osCompletionTimeoutMin
            osInstall                    = [bool]$AutoOsImageInstallOnAdd
            storageConfiguration         = [bool]$AutoStorageVolumeCreationOnAdd
            storageVolumeDeletion        = [bool]$AutoStorageVolumeDeletionOnAdd
            storageVolumeName            = $Null
        }

     


        if ($storageVolumeName) {
            $onDeviceAdd.storageVolumeName = $storageVolumeName
            $onDeviceAdd.storageConfiguration = $True
        }
        
        if ($FirmwareDowngrade) {
            
            $onDeviceApply = @{ 
                firmwareDowngrade = [bool]$firmwareDowngrade 
            }
                        
            $Policies = @{
                onDeviceAdd   = $onDeviceAdd
                onDeviceApply = $onDeviceApply                
            }
        }
        else {
             
            $Policies = @{
                onDeviceAdd = $onDeviceAdd
                
            }
        }

        if ($DeviceType -eq "Servers") {
            $DeviceTypeValue = "DIRECT_CONNECT_SERVER"
        }
        elseif ($DeviceType -eq "OneView Synergy appliances") {
            $DeviceTypeValue = "OVE_APPLIANCE_SYNERGY"
        }
        elseif ($DeviceType -eq "OneView VM appliances") {
            $DeviceTypeValue = "OVE_APPLIANCE_VM"
        }
        else {
            # When pipeline is group, we capture DeviceType directly from the object
            $DeviceTypeValue = $DeviceType
        }
                     
        # Build payload
        $payload = ConvertTo-Json -Depth 10 @{
            name         = $Name
            description  = $Description
            deviceType   = $DeviceTypeValue 
            settingsUris = $SettingsObject
            policies     = $Policies
            autoAddTags  = $TagList

        }


        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 
            
            if (-not $WhatIf) {

                "[{0}] Group creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Group '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Group successfully created in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Group cannot be created!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           


        [void] $CreateGroupStatus.add($objStatus)

        if (-not $WhatIf) {

            if ($CreateGroupStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more groups failed the creation attempt!"
          
            }
            
            Return $CreateGroupStatus
        }


    }
}


Function Remove-HPECOMGroup {
<#
    .SYNOPSIS
    Deletes a group from a specified region.

    .DESCRIPTION
    This Cmdlet deletes a group from a specified region.
    
    Note: If you want to delete a group without modifying the server configuration, you must first remove the servers from the group using 'Remove-HPECOMServerfromGroup' before deleting the group.

    Note: If the group you want to delete is part of a resource restriction policy (RRP) saved filter, this filter will not be updated and should be manually reviewed. Check the user accounts associated with the RRP in HPE GreenLake using 'Get-HPEGLUserRole' or 'Get-HPEGLResourceRestrictionPolicy'.
    If necessary, adjust the user account RRP settings using 'Add-HPEGLUserRole' to ensure that the intended resource restrictions are preserved.

    .PARAMETER Name 
    The name of the group to remove. 
    
    .PARAMETER Region 
    The name of the region from which to remove the group. 

    .PARAMETER Force
    A switch parameter to force the removal of the group even if servers are still assigned to it. With this parameter, all group policies and configurations on the servers will be removed.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMGroup -Region eu-central -Name 'vmware_horizon'
    
    Removes the group named 'vmware_horizon' from the central EU region. 

    .EXAMPLE
    Get-HPECOMGroup -Region us-west -Name ESXi_Hypervisors | Remove-HPECOMGroup 

    Removes the group 'ESXi_Hypervisors' from the western US region. 

    .EXAMPLE 
    Get-HPECOMGroup -Region us-west | Where-Object {$_.name -eq 'ESXi_Hypervisors' -or $_.name -eq 'RHEL_Hypervisor'} | Remove-HPECOMGroup
    
    Removes the groups 'ESXi_Hypervisors' and 'RHEL_Hypervisor' from the western US region. 

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Remove-HPECOMGroup -Force

    Removes all groups from the central EU region, even if servers are still assigned to the groups, using the -Force switch. In this case, all group policies and configurations on the servers will be removed.

    .INPUTS
    System.Collections.ArrayList
        A list of groups from 'Get-HPECOMGroup'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - The name of the group attempted to be removed
        * Region - The name of the region from which the group is removed
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.

    
#>
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveGroupStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        try {
            $GroupResource = Get-HPECOMGroup -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $GroupID = $GroupResource.id

        
        if (-not $GroupID) {

            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Group cannot be found in the Compute Ops Management instance!"
            }
        }
        else {
            
            if ($Force) {

                $Uri = $COMGroupsUri + "/" + $GroupID + "?Force=true"
            }
            else {
                
                $Uri = $COMGroupsUri + "/" + $GroupID
            }

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Group removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Group '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Group successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Group cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveGroupStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveGroupStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more groups has failed!"

          
            }
            
            Return $RemoveGroupStatus
        }


    }
}


Function Set-HPECOMGroup {
    <#
    .SYNOPSIS
    Update a group resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies a group resource in a given region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.

    .PARAMETER Name 
    Specifies the name of the group to update. 

    .PARAMETER Region 
    Specifies the name of the region where the group will be updated. 

    .PARAMETER NewName 
    Specifies the new name for the group. 

    .PARAMETER Description 
    Specifies a new description of the group.

    .PARAMETER DeviceType
    Specifies the type of device to be added to the group. Servers is the only supported device type at the moment.

    .PARAMETER BiosSettingName
    Specifies the name of a BIOS setting resource.

    .PARAMETER ExternalStorageSettingName
    Specifies the name of an external storage setting resource.

    .PARAMETER FirmwareSettingName
    Specifies the name of a firmware setting resource.

    .PARAMETER OSSettingName
    Specifies the name of an OS setting resource.

    .PARAMETER StorageSettingName
    Specifies the name of a storage setting resource.

    .PARAMETER EnableiLOSettingsForSecurity
    Specifies the name of an iLO-settings setting resource.
    Switch to enable iLO settings in the group that reduce the overall security risk of a server. This switch applies the HPE-recommended security settings for iLOs.

    .PARAMETER AutoBiosApplySettingsOnAdd
    Enables automatic application of BIOS settings when a server is added to the group. A group must have one of the HPE pre-defined BIOS/Workload profiles for this setting to be effective.
    Note: Effective only when a BIOS setting is defined in the group.

    .PARAMETER ResetBIOSConfigurationSettingsToDefaultsonAdd
    Resets the BIOS configuration settings to default when a server is added to the group.
    Note: Effective only when a BIOS setting is defined in the group.

    .PARAMETER AutoFirmwareUpdateOnAdd
    Enables automatic firmware updates to the configured baseline when a server is added to the group. 
    Note: Effective only when a firmware setting is defined in the group.
       
    .PARAMETER PowerOffServerAfterFirmwareUpdate
    Powers off the server after performing a firmware update.
    Note: Effective only when a firmware setting is defined in the group.
        
    .PARAMETER FirmwareDowngrade
    Allows or forbids the downgrade of firmware during updates.
    Note: Effective only when a firmware setting is defined in the group.
    
    .PARAMETER AutoOsImageInstallOnAdd
    Installs the operating system image immediately when a server is added to the group if it is activated; otherwise, it will install when the server is activated at a later time.
    Note: Effective only when an OS setting is defined in the group.

    .PARAMETER OsCompletionTimeoutMin
    Sets the timeout duration (in minutes) for operating system installation when a server is added to the group with automatic OS installation enabled. The timeout applies per individual server.
    Note: Effective only when an OS setting is defined in the group.
        
    .PARAMETER AutoStorageVolumeCreationOnAdd
    Creates the storage volume for the Operating system immediately when the server is added to the group if it is activated; otherwise, it will create when the server is activated at a later time.
    Note: Effective only when an OS setting is defined in the group.
        
    .PARAMETER AutoStorageVolumeDeletionOnAdd
    Erases any existing internal storage configuration prior to creating a new OS volume when a server is added to the group if the server is activated; otherwise, it will erase when the server is activated at a later time.
    Note: Effective only when a storage setting is defined in the group.
    
    .PARAMETER StorageVolumeName
    Assigns a name to the created storage volume when a server is added to the group if the server is activated; otherwise, it will assign when the server is activated at a later time.
    Note: Effective only when a storage setting is defined in the group.

    .PARAMETER AutoIloApplySettingsOnAdd
    Enables automatic application of iLO settings when a server is added to the group. A group must have HPE pre-defined iLO settings for this setting to be effective.
    Note: Effective only when an iLO-settings setting is defined in the group.
        
    .PARAMETER AutoExternalStorageConfigurationOnAdd
    Applies the external storage configuration immediately when a server is added to the group if the server is activated; otherwise, it will apply when the server is activated at a later time.
    Note: Effective only when an external storage setting is defined in the group.

    .PARAMETER TagUsedForAutoAddServer
    Associates a case-insensitive tag with a group to automatically add servers to the group when they are activated. 
    
    The tag must meet the following string format <Name>=<Value> and can contain any alphaneumeric characters, any Unicode space separators, and the following characters: _ . : + - @ such as:
     - "Country=US"
     - "App=ESX-8"
     - "Site=Houston site"
     - "Domain=my.lab@domain.com"
    
    Note: 
        - A group can have a maximum of one tag and multiple groups can not have the same tag.
        - Automatic addition to groups can only occur before server activation. If a servers tags match more than one group, it wont be added to any group, and will need to be added using a different method.
        - When a server is onboarded or has its tags changed, the server's tags will be checked against the group's autoAddServerTags. 
        - If at least one of the server tags matches one group's autoAddServerTags, the server will be placed into the associated group. 
        - Once a server has been connected, the server becomes ineligible for automatically being placed into groups, even if it is later disconnected.
        - If a server is in a group, any further tag changes will not move it to another group. 

    .PARAMETER WhatIf
    Displays the raw REST API call to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMGroup -Region eu-central -Name AI_Group -Description "Group for AI systems" `
        -BiosSettingName "Virtualization - Power Efficient" -AutoBiosApplySettingsOnAdd:$true -ResetBIOSConfigurationSettingsToDefaultsonAdd:$True `
        -FirmwareSettingName "ESXi firmware baseline"   -AutoFirmwareUpdateOnAdd:$True -PowerOffServerAfterFirmwareUpdate:$True -FirmwareDowngrade:$True `
        -OSSettingName OS_ESXi -AutoOsImageInstallOnAdd:$True -OsCompletionTimeoutMin 60 `
        -StorageSettingName "RAID1" -StorageVolumeName "OS-vol" -AutoStorageVolumeCreationOnAdd:$True -AutoStorageVolumeDeletionOnAdd:$True  `
        -EnableiLOSettingsForSecurity:$True -AutoIloApplySettingsOnAdd:$True  `
        -TagUsedForAutoAddServer "App=RHEL"

    This example demonstrates how to configure a group named "AI_Group" in the "eu-central" region with various settings.
    The group is described as "Group for AI systems".
    BIOS settings are applied automatically with the "Virtualization - Power Efficient" profile, and BIOS settings are reset to defaults on add.
    Firmware settings are configured with the "ESXi firmware baseline", enabling automatic firmware updates.
    The server is powered off after firmware updates, and firmware downgrades are permitted.
    OS settings are configured with "OS_ESXi", enabling automatic OS image installation with a completion timeout of 60 minutes.
    Storage settings are configured with "RAID1", naming the storage volume "OS-vol".
    Automatic storage volume creation and deletion are enabled.
    iLO settings for security are enabled, with automatic application of iLO settings.
    The group is tagged with "App=RHEL" for automatic server addition based on this tag.

    .EXAMPLE
    Set-HPECOMGroup -Region eu-central -Name AI_Group -AutoBiosApplySettingsOnAdd:$false -AutoFirmwareUpdateOnAdd:$false -AutoOsImageInstallOnAdd:$false -AutoStorageVolumeCreationOnAdd:$false -AutoStorageVolumeDeletionOnAdd:$false -AutoIloApplySettingsOnAdd:$false 

    This example demonstrates how to disable all automatic settings when servers are added to the group named "AI_Group" in the "eu-central" region.
        
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name 'Hypervisors_Group' | Set-HPECOMGroup `
    -NewName "ESX_Hypervisors_Group" `
    -Description "My new description" `
    -AutoFirmwareUpdateOnAdd:$False -AutoBiosApplySettingsOnAdd:$True `
    -BiosSettingName "Virtualization - Power Efficient"

    The first command retrieves the server group named 'Hypervisors_Group' located in the 'eu-central' region. 
    The second command updates the group with a new name 'ESX_Hypervisors_Group', a new description 'My new description', and disables automatic firmware updates when a server is added to the group.
       
    .EXAMPLE
    Set-HPECOMGroup -Name AI_Group -Region eu-central -TagUsedForAutoAddServer "" -OSSettingName "" -EnableiLOSettingsForSecurity:$false 
    
    This example demonstrates how to remove the tag and OS settings from the group named "AI_Group" in the "eu-central" region and disable iLO settings for security.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Set-HPECOMGroup -AutoFirmwareUpdateOnAdd:$False

    This example modifies all groups in the eu-central region to disable automatic firmware updates when a server is added to the group.

    .INPUTS
    System.Collections.ArrayList
        List of groups from 'Get-HPECOMGroup'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:  
        * Name - Name of the group attempted to be updated
        * Region - Name of the region where the group is updated
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Filter')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        # [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 10000 })]
        [String]$Description,

        [ArgumentCompleter({
            param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
            $Items = @('Servers') #, 'OneView Synergy appliances', 'OneView VM appliances')
            $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
            return $filteredItems | ForEach-Object {
               [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }
        })]
        [ValidateSet ('Servers')] # , 'OneView Synergy appliances', 'OneView VM appliances')]
        # [Parameter (ValueFromPipelineByPropertyName)] 
        [String]$DeviceType = "Servers",

        [String]$BiosSettingName,        
       
        [String]$ExternalStorageSettingName,

        [string]$FirmwareSettingName,
                
        [String]$OSSettingName,
        
        [String]$StorageSettingName,
        
        [bool]$EnableiLOSettingsForSecurity,

        
        # BIOS settings
        [bool]$AutoBiosApplySettingsOnAdd,
        [bool]$ResetBIOSConfigurationSettingsToDefaultsonAdd,  
        
        
        # Firmware settings
        [bool]$AutoFirmwareUpdateOnAdd,
        [bool]$PowerOffServerAfterFirmwareUpdate,
        [bool]$FirmwareDowngrade,

        
        # OS settings
        [bool]$AutoOsImageInstallOnAdd,
        [ValidateScript({ $_ -ge 60 -and $_ -le 720 })]
        [Int]$OsCompletionTimeoutMin,

        
        # Storage settings
        [bool]$AutoStorageVolumeCreationOnAdd,
        [bool]$AutoStorageVolumeDeletionOnAdd,
        [String]$StorageVolumeName,


        # iLO settings
        [bool]$AutoIloApplySettingsOnAdd,


        # External storage settings       
        [bool]$AutoExternalStorageConfigurationOnAdd,
        

        # Tags settings  
        [ValidateScript({
            # Allows empty strings to pass the validation when "" is provided to remove the tag or when group in the pipeline does not have a tag
            if ($_ -eq '' -or $_ -eq $null) {
                $True
            }    
            # Checks if the input string matches a specific pattern that starts with '@{' and ends with '}', 
            # containing letters, digits, underscores, spaces, dots, colons, plus signs, hyphens, and at signs.
            elseif ($_ -match '^@\{[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+\}$') {
                $True
            }
            
            elseif (($_ -split '=').Count -gt 2) {
                throw "Input '$_' is not in a valid tag format. Only one tag is expected such as <Name>=<Value>"
            }
            # Checks if the input string matches a specific pattern <Name>=<Value> that starts with a letter, followed by letters, digits, underscores, spaces, dots, colons, plus signs, hyphens, and at signs,
            elseif ($_ -match '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') { 
                $True
            }
            elseif ($_ -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                throw "Input '$_' is not in a valid tag format. Expected format is <Name>=<Value> and can only contain alphanumeric characters, Unicode space separators, and the following: _ . : + - @"
            }
            })] 
        [String]$TagUsedForAutoAddServer,      

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetGroupStatus = [System.Collections.ArrayList]::new()
        $onDeviceAdd = [System.Collections.Hashtable]::new()
        $Policies = [System.Collections.Hashtable]::new()

        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
           
            $GroupResource = Get-HPECOMGroup -Region $Region -Name $Name 
            $GroupID = $GroupResource.id
        }   
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

      
     
        if (-not $GroupID) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord GroupNotFoundInCOM ObjectNotFound -TargetObject 'Group' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Group cannot be found in the Compute Ops Management instance!"
            }
        }
        else {
            
            $Uri = $COMGroupsUri + "/" + $GroupID

            # Get existing group settings
            $ExistingGroupSettings = Get-HPECOMGroup -Region $Region -Name $Name -ShowSettings
                           
            # Get settings from the Compute Ops Management instance
            try {
                $Settings = Get-HPECOMSetting -Region $Region -ErrorAction Stop
                
            }
            catch {
                
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            
            $SettingsUris = [System.Collections.ArrayList]::new()

            # Check if settings are provided or not, if provided, get the resourceUri and add it to the settingsUris list, if not, get the existing settings from the group
            if (-not $PSBoundParameters.ContainsKey('BiosSettingName')) {

                $Category = 'BIOS'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $BiosSettingFound = $True
                    }
                }
            }
            else {
                
                if ($BiosSettingName) {

                    $Category = 'BIOS'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $BiosSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $BiosSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $BiosSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }   
                else {
                    # Need to disable bios configuration if bios setting name provided is ""
                    $DeleteBiosSettings = $True

                }              
            }           

            if (-not $PSBoundParameters.ContainsKey('ExternalStorageSettingName')) {

                $Category = 'EXTERNAL_STORAGE'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $ExternalStorageSettingFound = $True

                    }
                }
            }
            else {
                
                if ($ExternalStorageSettingName) {

                    $Category = 'EXTERNAL_STORAGE'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $ExternalStorageSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $ExternalStorageSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $ExternalStorageSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }
                else {
                    # Need to disable external configuration if external storage setting name provided is ""
                    $DeleteExternalStorageSettings = $True

                }                   
            }
            
            if (-not $PSBoundParameters.ContainsKey('FirmwareSettingName')) {

                $Category = 'FIRMWARE'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $FirmwareSettingFound = $True

                    }
                }
            }
            else {
                
                if ($FirmwareSettingName) {

                    $Category = 'FIRMWARE'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $FirmwareSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $FirmwareSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $FirmwareSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }  
                else {
                    # Need to disable Firmware configuration if firmware setting name provided is ""
                    $DeleteFirmwareSettings = $True

                }                
            }
            
            if (-not $PSBoundParameters.ContainsKey('EnableiLOSettingsForSecurity')) {

                $Category = 'ILO_SETTINGS'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {
            
                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] iLO settings setting found in group: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $iLOSettingFound = $True

                    }
                }
            }
            else {

                if ($EnableiLOSettingsForSecurity) {
                
                    $_RessourceUri = ($Settings | Where-Object category -eq "ILO_SETTINGS" | Where-Object name -eq "iLO settings enabled for security").resourceUri

                    if (-not $_RessourceUri) {
                        
                        # Must return a message if not found
                        Throw "HPE pre-defined 'iLO settings enabled for security' cannot be found!"

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }
                else {
                    # Need to disable iLO configuration if EnableiLOSettingsForSecurity is $False
                    $DeleteiLOSettings = $True

                }   
            }

            if (-not $PSBoundParameters.ContainsKey('OSSettingName')) {

                $Category = 'OS'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $OSSettingFound = $True

                    }
                }
            }
            else {
                
                if ($OSSettingName) {

                    $Category = 'OS'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $OSSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $OSSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $OSSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }  
                else {
                    # Need to disable OS configuration if OS setting name provided is ""
                    $DeleteOSSettings = $True

                }             
            }

            if (-not $PSBoundParameters.ContainsKey('StorageSettingName')) {

                $Category = 'STORAGE'

                if ($ExistingGroupSettings | Where-Object category -eq $Category) {

                    $_RessourceUri = $ExistingGroupSettings | Where-Object category -eq $Category | ForEach-Object resourceUri

                    if ($_RessourceUri) {

                        "[{0}] {1} setting found in group: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Category, $_RessourceUri | Write-Verbose
                        
                        [void]$SettingsUris.add($_RessourceUri) 

                        $StorageSettingFound = $True

                    }
                }
            }
            else {
                
                if ($StorageSettingName) {

                    $Category = 'STORAGE'

                    $_RessourceUri = ($Settings | Where-Object category -eq $Category | Where-Object name -eq $StorageSettingName).resourceUri
                
                    if (-not $_RessourceUri) {

                        # Must return a message if not found    
                        $ErrorMessage = "Setting '{0}' using the category '{1}' cannot be found in the Compute Ops Management instance!" -f $StorageSettingName, $Category
                        $ErrorRecord = New-ErrorRecord ServerSettingeNotFoundInCOM ObjectNotFound -TargetObject 'Server-settings' -Message $ErrorMessage -TargetType $StorageSettingName.GetType().Name
                    
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)   

                    }
                    else {

                        [void]$SettingsUris.add($_RessourceUri) 
                    }
                }      
                else {
                    # Need to disable storage configuration if storage setting name provided is ""
                    $DeleteStorageSettings = $True

                }        
            }
            

            if (-not $PSBoundParameters.ContainsKey('TagUsedForAutoAddServer')) {

                if ($GroupResource.autoAddTags) {

                    $TagList = $GroupResource.autoAddTags
                }
                else {
                    $TagList = @{}
                }
            
            }
            else {

                if ($TagUsedForAutoAddServer) {
                    
                    "[{0}] TagUsedForAutoAddServer value: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $TagUsedForAutoAddServer | Write-Verbose

                    # Remove space at the end of the string if any
                    $AutoAddServerTag = $TagUsedForAutoAddServer.TrimEnd()
    
                    $Tagname = $AutoAddServerTag.split('=')[0]
                    $Tagvalue = $AutoAddServerTag.split('=')[1]


                    # Remove existing tag (if any) and if the new tag is different from the existing tag name 
                    if ( ($GroupResource.autoAddTags.psobject.properties.name -and $GroupResource.autoAddTags.psobject.properties.name -ne $Tagname) ) {

                        "[{0}] Existing AutoAddTags object: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($GroupResource.autoAddTags.psobject.properties | out-string) | Write-Verbose
                    
                        $TagNameToRemove = $GroupResource.autoAddTags.psobject.properties.name
                        $TagList += @{ $TagNameToRemove = $Null }
                    }
                    
                    # Set existing tag (if any) and if the new tag name is the same as the existing one but with a different value 
                    if ( $GroupResource.autoAddTags.psobject.properties.name -and $GroupResource.autoAddTags.psobject.properties.name -eq $Tagname -and $GroupResource.autoAddTags.psobject.properties.value -ne $Tagvalue ) {

                        "[{0}] Existing AutoAddTags object: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($GroupResource.autoAddTags.psobject.properties | out-string) | Write-Verbose
                    
                        $TagList += @{ $Tagname = $Tagvalue }
                    }
                    else {

                        $TagList += @{ $Tagname = $Tagvalue }
                    }
                }
                else {
                    if ( $GroupResource.autoAddTags.psobject.properties.name) {
                        
                        $Tagname = $GroupResource.autoAddTags.psobject.properties.name
                        $TagList = @{ $Tagname = $Null }
                    }
                    else {
                        $TagList = @{}
                    }    
                }           
            }


            # BIOS settings
            if (-not $PSBoundParameters.ContainsKey('AutoBiosApplySettingsOnAdd')) {
                if ($BiosSettingFound -and $GroupResource.policies.onDeviceAdd.biosApplySettings) {
                    $onDeviceAdd["biosApplySettings"] = $GroupResource.policies.onDeviceAdd.biosApplySettings
                }
            }
            else {
                $onDeviceAdd["biosApplySettings"] = $AutoBiosApplySettingsOnAdd
            }

            if (-not $PSBoundParameters.ContainsKey('ResetBIOSConfigurationSettingsToDefaultsonAdd')) {
                if ($BiosSettingFound -and $GroupResource.policies.onDeviceAdd.biosFactoryReset) {
                    $onDeviceAdd["biosFactoryReset"] = $GroupResource.policies.onDeviceAdd.biosFactoryReset
                }
            }
            else {
                $onDeviceAdd["biosFactoryReset"] = $ResetBIOSConfigurationSettingsToDefaultsonAdd
            }

            # Firmware settings
            if (-not $PSBoundParameters.ContainsKey('AutoFirmwareUpdateOnAdd')) {
                if ($FirmwareSettingFound -and $GroupResource.policies.onDeviceAdd.firmwareUpdate) {
                    $onDeviceAdd["firmwareUpdate"] = $GroupResource.policies.onDeviceAdd.firmwareUpdate
                }
            }  
            else {
                $onDeviceAdd["firmwareUpdate"] = $AutoFirmwareUpdateOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('firmwareDowngrade')) {
                if ($FirmwareSettingFound -and $GroupResource.policies.onDeviceApply.firmwareDowngrade) {
                    $onDeviceApply = @{ firmwareDowngrade = $GroupResource.policies.onDeviceApply.firmwareDowngrade }
                }
            }
            else {
                $onDeviceApply = @{ firmwareDowngrade = $FirmwareDowngrade }
            }
            if (-not $PSBoundParameters.ContainsKey('PowerOffServerAfterFirmwareUpdate')) {
                if ($FirmwareSettingFound -and $GroupResource.policies.onDeviceAdd.firmwarePowerOff) {
                    $onDeviceAdd["firmwarePowerOff"] = $GroupResource.policies.onDeviceAdd.firmwarePowerOff
                }
            }
            else {
                $onDeviceAdd["firmwarePowerOff"] = $PowerOffServerAfterFirmwareUpdate
            }
             
            # OS settings
            if (-not $PSBoundParameters.ContainsKey('AutoOsImageInstallOnAdd')) {
                if ($OSSettingFound -and $GroupResource.policies.onDeviceAdd.osInstall) {
                    $onDeviceAdd["osInstall"] = $GroupResource.policies.onDeviceAdd.osInstall
                }
            }
            else {
                $onDeviceAdd["osInstall"] = $AutoOsImageInstallOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('osCompletionTimeoutMin')) {
                if ($OSSettingFound -and $GroupResource.policies.onDeviceAdd.osCompletionTimeoutMin) {
                    $onDeviceAdd["osCompletionTimeoutMin"] = $GroupResource.policies.onDeviceAdd.osCompletionTimeoutMin
                }
            }
            else {
                $onDeviceAdd["osCompletionTimeoutMin"] = $OsCompletionTimeoutMin
            }
            
            # Storage settings
            if (-not $PSBoundParameters.ContainsKey('AutoStorageVolumeCreationOnAdd')) {
                if ($StorageSettingFound -and $GroupResource.policies.onDeviceAdd.storageConfiguration) {
                    $onDeviceAdd["storageConfiguration"] = $GroupResource.policies.onDeviceAdd.storageConfiguration
                }
            }
            else {
                $onDeviceAdd["storageConfiguration"] = $AutoStorageVolumeCreationOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('AutoStorageVolumeDeletionOnAdd')) {
                if ($StorageSettingFound -and $GroupResource.policies.onDeviceAdd.storageVolumeDeletion) {
                    $onDeviceAdd["storageVolumeDeletion"] = $GroupResource.policies.onDeviceAdd.storageVolumeDeletion
                }
            }
            else {
                $onDeviceAdd["storageVolumeDeletion"] = $AutoStorageVolumeDeletionOnAdd
            }
            if (-not $PSBoundParameters.ContainsKey('storageVolumeName')) {
                if ($StorageSettingFound -and $GroupResource.policies.onDeviceAdd.storageVolumeName) {
                    $onDeviceAdd["storageVolumeName"] = $GroupResource.policies.onDeviceAdd.storageVolumeName
                }
            }
            else {
                $onDeviceAdd["storageVolumeName"] = $storageVolumeName

            }
          
            # iLO settings

            if (-not $PSBoundParameters.ContainsKey('AutoIloApplySettingsOnAdd')) {
                if ($iLOSettingFound -and $GroupResource.policies.onDeviceAdd.iloApplySettings) {
                    $onDeviceAdd["iloApplySettings"] = $GroupResource.policies.onDeviceAdd.iloApplySettings
                }
            }
            else {
                $onDeviceAdd["iloApplySettings"] = $AutoIloApplySettingsOnAdd
            }

            # External storage settings
            if (-not $PSBoundParameters.ContainsKey('AutoExternalStorageConfigurationOnAdd')) {
                if ($ExternalStorageSettingFound -and $GroupResource.policies.onDeviceAdd.externalStorageConfiguration) {
                    $onDeviceAdd["externalStorageConfiguration"] = $GroupResource.policies.onDeviceAdd.externalStorageConfiguration
                }
            }
            else {
                $onDeviceAdd["externalStorageConfiguration"] = $AutoExternalStorageConfigurationOnAdd
            }


            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }
           
            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($GroupResource.description) {
                              
                    $Description = $GroupResource.description
                }
                else {
                    $Description = $Null
                }
            }
            else {
                $Description = $Description
            }

            # $onDeviceAdd = @{
            #     biosApplySettings            = [bool]$AutoBiosApplySettingsOnAdd
            #     biosFactoryReset	           = [bool]$ResetBIOSConfigurationSettingsToDefaultsonAdd
            #     externalStorageConfiguration = [bool]$AutoExternalStorageConfigurationOnAdd
            #     firmwarePowerOff             = [bool]$PowerOffServerAfterFirmwareUpdate
            #     firmwareUpdate               = [bool]$AutoFirmwareUpdateOnAdd
            #     iloApplySettings             = [bool]$AutoIloApplySettingsOnAdd
            #     osCompletionTimeoutMin       = [int]$osCompletionTimeoutMin
            #     osInstall                    = [bool]$AutoOsImageInstallOnAdd
            #     storageConfiguration         = [bool]$AutoStorageVolumeCreationOnAdd
            #     storageVolumeDeletion        = [bool]$AutoStorageVolumeDeletionOnAdd
            #     storageVolumeName            = $Null
            # }

   

            # Disabling bios configuration if bios setting is ""
            If ($DeleteBiosSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty biosApplySettings, biosFactoryReset

            }

            # Disabling firmware configuration if firmware setting is ""
            If ($DeleteFirmwareSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty firmwareUpdate, firmwarePowerOff

            }

            # Disabling iLO configuration if iLO setting is $False
            If ($DeleteIloSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty iloApplySettings

            }

            # Disabling OS configuration if OS setting is ""
            If ($DeleteOSSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty osCompletionTimeoutMin, osInstall

            }

            # Disabling external storage configuration if external storage setting is ""
            If ($DeleteExternalStorageSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty externalStorageConfiguration

            }

            # Disabling storage configuration if storage setting is ""
            If ($DeleteStorageSettings) {
                $onDeviceAdd = $onDeviceAdd | Select-Object -Property * -ExcludeProperty storageVolumeDeletion, storageConfiguration, storageVolumeName
                
            }

            
            If ($onDeviceApply) {
               
                $Policies = @{
                    onDeviceAdd   = $onDeviceAdd
                    onDeviceApply = $onDeviceApply
                }

            }
            elseif ($onDeviceAdd.count -gt 0) {
                $Policies = @{
                    onDeviceAdd = $onDeviceAdd
                }
            }
            else {
                $Policies = @{}
            }

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                name         = $Name
                description  = $Description
                settingsUris = $SettingsUris
                policies     = $Policies
                autoAddTags  = $TagList
            }          
          
            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Group update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Group '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Group successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Group cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $SetGroupStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetGroupStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Group failed the update attempt!"
          
            }
            
            Return $SetGroupStatus
        }
    }
}


Function Add-HPECOMServerToGroup {
    <#
    .SYNOPSIS
    Add server to a group in a specified region.

    .DESCRIPTION   
    This cmdlet adds a server to a group within a specified region. It does not support transferring a server directly from one group to another. 
    To transfer a server, first use `Remove-HPECOMServerFromGroup` to remove the server from its current group, and then use `Add-HPECOMServerToGroup` to add it to the new group.

    .PARAMETER Region 
    Specifies the name of the region where the group is located.  

    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server to be assigned to the group.

    .PARAMETER GroupName 
    Specifies the name of the group to which servers will be added. 

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    Add-HPECOMServerToGroup -Region us-west -ServerSerialNumber "J208PP0026" -GroupName RHEL_Hypervisors 
   
    This example adds a server with the serial number 'J208PP0026' to the group 'RHEL_Hypervisors' in the western US region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "esx5-2.domain.lab" | Add-HPECOMServerToGroup -GroupName ESXi_group 

    This command retrieves a server named 'esx5-2.domain.lab' in the central EU region and adds it to the group 'ESXi_group'.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model "ProLiant DL345 Gen10 Plus" | Add-HPECOMServerToGroup -GroupName RHEL_Hypervisors

    This command retrieves servers with the model 'ProLiant DL345 Gen10 Plus' in the western US region and adds them to the group 'RHEL_Hypervisors'.
    
    .EXAMPLE
    "J208PP0026", "J208PP000X" | Add-HPECOMServerToGroup -Region us-west -GroupName RHEL_Hypervisors 

    This command adds servers with serial numbers 'J208PP0026' and 'J208PP000X' to the group 'RHEL_Hypervisors' in the western US region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:  
        * SerialNumber - Serial number of the server attempted to be added to the group
        * Region - Name of the region where the group is located
        * Group - Name of the group to which the server is added
        * Status - The status of the addition attempt (`Failed` for HTTP error return; `Complete` if successful; `Warning` if no action is needed) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.

    
    #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
            if ($HPECOMAPICredentialRegions -contains $_) {
                $true
            }
            else {
                Throw "The COM region '$_' is not provisioned in this workspace!"
            }
        })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory)]
        [String]$GroupName,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $ServerSerialNumber
            Region       = $Region         
            Group        = $GroupName                   
            Status       = $Null
            Details      = $Null
            Exception    = $Null
        }

       
        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        
        try {
            $Group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers =  $Group.devices 

            $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices"
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $Group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }


        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of servers to add to group: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose


        foreach ($Object in $ObjectStatusList) {

            "[{0}] Checking server '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber | Write-Verbose

            $Server = $Servers | Where-Object serialNumber -eq $Object.SerialNumber

            if ( -not $Server) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server cannot be found in the Compute Ops Management instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ($GroupMembers | Where-Object serial -eq $Object.SerialNumber) {  

                # Must return a message if server already member of the group
                $Object.Status = "Warning"
                $Object.Details = "Server already a member of the group!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' is already a member of the group '{1}'!" -f $Object.SerialNumber, $GroupName
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       

                "[{0}] Server '{1}' is not a member of the group '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber, $GroupName | Write-Verbose
            
                # Build DeviceList object for paylaod
                $DeviceList = [PSCustomObject]@{
                    deviceId = $server.id
                  
                }

                # Build DeviceInfo object for tracking
                $DeviceInfo = [PSCustomObject]@{
                    serialnumber = $server.serialNumber
                  
                }

                # Building the list of devices object for payload
                [void]$DevicesList.Add($DeviceList)

                # Building the list of devices object for tracking
                [void]$DevicesTrackingList.Add($DeviceInfo)
                    
            }
        }

        
        if ($DevicesList) {

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                devices = $DevicesList
            } 
        
            # Add Devices to group  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Server successfully added to '$groupname' group in '$Region' region"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Server cannot be added to '$groupname' group!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed to join '$groupname' group!"
          
            }
            
            Return $ObjectStatusList
        }


    }
}



Function Remove-HPECOMServerFromGroup {
    <#
    .SYNOPSIS
    Remove a server from a group in a specified region.

    .DESCRIPTION   
    This cmdlet removes a server from a specified group within a region. It can also remove all servers from the group and initiate a factory reset of the server BIOS once the removal is complete.

    .PARAMETER Region 
    The name of the region where the group is located.  
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server to be removed from the group. Serial numbers can be found using 'Get-HPECOMGroup -Region $Region -Name $GroupName -ShowMembers'.
    
    .PARAMETER GroupName 
    The name of the group from which the servers will be removed. 
 
    .PARAMETER All
    An optional parameter to remove all servers from the group.

    .PARAMETER ResetBios
    An optional parameter that initiates a factory reset of the server BIOS once the removal is complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMServerFromGroup -Region us-west -ServerSerialNumber "J208PP0026" -GroupName RHEL_Hypervisors 
   
    This example removes the server with serial number 'J208PP0026' from the group 'RHEL_Hypervisors' in the western US region.

    .EXAMPLE
    Remove-HPECOMServerFromGroup -Region us-west -GroupName RHEL_Hypervisors -All -ResetBios 
 
    This example removes all servers from the group 'RHEL_Hypervisors' in the western US region and initiates a factory reset of all servers' BIOS once the removal is complete.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_group -ShowMembers | Remove-HPECOMServerFromGroup

    This example retrieves all servers from the group 'ESXi_group' in the central EU region and removes them from the group.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-Gen10P-1.lab | Remove-HPECOMServerFromGroup -GroupName ESXi_group 

    This example retrieves the server named 'ESX-Gen10P-1.lab' in the central EU region and removes it from the group 'ESXi_group'.

    .EXAMPLE
    "J208PP0026", "J208PP000X" | Remove-HPECOMServerFromGroup -Region us-west -GroupName RHEL_Hypervisors 

    This example removes servers with serial numbers 'J208PP0026' and 'J208PP000X' from the group 'RHEL_Hypervisors' in the western US region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model "ProLiant DL345 Gen10 Plus" | Remove-HPECOMServerFromGroup -GroupName RHEL_Hypervisors 

    This example retrieves servers with the model 'ProLiant DL345 Gen10 Plus' in the western US region and removes them from the group 'RHEL_Hypervisors'.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the server attempted to be removed from the group
        * Region - Name of the region where the group is located
        * Group - Name of the group from which the server is removed
        * Status - The status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
            if ($HPECOMAPICredentialRegions -contains $_) {
                $true
            }
            else {
                Throw "The COM region '$_' is not provisioned in this workspace!"
            }
        })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = "serialnumber")] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,
        
        [Parameter(ParameterSetName = "All")]
        [Switch]$All,

        [Switch]$ResetBios,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $Null
            Region       = $Region                            
            Group        = $GroupName                   
            Status       = $Null
            Details      = $Null
            Exception    = $Null
        }

        if ($ServerSerialNumber) {

            $objStatus.SerialNumber = $ServerSerialNumber
        }

       

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            $Group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers =  $Group.devices 

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $Group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }

        
        If (-not $All) {
        
            try {
        
                $Servers = Get-HPECOMServer -Region $Region
                    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)                
            }
                
            "[{0}] List of servers to remove from group: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose
        

            foreach ($Object in $ObjectStatusList) {
                
                "[{0}] Checking server '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber | Write-Verbose

                $Server = $Servers | Where-Object serialNumber -eq $Object.SerialNumber

                if ( -not $Server) {

                    # Must return a message if device not found
                    $Object.Status = "Failed"
                    $Object.Details = "Server cannot be found in the Compute Ops Management instance!"

                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object.SerialNumber
                        Write-warning $ErrorMessage
                        continue
                    }
                    
                } 
                elseif (-not ( $GroupMembers | Where-Object serial -eq $Object.SerialNumber)) { 

                    # Must return a message if server already member of the group
                    $Object.Status = "Warning"
                    $Object.Details = "Server is not a member of the group!"
                    
                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}' is not a member of the group '{1}'!" -f $Object.SerialNumber, $GroupName
                        Write-warning $ErrorMessage
                        continue
                    }
                    
                }
                else {    

                    "[{0}] Server '{1}' is a member of the group '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Object.SerialNumber, $GroupName | Write-Verbose
                    
                    # Build DeviceList object for paylaod
                    $DeviceList = [PSCustomObject]@{
                        deviceId = $server.id
                        
                    }
                    
                    # Build DeviceInfo object for tracking
                    $DeviceInfo = [PSCustomObject]@{
                        serialnumber = $server.serialNumber
                        
                    }
                    
                    # Building the list of devices object for payload
                    [void]$DevicesList.Add($DeviceList)
                    
                    # Building the list of devices object for tracking
                    [void]$DevicesTrackingList.Add($DeviceInfo)
                    
                }
            }
        }
        elseif ($all -and -not $GroupMembers) {

            "[{0}] Tracking object: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | out-string) | Write-Verbose

            # Must return a message if no servers are member of the group when all is used
            $ObjectStatusList[0].SerialNumber = "[All]"
            $ObjectStatusList[0].Status = "Warning"
            $ObjectStatusList[0].Details = "No servers are member of the group!"
            
            if ($WhatIf) {
                $ErrorMessage = "No servers are member of the group '{0}'!" -f $GroupName
                Write-warning $ErrorMessage
            }
        }

        
       
      

        if ($DevicesList) {

            if ($ResetBios) {

                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" + "?reset-subsystems=BIOS"

            }
            else {
                
                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" 
            
            }

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                devices = $DevicesList
            } 

            # Remove Devices from group  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Server successfully removed from '$groupname' group in '$Region' region"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object serialnumber -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Server cannot be removed from '$groupname' group!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        elseif ($All -and $_group.devices) {

            if ($ResetBios) {

                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" + "?force=true&reset-subsystems=BIOS"
                
            }
            else {
                
                $Uri = $COMGroupsUri + "/" + $Group.ID + "/devices/unassign" + "?force=true"

            }

            # Remove all devices from group  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                    
                    $ObjectStatusList[0].SerialNumber = "[All]"
                    $ObjectStatusList[0].Status = "Complete"
                    $ObjectStatusList[0].Details = "All servers successfully removed from '$groupname' group in '$Region' region"
                }                    
            }
            catch {
                
                if (-not $WhatIf) {
                    
                    $ObjectStatusList[0].SerialNumber = "[All]"
                    $ObjectStatusList[0].Status = "Failed"
                    $ObjectStatusList[0].Details = "Servers cannot be removed from '$groupname' group!"
                    $ObjectStatusList[0].Exception = $_.Exception.message 
                }
            }
        }


        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed to be removed from $groupname group!"
          
            }
            
            Return $ObjectStatusList
        }
    }
}

#EndRegion


#Region --- JOB TEMPLATES ---

Function Get-HPECOMJobTemplate {
    <#
    .SYNOPSIS
    Retrieve the list of job templates.

    .DESCRIPTION
    This Cmdlet returns a collection of job templates that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Optional parameter that can be used to specify the name of a job template to display.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMJobTemplate -Region us-west

    Return all job templates resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMJobTemplate -Region us-west -Name OrchestratorGroupIloSettings

    Return the job template resource named 'OrchestratorGroupIloSettings' located in the western US region. 

    .INPUTS
    No pipeline support

   
    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"

                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$Name,

        [Switch]$WhatIf
       
    ) 


    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose     
        
        $Uri = $COMJobTemplatesUri

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            

            if ($Name) {

                $CollectionList = $CollectionList | Where-Object name -eq $Name

            }   
             
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.JobTemplates"    
    
            $ReturnData = $ReturnData | Sort-Object name 
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- JOBS ---

function Wait-HPECOMJobComplete {
    <#
    .SYNOPSIS
    Wait for a job to complete.
    
    .DESCRIPTION    
    This blocking Cmdlet assists a caller with monitoring a specific job resource, and will wait for the given job to "complete" (get to a terminal state, including error) or timeout.  
    The Cmdlet accepts either the job URI or resource object via pipeline.
    Once the job is no longer in a running state, the cmlet will return the job resource object.  
    The caller should examine the taskState property/key for the final task status.
    
    .PARAMETER Region
    Name of the region. 
    
    .PARAMETER Job
    Job URI or resource object  
    
    .PARAMETER Timeout
    Timeout in seconds before the cmdlet stops

    .PARAMETER Interval
    Polling interval in seconds

    .EXAMPLE
    Get-HPECOMJob -Region us-west -Limit 2 | Wait-HPECOMJobComplete

    .EXAMPLE
    Wait-HPECOMJobComplete -Region us-west -Job '/compute-ops-mgmt/v1beta3/jobs/1649bcb6-6362-44bf-a737-8caa5142be6e' 

    .EXAMPLE
    Stop-HPECOMserver -Region us-west -Name HOL58 -Async  | Wait-HPECOMJobComplete 

    .EXAMPLE
    '/compute-ops-mgmt/v1beta3/jobs/1649bcb6-6362-44bf-a737-8caa5142be6e', '/compute-ops-mgmt/v1beta3/jobs/e8b39555-1dd0-4baf-8f62-bc39d584d8f3' | Wait-HPECOMJobComplete -Region us-west 

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
                
    #>

    [CmdletBinding ()]
    Param(

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      

        [Parameter (ValueFromPipeline, Mandatory)]
        [Alias ('resourceUri')]
        [ValidateNotNullOrEmpty()]
        [Object]$Job,

        # Timeout in seconds
        [Parameter (Mandatory = $false)]
        [int]$Timeout = 300, # $DefaultTimeout,

        # Polling interval in seconds
        [int]$Interval = 5

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $startTime = Get-Date
        $endTime = $startTime.AddSeconds($Timeout)
        $jobState = ""
        $jobResource = $null
        $jobResourceSN = $null
        $percentComplete = 0

        $JobCollection = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Validate the job object

        if (($job -is [String]) -and ($Job.StartsWith($COMJobsUri))) {

            "[{0}] Processing job resource uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $job | Write-Verbose       
    
            $Uri = $Job

        }

        elseif ($Job -is [PSCustomObject] -and $Job.type -ieq 'compute-ops-mgmt/job') {

            "[{0}] Job is $($Job.GetType()). Job URI: $($Job.resourceUri)" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            $Uri = $Job.resourceUri

        }

        else {

            $ErrorMessage = "Invalid job resourceUri provided. Please verify the job object you are passing and try again."         
            $ErrorRecord = New-ErrorRecord InvalidResourceUri InvalidArgument -TargetObject 'Job' -Message $ErrorMessage -TargetType $ResourceUri.GetType().Name
            $PSCmdlet.ThrowTerminatingError($ErrorRecord )

        }    

        while ($true) {

            # Update the progress bar
            $elapsedTime = (Get-Date) - $startTime
            $percentComplete = [math]::Min((($elapsedTime.TotalSeconds / $Timeout) * 100), 100)
            
            try {
                
                $jobResource = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method GET -WhatIfBoolean $WhatIf 
                
                "[{0}] Get job raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobResource | Write-Verbose
                
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }                                
            
            # Extract job state from the resource object
            $jobState = $jobResource.State
            
            if ($jobResource.associatedResourceId -like "*+*") {
                
                $_jobResource = ($jobResource.associatedResourceId -split "\+")[-1]

                Write-Progress -Activity "Waiting for job completion" `
                    -Status "$_jobResource - Current state: $jobState" `
                    -PercentComplete $percentComplete
            }
            else {

                Write-Progress -Activity "Waiting for job completion" `
                    -Status "Current state: $jobState" `
                    -PercentComplete $percentComplete

            }
          

            "[{0}] Current job state: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobState | Write-Verbose
            
            if ($jobState -match "COMPLETE|ERROR|STALLED") {

                Write-Progress -Activity "Job completion" -Completed
                break
            }

            if ((Get-Date) -ge $endTime) {
                # throw "Timeout reached waiting for job to complete."
                $errorMessage = "Timeout reached waiting for job '{0}' to complete." -f $jobResource.name
                $errorRecord = New-ErrorRecord TimeoutError OperationTimeout -Message $ErrorMessage 
                Write-Progress -Activity "Job timeout reached" -Completed
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            }

            Start-Sleep -Seconds $Interval
        }

        Write-Progress -Activity "Job has reached terminal state" -Completed
        "[{0}] Job has reached terminal state: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jobState | Write-Verbose

        [void]$JobCollection.Add($jobResource)

    }

    End {

        $ReturnData = Invoke-RepackageObjectWithType -RawObject $JobCollection -ObjectName "COM.Jobs"    

        return $ReturnData 

    }
}


Function Get-HPECOMJob {
    <#
    .SYNOPSIS
    Retrieve the list of jobs.

    .DESCRIPTION
    This Cmdlet returns a collection of the last 50 jobs that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER ShowRunning
    Optional switch parameter that can be used to display only running jobs.

    .PARAMETER JobResourceUri
    Optional parameter that can be used to specify the Uri of a job to display.

    .PARAMETER Type
    Type of the job resource such as 'servers', 'groups', etc.

    .PARAMETER Limit
    This parameter allows you to define the number of jobs to be displayed. 

    .PARAMETER NoLimit
    This switch parameter can be used to display the total number of jobs. Be aware, however, that this may take some time, depending on your history.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMJob -Region us-west 

    Return the last 50 jobs resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Type servers

    Return the last 50 jobs resources of type 'servers' located in the western US region. 

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Type Analyze -NoLimit

    Return all jobs resources of type 'Analyze' located in the western US region.

    .EXAMPLE
    Get-HPECOMJob -Region us-west -NoLimit

    Return all jobs resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMActivity -Region eu-central -GroupName ESXi_group -Limit 1 | Get-HPECOMJob

    Retrieves the job resource associated with the most recent activity of the 'ESXi_group' in the central EU region.

    .EXAMPLE
    Get-HPECOMJob -Region us-west -ResourceUri '/compute-ops-mgmt/v1beta3/jobs/1649bcb6-6362-44bf-a737-8caa5142be6e'

    Return the job resource with the specified resource URI located in the western US region. 

    .INPUTS
    System.Collections.ArrayList
        List of activities retrieved using 'Get-HPECOMActivity'.


    
   #>
    [CmdletBinding(DefaultParameterSetName = "Limit")]
    Param( 
    
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Switch]$ShowRunning,
        
        [Parameter (ValueFromPipelineByPropertyName)] 
        [Alias('sourceResourceUri')]
        [string]$JobResourceUri,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Analyze', 'Filters', 'Groups', 'Oneview-appliances', 'Reports', 'Servers', 'Server-hardware', 'Settings')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Analyze', 'Filters', 'Groups', 'Oneview-appliances', 'Reports', 'Servers', 'Server-hardware', 'Settings')]
        [string]$Type,

        [Parameter (ParameterSetName = 'Limit')]
        [ValidateScript({ $_ -le 1000 })]
        [int]$Limit,

        [Parameter (ParameterSetName = 'NoLimit')]
        [Switch]$NoLimit,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command
  
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        # Validate the job object

        if ($JobResourceUri) {

            if ($JobResourceUri -match '^/compute-ops-mgmt/[^/]+/jobs/[^/]+$') {

                "[{0}] Processing job resource uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $JobResourceUri | Write-Verbose       

            }

            else {

                $ErrorMessage = "Invalid job resourceUri provided. Please verify the job object you are passing and try again."         
                $ErrorRecord = New-ErrorRecord InvalidResourceUri InvalidArgument -TargetObject 'Job' -Message $ErrorMessage -TargetType $JobResourceUri.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )

            }  
        }

    }
    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($JobResourceUri) {

            "[{0}] Processing job resource uri: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $JobResourceUri | Write-Verbose       

            $Uri = $JobResourceUri    
            
        }
        else {
            $uri = $COMJobsUri
        }
        
        
        if ($Limit) {
            $Uri = $Uri + "?limit=$limit"    
        }
        elseif ($NoLimit) {
            $Uri = $Uri
        }
        else {
            $Uri = $Uri + "?limit=50"    

        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
             
            if ($Type) {
                $CollectionList = $CollectionList | Where-Object associatedResourceType -eq $Type
            }

            if ($ShowRunning) {
                $CollectionList = $CollectionList | Where-Object state -eq "Running"
            }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Jobs"    
            $ReturnData = $ReturnData | Sort-Object -Property createdAt -Descending
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function Start-HPECOMserver {
    <#
    .SYNOPSIS
    Power on a server resource.

    .DESCRIPTION
    This cmdlet initiates the power state of a server using the virtual power button     
    It provides options for scheduling the execution at a specific time and setting recurring schedules.

    .PARAMETER Region 
    Specifies the name of the region where the server is located. 

    .PARAMETER ServerSerialNumber 
    Specifies the serial number of the server to power on. 

    .PARAMETER ScheduleTime
    Indicates when to schedule the power on operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Start-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312
    
    This command powers on the server with the serial number 'CZ12312312' and waits for the job to complete before returning the job resource object. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-2  | Start-HPECOMserver -Async

    This command powers on the server named 'ESX-2' and immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -PowerState OFF -ConnectionType Direct | Start-HPECOMserver 

    This command powers on all servers in the 'us-west' region that are currently powered off and are directly managed (not OneView managed, as power controls are unsupported).

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Start-HPECOMserver -Region eu-central

    This command powers on the servers with the serial numbers 'CZ12312312' and 'DZ12312312' in the `eu-central` region.

    .EXAMPLE
    Start-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6)  

    This command schedules a power on operation for the server with the serial number 'CZ12312312' in the `eu-central` region to occur six hours from the current time. 

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -ServerSerialNumber CZ12312312 | Start-HPECOMserver -ScheduleTime (Get-Date).AddDays(2)
  
    This command retrieves the server with the serial number 'CZ12312312' in the `eu-central` region and schedules a power on to occur two days from the current date.
    
    .EXAMPLE
    Start-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W
 
    Schedules a weekly power-on operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,        

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [String]$Interval,    

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [Switch]$WhatIf
    ) 
    
    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'PowerOn.New'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $Uri = $COMJobsUri  
        $SetServerPowerControlStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {

            $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if (-not $_server) {

            # Must return a message if not found
            $errorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ServerSerialNumber
            Write-warning $ErrorMessage

        }
        elseif ($_server.connectionType -eq "ONEVIEW") {

            # Not supported on OneView managed servers!
            # Must return a message if OneView managed server
            $ErrorMessage = "The attempted operation on server '{0}' is not supported on OneView managed servers!" -f $ServerSerialNumber
            Write-warning $ErrorMessage
            
        }
        elseif ($_server.hardware.powerState -eq "ON") {
            
            $ErrorMessage = "Server '{0}' requested Power State '{1}' is the same value as the current Server Power State '{1}'." -f $ServerSerialNumber, $_server.hardware.powerState  
            Write-warning $ErrorMessage
            
        }
        else {
            
            $_serverResourceUri = $_server.resourceUri
            
            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_serverResourceUri
                    # data           = $data
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($ServerSerialNumber)_ServerPowerOn_Schedule_$($randomNumber)"
                $Description = "Scheduled task to power on server '$ServerSerialNumber'"


                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }


                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_serverResourceUri
                    purpose               = "SERVER_POWER_ON"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {
                
                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_serverResourceUri
                }
                
            }          
            
            $payload = ConvertTo-Json $payload -Depth 10 

        
            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
                
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
                
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  
        }

        if ($ScheduleTime) {

            if (-not $WhatIf ) {
    
                Return $ReturnData
            
            }
        }

        if (-not $ScheduleTime) {

            [void] $SetServerPowerControlStatus.add($_resp)

        }
    }

    end {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $SetServerPowerControlStatus
        
        }
    }
}


Function Restart-HPECOMserver {
    <#
    .SYNOPSIS
    Restart a server resource.

    .DESCRIPTION
    This cmdlet initiates the restart of a server to force the server to warm-boot which resets CPUs and I/O resources. 
    It provides options for scheduling the execution at a specific time and setting recurring schedules.
    Using this option circumvents the graceful shutdown features of the operating system.
            
    .PARAMETER Region 
    Specifies the name of the region where the server is located. 

    .PARAMETER ServerSerialNumber 
    Specifies the serial number of the server to restart. 

    .PARAMETER ScheduleTime
    Indicates when to schedule the restart operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Restart-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312
    
    This command restarts the server with the serial number 'CZ12312312' and waits for the job to complete then return the job resource object. 

    .EXAMPLE
    Restart-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312 -Async 

    This command restarts the server with the serial number 'CZ12312312' and immediately returns the asynchronous job resource to monitor.
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-2  | Start-HPECOMserver -Async

    This command restarts the server named 'ESX-2' and immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -PowerState ON -ConnectionType Direct | Restart-HPECOMserver 

    This command restarts on all servers in the 'us-west' region that are currently powered on and are directly managed (not OneView managed, as power controls are unsupported).
    
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Restart-HPECOMserver -Region eu-central

    This command restarts the servers with the serial numbers 'CZ12312312' and 'DZ12312312' in the `eu-central` region.

    .EXAMPLE
    Restart-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6)  

    This command schedules a restart operation for the server with the serial number 'CZ12312312' in the `eu-central` region to occur six hours from the current time. 

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZ12312312 | Restart-HPECOMserver -ScheduleTime (Get-Date).AddDays(2)
  
    This command retrieves the server with the serial number 'CZ12312312' in the `eu-central` region and schedules a restart to occur two days from the current date.

    .EXAMPLE
    Restart-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W
 
    Schedules a weekly restart operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [String]$Interval,    

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'Restart.New'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $Uri = $COMJobsUri  
        $SetServerPowerControlStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {
          
            $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber


        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_server) {

            # Must return a message if not found
            $errorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ServerSerialNumber
            Write-warning $ErrorMessage

        }
        elseif ($_server.connectionType -eq "ONEVIEW") {

            # Not supported on OneView managed servers!
            # Must return a message if OneView managed server
            $ErrorMessage = "The attempted operation on server '{0}' is not supported on OneView managed servers!" -f $ServerSerialNumber
            Write-warning $ErrorMessage
            
        }
        elseif ($_server.hardware.powerState -eq "OFF") {
            
            $ErrorMessage = "Server '{0}' power state must be ON to be restarted." -f $SerialNumber
            Write-warning $ErrorMessage
            
        }
        else {
            
            $_serverResourceUri = $_server.resourceUri

            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_serverResourceUri
                    # data           = $data
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($ServerSerialNumber)_ServerRestart_Schedule_$($randomNumber)"
                $Description = "Scheduled task to restart server '$ServerSerialNumber'"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }    

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_serverResourceUri
                    purpose               = "SERVER_RESTART"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_serverResourceUri
    
                }   
        
                $payload = ConvertTo-Json $payload -Depth 10 

                try {
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                    # Add region to object
                    $_resp | Add-Member -type NoteProperty -name region -value $Region

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
        
                            $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"
    
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                        }

                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {
                    
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
                    
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 420
        
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                        }
                    }
                }
                catch {

                    if (-not $WhatIf) {

                        $PSCmdlet.ThrowTerminatingError($_)

                    }
                }  


            }   
        }

        if ($ScheduleTime) {

            if (-not $WhatIf ) {
    
                Return $ReturnData
            
            }
        }

        if (-not $ScheduleTime) {

            [void] $SetServerPowerControlStatus.add($_resp)

        }

    }

    end {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $SetServerPowerControlStatus
        
        }
    }
}


Function Stop-HPECOMserver {
    <#
    .SYNOPSIS
    Power off a server resource.

    .DESCRIPTION
    This cmdlet initiates a graceful shutdown of a server using the virtual power button. It provides options for scheduling the execution at a specific time and setting recurring schedules.

    Note: If the OS does not shut down, this cmdlet will forcibly power off the server using the force-off option.
            
    .PARAMETER Region 
    Specifies the name of the region where the server is located. 

    .PARAMETER ServerSerialNumber 
    Specifies the serial number of the server to power off. 

    .PARAMETER ScheduleTime
    Indicates when to schedule the power off operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Force 
    Switch parameter to force the power off, akin to pressing the physical power button for 5 seconds and then releasing it.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Stop-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312
    
    This command initiates a graceful shutdown of the server with the serial number 'CZ12312312' and waits for the job to complete before returning the job resource object. 
    
    .EXAMPLE
    Stop-HPECOMserver -Region us-west -ServerSerialNumber CZ12312312 -Force
    
    This command forces the server with the serial number 'CZ12312312' to power off without waiting for a graceful shutdown of the OS, then waits for the job to complete, and finally returns the job resource object.

    .EXAMPLE 
    Get-HPECOMServer -Region eu-central -Name ESX-2  | Stop-HPECOMserver -Async

    This command powers off the server named 'ESX-2' and immediately returns the asynchronous job resource to monitor.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -PowerState ON -ConnectionType Direct | Stop-HPECOMserver 

    This command initiates a graceful shutdown of all servers in the 'us-west' region that are currently powered on and are directly managed (not OneView managed, as power controls are unsupported).
    
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Stop-HPECOMserver -Region eu-central

    This command powers off the servers with the serial numbers 'CZ12312312' and 'DZ12312312' in the `eu-central` region.

    .EXAMPLE
    Stop-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6)  

    This command schedules a power off operation for the server with the serial number 'CZ12312312' in the `eu-central` region to occur six hours from the current time. 

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZ12312312 | Stop-HPECOMserver -ScheduleTime (Get-Date).AddDays(2)
  
    This command retrieves the server with the serial number 'CZ12312312' in the `eu-central` region and schedules a power off to occur two days from the current date.
    
    .EXAMPLE
    Stop-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W
 
    This command schedules a weekly graceful shutdown operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .EXAMPLE
    Stop-HPECOMserver -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddHours(6) -Interval P1W -Force
 
    This command schedules a weekly forced shutdown operation for the server with serial number 'CZ12312312' in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,    

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,
        
        [Parameter (ParameterSetName = 'SerialNumber')]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [switch]$Force,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [Parameter (ParameterSetName = 'ScheduleSerialNumber')]
        [String]$Interval,    

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [Switch]$WhatIf
    ) 
  


    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'PowerOff.New'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $Uri = $COMJobsUri  
        $SetServerPowerControlStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        try {

            $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_server) {

            # Must return a message if not found
            $errorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ServerSerialNumber
            Write-warning $ErrorMessage

        }
        elseif ($_server.connectionType -eq "ONEVIEW") {

            # Not supported on OneView managed servers!
            # Must return a message if OneView managed server
            $ErrorMessage = "The attempted operation on server '{0}' is not supported on OneView managed servers!" -f $ServerSerialNumber
            Write-warning $ErrorMessage
            
        }
        elseif ($_server.hardware.powerState -eq "OFF") {
            
            $ErrorMessage = "Server '{0}' requested Power State '{1}' is the same value as the current Server Power State '{1}'." -f $ServerSerialNumber, $_server.hardware.powerState  
            Write-warning $ErrorMessage
            
        }
        else {

            $_serverResourceUri = $_server.resourceUri

            if ($ScheduleTime) {
                    
                if ($Force) {

                    $data = @{operationType = "ForceOff" }
                    
                }
                else {

                    $data = @{operationType = "GracefulShutdown" }
                    
                }

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_serverResourceUri
                    data           = $data
                }      
               

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($ServerSerialNumber)_ServerPowerOff_Schedule_$($randomNumber)"
                $Description = "Scheduled task to power off server '$ServerSerialNumber'"


                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }    


                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_serverResourceUri
                    purpose               = "SERVER_POWER_ON"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                if ($Force) {

                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_serverResourceUri
                        data           = @{operationType = "ForceOff" }
                    } 
                }
                else {

                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_serverResourceUri
                        data           = @{operationType = "GracefulShutdown" }
                    } 
                }
              
            }

            $payload = ConvertTo-Json $payload -Depth 10 

        
            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Adding region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {

                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
                
                        if ($GracefulShutdown) {
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 420
                            
                        }
                        else {

                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri
                        }
        
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

        }

        if ($ScheduleTime) {

            if (-not $WhatIf ) {
    
                Return $ReturnData
            
            }
        }           

        if (-not $ScheduleTime) {
            
            [void] $SetServerPowerControlStatus.add($_resp)
        }

    }

    end {

        if (-not $ScheduleTime -and -not $WhatIf ) {

            Return $SetServerPowerControlStatus
        
        }
    }
}


function Update-HPECOMServerFirmware {
    <#
    .SYNOPSIS
    Update the firmware on a server.
    
    .DESCRIPTION   
    This cmdlet updates the firmware on a specified server, identified by its serial number. It also provides an option to schedule the update at a specific time.

    .PARAMETER Region
    Specifies the name of the region where the server is located. 
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the firmware update will be performed.
    
    .PARAMETER FirmwareBundleReleaseVersion
    Mandatory parameter that defines the firmware bundle release version to use for updating the server. 
    This release version can be found using 'Get-HPECOMFirmwareBundle'.

    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER InstallHPEDriversAndSoftware
    Specifies whether to install HPE drivers and software during the firmware update.

    .PARAMETER PowerOffAfterUpdate
    Specifies whether to power off the server after the firmware update.

    .PARAMETER DisablePrerequisiteCheck
    Specifies whether to disable the prerequisites check before running the firmware update.

    .PARAMETER AllowFirmwareDowngrade
    Specifies whether to allow the downgrade of firmware during the firmware update.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMServerFirmware -Region us-west -ServerSerialNumber 2M28490180 -FirmwareBundleReleaseVersion "2024.04.00.01" -InstallHPEDriversAndSoftware -PowerOffAfterUpdate -DisablePrerequisiteCheck -AllowFirmwareDowngrade

    This command updates the firmware on a server with serial number `2M28490180` located in the `us-west` region using firmware bundle release version `2024.04.00.01`. 
    It also installs HPE drivers and software, powers off the server after the update, disables the prerequisites check, and allows firmware downgrade. 
   
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Update-HPECOMServerFirmware -Region eu-central -FirmwareBundleReleaseVersion "2024.04.00.01"

    This command updates the firmware on servers with serial numbers `CZ12312312` and `DZ12312312` located in the `eu-central` region using firmware bundle release version `2024.04.00.01`.
    By default, it does not install HPE drivers and software, does not power off the server after the update, enables the prerequisite check, and does not allow firmware downgrade.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name HOL58 | Update-HPECOMServerFirmware -FirmwareBundleReleaseVersion "2024.04.00.01"

    This command updates the firmware on a server with the name `HOL58` located in the `us-west` region using firmware bundle release version `2024.04.00.01`. 
    By default, it does not install HPE drivers and software, does not power off the server after the update, enables the prerequisite check, and does not allow firmware downgrade.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectedState True -PowerState OFF -Model 'ProLiant DL385 Gen10 Plus' | Update-HPECOMServerFirmware -FirmwareBundleReleaseVersion "2024.04.00.01" -PowerOffAfterUpdate -AllowFirmwareDowngrade -Async 

    This command update all DL385 Gen10 Plus servers that are powered off and connected to COM with the specified firmware bundle release version. 
    The first command retrieves a list of all "ProLiant DL385 Gen10 Plus" servers in the "us-west" region that are currently powered off and connected.
    The retrieved servers are then piped (|) to the Update-HPECOMServerFirmware cmdlet, which updates their firmware to the specified version.
    The command also powers off the servers after the update, allows firmware downgrade and returns mmediately the async task.

    .EXAMPLE
    Update-HPECOMServerFirmware -Region eu-central -ServerSerialNumber DZ12312312 -FirmwareBundleReleaseVersion 2024.04.00.02 -ScheduleTime (Get-Date).AddMonths(6) -InstallHPEDriversAndSoftware -PowerOffAfterUpdate -AllowFirmwareDowngrade

    This command creates a schedule to update the firmware of a server with the serial number `DZ12312312` in the `eu-central` region using firmware bundle release version `2024.04.00.01`. 
    The update is scheduled to occur six months from the current date and includes installing HPE drivers and software while allowing firmware downgrade.
    The command also powers off the server after the update.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Model "ProLiant DL360 Gen10 Plus" | Update-HPECOMServerFirmware -FirmwareBundleReleaseVersion 2024.04.00.02 -ScheduleTime (Get-Date).AddDays(4) -InstallHPEDriversAndSoftware  -AllowFirmwareDowngrade

    This example retrieves a list of all "ProLiant DL360 Gen10 Plus" servers in the `eu-central` region and schedules a firmware update for them using bundle version `2024.04.00.02`. 
    The update is scheduled to occur four days from the current date and includes installing HPE drivers and software while allowing firmware downgrade.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ScheduleSerialNumber')]
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,
        
        [Parameter (Mandatory)]
        [String]$FirmwareBundleReleaseVersion,

        [Parameter (Mandatory, ParameterSetName = 'ScheduleSerialNumber')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [switch]$InstallHPEDriversAndSoftware,

        [switch]$PowerOffAfterUpdate,

        [switch]$DisablePrerequisiteCheck,

        [switch]$AllowFirmwareDowngrade,

        [Parameter (ParameterSetName = 'SerialNumber')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600

        $Caller = (Get-PSCallStack)[1].Command
    
        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $_JobTemplateName = 'FirmwareUpdate.New'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $ServerFWUpdateStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_server) {

            # Must return a message if not found
            $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ServerSerialNumber
            Write-warning $ErrorMessage

        }
        else {

            $_serverResourceUri = $_server.resourceUri
            
            [int]$_serverGeneration = $_server.serverGeneration -replace "GEN_", ""
            
            "[{0}] Server '{1}' generation is '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerSerialNumber, $_serverGeneration | Write-Verbose
            
            if ($_serverGeneration -le 9) {
                # Must return a message if generation is not supported
                $ErrorMessage = "Server '{0}' is a Gen{1} and is not supported by firmware bundle release version '{2}'." -f $ServerSerialNumber, $_serverGeneration, $FirmwareBundleReleaseVersion
                Write-warning $ErrorMessage
                
            }
            else {

                try {
                    $Bundle = Get-HPECOMFirmwareBundle -Region $Region -ReleaseVersion $FirmwareBundleReleaseVersion -Generation $_serverGeneration
                    $BundleID = $Bundle.id
                    
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }
    
                if (-not $BundleID) {
                    # Must return a message if not found
                    $ErrorMessage = "Firmware bundle release version '{0}' cannot be found in the Compute Ops Management instance!" -f $FirmwareBundleReleaseVersion
                    throw $ErrorMessage
        
                }
                else {   
    
                    if ($AllowFirmwareDowngrade) {
                        $Downgrade = $true
                    }
                    else {
                        $Downgrade = $false
                    }
    
                    if ($PowerOffAfterUpdate) {
                        $PowerOff = $true
                    }
                    else {
                        $PowerOff = $false
                    }
    
                    if ($InstallHPEDriversAndSoftware) {
                        $InstallSwDrivers = $true
                    }
                    else {
                        $InstallSwDrivers = $false
                    }
    
                    if ($DisablePrerequisiteCheck) {
                        $PrerequisiteCheck = $false
                    }
                    else {
                        $PrerequisiteCheck = $true
                    }
            
                    $data = @{
                        bundle_id          = $BundleID
                        downgrade          = $Downgrade
                        install_sw_drivers = $InstallSwDrivers
                        power_off          = $PowerOff
                        prerequisite_check = $PrerequisiteCheck
                    }
    
                    if ($ScheduleTime) {
    
                        $uri = $COMSchedulesUri
    
                        $_Body = @{
                            jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                            # jobTemplateUri = $JobTemplateUri
                            resourceUri    = $_serverResourceUri
                            data           = $data
                        }      
        
                        $Operation = @{
                            type   = "REST"
                            method = "POST"
                            uri    = "/api/compute/v1/jobs"
                            body   = $_Body
        
                        }
    
                        $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                        $Name = "$($ServerSerialNumber)_ServerFirmwareUpdate_Schedule_$($randomNumber)"
                        $Description = "Scheduled task to update firmware for '$ServerSerialNumber' server"
        
    
                        $Schedule = @{
                            startAt = $ScheduleTime
                            # interval = $Null
                        }
        
    
                        $Payload = @{
                            name                  = $Name
                            description           = $Description
                            associatedResourceUri = $_serverResourceUri
                            purpose               = "SERVER_FW_UPDATE"
                            schedule              = $Schedule
                            operation             = $Operation
        
                        }
    
                    }
                    else {
                    
                        $Payload = @{
                            jobTemplateUri = $JobTemplateUri
                            resourceUri    = $_serverResourceUri
                            data           = $data
                        }      
                    }
    
                    $payload = ConvertTo-Json $payload -Depth 10 
    
                    try {
                        $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
    
                        # Add region to object
                        $_resp | Add-Member -type NoteProperty -name region -value $Region
    
                        if ($ScheduleTime) {
                            
                            if (-not $WhatIf) {
            
                                $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"
        
                                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
        
                            }
                        }
                        else {
    
                            if (-not $WhatIf -and -not $Async) {
                
                                "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
                
                                $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $TimeoutinSecondsPerServer 
                                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                            }
                        }
                    }
                    catch {
    
                        if (-not $WhatIf) {
    
                            $PSCmdlet.ThrowTerminatingError($_)
    
                        }
                    }  
    
                    if ($ScheduleTime) {
    
                        if (-not $WhatIf ) {
                
                            Return $ReturnData
                        
                        }
                    }
                }

            }

        }

        if (-not $ScheduleTime) {
      
            [void] $ServerFWUpdateStatus.add($_resp)

        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf) {

            Return $ServerFWUpdateStatus
            
        }

    }
}


function Update-HPECOMServeriLOFirmware {
    <#
    .SYNOPSIS
    Updates the iLO firmware component on a server. 
    
    .DESCRIPTION   
    This cmdlet updates the iLO firmware of a specified server using its serial number by installing the firmware version required by Compute Ops Management.
    It also provides an option to schedule the update at a specific time.

    Note: This cmdlet can ONLY be used when automatic iLO firmware updates are disabled in your workspace. 
          Refer to 'Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber -ShowAutoiLOFirmwareUpdateStatus', 'Enable-HPECOMServerAutoiLOFirmwareUpdate', and 'Disable-HPECOMServerAutoiLOFirmwareUpdate' for more information.
    
    .PARAMETER Region
    Specifies the name of the region where the server is located. 
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the iLO firmware update will be performed.
    
    .PARAMETER ScheduleTime
    Indicates when to schedule the firmware update operation..

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMServeriLOFirmware -Region us-west -ServerSerialNumber 2M240400JN 

    This command updates the iLO firmware on a server with serial number `2M240400JN` located in the `us-west` region.
   
    .EXAMPLE
    Update-HPECOMServeriLOFirmware -Region us-west -ServerSerialNumber 2M240400JN -Async

    This command updates the iLO firmware on a server with serial number `2M240400JN` located in the `us-west` region and immediately returns the async task.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "HOL58" | Update-HPECOMServeriLOFirmware 

    This command updates the iLO firmware on a server with the name `HOL58` located in the `eu-central` region.
    
    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model 'ProLiant DL385 Gen10 Plus' | Update-HPECOMServeriLOFirmware 

    This command updates the iLO firmware on all 'ProLiant DL385 Gen10 Plus' servers located in the `us-west` region. 

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Update-HPECOMServeriLOFirmware -Region eu-central 
    
    This command updates the iLO firmware on the servers with serial numbers `CZ12312312` and `DZ12312312` located in the `eu-central` region.
    
    .EXAMPLE
    Update-HPECOMServeriLOFirmware -Region eu-central -ServerSerialNumber CZ12312312 -ScheduleTime (Get-Date).AddMinutes(10)

    This command schedules the iLO firmware update for the server with serial number `CZ12312312` located in the `eu-central` region to run ten minutes from now.
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectedState True -Model "ProLiant DL360 Gen10 Plus" | Update-HPECOMServeriLOFirmware -ScheduleTime (Get-Date).AddHours(12)

    This command schedules the iLO firmware update for all 'ProLiant DL360 Gen10 Plus' servers located in the `eu-central` region to run twelve hours from now. 

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.


    #>

    [CmdletBinding(DefaultParameterSetName = 'Scheduled')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'IloOnlyFirmwareUpdate'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri      
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $ServeriLOFWUpdateStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            
            $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_server) {
            # Must return a message if not found
            $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance." -f $ServerSerialNumber
            Write-warning $ErrorMessage
            return

        }
        else {

            # Not supported on OneView managed servers
            if ($_server.connectionType -eq "ONEVIEW") {
                
                # Must return a message if OneView managed server
                $ErrorMessage = "Operation not supported on server '{0}' because it is managed by HPE OneView." -f $ServerSerialNumber
                Write-warning $ErrorMessage
                return
            }

            # Only supported if ServerAutoiLOFirmwareUpdate is disabled
            if ((Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber -ShowAutoiLOFirmwareUpdateStatus).autoIloFwUpdate -eq $True ) {

                # Must return a message if OneView managed server

                $ErrorMessage = "Operation not supported on server '{0}' because auto iLO firmware update is enabled. To proceed, disable auto iLO firmware update using 'Disable-HPECOMServerAutoiLOFirmwareUpdate'." -f $ServerSerialNumber
                Write-warning $ErrorMessage
                return
            }

            $_serverResourceUri = $_server.resourceUri
           


            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_serverResourceUri
                    # data           = $data
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($ServerSerialNumber)_ServeriLOFirmwareUpdate_Schedule_$($randomNumber)"
                $Description = "Scheduled task to update iLO firmware for '$ServerSerialNumber' server"


                $Schedule = @{
                    startAt = $ScheduleTime
                    # interval = $Null
                }


                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_serverResourceUri
                    purpose               = "SERVER_ILO_FW_UPDATE"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_serverResourceUri
                
                }      
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
        
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
        
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 600
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $ServeriLOFWUpdateStatus.add($_resp)

        }

    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $ServeriLOFWUpdateStatus
        
        }

    }
}


function Update-HPECOMGroupFirmware {
    <#
    .SYNOPSIS
    Updates the firmware of a group of servers.
    
    .DESCRIPTION   
    This cmdlet initiates a server group firmware update that will affect some or all of the server group members. It also provides an option to schedule the update at a specific time.
    
    .PARAMETER Region
    Name of the region where the group is located. 
        
    .PARAMETER GroupName
    Name of the group on which the firmware update will be performed.     
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the firmware update will be performed.

    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER SerialUpdates
    Specifies to perform the firmware updates to each server in the group in serial (instead of parallel by default). 

    .PARAMETER StopOnFailure
    Specifies if the group firmware serial update process will continue after the first failure. 
    When StopOnFailure is not used, the update continues after a failure. When used, the update stops after a failure and the remaining servers in the group will not be updated. 
    
    Note: This switch is only applicable for serial firmware updates (i.e. when SerialUpdates switch is used). 
    
    .PARAMETER InstallHPEDriversAndSoftware
    Specifies whether to install HPE drivers and software during the firmware update.

    .PARAMETER PowerOffAfterUpdate
    Specifies whether to power off the server after the firmware update.

    .PARAMETER DisablePrerequisiteCheck
    Specifies whether to disable the prerequisites check before running the firmware update.

    .PARAMETER AllowFirmwareDowngrade
    Specifies whether to allow the downgrade of firmware during the firmware update.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -PowerOffAfterUpdate 

    This command updates in parallel the firmware for all servers in a group named `ESXi_800` located in the `eu-central` region. It also powers off the servers after the update.
   
    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -SerialUpdates -StopOnFailure -AllowFirmwareDowngrade -InstallHPEDriversAndSoftware -DisablePrerequisiteCheck 
    
    This command updates in serial the firmware for all servers in a group named `ESXi_800` located in the `eu-central` region. It specifies that after a failure, the firmware update process will stop,
    and the remaining devices in the group will not be updated. It also installs HPE drivers and software, disables the prerequisites check, and allows firmware downgrade. 

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ2311004H' -AllowFirmwareDowngrade 

    This command updates the firmware for a specific server with the serial number `CZ2311004H` in a group named `ESXi_800` located in the `eu-central` region. It allows firmware downgrade.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Update-HPECOMGroupFirmware -GroupName  ESXi_800 -AllowFirmwareDowngrade -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command updates the firmware of the selected servers as part of the 'ESXi_800' group.
    The update runs in parallel across the selected servers. Firmware downgrades are allowed if necessary. The update runs asynchronously, allowing other tasks to continue without waiting for completion.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_800 -ShowMembers | Update-HPECOMGroupFirmware 
    
    This command retrieves the list of servers in a group named 'ESXi_800' located in the 'eu-central' region and updates the firmware for all servers in the group.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800
    
    This command updates the firmware for servers with serial numbers 'CZ12312312' and 'DZ12312312' in a group named 'ESXi_800' located in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Update-HPECOMGroupFirmware } 

    This command retrieves all groups in the 'eu-central' region and updates the firmware for each group.

    .EXAMPLE
    Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_800 -ScheduleTime (Get-Date).AddDays(4)

    This command creates a schedule to update the firmware of all servers in a group named 'ESXi_800' located in the 'eu-central' region. The schedule is set to run four days from now.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object { $_.SerialNumber -eq "CZ12312312" -or $_.SerialNumber -eq "DZ12312312" } | Update-HPECOMGroupFirmware -GroupName ESXi_800 -ScheduleTime (Get-Date).AddHours(12)

    This command retrieves servers with specific serial numbers from the 'eu-central' region and schedules a firmware update for them in the 'ESXi_800' group in twelve hours.
   
    .EXAMPLE    
    Get-HPECOMGroup -Region eu-central -name ESXi_800 -ShowMembers | Select-Object -Last 2 | Update-HPECOMGroupFirmware -GroupName ESXi_800 -ScheduleTime (Get-Date).AddMonths(6)

    This example retrieves the last two servers from the 'ESXi_800' in the 'eu-central' region and schedules a firmware update for them six months from the current date.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.


    #>

    [CmdletBinding(DefaultParameterSetName = 'Scheduled')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,
        
        
        [switch]$AllowFirmwareDowngrade,
        
        [switch]$InstallHPEDriversAndSoftware,
        
        [switch]$PowerOffAfterUpdate,
        
        [switch]$DisablePrerequisiteCheck,

        [switch]$SerialUpdates,

        [switch]$StopOnFailure,

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600  # Timeout 1 hour

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupFirmwareUpdate'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()


        if ($AllowFirmwareDowngrade) {
            $Downgrade = $true
        }
        else {
            $Downgrade = $false
        }
       
        if ($StopOnFailure) {
            $StopOnFailureValue = $true
        }
        else {
            $StopOnFailureValue = $false
        }
        
        if ($PowerOffAfterUpdate) {
            $PowerOff = $true
        }
        else {
            $PowerOff = $false
        }

        if ($InstallHPEDriversAndSoftware) {
            $InstallSwDrivers = $true
        }
        else {
            $InstallSwDrivers = $false
        }

        if ($DisablePrerequisiteCheck) {
            $PrerequisiteCheck = $false
        }
        else {
            $PrerequisiteCheck = $true
        }
        
        if ($SerialUpdates -or $StopOnFailure) {
            $Parallel = $False
        }
        else {
            $Parallel = $True
        }

        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {
            
            [void]$ServersList.add($ServerSerialNumber)
        }

    }

    End {

        try {
            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $_group.devices

            $_groupName = $_group.name
            $_groupResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose

            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }

        
        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        
        
        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}' is not a member of the group '{1}'!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {
                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }
            

        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose
            
    
            $uri = $COMJobsUri

            # Serial updates
            if (-not $Parallel -and -not $ServerIdsList) {

                $data = @{
                    parallel           = $Parallel
                    stopOnFailure      = $StopOnFailureValue
                    downgrade          = $Downgrade
                    installSWDrivers   = $InstallSwDrivers
                    powerOff           = $PowerOff
                    prerequisite_check = $PrerequisiteCheck
                }

            }
            elseif (-not $Parallel -and $ServerIdsList) {

                $data = @{
                    parallel           = $Parallel
                    stopOnFailure      = $StopOnFailureValue
                    downgrade          = $Downgrade
                    installSWDrivers   = $InstallSwDrivers
                    powerOff           = $PowerOff
                    prerequisite_check = $PrerequisiteCheck
                    devices            = $ServerIdsList
                }

            }

            # Parallel updates
            elseif ($Parallel -and -not $ServerIdsList) {

                $data = @{
                    parallel           = $Parallel
                    downgrade          = $Downgrade
                    installSWDrivers   = $InstallSwDrivers
                    powerOff           = $PowerOff
                    prerequisite_check = $PrerequisiteCheck
                }

            }
            elseif ($Parallel -and $ServerIdsList) {

                $data = @{
                    parallel           = $Parallel
                    downgrade          = $Downgrade
                    installSWDrivers   = $InstallSwDrivers
                    powerOff           = $PowerOff
                    prerequisite_check = $PrerequisiteCheck
                    devices            = $ServerIdsList
                }

            }
            
            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    # jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_groupResourceUri
                    data           = $data
                }      
    
                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body
    
                }
    
                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                $Name = "$($GroupName)_ServerFirmwareUpdate_Schedule_$($randomNumber)"
                $Description = "Scheduled task to update firmware for '$_GroupName' group"
    
                
                # Get GMT time difference in hours
                # $GMTTimeDifferenceInHour = Get-GMTTimeDifferenceInMinutes
                
                # Calculate the schedule time for GMT
                # $ScheduleTimeForGMT = $ScheduleTime.AddMinutes(-$GMTTimeDifferenceInMinutes)
  
                $Schedule = @{
                    startAt = $ScheduleTime 
                    # interval = $Null
                }



                # Build payload
                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_groupResourceUri
                    purpose               = "GROUP_FW_UPDATE"
                    schedule              = $Schedule
                    operation             = $Operation
    
                }    

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_groupResourceUri
                    data           = $data
                }      
            }


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {    
                                  
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }

                }
                else {
                    
                    if (-not $WhatIf -and -not $Async) {    
                    
                        # Timeout for parallel group FW update 
                        if ($ParallelUpdates) {
                            $Timeout = $TimeoutinSecondsPerServer
                        
                        }
                        # Timeout for serial (default):  default timeout x nb of servers found in the group
                        else {
                            $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                        }
                    
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
    
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
            
                    Return $ReturnData
            
                }
        
            }
            else {

                if (-not $WhatIf ) {
                
                    Return $_resp
            
                }
            }
        }
    }
}


function Stop-HPECOMGroupFirmware {
    <#
    .SYNOPSIS
    Cancel an ongoing serial firmware update job.
    
    .DESCRIPTION   
    This cmdlet can be used to cancel an ongoing serial firmware update job that is running.  
    
    .PARAMETER Region
    Name of the region where the group/job is located.  
    
    .PARAMETER InputJobObject 
    The server group firmware update job resource from 'Get-HPECOMJob'. 

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    $Job = Update-HPECOMGroupFirmware -Region eu-central -GroupName ESXi_group -Async 
    Stop-HPECOMGroupFirmware -Region eu-central -InputJobObject $Job

    The first command initiates an asynchronous firmware update for the server group named ESXi_group in the eu-central region. The second command cancels this ongoing firmware update job.

    .EXAMPLE
    $Job = Update-HPECOMGroupFirmware -Region  eu-central -GroupName ESXi_group -Async 
    $Job | Stop-HPECOMGroupFirmware 

    This command starts an asynchronous firmware update for all servers in a group named `ESXi_group` located in the `eu-central` region, and then it stops the update process.

    .EXAMPLE
    Get-HPECOMJob -Region eu-central -Type groups | select -last 1 | Stop-HPECOMGroupFirmware 

    This command retrieves the last group firmware update job in the `eu-central` region and stops the update process.

    .INPUTS
    System.Collections.ArrayList
        List of jobs from 'Get-HPECOMJob'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding(DefaultParameterSetName = 'GroupNameSerial')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      

        [Parameter (ValueFromPipeline)]
        [Object]$InputJobObject,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $StopGroupFirmwareStatus = [System.Collections.ArrayList]::new()

    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        try {            
            
            if ($InputJobObject) {
                
                if ($InputJobObject.type -ieq "compute-ops-mgmt/job") {
                
                    "[{0}] Pipeline object detected as job type" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    # $Server_InputObject_pipeline = $True
    
                    "[{0}] ID = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $InputJobObject.id | Write-Verbose
                    $uri = $COMJobsUri + '/' + $InputJobObject.id

                    $_job = Get-HPECOMJob -Region $Region -JobResourceUri $uri

    
                }
                else {    
                    $ExceptionMessage = "The parameter 'InputJobObject' value is invalid. Please validate the 'InputJobObject' parameter value you passed and try again."
                    $ErrorRecord = New-ErrorRecord InvalidOperationException InvalidArgument -TargetObject 'InputJobObject' -Message $ExceptionMessage -TargetType $InputJobObject.GetType().Name 
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
        
                }
            }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_job) {

            # Must return a message if not found
            $ErrorMessage = "Job ID '{0}' cannot be found in the Compute Ops Management instance!" -f $InputJobObject.id
            $ErrorRecord = New-ErrorRecord JobNotFoundInCOM ObjectNotFound -TargetObject 'Job' -Message $ErrorMessage -TargetType $InputJobObject.GetType().Name
            $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }

        
        
        # Build payload
        $payload = @{
            input = @{ 
                stopOnRequest = $true
            }
        }      


        $payload = ConvertTo-Json $payload -Depth 10 

        try {
            $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

            # Add region to object
            $_resp | Add-Member -type NoteProperty -name region -value $Region
            # Apply Jobs format
            $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

            if (-not $WhatIf -and -not $Async) {
    
                $Timeout = 3600 # 1 hour
                                
                "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                $_resp = Wait-HPECOMJobComplete -Region $Region -Job $MyInvocation.InvocationName.ToString().ToUpper(), $_resp.resourceuri -Timeout $Timeout 

                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

            }
        }
        catch {

            if (-not $WhatIf) {

                $PSCmdlet.ThrowTerminatingError($_)

            }
        }  
        
        [void]$StopGroupFirmwareStatus.add($_resp)

    }
    
    End {

        if (-not $WhatIf ) {
            
            Return $StopGroupFirmwareStatus
        
        }
    }
}


function Invoke-HPECOMGroupFirmwareComplianceCheck {
    <#
    .SYNOPSIS
    Initiate a firmware compliance check on all servers in a group.
    
    .DESCRIPTION   
    This cmdlet initiates a group firmware compliance check to ensure all server components are at or above the group's baseline versions. 
    It also provides options for scheduling execution at a specific time and setting recurring schedules.

    Note: A firmware server setting must be configured in the server group for the compliance feature to be available. 
          This feature does not monitor HPE driver and software versions.

    .PARAMETER Region
    Name of the region where the group is located. 
    
    .PARAMETER GroupName
    Name of the group on which the firmware compliance check will be performed.    

    .PARAMETER ScheduleTime
    Indicates when to schedule the power off operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) referencing days, weeks, months, years but not time (T) designations that reference hours, minutes, and seconds.

    This parameter supports common ISO 8601 period durations such as:
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupFirmwareComplianceCheck -Region eu-central -GroupName ESX-800  

    This command checks firmware compliance of all servers in the group 'ESX-800' in the 'eu-central' region.
   
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central -Name ESXi_group | Invoke-HPECOMGroupFirmwareComplianceCheck

    This command checks firmware compliance of all servers in the group named 'ESXi_group' in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Invoke-HPECOMGroupFirmwareComplianceCheck 

    This command checks firmware compliance of all servers in all groups of the 'eu-central' region.

    .EXAMPLE
    Invoke-HPECOMGroupFirmwareComplianceCheck -Region eu-central -GroupName ESX-800 -ScheduleTime (get-Date).addminutes(10) 

    Schedules the execution of a group firmware compliance check on the group named 'ESX-800' in the `eu-central` region starting 10 minutes from now. 

    .EXAMPLE
    Invoke-HPECOMGroupFirmwareComplianceCheck -Region eu-central -GroupName ESX-800 -ScheduleTime (get-Date).addhours(6) -Interval P1M

    Schedules a monthly execution of a group firmware compliance check on the group named 'ESX-800' in the `eu-central` region. The first execution will start in 6 hours. 

    .EXAMPLE
    "ESXi_group", "RHEL_group" | Invoke-HPECOMGroupFirmwareComplianceCheck -Region  eu-central

    This command checks firmware compliance of all servers in the groups 'ESXi_group' and 'RHEL_group' in the `eu-central` region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the group's names.
    
    System.Collections.ArrayList
        List of groups from 'Get-HPECOMGroup'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'Async')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [alias('name')]
        [String]$GroupName,

        [Parameter (Mandatory, ParameterSetName = 'Schedule')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Schedule')]
        [String]$Interval,    
        
        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 900  # 15 minutes

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupFirmwareCompliance'
        
        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri   
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri

        $GroupFirmwareComplianceStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName      
            # $_groupMembers = Get-HPECOMGroup -Region $Region -Name $GroupName -ShowMembers

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_group) {
        
            # Must return a message if resource not found
            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName
            Write-warning $ErrorMessage
            return
            
        }
        # elseif ($_groupCompliance.complianceState -like "Not Applicable") {
            
        #     # Must return an error if one of the server is not in good condition to run a compliance report (I had a 'Power stalled' condition which causes exception)
        #     $ErrorMessage = "Group '{0}' is not applicable for a compliance check. Please verify the state of each server in the group using 'Get-HPECOMGroup -ShowCompliance'." -f $GroupName
        #     Write-warning $ErrorMessage
        # }
        else {
            
            $_ResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $GroupName, $_ResourceUri, $NbOfServers | Write-Verbose         

            if ($NbOfServers -eq 0) {

                # Must return a message if no servers in group
                Write-Warning "Operation on group '$GroupName' cannot be executed because no server has been found in the group!"
                return
            }


            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_ResourceUri
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($GroupName)_GroupFirmwareComplianceCheck_Schedule_$($randomNumber)"
                $Description = "Scheduled task to run a group firmware compliance check on '$($GroupName)'"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "GROUP_FIRMWARE_COMPLIANCE_CHECK"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_ResourceUri
                    
                }      
            }


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region
                
                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
    
                        # Timeout: default timeout x nb of servers found in the group
    
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer 
        
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
        
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $GroupFirmwareComplianceStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $GroupFirmwareComplianceStatus
        
        }

    }
}


function Get-HPECOMGroupFirmwareCompliance {
    <#
    .SYNOPSIS
    Retrieves the firmware compliance details of servers within a specified group.
    
    .DESCRIPTION   
    The `Get-HPECOMGroupFirmwareCompliance` cmdlet allows you to obtain detailed information about the firmware compliance of all servers in a designated group. 
    This cmdlet can be useful for identifying deviations from the group's firmware baseline, ensuring that all devices are up to date and compliant with organizational standards.
    
    .PARAMETER Region
    Specifies the name of the region where the server group is located. 
    
    .PARAMETER GroupName
    Specifies the name of the server group on which the firmware compliance details will be retrieved.

    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to retrieve its specific compliance details within the group.

    .PARAMETER Deviations
    Switch parameter that retrieves only the firmware components which have deviations from the group's firmware baseline.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMGroupFirmwareCompliance -Region eu-central -GroupName ESX-800  

    This command returns the firmware compliance of all servers in the group 'ESX-800' in the 'eu-central' region.
   
    .EXAMPLE
    Get-HPECOMGroupFirmwareCompliance -Region eu-central -GroupName ESX-800 -ServerSerialNumber CZ12312312 

    This command returns the firmware compliance of the server with serial number 'CZ12312312' in the group 'ESX-800' in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMGroupFirmwareCompliance -Region eu-central -GroupName ESX-800 -ServerSerialNumber CZ12312312 -Deviations

    This command returns the firmware components which have a deviation with the group 'ESX-800' firmware baseline in the 'eu-central' region.
    
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Get-HPECOMGroupFirmwareCompliance 

    This command returns the firmware compliance of all servers in all groups in the 'eu-central' region.

    .INPUTS
    System.Collections.ArrayList
        List of groups retrieved using the `Get-HPECOMGroup` cmdlet.


    #>

    [CmdletBinding(DefaultParameterSetName = "ServerSerialNumber")]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ServerSerialNumber')]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'DeviationsServerSerialNumber')]
        [alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'DeviationsServerSerialNumber')]
        [Parameter (ParameterSetName = 'DeviationsServerName')]
        [switch]$Deviations,

        [switch]$WhatIf

    )

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      

        $Uri = $COMGroupsUri + "?filter=name eq '$GroupName'"

        try {

            $_group = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
            $GroupID = $_group.id

            "[{0}] ID found for group '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $GroupID | Write-Verbose

            if ($Null -eq $GroupID) { return }

            $Uri = $COMGroupsUri + "/" + $GroupID + "/compliance"
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }
        

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
      
        if ($Null -ne $CollectionList) {   
            
            # Add groupName, servername and serialNumber (only serial is provided)
            # groupName is used in Invoke-HPECOMGroupInternalStorageConfiguration, Update-HPECOMGroupFirmware, etc. 
            Foreach ($Item in $CollectionList) {

                try {
                    $_ServerName = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serial                        
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                $Item | Add-Member -type NoteProperty -name region -value $Region
                $Item | Add-Member -type NoteProperty -name groupName -value $GroupName
                $Item | Add-Member -type NoteProperty -name serialNumber -value $Item.serial
                $item | Add-Member -Type NoteProperty -Name serverName -Value $_ServerName.name
                
            }
                        
            if ($ServerSerialNumber) {

                
                if ($Deviations) {
                    
                    $CollectionList = $CollectionList | Where-Object serial -eq $ServerSerialNumber | ForEach-Object deviations | Sort-Object -Property ComponentName


                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance.Deviations"   
                    
                }
                else {
                    
                    $CollectionList = $CollectionList | Where-Object serial -eq $ServerSerialNumber

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance"   
                                        
                }
                
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Groups.Compliance"   
                
            }
            
            $ReturnData = $ReturnData | Sort-Object -Property serverName, serial
            return $ReturnData 
                
        }
        else {

            return
                
        }     
    }
}


function Invoke-HPECOMGroupInternalStorageConfiguration {
    <#
    .SYNOPSIS
    Initiate a server group internal storage configuration.
    
    .DESCRIPTION   
    This cmdlet initiates a server group internal storage configuration that will affect some or all of the server group members.
    
    .PARAMETER Region
    Name of the region where the group is located. 
        
    .PARAMETER GroupName
    Name of the group on which the internal storage configuration will be performed.     
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to configure its internal storage within the group.

    .PARAMETER AllowStorageVolumeDeletion
    Specifies to delete any existing internal storage configuration prior to creating the new OS volume.

    .PARAMETER StorageVolumeName 
    Specifies the name of the volume to create.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800

    This command initiates a server group internal storage configuration of all servers in a group named `ESXi_800` located in the `eu-central` region. 
   
    .EXAMPLE
    Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800 -AllowStorageVolumeDeletion -StorageVolumeName ESX_Boot_Volume 

    This command initiates a server group internal storage configuration of all servers in a group named `ESXi_800` located in the `eu-central` region. 
    It also specifies to delete any existing internal storage configuration prior to creating the new OS volume that will be named 'ESX_Boot_Volume'.

    .EXAMPLE
    Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ12312312' 

    This command initiates a server group internal storage configuration of the server with the serial number 'CZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "ESX-1" | Invoke-HPECOMGroupInternalStorageConfiguration -GroupName ESXi_800

    This command initiates a server group internal storage configuration of the server named 'ESX-1' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Invoke-HPECOMGroupInternalStorageConfiguration -GroupName ESXi_800 -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command initiates a server group internal storage configuration of the specified servers as part of the 'ESXi_800' group.
    The configuration runs asynchronously, allowing other tasks to continue without waiting for completion.
       
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Invoke-HPECOMGroupInternalStorageConfiguration -Region eu-central -GroupName ESXi_800 
    
    This command initiates a server group internal storage configuration of the servers with serial numbers 'CZ12312312' and 'DZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupInternalStorageConfiguration }
    
    This command retrieves a list of all groups in the 'eu-central' region and initiates a server group internal storage configuration for each group.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [switch]$AllowStorageVolumeDeletion,

        [string]$StorageVolumeName,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupStorageVolumeConfiguration'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()
        
        if ($AllowStorageVolumeDeletion) {
            $isStorageVolumeDeletionAllowed = $true
        }
        else {
            $isStorageVolumeDeletionAllowed = $false
        }     
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {
            
            [void]$ServersList.add($ServerSerialNumber)
        }

    }

    End {

        try {
            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $_group.devices
            # $GroupMembers = Get-HPECOMGroup -Region $Region -Name $GroupName -ShowMembers

            $_groupName = $_group.name
            $_groupResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose

            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }

        
        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        
        
        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}' is not a member of the group '{1}'!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {

                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }
            

        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose
            

            # Build payload
            if ($StorageVolumeName) {

                $data = @{
                    devices                        = $ServerIdsList
                    isStorageVolumeDeletionAllowed = $isStorageVolumeDeletionAllowed
                    storageVolumeName              = $storageVolumeName
                }
            }
            else {

                $data = @{
                    devices                        = $ServerIdsList
                    isStorageVolumeDeletionAllowed = $isStorageVolumeDeletionAllowed
                }
            
            }
          
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
                data           = $data                 
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                 
                    $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }
        }
    }
}


function Invoke-HPECOMGroupOSInstallation {
    <#
    .SYNOPSIS
    Initiate a group OS installation.
    
    .DESCRIPTION   
    This cmdlet initiates a group operating system installation that will affect some or all of the server group members.
    
    .PARAMETER Region
    Name of the region where the group is located. 
        
    .PARAMETER GroupName
    Name of the group on which the operating system installation will be performed.     

    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to install the operating system within the group.

    .PARAMETER StopOnFailure
    Specifies if the operating system installation process will continue after the first failure. 
    When StopOnFailure is not used, the installation continues after a failure. When used, the installation stops after a failure and the remaining servers in the group will not be installed. 
    
    Note: This switch is applicable for serial operating system installation (i.e. when ParallelInstallations switch is not used). 

    .PARAMETER ParallelInstallations
    Specifies to perform the operating system installation to each server in the group in parallel instead of serial by default. 
    
    .PARAMETER OSCompletionTimeoutMin
    Specifies the amount of time (minutes) that Compute Ops Management waits before automatically marking an OS installation job complete. 
    The operating system image is then unmounted from the server. The specified timeout value applies to each server group member.
    Supported value:
    - Default: 240
    - Minimum: 60
    - Maximum: 720

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800

    This command initiates a group operating system installation of all servers in a group named `ESXi_800` located in the `eu-central` region.
    
    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 -ParallelInstallations

    This command initiates a group operating system installation of all servers in a group named `ESXi_800` located in the `eu-central` region.
    The installation is performed in parallel instead of serial by default.
   
    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 -StopOnFailure -OSCompletionTimeoutMin 100

    This command initiates a group operating system installation of all servers in a group named `ESXi_800` located in the `eu-central` region.
    The installation halts upon the first failure, and the operating system image is unmounted from the server after 100 minutes, reduced from the default 240 minutes.

    .EXAMPLE
    Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ12312312' 

    This command initiates a group operating system installation of the server with the serial number 'CZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "ESX-1" | Invoke-HPECOMGroupOSInstallation -GroupName ESXi_800

    This command initiates a group operating system installation of the server named 'ESX-1' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Invoke-HPECOMGroupOSInstallation -GroupName ESXi_800 -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command initiates a group operating system installation of the specified servers as part of the 'ESXi_800' group. 
    The configuration runs asynchronously, allowing other tasks to continue without waiting for completion.
       
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Invoke-HPECOMGroupOSInstallation -Region eu-central -GroupName ESXi_800 
    
    This command initiates a group operating system installation of the servers with serial numbers 'CZ12312312' and 'DZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupOSInstallation }

    This command retrieves a list of all groups in the 'eu-central' region and initiates a group operating system installation for each group.
      
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber' or 'Get-HPECOMGroup -ShowMembers'.    

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding(DefaultParameterSetName = 'GroupNameSerial')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "GroupNameSerial")]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "GroupNameParallel")]
        [String]$GroupName,
        
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [Parameter (ParameterSetName = 'GroupNameSerial')]
        [switch]$StopOnFailure,

        [Parameter (ParameterSetName = 'GroupNameParallel')]
        [switch]$ParallelInstallations,

        [ValidateRange(60, 720)]
        [int]$OSCompletionTimeoutMin,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 3600

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupOSInstallation'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()
        
      
        if ($StopOnFailure) {
            $StopOnFailureValue = $true
        }
        else {
            $StopOnFailureValue = $false
        }
                
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {
            
            [void]$ServersList.add($ServerSerialNumber)
        }

           

    }

    End {

        try {
            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $_group.devices

            $_groupName = $_group.name
            $_groupResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose

            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }


        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}' is not a member of the group '{1}'!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {
                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }


        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose
               
            # Parallel updates
            if ($ParallelInstallations -and -not $ServerIdsList -and -not $OSCompletionTimeoutMin) {

                $data = @{
                    parallel = $True
                }

            }
            elseif ($ParallelInstallations -and $ServerIdsList -and -not $OSCompletionTimeoutMin) {

                $data = @{
                    parallel = $True
                    devices  = $ServerIdsList
                }
            
            }
            elseif ($ParallelInstallations -and -not $ServerIdsList -and $OSCompletionTimeoutMin) {

                $data = @{
                    parallel               = $True
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin
                }
            }
            elseif ($ParallelInstallations -and $ServerIdsList -and $OSCompletionTimeoutMin) {
                
                $data = @{
                    parallel               = $True
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin
                    devices                = $ServerIdsList

                }
            }

            # Serial updates
            elseif (-not $ParallelInstallations -and -not $ServerIdsList -and -not $OSCompletionTimeoutMin) {
            
                $data = @{
                    parallel      = $False
                    stopOnFailure = $StopOnFailureValue
                   
                }
            
            }
            elseif (-not $ParallelInstallations -and $ServerIdsList -and -not $OSCompletionTimeoutMin) {
           
                $data = @{
                    parallel      = $False
                    stopOnFailure = $StopOnFailureValue
                    devices       = $ServerIdsList
                }

            }
            elseif (-not $ParallelInstallations -and $ServerIdsList -and $OSCompletionTimeoutMin) {
           
                $data = @{
                    parallel               = $False
                    stopOnFailure          = $StopOnFailureValue
                    devices                = $ServerIdsList
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin

                }

            }
            elseif (-not $ParallelInstallations -and -not $ServerIdsList -and $OSCompletionTimeoutMin) {
           
                $data = @{
                    parallel               = $False
                    stopOnFailure          = $StopOnFailureValue
                    osCompletionTimeoutMin = $OSCompletionTimeoutMin

                }

            }

          
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
                data           = $data                 
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                
                    # Timeout for parallel group FW update 
                    if ($ParallelInstallations) {
                        $Timeout = $TimeoutinSecondsPerServer
                    
                    }
                    # Timeout for serial (default):  default timeout x nb of servers found in the group
                    else {
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                    }
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }

        }
    }
}


function Invoke-HPECOMGroupBiosConfiguration {
    <#
    .SYNOPSIS
    Initiate a server group bios configuration.
    
    .DESCRIPTION   
    This cmdlet initiates a server group bios configuration that will affect some or all of the server group members.

    Note: A server reboot is necessary for the new BIOS settings to take effect. COM will attempt to restart the server automatically. If the server cannot be restarted by COM, you must manually reboot the server (or use 'Restart-HPECOMserver') to complete the configuration process.
    
    .PARAMETER Region
    Name of the region where the group is located. 
        
    .PARAMETER GroupName
    Name of the group on which the bios configuration will be performed.     
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of an individual server to configure its BIOS settings within the group.     

    .PARAMETER ParallelConfigurations
    Specifies to perform the bios configuration to each server in the group in parallel (20 max) instead of serial by default. 

    .PARAMETER ResetBiosSettingsToDefaults
    Specifies to perform a reset server's BIOS settings to default values before applying the BIOS setting.
    
    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800

    This command initiates a server group bios configuration of all servers in a group named `ESXi_800` located in the `eu-central` region.

    .EXAMPLE
    Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800 -ResetBiosSettingsToDefaults -ParallelConfigurations

    This command initiates a server group bios configuration of all servers in a group named `ESXi_800` located in the `eu-central` region.
    The configuration is performed in parallel instead of serial by default, and the server's BIOS settings are reset to default values before applying the new BIOS settings.

    .EXAMPLE
    Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800 -ServerSerialNumber 'CZ12312312' 

    This command initiates a server group bios configuration of the server with the serial number 'CZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name "ESX-1" | Invoke-HPECOMGroupBiosConfiguration -GroupName ESXi_800

    This command initiates a server group bios configuration of the server named 'ESX-1' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | Where-Object {$_.serialNumber -eq "CZ12312312" -or $_.serialNumber -eq "DZ12312312"}  | Invoke-HPECOMGroupBiosConfiguration -GroupName ESXi_800 -Async
     
    The first command retrieves a list of all servers in the 'eu-central' region.
    The second command filters the list to include only the servers with serial numbers 'CZ12312312' or 'DZ12312312'.
    The last command initiates a server group bios configuration of the specified servers as part of the 'ESXi_800' group.
    The configuration runs asynchronously, allowing other tasks to continue without waiting for completion.
       
    .EXAMPLE
    "CZ12312312", "DZ12312312" | Invoke-HPECOMGroupBiosConfiguration -Region eu-central -GroupName ESXi_800 
    
    This command initiates a server group bios configuration of the servers with serial numbers 'CZ12312312' and 'DZ12312312' as part of the 'ESXi_800' group located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupBiosConfiguration }
    
    This command retrieves a list of all groups in the 'eu-central' region and initiates a server group bios configuration for each group.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber' or 'Get-HPECOMGroup -ShowMembers'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$GroupName,
        
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [Alias('serial', 'serialnumber')]
        [String]$ServerSerialNumber,

        [switch]$ParallelConfigurations,

        [switch]$ResetBiosSettingsToDefaults,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 600 # 10 minutes

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GroupApplyServerSettings'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri

        $ServersList = [System.Collections.ArrayList]::new()
        $ServerIdsList = [System.Collections.ArrayList]::new()
      
                
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        if ($ServerSerialNumber -and $ServerSerialNumber -notmatch '^@\{.*\}$') {

            [void]$ServersList.add($ServerSerialNumber)
        }

    }

    End {

        try {
            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $_group.devices 

            $_groupName = $_group.name
            $_groupResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose

            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }

        
        try {
            
            $Servers = Get-HPECOMServer -Region $Region
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        

        
        
        if ($ServersList) {

            "[{0}] List of servers to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServersList | out-string) | Write-Verbose

            foreach ($Object in $ServersList) {

                $Server = $Servers | Where-Object SerialNumber -eq $Object
    
                if ( -not $Server) {
    
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object
                    Write-warning $ErrorMessage
    
                } 
                elseif (-not ($GroupMembers | Where-Object serial -eq $Object)) {   
                   
                    $ErrorMessage = "Server '{0}' is not a member of the group '{1}'!" -f $Object, $GroupName
                    Write-warning $ErrorMessage
    
                }
                else {       
                   
                    # Building the list of devices object for payload
                    [void]$ServerIdsList.Add($server.id)       
                        
                }
            }
        }
        else {

            if ($GroupMembers) {
                foreach ($Object in $GroupMembers) {
                    [void]$ServerIdsList.Add($Object.id)
                }
            }
            else {

                # Must return a message if no server members are found in the group
                $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
                Write-warning $ErrorMessage
                
            }
        }

      
        if ($ServerIdsList) {   
            
            "[{0}] List of server IDs to configure: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServerIdsList | out-string) | Write-Verbose

          
            # Parallel updates
            if ($ParallelConfigurations -and -not $ServerIdsList) {

                $data = @{
                    batch_size        = 20
                    redfish_subsystem = "BIOS"
                }

            }
            elseif ($ParallelConfigurations -and $ServerIdsList) {

                $data = @{
                    batch_size        = 20
                    devices           = $ServerIdsList
                    redfish_subsystem = "BIOS"

                }
            
            }

            # Serial updates
            elseif (-not $ParallelConfigurations -and -not $ServerIdsList) {
            
                $data = @{
                    batch_size        = 1
                    redfish_subsystem = "BIOS"
                   
                }
            
            }
            elseif (-not $ParallelConfigurations -and $ServerIdsList) {
           
                $data = @{
                    batch_size        = 1
                    devices           = $ServerIdsList
                    redfish_subsystem = "BIOS"

                }

            }

            if ($ResetBiosSettingsToDefaults) {

                $data.factory_reset	= $true
            }


            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
                data           = $data                 
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                
                    # Timeout for parallel group FW update 
                    if ($ParallelConfigurations) {
                        $Timeout = $TimeoutinSecondsPerServer
                    
                    }
                    # Timeout for serial (default):  default timeout x nb of servers found in the group
                    else {
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                    }
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }

        }
    }
}


function Invoke-HPECOMGroupExternalStorageConfiguration {
    <#
    .SYNOPSIS
    Initiate a server group external storage configuration.
    
    .DESCRIPTION   
    This cmdlet initiates a server group external storage configuration that will affect all server group members.
    
    .PARAMETER Region
    Name of the region where the group is located. 
        
    .PARAMETER GroupName
    Name of the group on which the external storage configuration will be performed.     
    
    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
    
    .EXAMPLE
    Invoke-HPECOMGroupExternalStorageConfiguration -Region eu-central -GroupName ESXi_800

    This command initiates a server group external storage configuration of all servers in a group named `ESXi_800` located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | ForEach-Object { $_ | Invoke-HPECOMGroupExternalStorageConfiguration } 
    
    This command retrieves a list of all groups in the 'eu-central' region and initiates a server group external storage configuration for each group.
    
    .INPUTS
    No pipeline input is supported

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
                
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [String]$GroupName,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 60

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        # $_JobTemplateName = 'GroupExternalStorageConfiguration' # ERROR CASE 5383889168
        
        # $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateUri = "/compute-ops-mgmt/v1beta2/job-templates/1262f08e-79eb-4e9f-91d2-6984da9d31cd"

        $uri = $COMJobsUri
                
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

    }

    End {
      
        try {
            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            $GroupMembers = $_group.devices

            $_groupName = $_group.name
            $_groupResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count

            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_groupName, $_groupResourceUri, $NbOfServers | Write-Verbose

            

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $_group) {

            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName

            throw $ErrorMessage

        }
        elseif (-not $GroupMembers) {

            # Must return a message if no server members are found in the group
            $ErrorMessage = "Group '{0}' has no members to be configured!" -f $GroupName
            Write-warning $ErrorMessage
            
        }
        else {
        
            # Build payload          
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_groupResourceUri
            }      


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if (-not $WhatIf -and -not $Async) {    
                 
                    $Timeout = $NbOfServers * $TimeoutinSecondsPerServer
                
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose

                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                }
            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if (-not $WhatIf ) {
            
                Return $_resp
        
            }

        }
    }
}


function Invoke-HPECOMGroupExternalStorageComplianceCheck {
    <#
    .SYNOPSIS
    Initiate an external storage compliance check on all servers in a group.
    
    .DESCRIPTION   
    This cmdlet initiates an external storage compliance check on all servers within a specified group.
    It also provides options for scheduling the execution at a specific time and setting recurring schedules.

    Note: An external storage server setting must be configured in the server group for the compliance feature to be available.
        
    .PARAMETER Region
    Name of the region where the group is located. 
    
    .PARAMETER GroupName
    Name of the group on which the external storage compliance check will be performed.    

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Invoke-HPECOMGroupExternalStorageComplianceCheck -Region eu-central -GroupName ESX-800  

    This command checks the external storage compliance of all servers in the group 'ESX-800' in the 'eu-central' region.
       
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Invoke-HPECOMGroupExternalStorageComplianceCheck 

    This command checks the external storage compliance of all servers in all groups within the 'eu-central' region.
    
    .EXAMPLE
    Invoke-HPECOMGroupExternalStorageComplianceCheck -Region eu-central -GroupName ESX-800 -ScheduleTime (Get-Date).AddHours(1) 

    Schedules the execution of a group external storage compliance check on the group named 'ESX-800' in the `eu-central` region starting 1 hour from now. 
    
    .EXAMPLE
    Get-HPECOMGroup -Region eu-central | Invoke-HPECOMGroupExternalStorageComplianceCheck -ScheduleTime (Get-Date).AddDays(1) -Interval P1M 

    Schedules a monthly execution of a group external storage compliance check on all groups within the `eu-central` region. The first execution will occur one day from now.

    .EXAMPLE
    "ESXi_group", "RHEL_group" | Invoke-HPECOMGroupExternalStorageComplianceCheck -Region  eu-central
    
    This command checks the external storage compliance of all servers in the groups 'ESXi_group' and 'RHEL_group' in the 'eu-central' region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the group's names.

    System.Collections.ArrayList
        List of groups from 'Get-HPECOMGroup'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'Async')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [alias('name')]
        [String]$GroupName,
                
        [Parameter (Mandatory, ParameterSetName = 'Schedule')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Schedule')]
        [String]$Interval,    
        
        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 900  # 15 minutes

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        # $_JobTemplateName = 'GroupExternalStorageCompliance'  # ERROR CASE 5383889168

        
        # $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri    
        $JobTemplateUri = "/compute-ops-mgmt/v1beta2/job-templates/977139e0-f9d9-4940-9418-e0c321b5a458"
        # $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id
        $JobTemplateId =  $JobTemplateUri.split('/')[-1]

        $uri = $COMJobsUri
        $GroupFirmwareComplianceStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_group = Get-HPECOMGroup -Region $Region -Name $GroupName
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_group) {
            
            # Must return a message if resource not found
            $ErrorMessage = "Group '{0}' cannot be found in the Compute Ops Management instance!" -f $GroupName
            Write-warning $ErrorMessage
            return
            
        }
        else {
            
            $_ResourceUri = $_group.resourceUri
            $NbOfServers = $_group.devices.count
            
            "[{0}] GroupName '{1}' detected - URI: '{2}' - Nb of servers: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $GroupName, $_ResourceUri, $NbOfServers | Write-Verbose         

            if ($NbOfServers -eq 0) {

                # Must return a message if no servers in group
                Write-Warning "Operation on group '$GroupName' cannot be executed because no server has been found in the group!"
                return
            }


            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_ResourceUri
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "$($GroupName)_GroupExternalStorageComplianceCheck_Schedule_$($randomNumber)"
                $Description = "Scheduled task to run a group external storage compliance check on '$($GroupName)'"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "GROUP_EXTERNAL_STORAGE_COMPLIANCE_CHECK"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {
                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_ResourceUri
                    
                }      
            }


            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region
                # Apply Jobs format
                $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {
                    if (-not $WhatIf -and -not $Async) {
    
                        # Timeout: default timeout x nb of servers found in the group
    
                        $Timeout = $NbOfServers * $TimeoutinSecondsPerServer 
        
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
        
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  
            
            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }
        if (-not $ScheduleTime) {

            [void] $GroupFirmwareComplianceStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $GroupFirmwareComplianceStatus
        
        }

    }
}


function Update-HPECOMApplianceFirmware {
    <#
    .SYNOPSIS
    UUpdates the firmware on a specified appliance.
    
    .DESCRIPTION   
    This cmdlet updates the firmware on an appliance using its IP address. It also provides an option to schedule the update at a specific time.
        
    .PARAMETER Region
    Specifies the region where the appliance is located.

    .PARAMETER IPAddress
    Specifies the IP address of the appliance for the firmware update.

    .PARAMETER ApplianceFirmwareBundleReleaseVersion
    Mandatory parameter specifying the appliance firmware bundle release version to use for the update. 
    The release version can be obtained using 'Get-HPECOMApplianceFirmwareBundle'.

    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Update-HPECOMApplianceFirmware -Region eu-central -IPAddress 192.168.7.59 -ApplianceFirmwareBundleReleaseVersion 9.00.00 

    This command updates the firmware on a OneView appliance with the IP address `192.168.7.59` located in the `eu-central` region using firmware bundle release version `9.00.00`. 
    
    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central -Hostname composer.lab | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00

    This command retrieves OneView appliances with the hostname 'composer.lab' in the `eu-central` region.
    It then updates the firmware on these appliances using firmware bundle release version `9.00.00`.

    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00 
    
    This command updates all OneView appliances in the 'eu-central' region with the specified firmware bundle release version.
    First, it retrieves a list of all OneView appliances in the "eu-central" region.
    Then, the retrieved appliances are piped (|) to the Update-HPECOMApplianceFirmware cmdlet to update their firmware to the specified version.

    .EXAMPLE
    "192.168.1.2", "192.168.1.10" | Update-HPECOMApplianceFirmware -Region eu-central -ApplianceFirmwareBundleReleaseVersion 9.00.00

    This command updates the firmware on the appliances with the IP addresses `192.168.1.2'and '192.168.1.10'.
    The firmware update is performed in the `eu-central` region using firmware bundle release version `9.00.00`.

    .EXAMPLE
    Update-HPECOMApplianceFirmware -Region eu-central -IPAddress 192.168.7.59 -ApplianceFirmwareBundleReleaseVersion 9.00.00 -ScheduleTime ((Get-Date).AddMinutes(10))   

    This command schedules a firmware update for the appliance with the IP address `192.168.7.59` in the `eu-central` region using firmware bundle release version `9.00.00`, starting 10 minutes from now. 

    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central -Hostname composer.domain.net | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00 -ScheduleTime ((Get-Date).AddHours(2))  

    This command first retrieves OneView appliances with the hostname 'composer.domain.net' in the `eu-central` region.
    It then schedules a firmware update for this appliance using firmware bundle release version `9.00.00`, starting 2 hours from now.

    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central | Update-HPECOMApplianceFirmware -ApplianceFirmwareBundleReleaseVersion 9.00.00 -ScheduleTime ((Get-Date).AddDays(5))  

    This command first retrieves all OneView appliances in the `eu-central` region.
    It then schedules a firmware update for these appliances using firmware bundle release version `9.00.00`, starting 5 days from now.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the appliance's IP addresses.

    System.Collections.ArrayList
        List of appliances from 'Get-HPECOMOneViewAppliance'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.


    #>

    [CmdletBinding(DefaultParameterSetName = 'Scheduled')]
    Param
    (

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        # [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'IP')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or $_ -match [Net.IPAddress]$_ })]
        [string]$IPAddress,
        
        [Parameter (Mandatory)]
        [String]$ApplianceFirmwareBundleReleaseVersion,

        [Parameter (ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'ApplianceUpdate'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $ApplianceFWUpdateStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            $_appliance = Get-HPECOMOneViewAppliance -Region $Region -IPAddress $IPAddress                 

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_appliance) {

            # Must return a message if not found
            $ErrorMessage = "OneView appliance '{0}' cannot be found in the Compute Ops Management instance!" -f $IPAddress
            Write-warning $ErrorMessage

            # $ErrorRecord = New-ErrorRecord ApplianceNotFoundInCOM ObjectNotFound -TargetObject 'OneView-appliances' -Message $ErrorMessage -TargetType $IPAddress.GetType().Name          
            # $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }
        else {

            $_applianceResourceUri = $_appliance.resourceUri
            $_applianceType = $_appliance.applianceType
            $_applianceName = $_appliance.name

            try {
                $Bundle = Get-HPECOMApplianceFirmwareBundle -Region $Region -Version $ApplianceFirmwareBundleReleaseVersion -Type $_applianceType

                $BundleID = $Bundle.id
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $BundleID) {
                # Must return a message if not found
                    
                $ErrorMessage = "Appliance firmware bundle release version '{0}' cannot be found in the Compute Ops Management instance!" -f $ApplianceFirmwareBundleReleaseVersion
                throw $ErrorMessage

                # $ErrorRecord = New-ErrorRecord ApplianceFirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Appliance-Firmware-bundles' -Message $ErrorMessage -TargetType $ApplianceFirmwareBundleReleaseVersion.GetType().Name
                # $PSCmdlet.ThrowTerminatingError($ErrorRecord)
    
            }
            else {

                $data = @{
                    applianceFirmwareId = $BundleID

                }

                if ($ScheduleTime) {

                    $uri = $COMSchedulesUri
    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_applianceResourceUri
                        data           = $data
                    }      
    
                    $Operation = @{
                        type   = "REST"
                        method = "POST"
                        uri    = "/api/compute/v1/jobs"
                        body   = $_Body
    
                    }
    
                    $randomNumber = Get-Random -Minimum 000000 -Maximum 999999
    
                    $Name = "$($_applianceName)_ApplianceFirmwareUpdate_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to update firmware for '$IPAddress' appliance"
    
    
                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
    
    
                    $Payload = @{
                        name                  = $Name
                        description           = $Description
                        associatedResourceUri = $_applianceResourceUri
                        purpose               = "APPLIANCE_FW_UPDATE"
                        schedule              = $Schedule
                        operation             = $Operation
    
                    }
    
                }
                else {
    
                    # Build payload
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_applianceResourceUri
                        data           = $data
                    }      
                }


                $payload = ConvertTo-Json $payload -Depth 10 

                try {
                    $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                    # Add region to object
                    $_resp | Add-Member -type NoteProperty -name region -value $Region
                    # Apply Jobs format
                    $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 

                    if ($ScheduleTime) {

                        if (-not $WhatIf) {
        
                            $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"
    
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                        }
    
                    }
                    else {

                        if (-not $WhatIf -and -not $Async) {
            
                            "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
            
                            $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout 3600 # Timeout 1 hour
                            "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                        }
                    }
                }
                catch {

                    if (-not $WhatIf) {

                        $PSCmdlet.ThrowTerminatingError($_)

                    }
                }  

                if ($ScheduleTime) {

                    if (-not $WhatIf ) {
            
                        Return $ReturnData
                    
                    }
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $ApplianceFWUpdateStatus.add($_resp)
        }

    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $ApplianceFWUpdateStatus
        
        }

    }
}


function Enable-HPECOMIloIgnoreSecuritySetting {
    <#
    .SYNOPSIS
    Enable ignore iLO security risk settings.
    
    .DESCRIPTION   
    This cmdlet can be used to enable ignore iLO security risk settings on a server.
        
    .PARAMETER Region
    Name of the region where the server is located. 
        
    .PARAMETER SerialNumber
    Serial number of the server on which the ignore iLO security risk will be enabled.
    
    .PARAMETER Name
    Name of the server on which the ignore iLO security risk will be enabled.
    
    .PARAMETER AccessPanelStatus 
    Parameter to enable the option to ignore the access panel status security risk warning.

    .PARAMETER AuthenticationFailureLogging 
    Parameter to enable the option to ignore the authentication failure logging security risk warning.

    .PARAMETER DefaultSSLCertificateInUse 
    Parameter to enable the option to ignore the default SSL Certificate In Use security risk warning.

    .PARAMETER IPMIDCMIOverLAN
    Parameter to enable the option to ignore the IPMI/DCMI Over LAN security risk warning.

    .PARAMETER LastFirmwareScanResult 
    Parameter to enable the option to ignore the last firmware scan result security risk warning.

    .PARAMETER MinimumPasswordLength 
    Parameter to enable the option to ignore the minimum password length security risk warning.

    .PARAMETER PasswordComplexity 
    Parameter to enable the option to ignore the password complexity security risk warning.

    .PARAMETER RequireHostAuthentication 
    Parameter to enable the option to ignore the require host authentication security risk warning.

    .PARAMETER RequireLoginforiLORBSU 
    Parameter to enable the option to ignore the require login for iLO RBSU security risk warning.

    .PARAMETER SecureBoot 
    Parameter to enable the option to ignore the secure boot security risk warning.

    .PARAMETER SecurityOverrideSwitch 
    Parameter to enable the option to ignore the security override switch security risk warning.

    .PARAMETER SNMPv1 
    Parameter to enable the option to ignore the SNMPv1 request: disabled security risk warning.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Enable-HPECOMIloIgnoreSecuritySetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging

    This command enables the ignore iLO security risk settings "Access Panel Status" and "Authentication Failure Logging" on the server with serial number 'CZ12312312' located in the `eu-central` region. 
   
    .EXAMPLE
    Enable-HPECOMIloIgnoreSecuritySetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse -IPMIDCMIOverLAN -LastFirmwareScanResult -MinimumPasswordLength -PasswordComplexity -RequireHostAuthentication -RequireLoginforiLORBSU -SecureBoot -SecurityOverrideSwitch -SNMPv1 

    This command enables all ignore iLO security risk settings on the server with serial number 'CZ12312312' located in the `eu-central` region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1 | Enable-HPECOMIloIgnoreSecuritySetting -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse 

    This command enables the ignore iLO security risk settings "Access Panel Status", "Authentication Failure Logging", and "Default SSL Certificate In Use" on the server named 'ESX-1' located in the `eu-central` region.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Enable-HPECOMIloIgnoreSecuritySetting -Region eu-central -MinimumPasswordLength 

    This command enables the ignore iLO security risk setting "Minimum Password Length" on the servers with serial numbers 'CZ12312312' and 'DZ12312312' located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | select -First 3 | Enable-HPECOMIloIgnoreSecuritySetting -MinimumPasswordLength -PasswordComplexity

    The first command retrieves all servers in the 'eu-central' region. The second command selects the first three servers.
    The third command enables the ignore iLO security risk settings "Minimum Password Length" and "Password Complexity" on the selected servers.
 
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [alias('serial')]
        [String]$SerialNumber,
        
        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$Name,    

        [switch]$AccessPanelStatus,
	
        [switch]$AuthenticationFailureLogging,
            
        [switch]$DefaultSSLCertificateInUse,
            
        [switch]$IPMIDCMIOverLAN,
            
        [switch]$LastFirmwareScanResult,
            
        [switch]$MinimumPasswordLength,
            
        [switch]$PasswordComplexity,
            
        [switch]$RequireHostAuthentication,
            
        [switch]$RequireLoginforiLORBSU,
            
        [switch]$SecureBoot,
            
        [switch]$SecurityOverrideSwitch,
            
        [switch]$SNMPv1,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 60

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'iLOSecurity'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri 
        
    }
    
    Process {

        $IgnoreSecuritySettings = [System.Collections.ArrayList]::new()

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
           
            if ($SerialNumber) {

                $ParamUsed = $SerialNumber
                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber

            } 
            elseif ($Name) {

                $ParamUsed = $Name
                $_server = Get-HPECOMServer -Region $Region -Name $Name

            }


        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        

        if (-not $_server) {
            
            # Must return a message if not found

            $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
            Write-Warning $ErrorMessage
            # $ErrorRecord = New-ErrorRecord ServerNotFoundInCOM ObjectNotFound -TargetObject 'Server' -Message $ErrorMessage -TargetType $ParamUsed.GetType().Name
            # $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }
        else {

            $_serverResourceUri = $_server.resourceUri

            # Build $IgnoreSecuritySettings
            function New-Setting {
                param (
                    [string]$Name,
                    [string]$Id
                )
            
                return @{
                    name   = $Name
                    ignore = $true
                    id     = $Id
                }
            }
            
    
            if ($AccessPanelStatus) {
    
                $Setting = New-Setting "Access Panel Status" 7
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($AuthenticationFailureLogging) {
    
                $Setting = New-Setting "Authentication Failure Logging" 4
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($DefaultSSLCertificateInUse) {
    
                $Setting = New-Setting "Default SSL Certificate In Use" 10
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($IPMIDCMIOverLAN) {
    
                $Setting = New-Setting "IPMI/DCMI Over LAN" 1
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($LastFirmwareScanResult) {
    
                $Setting = New-Setting "Last Firmware Scan Result" 11
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($MinimumPasswordLength) {
    
                $Setting = New-Setting "Minimum Password Length" 2
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($PasswordComplexity) {
    
                $Setting = New-Setting "Password Complexity" 6
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($RequireHostAuthentication) {
    
                $Setting = New-Setting "Require Host Authentication" 8
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($RequireLoginforiLORBSU) {
    
                $Setting = New-Setting "Require Login for iLO RBSU" 3
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($SecureBoot) {
    
                $Setting = New-Setting "Secure Boot" 5
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($SecurityOverrideSwitch) {
    
                $Setting = New-Setting "Security Override Switch" 0
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($SNMPv1) {
    
                $Setting = New-Setting "SNMPv1" 9
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
    
            if (-not $IgnoreSecuritySettings) {
                
                # Must return a message if no parameter is used    
                $ErrorMessage = "At least one ignore iLO security risk setting must be provided with this cmdlet!" -f $ParamUsed
                $ErrorRecord = New-ErrorRecord IgnoreParameterNotFound InvalidArgument -TargetObject 'Server' -Message $ErrorMessage 
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
    
    
            # Build payload
            $data = @{
                ignoreSecuritySettings = $IgnoreSecuritySettings
            }
                
              
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_serverResourceUri
                data           = $data                 
            }      
    
    
            $payload = ConvertTo-Json $payload -Depth 10 
    
            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
    
                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region
                # Apply Jobs format
                $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 
    
                if (-not $WhatIf -and -not $Async) {    
                     
                    $Timeout = $TimeoutinSecondsPerServer
                    
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
    
                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                }
            }
            catch {
    
                if (-not $WhatIf) {
    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
            }  
    
            if (-not $WhatIf ) {
                
                Return $_resp
            
            }
        }
    }          
}


function Disable-HPECOMIloIgnoreSecuritySetting {
    <#
    .SYNOPSIS
    Disable ignore iLO security risk settings.
    
    .DESCRIPTION   
    This cmdlet can be used to disable ignore iLO security risk settings on a server.
        
    .PARAMETER Region
    Name of the region where the server is located. 
        
    .PARAMETER SerialNumber
    Serial number of the server on which the ignore iLO security risk will be disabled.
    
    .PARAMETER Name
    Name of the server on which the ignore iLO security risk will be disabled.
    
    .PARAMETER AccessPanelStatus 
    Parameter to disable the option to ignore the access panel status security risk warning.

    .PARAMETER AuthenticationFailureLogging 
    Parameter to disable the option to ignore the authentication failure logging security risk warning.

    .PARAMETER DefaultSSLCertificateInUse 
    Parameter to disable the option to ignore the default SSL Certificate In Use security risk warning.

    .PARAMETER IPMIDCMIOverLAN
    Parameter to disable the option to ignore the IPMI/DCMI Over LAN security risk warning.

    .PARAMETER LastFirmwareScanResult 
    Parameter to disable the option to ignore the last firmware scan result security risk warning.

    .PARAMETER MinimumPasswordLength 
    Parameter to disable the option to ignore the minimum password length security risk warning.

    .PARAMETER PasswordComplexity 
    Parameter to disable the option to ignore the password complexity security risk warning.

    .PARAMETER RequireHostAuthentication 
    Parameter to disable the option to ignore the require host authentication security risk warning.

    .PARAMETER RequireLoginforiLORBSU 
    Parameter to disable the option to ignore the require login for iLO RBSU security risk warning.

    .PARAMETER SecureBoot 
    Parameter to disable the option to ignore the secure boot security risk warning.

    .PARAMETER SecurityOverrideSwitch 
    Parameter to disable the option to ignore the security override switch security risk warning.

    .PARAMETER SNMPv1 
    Parameter to disable the option to ignore the SNMPv1 request: disabled security risk warning.

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Disable-HPECOMIloIgnoreSecuritySetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging

    This command disables the ignore iLO security risk settings "Access Panel Status" and "Authentication Failure Logging" on the server with serial number 'CZ12312312' located in the `eu-central` region. 
   
    .EXAMPLE
    Disable-HPECOMIloIgnoreSecuritySetting -Region eu-central -SerialNumber "CZ12312312" -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse -IPMIDCMIOverLAN -LastFirmwareScanResult -MinimumPasswordLength -PasswordComplexity -RequireHostAuthentication -RequireLoginforiLORBSU -SecureBoot -SecurityOverrideSwitch -SNMPv1 

    This command disables all ignore iLO security risk settings on the server with serial number 'CZ12312312' located in the `eu-central` region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1 | Disable-HPECOMIloIgnoreSecuritySetting -AccessPanelStatus -AuthenticationFailureLogging -DefaultSSLCertificateInUse

    This command disables the ignore iLO security risk settings "Access Panel Status", "Authentication Failure Logging", and "Default SSL Certificate In Use" on the server named 'ESX-1' located in the `eu-central` region.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Disable-HPECOMIloIgnoreSecuritySetting -Region eu-central -MinimumPasswordLength

    This command disables the ignore iLO security risk setting "Minimum Password Length" on the servers with serial numbers 'CZ12312312' and 'DZ12312312' located in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central | select -First 3 | Disable-HPECOMIloIgnoreSecuritySetting -MinimumPasswordLength -PasswordComplexity

    The first command retrieves all servers in the 'eu-central' region. The second command selects the first three servers.
    The third command disables the ignore iLO security risk settings "Minimum Password Length" and "Password Complexity" on the selected servers.
 
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)
    #>

    [CmdletBinding()]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,     

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [alias('serial')]
        [String]$SerialNumber,
        
        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$Name,    

        [switch]$AccessPanelStatus,
	
        [switch]$AuthenticationFailureLogging,
            
        [switch]$DefaultSSLCertificateInUse,
            
        [switch]$IPMIDCMIOverLAN,
            
        [switch]$LastFirmwareScanResult,
            
        [switch]$MinimumPasswordLength,
            
        [switch]$PasswordComplexity,
            
        [switch]$RequireHostAuthentication,
            
        [switch]$RequireLoginforiLORBSU,
            
        [switch]$SecureBoot,
            
        [switch]$SecurityOverrideSwitch,
            
        [switch]$SNMPv1,

        [switch]$Async,

        [switch]$WhatIf

    )

    Begin {

        [int]$TimeoutinSecondsPerServer = 60

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'iLOSecurity'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri

        $uri = $COMJobsUri       
        
    }
    
    Process {
        
        $IgnoreSecuritySettings = [System.Collections.ArrayList]::new()

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
           
            if ($SerialNumber) {

                $ParamUsed = $SerialNumber
                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber

            } 
            elseif ($Name) {

                $ParamUsed = $Name
                $_server = Get-HPECOMServer -Region $Region -Name $Name

            }

            $_serverResourceUri = $_server.resourceUri

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        

        if (-not $_serverResourceUri) {
            
            # Must return a message if not found

            $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
            Write-warning $ErrorMessage

            # $ErrorRecord = New-ErrorRecord ServerNotFoundInCOM ObjectNotFound -TargetObject 'Server' -Message $ErrorMessage -TargetType $ParamUsed.GetType().Name
            # $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }
        else {

            # Build $IgnoreSecuritySettings
            function New-Setting {
                param (
                    [string]$Name,
                    [string]$Id
                )
            
                return @{
                    name   = $Name
                    ignore = $false
                    id     = $Id
                }
            }
            
    
            if ($AccessPanelStatus) {
    
                $Setting = New-Setting "Access Panel Status" 7
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($AuthenticationFailureLogging) {
    
                $Setting = New-Setting "Authentication Failure Logging" 4
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($DefaultSSLCertificateInUse) {
    
                $Setting = New-Setting "Default SSL Certificate In Use" 10
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($IPMIDCMIOverLAN) {
    
                $Setting = New-Setting "IPMI/DCMI Over LAN" 1
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($LastFirmwareScanResult) {
    
                $Setting = New-Setting "Last Firmware Scan Result" 11
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($MinimumPasswordLength) {
    
                $Setting = New-Setting "Minimum Password Length" 2
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($PasswordComplexity) {
    
                $Setting = New-Setting "Password Complexity" 6
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($RequireHostAuthentication) {
    
                $Setting = New-Setting "Require Host Authentication" 8
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($RequireLoginforiLORBSU) {
    
                $Setting = New-Setting "Require Login for iLO RBSU" 3
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($SecureBoot) {
    
                $Setting = New-Setting "Secure Boot" 5
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($SecurityOverrideSwitch) {
    
                $Setting = New-Setting "Security Override Switch" 0
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
            if ($SNMPv1) {
    
                $Setting = New-Setting "SNMPv1" 9
                [void]$IgnoreSecuritySettings.add($Setting)
            }
    
    
            if (-not $IgnoreSecuritySettings) {
                
                # Must return a message if no parameter is used    
                $ErrorMessage = "At least one ignore iLO security risk setting must be used with this cmdlet!" -f $ParamUsed
                $ErrorRecord = New-ErrorRecord IgnoreParameterNotFound InvalidArgument -TargetObject 'Server' -Message $ErrorMessage 
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
    
    
            # Build payload
            $data = @{
                ignoreSecuritySettings = $IgnoreSecuritySettings
            }
                
              
            $payload = @{
                jobTemplateUri = $JobTemplateUri
                resourceUri    = $_serverResourceUri
                data           = $data                 
            }      
    
    
            $payload = ConvertTo-Json $payload -Depth 10 
    
            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
    
                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region
                # Apply Jobs format
                $_resp = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Jobs" 
    
                if (-not $WhatIf -and -not $Async) {    
                     
                    $Timeout = $TimeoutinSecondsPerServer
                    
                    "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}' -Timeout '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri), $Timeout | Write-Verbose
    
                    $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri -Timeout $Timeout 
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                }
            }
            catch {
    
                if (-not $WhatIf) {
    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
            }  
    
            if (-not $WhatIf ) {
                
                Return $_resp
            
            }
        }
    }          
}


#EndRegion


#Region --- METRICS CONFIGURATION ---

Function Get-HPECOMMetricsConfiguration {
    <#
    .SYNOPSIS
    Retrieve the metrics data collection configuration.

    .DESCRIPTION
    This Cmdlet returns a collection of metrics data configuration that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMMetricsConfiguration -Region us-west 

    Return metrics data collection configuration located in the western US region. 

    .INPUTS
    No pipeline support

    
   #>
    [CmdletBinding()]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose      
        
        $Uri = $COMMetricsConfigurationsUri
            
        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            
             
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Jobs"    
            
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- ONEVIEW APPLIANCES ---

Function Get-HPECOMOneViewAppliance {
    <#
    .SYNOPSIS
    Retrieve the list of HPE OneView appliances.
    
    .DESCRIPTION
    This Cmdlet returns a collection of HPE OneView appliance resources in the specified region. 
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.  

    .PARAMETER Hostname
    Specifies the name of the OneView appliance resource.      

    .PARAMETER IPAddress
    Specifies the IP address of the OneView appliance resource.      

    .PARAMETER Limit 
    This parameter allows you to define the number of HPE OneView appliances to be displayed. 
   
    .PARAMETER Type 
    Optional parameter that can be used to get a certain type of OneView appliances such as 'VM' or 'Synergy'.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central

    Return all HPE OneView appliances in the central european region. 

    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central -Name oneview.hpelab.net

    Return the OneView appliance named 'oneview.hpelab.net' in the central european region. 
    
    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central -Type Synergy

    Return data for all OneView appliances located in the central European region that are classified as type 'Synergy'.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
    
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'IP')]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or $_ -match [Net.IPAddress]$_ })]
        [string]$IPAddress,

        [Parameter (ParameterSetName = 'Name')]
        [Parameter (Mandatory, ParameterSetName = 'ActivationKeyName')]
        [String]$Hostname,

        [Parameter (ParameterSetName = 'Limit')]
        [ValidateScript({ $_ -le 1000 })]
        [int]$Limit,

        [Parameter (ParameterSetName = 'Limit')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $environments = @('Synergy', 'VM')
                $filteredEnvironments = $environments | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredEnvironments | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateScript({
                $validOptions = @('Synergy', 'VM')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]                
        [String]$Type,

        [Parameter (ParameterSetName = 'ActivationKeyName')]
        [Switch]$ShowActivationKey,

        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # No limit by default
        if ($Limit) {

            $Uri = $COMOneViewAppliancesUri + "?limit=$Limit"
       
        } 
        else {
            
            $Uri = $COMOneViewAppliancesUri 
        }           


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
               
        }
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {      

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            
            
            if ($Type) {
                
                $CollectionList = $CollectionList | Where-Object applianceType -eq $Type
            }
            elseif ($IPAddress) {
            
                $CollectionList = $CollectionList | Where-Object ipaddress -eq $IPAddress
                  
            } 
            elseif ($Hostname) {
                
                $CollectionList = $CollectionList | Where-Object Hostname -eq $Hostname 
                
            }       
            
            if ($ShowActivationKey) {
                    
                $CollectionList = $CollectionList.activationkey
                return $CollectionList 
                
            }
             

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.OneViewAppliances"    
    
            $ReturnData = $ReturnData | Sort-Object name, ipaddress
        
            return $ReturnData 
           
        }
        else {

            return
                
        }     

    
    }
}



Function Add-HPECOMApplianceOneView {
    <#
    .SYNOPSIS
    Adds an HPE OneView appliance for management to a specific region.

    .DESCRIPTION   
    This cmdlet adds an HPE OneView appliance to the specified region for management.

    Note: Once added, the appliance must be activated in OneView with the activation key returned by this cmdlet using the 'Enable-OVComputeOpsManagement -ActivationKey $ActivationKey' cmdlet from the HPE OneView PowerShell library.

    Note: The appliance activation key required to enable Compute Ops Management in OneView can also be retrieved using 'Get-HPECOMOneViewAppliance -Hostname <OV hostname> -ShowActivationKey'.

    .PARAMETER Region 
    The name of the region where the appliance will be located.  

    .PARAMETER ID
    The unique identifier of the OneView appliance to be added.

    Note: The appliance ID can be retrieved using the 'Get-OVComputeOpsManagement' cmdlet from the HPE OneView PowerShell library.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    $credentials = Get-Credential
    Connect-OVMgmt -Appliance OV.domain.com -Credential $credentials
    $AddTask = Get-OVComputeOpsManagement | Add-HPECOMApplianceOneView -Region eu-central
    Enable-OVComputeOpsManagement -ActivationKey $AddTask.activationkey
    
    In this example:
    1. Prompts the user to enter their credentials and stores them in the $credentials variable.
    2. Establishes a connection to the OV.domain.com appliance using the Connect-OVMgmt cmdlet, passing the appliance URL (OV.domain.com) and the credentials stored in the $credentials variable.
    3. Retrieves the Compute Ops Management configuration from OneView using the HPE OneView PowerShell library, then pipes the output to add the OneView appliance to the 'eu-central' region.
    4. Activates the Compute Ops Management configuration in OneView using the obtained activation key from the returned $AddTask object with the 'Enable-OVComputeOpsManagement' cmdlet. The activation key is required for enabling Compute Ops Management in OneView.

    .EXAMPLE
    $credentials = Get-Credential
    Connect-OVMgmt -Appliance OV.domain.com -Credential $credentials
    $ApplianceID = (Get-OVComputeOpsManagement).ApplianceID
    $AddTask = Add-HPECOMApplianceOneView -Region eu-central -ID $ApplianceID 
    Enable-OVComputeOpsManagement -ActivationKey $AddTask.activationkey

    In this example:
    1. Prompts the user to enter their credentials and stores them in the $credentials variable.
    2. Establishes a connection to the OV.domain.com appliance using the Connect-OVMgmt cmdlet, passing the appliance URL (OV.domain.com) and the credentials stored in the $credentials variable.
    3. Retrieves the ApplianceID from 'Get-OVComputeOpsManagement'.
    4. Adds the OneView appliance to the 'eu-central' region using the appliance ID.
    5. Activates the Compute Ops Management configuration in OneView using the obtained activation key from the returned $AddTask object with the 'Enable-OVComputeOpsManagement' cmdlet. The activation key is required for enabling Compute Ops Management in OneView.

    .INPUTS
    System.Collections.ArrayList
        OneView appliance details from 'Get-OVComputeOpsManagement' (HPE OneView PowerShell library).

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * ID - ID of the OneView appliance attempted to be added to the region
        * Region - Name of the region 
        * ActivationKey - The activation key to be used in OneView for enabling Compute Ops Management
        * Status - The status of the addition attempt (Failed for HTTP error return; Complete if addition is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
#>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [alias('ApplianceID')]
        [String]$ID,
                  
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $AddOneViewStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            ID            = $ID
            Region        = $Region   
            ActivationKey = $Null                         
            Status        = $Null
            Details       = $Null
            Exception     = $Null
        }
            
        $Uri = $COMOneViewAppliancesUri                         
    
        # Build payload
        $payload = ConvertTo-Json @{
            id = $ID
        }          
              
        # Add resource
        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                        
            if (-not $WhatIf) {

                "[{0}] Add OneView appliance call response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                "[{0}] OneView appliance '{1}' successfully added to '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ID, $Region | Write-Verbose
                        
                $objStatus.Status = "Complete"
                $objStatus.Details = "OneView appliance successfully added to $Region region"
                $objStatus.ActivationKey = $Response.ActivationKey
    
            }
    
        }
        catch {
    
            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "OneView appliance cannot be added to $Region region!"
                $objStatus.Exception = $_.Exception.message 
    
            }
        }   
            
        

        [void] $AddOneViewStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($AddOneViewStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more OneView appliances failed to be added to $Region!"
          
            }
            
            Return $AddOneViewStatus
        }


    }
}



Function Remove-HPECOMApplianceOneView {
    <#
    .SYNOPSIS
    Remove a OneView appliance from management.

   .DESCRIPTION   
    This cmdlet removes a OneView appliance from a specified region. 

    .PARAMETER Region 
    The name of the region where the appliance is located.  

    .PARAMETER Hostname
    Specifies the name of the OneView appliance resource.      

    .PARAMETER IPAddress
    Specifies the IP address of the OneView appliance resource.    

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

   .EXAMPLE
    Remove-HPECOMApplianceOneView -Region eu-central -Hostname oneview.lab
    
    This example removes the OneView appliance named 'oneview.lab' from the eu-central region.
        
    .EXAMPLE
    Remove-HPECOMApplianceOneView -Region eu-central -IPAddress 192.168.1.22

    This example removes the OneView appliance with the IP address '192.168.1.22' from the eu-central region.

    .EXAMPLE
    Get-HPECOMOneViewAppliance -Region eu-central | Remove-HPECOMApplianceOneView -WhatIf

    This example removes all OneView appliances from the eu-central region.

    .EXAMPLE
    "192.168.1.10", "192.168.1.20" | Remove-HPECOMApplianceOneView -Region eu-central 

    This example removes the OneView appliances with the IP addresses '192.168.1.10' and '192.168.1.20' from the eu-central region.

    .EXAMPLE
    $ApplianceID = (Get-OVComputeOpsManagement ).ApplianceID
    Remove-HPECOMApplianceOneView -Region eu-central -Hostname $ApplianceID 

    This example removes a OneView appliance from the 'eu-central' region using the appliance ID returned by the 'Get-OVComputeOpsManagement' cmdlet from the HPE OneView PowerShell library. This is typically done for appliances that have not been activated.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the appliance's IP addresses.

    System.Collections.ArrayList
        A list of OneView appliances from 'Get-HPECOMOneViewAppliance'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the OneView appliance attempted to be removed from the region
        * Region - Name of the region 
        * Status - The status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - Additional information about the status.
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 

        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'IP')]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or $_ -match [Net.IPAddress]$_ })]
        [string]$IPAddress,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Name')]
        [alias('name')]
        [String]$Hostname,
                  
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveOneViewStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Null
            Region    = $Region   
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {

            if ($Hostname) {
    
                $ParamUsed = $Hostname
    
                $_Appliance = Get-HPECOMOneViewAppliance -Region $Region -Hostname $Hostname
            }
            else {
    
                $ParamUsed = $IPAddress
    
                $_Appliance = Get-HPECOMOneViewAppliance -Region $Region -IPAddress $IPAddress
    
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        

        $objStatus.name = $ParamUsed

        if (-not $_Appliance) {
                
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Appliance '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "OneView appliance '$ParamUsed' cannot be found in the Compute Ops Management instance!"
              
            }

        }
        else {   
            
            $Uri = $_Appliance.resourceUri                    
              
            # Add resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 
                        
                if (-not $WhatIf) {

                    "[{0}] Remove OneView appliance call response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                    
                    "[{0}] OneView appliance '{1}' successfully removed from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ParamUsed, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "OneView appliance successfully removed from $Region region"
    
                }
    
            }
            catch {
    
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "OneView appliance cannot be removed from $Region region!"
                    $objStatus.Exception = $_.Exception.message 
    
                }
            }   
            
        }

        [void] $RemoveOneViewStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveOneViewStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more OneView appliances failed to be removed from $Region!"
          
            }
            
            Return $RemoveOneViewStatus
        }


    }
}


#EndRegion


#Region --- REPORTS ---

Function Get-HPECOMReport {
    <#
    .SYNOPSIS
    Retrieve the list of reports.

    .DESCRIPTION
    This Cmdlet returns a collection of reports and their associated data that are available in the specified region.

    Note: To get more information about report details, you can use Get-HPECOMServerInventory and Get-HPECOMSustainabilityReport.
    
    .PARAMETER Region 
    Specifies the region from which to retrieve the reports.

    .PARAMETER ServerHardwareInventoryReport
    Optional switch parameter that can be used to display the server hardware inventory report.

    .PARAMETER ServerHardwareInventoryData
    Optional switch parameter that can be used to display the data of the server hardware inventory report.  

    .PARAMETER SustainabilityReport
    Optional switch parameter that can be used to display the sustainability report.
    
    .PARAMETER SustainabilityData
    Optional switch parameter that can be used to display the data of the sustainability report.  

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMReport -Region us-west 

    Return all reports resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMReport -Region us-west -ServerHardwareInventoryReport 

    Return the server hardware inventory report located in the western US region. 

    .EXAMPLE
    Get-HPECOMReport -Region us-west -ServerHardwareInventoryData 
    
    Return the data of the server hardware inventory report. 
    
    .EXAMPLE
    Get-HPECOMReport -Region eu-central -SustainabilityReport 

    Return the sustainability report located in the western US region. 

    .EXAMPLE
    Get-HPECOMReport -Region eu-central -SustainabilityData 
    
    Return the data of the sustainability report. 

    
   #>
    [CmdletBinding(DefaultParameterSetName = "Region")]
    Param( 
        [Parameter (Mandatory, ParameterSetName = 'Region')]
        [Parameter (Mandatory, ParameterSetName = 'ServerHardwareInventoryReport')]
        [Parameter (Mandatory, ParameterSetName = 'ServerHardwareInventoryData')]
        [Parameter (Mandatory, ParameterSetName = 'SustainabilityReport')]
        [Parameter (Mandatory, ParameterSetName = 'Co2Emissions')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumption')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCost')]
        [Parameter (Mandatory, ParameterSetName = 'Co2EmissionsTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumptionTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCostTotal')]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  


        [Parameter (ParameterSetName = 'ServerHardwareInventoryReport')]
        [Switch]$ServerHardwareInventoryReport,

        [Parameter (ParameterSetName = 'ServerHardwareInventoryData')]
        [Switch]$ServerHardwareInventoryData,

        [Parameter (ParameterSetName = 'SustainabilityReport')]
        [Switch]$SustainabilityReport,

        [Parameter (ParameterSetName = 'Co2Emissions')]
        [Switch]$SustainabilityData,
    
        [Switch]$WhatIf
       
    ) 

    Begin {
    
        $Caller = (Get-PSCallStack)[1].Command
    
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


    }


    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        
        if ($ServerHardwareInventoryReport) {
            $Uri = $COMReportsUri + "?filter=reportType eq 'SERVER_HARDWARE_INVENTORY'&limit=10"
            
        }        
        elseif ($ServerHardwareInventoryData) {

            $Uri = $COMReportsUri + "?limit=10"

            try {

                $ReportList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
                
                "[{0}] Server hardware inventory report: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ReportList | ConvertTo-Json -d 10) | Write-Verbose

                $ReportID = ($ReportList | Where-Object reportType -eq "SERVER_HARDWARE_INVENTORY" ).id

                "[{0}] ID found for 'Server hardware inventory report': '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ReportID | Write-Verbose

                if ($Null -eq $ReportID) { Throw "Error: Server hardware inventory report not found! You need to run New-HPECOMServerInventory first" }
    
                $Uri = $COMReportsUri + "/" + $ReportID + "/data" + "?limit=10"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        elseif ($SustainabilityReport) {
            $Uri = $COMReportsUri + "?filter=reportType eq 'CARBON_FOOTPRINT'&limit=10"
            
        }
        elseif ($SustainabilityData) {
           
            $Uri = $COMReportsUri + "?limit=10"

            try {

                $ReportList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
                
                "[{0}] Sustainability report: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ReportList | ConvertTo-Json -d 10) | Write-Verbose

                $ReportID = ($ReportList | Where-Object reportType -eq "CARBON_FOOTPRINT" ).id

                "[{0}] ID found for 'sustainability report': '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ReportID | Write-Verbose

                if ($Null -eq $ReportID) { Throw "Error: Sustainability report not found! You need to run New-HPECOMSustainabilityReport first" }
    
                $Uri = $COMReportsUri + "/" + $ReportID + "/data" + "?limit=10"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
            
        }
        else {
            $Uri = $COMReportsUri + "?limit=10"
            
        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {    
            
            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region            


            if ($ServerHardwareInventoryData) {

                $CollectionList = $CollectionList.data.rows.items
               
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.ServerHardwareInventoryData"    
                $ReturnData = $ReturnData | Sort-Object name

            }
            
            elseif ($SustainabilityData) {

                $CollectionList = $CollectionList.data.series

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    
                $ReturnData = $ReturnData | Sort-Object { $_.name, $_.subject.displayName }

            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports"    
                $ReturnData = $ReturnData | Sort-Object name
            }

        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}



function New-HPECOMServerInventory {
    <#
    .SYNOPSIS
    Collect server inventory data.
    
    .DESCRIPTION   
    This cmdlet collects inventory data from all directly managed or OneView managed servers or from a specified server resource.
    It also provides options for scheduling execution at a specific time and setting recurring schedules.
    
    .PARAMETER Region
    Name of the region where the server is located. 
    
    .PARAMETER SerialNumber
    Serial number of the server on which server inventory data will be collected. 
    
    .PARAMETER Chassis
    Switch parameter that can be used to collect the chassis inventory data.
    When no inventory list is provided, all inventory resources will be collected.
    
    .PARAMETER Devices
    Switch parameter that can be used to collect the devices inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Fans
    Switch parameter that can be used to collect the fans inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Firmware
    Switch parameter that can be used to collect the firmware inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER LocalStorage
    Switch parameter that can be used to collect the local storage inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Memory
    Switch parameter that can be used to collect the memory inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER NetworkAdapters
    Switch parameter that can be used to collect the network adapters inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER PowerSupplies
    Switch parameter that can be used to collect the power supplies inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Processor
    Switch parameter that can be used to collect the processor inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER Software
    Switch parameter that can be used to collect the software inventory data.
    When no inventory list is provided, all inventory resources will be collected.

    .PARAMETER ScheduleTime
    Indicates when to schedule the server inventory operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"
    
    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) referencing days, weeks, months, years but not time (T) designations that reference hours, minutes, and seconds.

    This parameter supports common ISO 8601 period durations such as:
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMServerInventory -Region us-west 
    
    Collects a full inventory data from all directly managed or OneView managed servers in the western US region.

    .EXAMPLE
    New-HPECOMServerInventory -Region us-west -SerialNumber CN70490RXQ  

    Collects a full inventory data from server 'CN70490RXQ' in the western US region.

    .EXAMPLE
    New-HPECOMServerInventory -Region us-west -SerialNumber CN70490RXQ -Chassis -Fans 

    Collects the chassis and fans inventory data from server 'CN70490RXQ' in the western US region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -Name HOL19  | New-HPECOMServerInventory

    Collects the full inventory data from server named 'HOL19' in the western US region.    
    
    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model 'ProLiant DL380a Gen11' -ConnectedState True  | New-HPECOMServerInventory

    The first command retrieves all 'ProLiant DL380a Gen11' servers in the 'us-west' region that are connected to the COM. 
    The second command collects full inventory data of these servers provided through the pipeline.

    .EXAMPLE
    New-HPECOMServerInventory -Region eu-central -SerialNumber CZ12312312 -ScheduleTime (Get-Date).AddDays(1) 

    Creates a new server inventory in the 'eu-central' region with serial number 'CZ12312312', scheduled to start one day from the current date.

    .EXAMPLE
    New-HPECOMServerInventory -Region eu-central -SerialNumber CZ12312312 -ScheduleTime (Get-Date).AddDays(1) -Interval P1W

    Creates a new server inventory in the 'eu-central' region with serial number 'CZ12312312', scheduled to start one day from the current date and recur weekly.

    .EXAMPLE
    "CZ12312312", "CZ12312313" | New-HPECOMServerInventory -Region eu-central

    Collects a full inventory data from servers 'CZ12312312' and 'CZ12312313' in the 'eu-central' region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects that represent the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'. 

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]
        
        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Async')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$SerialNumber,
        
        [switch]$Chassis,

        [switch]$Devices,

        [switch]$Fans,

        [switch]$Firmware,
        
        [switch]$LocalStorage,

        [switch]$Memory,
        
        [switch]$NetworkAdapters,
        
        [switch]$PowerSupplies,

        [switch]$Processor,

        [switch]$Software,

        [Parameter (Mandatory, ParameterSetName = 'Schedule')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Schedule')]
        [String]$Interval, 

        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,

        [switch]$WhatIf


    )

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'GetFullServerInventory'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $ServerInventoryStatus = [System.Collections.ArrayList]::new()
        $Filters = [System.Collections.ArrayList]::new()

        
    }

    Process {  

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($SerialNumber) {

                $_ResourceUri = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber).resourceUri

                "[{0}] Resource is 'SERVERS' type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ResourceUri | Write-Verbose


            } 
            else {

                $_ResourceUri = (Get-HPECOMFilter -Region $Region -Name "All servers" ).resourceUri

                "[{0}] Resource is 'FILTERS' type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ResourceUri | Write-Verbose


            }



        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_ResourceUri) {
            # Must return a message if not found

            if ($SerialNumber) {
                
                $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $SerialNumber
                Write-warning $ErrorMessage
                return
            }
            else {
                $ErrorMessage = "Filter 'All servers' cannot be found in the Compute Ops Management instance!" 
                $ErrorRecord = New-ErrorRecord FilterNotFoundInCOM ObjectNotFound -TargetObject 'Filter' -Message $ErrorMessage 
                
            }

            $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }
        else {



            if ($Chassis -or $Processor -or $Memory -or $NetworkAdapters -or $LocalStorage -or $LocalStorageV2 -or $Devices -or $DevicesV2 -or $PowerSupplies -or $Fans -or $Firmware -or $Software) {
                
                if ($Chassis) {
                
                    [void]$Filters.Add("Chassis")

                }  

                if ($Processor) {
                
                    [void]$Filters.Add("Processor")

                }  

                if ($Memory) {
                
                    [void]$Filters.Add("memory")

                }  

                if ($NetworkAdapters) {
                
                    [void]$Filters.Add("networkAdapters")

                }  

                if ($LocalStorage) {
                
                    [void]$Filters.Add("localStorageV2")

                }  

                if ($Devices) {
                
                    [void]$Filters.Add("devicesV2")

                }  

                if ($PowerSupplies) {
                
                    [void]$Filters.Add("powerSupplies")

                }  

                if ($Fans) {
                
                    [void]$Filters.Add("fans")

                }  

                if ($Firmware) {
                
                    [void]$Filters.Add("firmware")

                }  

                if ($Software) {
                
                    [void]$Filters.Add("software")

                }  

                $data = @{
                    filters = $Filters
                }
                
            }
            

            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                if ($data) {
                    
                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_ResourceUri
                        data           = $data
                    }      
                }
                else {

                    $_Body = @{
                        jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                        resourceUri    = $_ResourceUri
                    }    

                }
                
                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                if ($SerialNumber) {

                    $Name = "$($SerialNumber)_Inventory_Report_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to run an inventory report on server '$($SerialNumber)'"

                }
                else {

                    $Name = "All_Servers_Inventroy_Report_Schedule_$($randomNumber)"
                    $Description = "Scheduled task to run an inventory report for all servers"
                }

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "INVENTORY_REPORT"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                if ($data) {
    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_ResourceUri
                        data           = $data
                    }
                    
                }
                else {
    
                    $payload = @{
                        jobTemplateUri = $JobTemplateUri
                        resourceUri    = $_ResourceUri
                    }      
                }
            }
            

            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
            
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
            
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $ServerInventoryStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $ServerInventoryStatus
        
        }

    }
}


Function Get-HPECOMServerInventory {
    <#
    .SYNOPSIS
    Retrieve the inventories of a server.
    
    .DESCRIPTION
    This Cmdlet can be used to retrieve firmware, software, storage inventories, PCI devices and smart update tool settings for a server specified by the 
    name or serial number of the server.
    
    Note: 
    A server hardware inventory report must be available or created with `New-HPECOMServerInventory` before using this cmdlet. 
    You can check reports using `Get-HPECOMReport`.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.
    
    .PARAMETER Name 
    Parameter that can be used to specify a server's name in order to obtain its inventory.

    .PARAMETER SerialNumber 
    Parameter that can be used to specify a server's serial number in order to obtain its inventory.
    
   .PARAMETER ShowChassis
    Parameter that can be used to get the chassis inventory.   

   .PARAMETER ShowDevice
    Parameter that can be used to get the device inventory (OCP, PCI, embedded, etc.).

   .PARAMETER ShowFans
    Parameter that can be used to get the fan inventory.

   .PARAMETER ShowFirmware
    Parameter that can be used to get the firmware inventory.

   .PARAMETER ShowMemory
    Parameter that can be used to get the memory inventory.

   .PARAMETER ShowNetworkAdapter
    Parameter that can be used to get the network adapter inventory (NIC, CNA, HBA, etc.).

   .PARAMETER ShowPowerSupply
    Parameter that can be used to get the power supply inventory.

   .PARAMETER ShowProcessor
    Parameter that can be used to get the processor inventory.

   .PARAMETER ShowSmartUpdateTool
    Parameter that can be used to get the Smart Update Tool (SUT) information details.

   .PARAMETER ShowSoftware
    Parameter that can be used to get the software inventory.

   .PARAMETER ShowStorageController
    Parameter that can be used to get the storage controller inventory.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
    
    .EXAMPLE
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6
    
    Retrieves the inventory for the server with the serial number TWA22565A6 in the western US region.
    
    .EXAMPLE
    # Retrieve the firmware inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowFirmware
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowFirmware
    
    This command returns the firmware inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the software inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowSoftware
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowSoftware
    
    This command returns the software inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the device inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowDevice
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowDevice
    
    This command returns the device inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the fan inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowFans
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowFans
    
    This command returns the fan inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .EXAMPLE
    # Retrieve the memory inventory details of a server using its serial number
    Get-HPECOMServerInventory -Region us-west -SerialNumber TWA22565A6 -ShowMemory
    
    # Alternatively, if the serial number is not known, use the server name
    Get-HPECOMServer -Region us-west -Name WIN-2022-1 | Get-HPECOMServerInventory -ShowMemory
    
    This command returns the memory inventory details of the server with serial number 'TWA22565A6' in the western US region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers retrieved using 'Get-HPECOMServer -Name $Name'.

   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 
    
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'InventoryName')]
        [String]$Name,
    
        [Parameter (Mandatory, ParameterSetName = 'SerialNumber', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorySN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorysoftwareSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventoryFirmwareSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorystorageSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorysmartStorageSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorydeviceSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorysmartUpdateToolSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorychassisSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorymemorySN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorynetworkAdapterSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventoryprocessorSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorypowerSupplySN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (Mandatory, ParameterSetName = 'InventorythermalSN', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias ('serial_number')]
        [String]$SerialNumber,
       
        # [Parameter (ParameterSetName = 'InventorychassisName')]
        [Parameter (ParameterSetName = 'InventorychassisSN')]
        [Switch]$ShowChassis,

        # [Parameter (ParameterSetName = 'InventorydeviceName')]
        [Parameter (ParameterSetName = 'InventorydeviceSN')]
        [Switch]$ShowDevice,
        
        # [Parameter (ParameterSetName = 'InventorythermalName')]
        [Parameter (ParameterSetName = 'InventorythermalSN')]
        [Switch]$ShowFans,

        # [Parameter (ParameterSetName = 'InventoryFirmwareName')]
        [Parameter (ParameterSetName = 'InventoryFirmwareSN')]
        [Switch]$ShowFirmware,
        
        # [Parameter (ParameterSetName = 'InventorymemoryName')]
        [Parameter (ParameterSetName = 'InventorymemorySN')]
        [Switch]$ShowMemory,

        # [Parameter (ParameterSetName = 'InventorynetworkAdapterName')]
        [Parameter (ParameterSetName = 'InventorynetworkAdapterSN')]
        [Switch]$ShowNetworkAdapter,

        # [Parameter (ParameterSetName = 'InventorypowerSupplyName')]
        [Parameter (ParameterSetName = 'InventorypowerSupplySN')]
        [Switch]$ShowPowerSupply,

        # [Parameter (ParameterSetName = 'InventoryprocessorName')]
        [Parameter (ParameterSetName = 'InventoryprocessorSN')]
        [Switch]$ShowProcessor,

        # [Parameter (ParameterSetName = 'InventorysmartStorageName')]
        # [Parameter (ParameterSetName = 'InventorysmartStorageSN')]
        # [Switch]$ShowSmartStorage,

        [Parameter (ParameterSetName = 'InventorysmartUpdateToolName')]
        [Parameter (ParameterSetName = 'InventorysmartUpdateToolSN')]
        [Switch]$ShowSmartUpdateTool,

        # [Parameter (ParameterSetName = 'InventorysoftwareName')]
        [Parameter (ParameterSetName = 'InventorysoftwareSN')]
        [Switch]$ShowSoftware,
        
        # [Parameter (ParameterSetName = 'InventorystorageName')]
        [Parameter (ParameterSetName = 'InventorystorageSN')]
        [Switch]$ShowStorageController,

        [Switch]$WhatIf
        
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

    
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose  

        # Get server ID using SN   
        if ($SerialNumber) {
            $Uri = $COMServersUri + "?filter=hardware/serialNumber eq '$SerialNumber'"
                
        }
        elseif ($Name) {
            $Uri = $COMServersUri + "?filter=host/hostname eq '$Name'"     
                
        }

        try {
            [Array]$Server = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

        
            if ($Null -eq $Server) { 
            
                Return
        
            }
            else {
                
                $ServerID = $Server.id
                
                if ($SerialNumber) {
                    
                    "[{0}] ID found for server serial number '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $ServerID | Write-Verbose
                    
                    
                }
                elseif ($Name) {
                    
                    "[{0}] ID found for server name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $ServerID | Write-Verbose
                    
                }
            }
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
           
        }
       

     
        # Requests using $ServerID
        $Uri = $COMServersUri + "/" + $ServerID + "/inventory"

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

            $FullInventoryAlreadyRun = if ($CollectionList.lastFullInventoryCollectionAt) { $True }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }



        $ReturnData = @()
               
        # Format response with Repackage Object With Type
        if ($Null -ne $CollectionList) {      
            
            # Add region, servername and serialNumber (only serial is provided)
            try {
                $_ServerName = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $CollectionList.serial                        
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            $CollectionList | Add-Member -type NoteProperty -name serialNumber -value $CollectionList.serial  
            $CollectionList | Add-Member -Type NoteProperty -Name serverName -Value $_ServerName.name


            if ($Showsoftware) {
                $ReturnData = $CollectionList.software.data 
                $ReturnData | Add-Member -Type NoteProperty -Name serverName -Value $_ServerName.name
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Software"    

            }
    
            elseif ($Showfirmware) {
                $ReturnData = $CollectionList.firmware.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Software"    

            }

            elseif ($ShowStorageController) {
                $ReturnData = $CollectionList.storage.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Storage"    

            }

            elseif ($ShowsmartStorage) {
                $ReturnData = $CollectionList.smartStorage.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Storage"    

            }

            elseif ($Showdevice) {
                $ReturnData = $CollectionList.device.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Device"    

            }

            elseif ($ShowSmartUpdateTool) {
                $ReturnData = $CollectionList.smartUpdateToolInventory.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.smartUpdateToolInventory"    

            }

            elseif ($Showchassis) {
                $ReturnData = $CollectionList.chassis.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Chassis"    

            }

            elseif ($Showmemory) {
                $ReturnData = $CollectionList.memory.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Memory"    

            }

            elseif ($ShownetworkAdapter) {
                $ReturnData = $CollectionList.networkAdapter.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.NetworkAdapter"    

            }

            elseif ($Showprocessor) {
                $ReturnData = $CollectionList.processor.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Processor"    

            }

            elseif ($ShowpowerSupply) {
                $ReturnData = $CollectionList.powerSupply.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.PowerSupply"    

            }

            elseif ($ShowFans) {
                $ReturnData = $CollectionList.thermal.data 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "COM.Servers.Inventory.Thermal"    

            }
            else {
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.Inventory"    
                
            }

            if ($Null -eq $ReturnData -and -not $FullInventoryAlreadyRun) {

                Write-Verbose ($PSCmdlet.MyInvocation.BoundParameters.Keys | Where-Object { $_ -like 'Show*' } )

                $ErrorMessage = "{0} inventory data is not populated. Please run New-HPECOMServerInventory first." -f (($PSCmdlet.MyInvocation.BoundParameters.Keys | Where-Object { $_ -like 'Show*' } ) -replace "Show")
                Write-Warning $ErrorMessage

            }
            else {
                
                return $ReturnData 
            }
        }
    }
}


function New-HPECOMSustainabilityReport {
    <#
    .SYNOPSIS
    Generates a carbon footprint report.
    
    .DESCRIPTION   
    This cmdlet generates a Carbon Footprint Report for all managed servers. It also provides options to schedule the execution at a specific time and to set recurring schedules.
    
    .PARAMETER Region
    Specifies the name of the region.
    
    .PARAMETER ScheduleTime
    Indicates when to schedule the update operation.

    Examples for setting the date and time using `Get-Date`:
    - (Get-Date).AddMonths(6)
    - (Get-Date).AddDays(15)
    - (Get-Date).AddHours(3)
    Example for using a specific date string:
    - "2024-05-20 08:00:00"

    .PARAMETER Interval
    Specifies the execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) referencing days, weeks, months, years but not time (T) designations that reference hours, minutes, and seconds.

    This parameter supports common ISO 8601 period durations such as:
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)

    .PARAMETER Async
    Use this parameter to immediately return the asynchronous job resource to monitor (using 'state' and 'resultCode' properties). By default, the Cmdlet will wait for the job to complete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSustainabilityReport -Region us-west 
    
    Generates a carbon footprint report in the western US region for all managed servers.

    .EXAMPLE
    New-HPECOMSustainabilityReport -Region eu-central -ScheduleTime (get-Date).addminutes(10) 

    Schedules the execution of a sustainability report in the `eu-central` region starting 10 minutes from now. 

    .EXAMPLE
    New-HPECOMSustainabilityReport -Region eu-central -ScheduleTime (get-Date).addhours(6) -Interval P1M

    Schedules a monthly execution of a sustainability report in the `eu-central` region. The first execution will occur six hours from the current time.

    .INPUTS
    You cannot pipe objects to this cmdlet.

    .OUTPUTS
    HPEGreenLake.COM.Jobs [System.Management.Automation.PSCustomObject]

        - The finished job object that includes the job result:
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

        - When `-Async` is used, it returns an asynchronous job resource to monitor, which includes the current job state (`state`):
            - PENDING
            - RUNNING
            - STALLED (The job is not making progress and needs to be terminated using Stop-HPECOMGroupFirmware)
            - ERROR
            - COMPLETE

          Additionally, it includes the result code (`resultCode`):
            - SUCCESS
            - FAILURE
            - null (non-terminating state)

    HPEGreenLake.COM.Schedules [System.Management.Automation.PSCustomObject]

        - The schedule job object that includes the schedule details when `-ScheduleTime` is used.

    #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param
    (
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,      

        [Parameter (Mandatory, ParameterSetName = 'Scheduled')]
        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$ScheduleTime,

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?$') {
                    return $true
                }
                else {
                    throw "Invalid period interval format. Please use an ISO 8601 period interval without time components (e.g., P1D, P1W, P1M, P1Y)"
                }
            })]
        [Parameter (ParameterSetName = 'Scheduled')]
        [String]$Interval,    
        
        [Parameter (ParameterSetName = 'Async')]
        [switch]$Async,
        
        [switch]$WhatIf

    )



    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_JobTemplateName = 'DataRoundupReportOrchestrator'

        $JobTemplateUri = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object resourceuri
        $JobTemplateId = $HPECOMjobtemplatesUris | Where-Object name -eq $_JobTemplateName | ForEach-Object id

        $uri = $COMJobsUri
        $SustainabilityReportStatus = [System.Collections.ArrayList]::new()

        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            
            $_ResourceUri = (Get-HPECOMFilter -Region $Region -Name "All servers" ).resourceUri
            "[{0}] Resource is 'FILTERS' type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_ResourceUri | Write-Verbose

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        if (-not $_ResourceUri) {

            # Must return a message if not found
            $ErrorMessage = "Filter 'All servers' cannot be found in the Compute Ops Management instance!" 
            $ErrorRecord = New-ErrorRecord FilterNotFoundInCOM ObjectNotFound -TargetObject 'Filter' -Message $ErrorMessage 
            $PSCmdlet.ThrowTerminatingError($ErrorRecord)

        }
        else {

            $data = @{
                reportType = "CARBON_FOOTPRINT"

            }
             
            if ($ScheduleTime) {

                $uri = $COMSchedulesUri

                $_Body = @{
                    jobTemplateUri = "/api/compute/v1/job-templates/" + $JobTemplateId
                    resourceUri    = $_ResourceUri
                    data           = $data
                }      

                $Operation = @{
                    type   = "REST"
                    method = "POST"
                    uri    = "/api/compute/v1/jobs"
                    body   = $_Body

                }

                $randomNumber = Get-Random -Minimum 000000 -Maximum 999999

                $Name = "All_Servers_SustainabilityReport_Schedule_$($randomNumber)"
                $Description = "Scheduled task to run a sustainability report for all servers"

                if ($Interval) {
                    
                    $Schedule = @{
                        startAt  = $ScheduleTime
                        interval = $Interval
                    }
                }
                else {

                    $Schedule = @{
                        startAt = $ScheduleTime
                        # interval = $Null
                    }
                }

                $Payload = @{
                    name                  = $Name
                    description           = $Description
                    associatedResourceUri = $_ResourceUri
                    purpose               = "SUSTAINABILITY_REPORT"
                    schedule              = $Schedule
                    operation             = $Operation

                }

            }
            else {

                $payload = @{
                    jobTemplateUri = $JobTemplateUri
                    resourceUri    = $_ResourceUri
                    data           = $data
                }
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {
                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                # Add region to object
                $_resp | Add-Member -type NoteProperty -name region -value $Region

                if ($ScheduleTime) {

                    if (-not $WhatIf) {
    
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $_resp -ObjectName "COM.Schedules"

                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    }

                }
                else {

                    if (-not $WhatIf -and -not $Async) {
            
                        "[{0}] Running Wait-HPECOMJobComplete -Region '{1}' -Job '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, ($_resp.resourceuri) | Write-Verbose
            
                        $_resp = Wait-HPECOMJobComplete -Region $Region -Job $_resp.resourceuri
    
                        "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose
    
                    }
                    
                }

            }
            catch {

                if (-not $WhatIf) {

                    $PSCmdlet.ThrowTerminatingError($_)

                }
            }  

            if ($ScheduleTime) {

                if (-not $WhatIf ) {
        
                    Return $ReturnData
                
                }
            }
        }

        if (-not $ScheduleTime) {

            [void] $SustainabilityReportStatus.add($_resp)
        }


    }

    End {

        if (-not $ScheduleTime -and -not $WhatIf ) {
            
            Return $SustainabilityReportStatus
        
        }

    }
}


Function Get-HPECOMSustainabilityReport {
    <#
    .SYNOPSIS
    Retrieve the sustainability report.

    .DESCRIPTION
    This Cmdlet can be used to display the sustainability report and data available in the specified region.

    Note: 
    An sustainability report must be available or created with `New-HPECOMSustainabilityReport` before using this cmdlet. 
    You can check reports using `Get-HPECOMReport`.

    .PARAMETER Region 
    Specifies the region from which to retrieve the sustainability report.
    
    .PARAMETER SerialNumber
    Optional parameter that can be used to get the report data of a specific server.
    
    .PARAMETER Co2Emissions
    Optional switch parameter that can be used to display the carbon emissions data.    
    
    .PARAMETER Co2EmissionsTotal
    Optional switch parameter that can be used to display the total carbon emissions data.    

    .PARAMETER EnergyConsumption
    Optional switch parameter that can be used to display the energy consumption data.   
    
    .PARAMETER EnergyConsumptionTotal
    Optional switch parameter that can be used to display the total energy consumption data.  
        
    .PARAMETER EnergyCost
    Optional switch parameter that can be used to display the energy cost data.    

    .PARAMETER EnergyCostTotal
    Optional switch parameter that can be used to display the total energy cost data.     

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west 
    
    Return the sustainability report information available in the us-west region.
        
    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -Co2Emissions
    
    Return the carbon emissions data of individual servers located the western US region.
    
    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region eu-central -Co2EmissionsTotal 

    Return the total carbon emissions data of all servers located in the central EU region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -SerialNumber MXQ73301YK -Co2Emissions 
    
    Return the carbon emissions data of the server with serial number MXQ73301YK.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyConsumption

    Return the energy consumption data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyConsumptionTotal

    Return the total energy consumption data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -SerialNumber MXQ73301YK -EnergyConsumption 
    
    Return the energy consumption data of the server with serial number MXQ73301YK.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyCost

    Return the energy cost data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region us-west -EnergyCostTotal

    Return the total energy cost data of the western US region.

    .EXAMPLE
    Get-HPECOMSustainabilityReport -Region eu-central -SerialNumber MXQ73301YK -EnergyCost

    Return the energy cost data of the server with serial number MXQ73301YK.
  
    
   #>
    [CmdletBinding(DefaultParameterSetName = "Region")]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'Region')]
        [Parameter (Mandatory, ParameterSetName = 'Co2Emissions')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumption')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCost')]
        [Parameter (Mandatory, ParameterSetName = 'Co2EmissionsTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumptionTotal')]
        [Parameter (Mandatory, ParameterSetName = 'EnergyCostTotal')]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
    

        [Parameter (ParameterSetName = 'Co2Emissions', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (ParameterSetName = 'EnergyConsumption', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (ParameterSetName = 'EnergyCost', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [alias('serial')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ParameterSetName = 'Co2Emissions')]
        [Switch]$Co2Emissions,

        [Parameter (Mandatory, ParameterSetName = 'Co2EmissionsTotal')]
        [Switch]$Co2EmissionsTotal,

        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumption')]
        [Switch]$EnergyConsumption,

        [Parameter (Mandatory, ParameterSetName = 'EnergyConsumptionTotal')]
        [Switch]$EnergyConsumptionTotal,

        [Parameter (Mandatory, ParameterSetName = 'EnergyCost')]
        [Switch]$EnergyCost,

        [Parameter (Mandatory, ParameterSetName = 'EnergyCostTotal')]
        [Switch]$EnergyCostTotal,

        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        
        if (        $Co2Emissions `
                -or $Co2EmissionsTotal `
                -or $EnergyConsumption `
                -or $EnergyConsumptionTotal `
                -or $EnergyCost `
                -or $EnergyCostTotal 

        ) {

            $Uri = $COMReportsUri + "?limit=10"

            try {
                [Array]$ReportList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                $ReportID = $ReportList | Where-Object { $_.name -eq "Sustainability report" } | ForEach-Object id

                "[{0}] ID found for 'Sustainability report': '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ReportID | Write-Verbose

                if ($Null -eq $ReportID) { Throw "Error: Sustainability report not found! You need to run New-HPECOMSustainabilityReport first" }
    
                $Uri = $COMReportsUri + "/" + $ReportID + "/data"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        else {
            $Uri = $COMReportsUri + "?filter=reportType eq 'CARBON_FOOTPRINT'&limit=10"
            
        }
     

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {        

            if (        $Co2Emissions `
                    -or $Co2EmissionsTotal `
                    -or $EnergyConsumption `
                    -or $EnergyConsumptionTotal `
                    -or $EnergyCost `
                    -or $EnergyCostTotal 
                     
            ) {
                $CollectionList = $CollectionList.data.series

            }


            if ($Co2Emissions) {

                if ($SerialNumber) {
                    $CollectionList = $CollectionList | Where-Object { ((($_.subject.id) -split "\+")[1]) -eq $SerialNumber } | ? { $_.seriesType -eq "CO2_EMISSIONS" }
                  
                }
                else {
                    # Exclude the first property that contains ALL emissions
                    $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "CO2_EMISSIONS" })[1..($CollectionList.count - 1)]
                }
                
                # Add serial number and region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  

                Foreach ($Item in $CollectionList) {
                    If ($Item.subject.id -match "\+") { 
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.subject.id.split('+')[-1] ) 
                    } 
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    

            }
            elseif ($Co2EmissionsTotal) {

                $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "CO2_EMISSIONS" })[0]

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityDataAllServers"    

            }  
            elseif ($EnergyConsumption) {

                if ($SerialNumber) {
                    $CollectionList = $CollectionList | Where-Object { ((($_.subject.id) -split "\+")[1]) -eq $SerialNumber } | Where-Object { $_.seriesType -eq "ENERGY_CONSUMPTION" }
                    
                }
                else {
                    # Exclude the first property that contains ALL energy consumption
                    $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_CONSUMPTION" })[1..($CollectionList.count - 1)]
                }
                
                # Add serial number and region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  

                Foreach ($Item in $CollectionList) {
                    If ($Item.subject.id -match "\+") { 
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.subject.id.split('+')[-1] ) 
                    } 
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    

            }
            elseif ($EnergyConsumptionTotal) {

                $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_CONSUMPTION" })[0]

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityDataAllServers"    

            }
            elseif ($EnergyCost) {

                if ($SerialNumber) {
                    $CollectionList = $CollectionList | Where-Object { ((($_.subject.id) -split "\+")[1]) -eq $SerialNumber } | Where-Object { $_.seriesType -eq "ENERGY_COST" }
                    
                }
                else {
                    # Exclude the first property that contains ALL energy cost
                    $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_COST" })[1..($CollectionList.count - 1)]
                }
                
                # Add serial number and region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region 
                
                Foreach ($Item in $CollectionList) {
                    If ($Item.subject.id -match "\+") { 
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.subject.id.split('+')[-1] ) 
                    } 
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityData"    

            }
            elseif ($EnergyCostTotal) {

                $CollectionList = ($CollectionList | Where-Object { $_.seriesType -eq "ENERGY_COST" })[0]

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region  
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports.SustainabilityDataAllServers"    

            }
            else {

                # Add region to object
                $CollectionList | Add-Member -type NoteProperty -name region -value $Region        

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Reports"    

            }
        
            $ReturnData = $ReturnData | Sort-Object { $_.subject.displayname }
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}

#EndRegion


#Region --- SCHEDULES ---

Function Get-HPECOMSchedule {
    <#
    .SYNOPSIS
    Retrieve the list of schedules.

    .DESCRIPTION
    This Cmdlet returns a collection of all schedules that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Optional parameter that can be used to specify the name of a schedule to display.

    .PARAMETER ID
    Optional parameter that can be used to specify the ID of a schedule to display.

    .PARAMETER History
    Optional switch parameter that can be used together with -Name to get all history of a schedule.

    .PARAMETER Limit 
    This parameter allows you to define the number of schedules to be displayed. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central 

    Return the last 50 schedules resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -name "Firmware update for group Prod"
    
    Return the schedule resource named "Firmware update for group Prod" located in the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -name "Firmware update for group Prod" -History
    
    Return the list of history entries of the schedule resource named "Firmware update for group Prod" located in the central EU region. 

    .INPUTS
        None. You cannot pipe objects to this cmdlet.
  
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'RegionOnly')]
    Param( 

        [Parameter(Mandatory)]
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        
        [Parameter(ParameterSetName = 'RegionOnly')]
        [Parameter(Mandatory, ParameterSetName = 'RegionWithName')]
        [Parameter(Mandatory, ParameterSetName = 'RegionWithNameHistory')]
        [String]$Name,
        
        [Parameter(ParameterSetName = 'RegionOnly')]
        [Parameter(Mandatory, ParameterSetName = 'RegionWithID')]
        [Parameter(Mandatory, ParameterSetName = 'RegionWithIDHistory')]
        [String]$ID,
        
        [Parameter(Mandatory, ParameterSetName = 'RegionWithNameHistory')]
        [Parameter(Mandatory, ParameterSetName = 'RegionWithIDHistory')]
        [Switch]$History,

        [Parameter (ParameterSetName = 'Limit')]
        [ValidateScript({ $_ -le 10000 })]
        [int]$Limit,
        
        [Switch]$WhatIf
       
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
      
        
        if ($Name) {       

            $Uri = $COMSchedulesUri + "?filter=name eq '$Name'"     
   
        }
        elseif ($ID) {
            $Uri = $COMSchedulesUri + "?filter=id eq '$ID'"     
            
        }
        elseif ($Limit) {

            $Uri = $COMSchedulesUri + "?limit=$Limit"
        }
        else {

            $Uri = $COMSchedulesUri 

            
        }

        if ($History) {

            $Uri = $COMSchedulesUri + "?filter=name eq '$Name'"     

            try {
                [Array]$SchedulesList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                $ScheduleID = $SchedulesList.id

                "[{0}] ID found for the schedule '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $ScheduleID | Write-Verbose

                if ($Null -eq $ScheduleID) { 
                    
                    "[{0}] Schedule name '{1}' cannot be found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    Return
                }
    
                $Uri = $COMSchedulesUri + "/" + $ScheduleID + "/history"
             
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {     

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            if ($History) {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Schedules.History"    
            
            }
            else {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Schedules"    
                $ReturnData = $ReturnData | Sort-Object name, purpose, nextStartAt
            }
    
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}



Function Remove-HPECOMSchedule {
    <#
    .SYNOPSIS
    Remove a schedule resource from a region.

    .DESCRIPTION
    This Cmdlet can be used to delete a schedule resource and its associated history in a region using its name property.     
        
    .PARAMETER Name 
    Name of the schedule resource to remove. 
    
    .PARAMETER Region 
    Name of the region where to remove a schedule resource. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMSchedule -Region eu-central -Name "ESXi_group_ServerFirmwareUpdate_Schedule_663933" 
    
    Remove the schedule named "ESXi_group_ServerFirmwareUpdate_Schedule_663933" from the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central -Name 'ESXi_group_ServerFirmwareUpdate_Schedule_663933' | Remove-HPECOMSchedule

    Remove schedule 'ESXi_group_ServerFirmwareUpdate_Schedule_663933' from the central EU region using 'Get-HPECOMSchedule' as a pipeline input. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central | Where-Object name -match "Inventory_Report_Schedule" | Remove-HPECOMSchedule 

    Remove all schedules with names that match 'Inventory_Report_Schedule' from the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central | Remove-HPECOMSchedule 

    Remove all schedules from the central EU region. 

    .INPUTS
    System.Collections.ArrayList
        List of schedule(s) from 'Get-HPECOMSchedule'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the schedule attempted to be removed
        * Region - Name of the region where the schedule is removed
        * Status - Status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

     
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveScheduleStatus = [System.Collections.ArrayList]::new()
        
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        try {
            $ScheduleResource = Get-HPECOMSchedule -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $ScheduleID = $ScheduleResource.id

        
        if (-not $ScheduleID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Schedule '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Schedule cannot be found in the Compute Ops Management instance!"
            }

        }
        else {
            
            $Uri = $COMSchedulesUri + "/" + $ScheduleID

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Schedule removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Schedule '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Schedule successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Schedule cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveScheduleStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveScheduleStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more schedules has failed!"


          
            }
            
            Return $RemoveScheduleStatus
        }


    }
}



Function Set-HPECOMSchedule {
    <#
    .SYNOPSIS
    Update a schedule resource in a region.

    .DESCRIPTION   
    This Cmdlet can be used to modify the basic settings of a schedule resource in a region. Basic settings include name, description, and schedule.
    To modify advanced settings, such as the schedule operations or the associated resource, it's necessary to remove the existing schedule (using 'Remove-HPECOMSchedule') and re-create it using 
    one of the Register cmdlets (such as 'Register-HPECOMGroupFirmwareUpdateSchedule', 'Register-HPECOMServerFirmwareUpdateSchedule', etc.).
        
    .PARAMETER Name 
    Name of the schedule to update. 

    .PARAMETER ID
    ID of the schedule to update.

    .PARAMETER Region 
    Name of the region where the schedule is located.

    .PARAMETER NewName 
    New name for the schedule.

    .PARAMETER NewScheduleTime  
    New time for the scheduled operation's execution.

    .PARAMETER NewInterval
    Specifies the new execution interval of a schedule in ISO 8601 format (e.g., P1D, P1W), useful for executing a recurring schedule. 
    The accepted formats include periods (P) and time (T) designations, referencing days, weeks, months, years, hours, minutes, and seconds.
    
    This parameter supports common ISO 8601 durations such as:
    - PT15M (15 Minutes)
    - PT1H (1 Hour)
    - P1D (1 Day)
    - P1W (1 Week)
    - P1M (1 Month)
    - P1Y (1 Year)
        
    .PARAMETER NewDescription 
    New description for the schedule.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSchedule -Region us-west -Name ServerFirmwareUpdate_Schedule -NewName CZ12312312_ServerFirmwareUpdate_Schedule 
   
    Change the name of the schedule named 'ServerFirmwareUpdate_Schedule' to 'CZ12312312_ServerFirmwareUpdate_Schedule' in the western US region.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewDescription "This is my new description"  

    Change the description of the schedule named 'ServerFirmwareUpdate_Schedule' to 'This is my new description' in the central EU region.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewScheduleTime (Get-Date).AddMonths(6)

    Change the schedule time of the schedule named 'ServerFirmwareUpdate_Schedule' to six months from the current date. 

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewInterval P2M 

    Change the interval time of the schedule named 'ServerFirmwareUpdate_Schedule' to an interval of two months.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewScheduleTime (Get-Date).AddMonths(6) -NewInterval P2M 

    Change both the schedule time and the interval time of the schedule named 'ServerFirmwareUpdate_Schedule' in the eu-central region. Set the schedule time to six months from the current date and the interval to recur every two months.

    .EXAMPLE
    Set-HPECOMSchedule -Region eu-central -Name ServerFirmwareUpdate_Schedule -NewName CZ12312312_ServerFirmwareUpdate_Schedule -NewScheduleTime ((Get-Date).AddMonths(6)) -NewDescription "My new description" 

    Change the name, the schedule time and description of the schedule named 'ServerFirmwareUpdate_Schedule' in the central EU region. 

    .EXAMPLE
    Get-HPECOMSchedule -Region eu-central | Set-HPECOMSchedule -NewScheduleTime  (Get-Date).AddDays(7)

    Change the schedule time of all schedules found in the central EU region to 7 days from the current date.

    .INPUTS
    System.Collections.ArrayList
        List of schedule(s) from 'Get-HPECOMSchedule'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the schedule attempted to be updated
        * Region - Name of the region where the schedule is updated
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Name')]
        [String]$Name,
                       
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'ID')]
        [String]$ID,

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,

        [ValidateScript({
                if ($_ -ge (Get-Date) -and $_ -le (Get-Date).AddYears(1)) {
                    $true
                }
                else {
                    throw "The ScheduleTime must be within one year from the current date."
                }
            })]
        [DateTime]$NewScheduleTime,   

        [ValidateScript({
                if ($_ -match '^P(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$') {
                    return $true
                }
                else {
                    throw "Invalid duration format. Please use an ISO 8601 period interval (e.g., P1D, P1W, P1M, P1Y, PT1H, PT15M)"
                }
            })]
        [String]$NewInterval, 

        [Parameter (ValueFromPipelineByPropertyName)] 
        [ValidateScript({ $_.Length -le 10000 })]
        [alias('description')]
        [String]$NewDescription,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetScheduleStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($Name) {

                $ParamUsed = $Name
                
                $SchedulesResources = Get-HPECOMSchedule -Region $Region -Name $Name
                
                if ($SchedulesResources.length -gt 1) {
                    
                    $ErrorMessage = "More than one schedule are using the name '{0}' in the region, !" -f $ParamUsed
                    $ErrorRecord = New-ErrorRecord MoreThanOneScheduleFoundInCOM InvalidOperation  -TargetObject 'Schedule' -Message $ErrorMessage -TargetType $ParamUsed.GetType().Name
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord )
                }
                else {

                    $ScheduleID = $SchedulesResources.id
                    
                }
            }
            else {
                
                $ParamUsed = $ID

                $SchedulesResources = Get-HPECOMSchedule -Region $Region 

                $ScheduleID = $SchedulesResources | Where-Object id -eq $ID

                
            }

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $ParamUsed
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        "[{0}] Schedule ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ScheduleID | Write-Verbose
       
        if (-not $ScheduleID) {

            # Must return a message if not found
            if ($WhatIf) {

                $ErrorMessage = "Schedule '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
                $ErrorRecord = New-ErrorRecord ScheduleNotFoundInCOM ObjectNotFound -TargetObject 'Schedule' -Message $ErrorMessage -TargetType $ParamUsed.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)   
              
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Schedule cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $_Schedule = Get-HPECOMSchedule -Region $Region -ID $ScheduleID
            
            $Uri = $COMSchedulesUri + "/" + $ScheduleID
            
            $Payload = @{}

            # Conditionally add properties
            if ($NewName) {
                $Payload.name = $NewName
            }
            else {
                $Payload.name = $Name
                
            }

            if (-not $PSBoundParameters.ContainsKey('NewDescription')) {
	
                if ($_Schedule.description) {
                    $Payload.description = $_Schedule.description
                }
                else {
                    $Payload.description = $Null
                }
            }
            else {
                $Payload.description = $NewDescription
            }
   

            if ($NewScheduleTime -and -not $NewInterval) {
                $Payload.schedule = @{
                    startAt  = $NewScheduleTime
                    interval = $_Schedule.schedule.interval
                }
            }
            elseif ($NewScheduleTime -and $NewInterval) {
                $Payload.schedule = @{
                    startAt  = $NewScheduleTime
                    interval = $NewInterval
                }
            }
            elseif (-not $NewScheduleTime -and $NewInterval) {
                $Payload.schedule = @{
                    startAt  = $_Schedule.schedule.startAt
                    interval = $NewInterval
                }
            }
            else {
                $Payload.schedule = @{
                    startAt  = $_Schedule.schedule.startAt
                    interval = $_Schedule.schedule.interval
                }
            }

            $Payload.purpose = $_Schedule.purpose
            $Payload.associatedResourceUri = $_Schedule.associatedResourceUri

            # Convert the hashtable to JSON
            $jsonPayload = $Payload | ConvertTo-Json


            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $jsonPayload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Schedule update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Schedule '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Schedule successfully updated in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Schedule cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }

        [void] $SetScheduleStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($SetScheduleStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Schedule failed the update attempt!"
          
            }
            
            Return $SetScheduleStatus
        }


    }
}

#EndRegion


#Region --- SERVER LOCATIONS ---

# Get-HPECOMServerLocation is an alias of Get-HPEGLLocation
Set-Alias -Name Get-HPECOMServerLocation -Value Get-HPEGLLocation


Function Set-HPECOMOneViewServerLocation {
    <#
    .SYNOPSIS
    Configure the server location for HPE OneView managed servers.

    .DESCRIPTION
    This Cmdlet assigns an a location that exists in HPE GreenLake to HPE OneView managed servers. 
    
    Assigning a location enhances the data visible in Compute Ops Management sustainability reports and the HPE Sustainability Insight Center.

    For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'.
    
    .PARAMETER Region 
    Specifies the region.

    .PARAMETER LocationName
    Specifies the name of the location to assign to the server.
    
    .PARAMETER ServerName
    Specifies the name of the server.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMOneViewServerLocation -Region eu-central -LocationName "Mougins" -ServerSerialNumber CN12312312

    Assign the location named 'Mougins' to the server with the serial number 'CN12312312' in the central EU region.

    .EXAMPLE
    Set-HPECOMOneViewServerLocation -Region eu-central -LocationName "Mougins" -ServerName RHEL-1
    
    Assign the location named 'Mougins' to the server named 'RHEL-1' in the central EU region.

    .EXAMPLE
    'CN12312312', 'CN12312313', 'CN12312314' |  Set-HPECOMOneViewServerLocation -Region eu-central  -LocationName "Mougins" 

    Assign the location named 'Mougins' to the servers with the serial numbers 'CN12312312', 'CN12312313', and 'CN12312314' in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType OneView | Set-HPECOMOneViewServerLocation -LocationName "Mougins" 
    
    Assign the location named 'Mougins' to all HPE OneView managed servers in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Model 'Synergy 480 Gen11' | Set-HPECOMOneViewServerLocation -LocationName "Mougins"

    Assign the location named 'Mougins' to all HPE OneView managed servers with the model 'Synergy 480 Gen11' in the central EU region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.    
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Server - Serial number or name of the server
        * Region - Name of the region where the server is located
        * Location - Name of the location assigned to the server
        * Status - Status of the assignment attempt (Failed for http error return; Complete if assignment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [String]$LocationName,

        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$ServerName,
    
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Alias('serialNumber')]
        [String]$ServerSerialNumber,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

        try {
            $Location = Get-HPEGLLocation -Name $LocationName
            $Uri = $COMServerLocationsUri + "/" + $Location.ID + "/servers"
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ( -not $Location) {

            $ErrorMessage = "Location '{0}' cannot be found in the Compute Ops Management instance!" -f $LocationName

            throw $ErrorMessage

        }

        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        # Build object for the output
        $objStatus = [pscustomobject]@{

            Server    = if ($ServerSerialNumber) { $ServerSerialNumber } else { $ServerName }
            Region    = $Region     
            Location  = $LocationName                       
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        [void] $ObjectStatusList.add($objStatus)
    
    }
    
    End {

        try {
            
            $Servers = Get-HPECOMServer -Region $Region 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of servers to add to location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose


        foreach ($Object in $ObjectStatusList) {

            $Server = $Servers | Where-Object serialNumber -eq $Object.server
            
            if (-not $Server) {
                $Server = $Servers | Where-Object serverName -eq $Object.server
            }
            
            #  Condition when serverName is used and when multiple servers use the same serverName 
            if ( $server -and $Server.id.count -gt 1) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource."

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource." -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ( $server -and $Server.connectionType -ne "OneView") {

                # Must return a message if device not OneView server
                $Object.Status = "Failed"
                $Object.Details = "Server is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $Server) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server cannot be found in the Compute Ops Management instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            else {       
            
                $ServerLocation = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $server.serialnumber -ShowLocation

                if ($ServerLocation) {   
                    # Must return a message if server already member of a location
                    $Object.Status = "Warning"
                    $Object.Details = "Server is already assigned to the '$($ServerLocation.name)' location!"

                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}' is already assigned to the '{1}' location!" -f $Object.server, $ServerLocation.name
                        Write-warning $ErrorMessage
                        continue
                    }

                }
                else {

                    # Build DeviceInfo object for tracking
                    $DeviceInfo = [PSCustomObject]@{
                        serialnumber = $server.serialNumber
                        servername   = $server.serverName
                        
                    }
                    
                    Write-Verbose "Server serialNumber: $($server.serialNumber)"
                    Write-Verbose "Server ID: $($server.id)"
                    
                    # Building the list of devices object for payload
                    [void]$DevicesList.Add($($Server.id))
    
                    # Building the list of devices object for tracking
                    [void]$DevicesTrackingList.Add($DeviceInfo)

                }
            }
        }


        if ($DevicesList) {

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                servers = $DevicesList
            } 

        
            # Add Devices to location  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully assigned to server"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be assigned to server!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf ) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more server locations failed to assign successfully!"
                
          
            }
            
            Return $ObjectStatusList
        
        }

    }
}



Function Remove-HPECOMOneViewServerLocation {
    <#
    .SYNOPSIS
    Remove location of one or more servers managed by HPE OneView.

    .DESCRIPTION
    This Cmdlet unassigns an HPE GreenLake location from HPE OneView managed server(s). 

    For non-HPE OneView servers, use `Remove-HPEGLDeviceLocation`.
    
    .PARAMETER Region 
    Specifies the region.
    
    .PARAMETER ServerName
    Specifies the name of the server.
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    Remove-HPECOMOneViewServerLocation -Region eu-central -ServerSerialNumber CN12312312
    
    Remove the location of the server with the serial number 'CN12312312' in the central EU region.

    .EXAMPLE
    Remove-HPECOMOneViewServerLocation -Region eu-central -ServerName RHEL-1

    Remove the location of the server named 'RHEL-1' in the central EU region.

    .EXAMPLE
    'CN12312312', 'CN12312313', 'CN12312314' |  Remove-HPECOMOneViewServerLocation -Region eu-central

    Remove the location of the servers with the serial numbers 'CN12312312', 'CN12312313', and 'CN12312314' in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectionType OneView | Remove-HPECOMOneViewServerLocation

    Remove the location of all HPE OneView managed servers in the central EU region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Model 'Synergy 480 Gen11' | Remove-HPECOMOneViewServerLocation

    Remove the location of all HPE OneView managed servers with the model 'Synergy 480 Gen11' in the central EU region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Server - Serial number or name of the server
        * Region - Name of the region where the server is located
        * Location - Name of the location assigned to the server
        * Status - Status of the assignment attempt (Failed for http error return; Complete if assignment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

   
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$ServerName,
    
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [Alias('serialNumber')]
        [String]$ServerSerialNumber,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()
        $DevicesTrackingList = [System.Collections.ArrayList]::new()

                
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        # Build object for the output
        $objStatus = [pscustomobject]@{

            Server    = if ($ServerSerialNumber) { $ServerSerialNumber } else { $ServerName }
            Region    = $Region     
            Location  = $Null                       
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        [void] $ObjectStatusList.add($objStatus)
    
    }
    
    End {

        try {
            
            $Servers = Get-HPECOMServer -Region $Region 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of servers where to remove the location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.SerialNumber | out-string) | Write-Verbose


        foreach ($Object in $ObjectStatusList) {

            $Server = $Servers | Where-Object serialNumber -eq $Object.server
            
            if (-not $Server) {
                $Server = $Servers | Where-Object serverName -eq $Object.server
            }
            

            #  Condition when serverName is used and when multiple servers use the same serverName 
            if ( $server -and $Server.id.count -gt 1) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource."

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' was found multiple times in the Compute Ops Management instance! Please refine your query to return a single server resource." -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }
            }
            elseif ( $server -and $Server.connectionType -ne "OneView") {

                # Must return a message if device not OneView server
                $Object.Status = "Failed"
                $Object.Details = "Server is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' is not an HPE OneView managed server! For non-HPE OneView servers, use 'Set-HPEGLDeviceLocation'" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $Server) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Server cannot be found in the Compute Ops Management instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $Object.server
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            else {       
            
                $ServerLocation = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $server.serialnumber -ShowLocation

                if (-not $ServerLocation) {   
                    # Must return a message if server already member of the location
                    $Object.Status = "Warning"
                    $Object.Details = "Server is not assigned to a location!"

                    if ($WhatIf) {
                        $ErrorMessage = "Server '{0}' is not assigned to a location" -f $Object.server
                        Write-warning $ErrorMessage
                        continue
                    }

                }
                else {

                    $Object.Location = $ServerLocation.name 

                    # Build DeviceInfo object for tracking
                    $DeviceInfo = [PSCustomObject]@{
                        serialnumber = $server.serialNumber
                        servername   = $server.serverName
                        
                    }
                    
                    Write-Verbose "Server serialNumber: $($server.serialNumber)"
                    Write-Verbose "Server ID: $($server.id)"
                    
                    # Building the list of devices object for payload
                    [void]$DevicesList.Add($($Server.id))
    
                    # Building the list of devices object for tracking
                    [void]$DevicesTrackingList.Add($DeviceInfo)

                }
            }
        }


        if ($DevicesList) {

            "[{0}] List of IDs to add to query: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($DevicesList | out-string) | Write-Verbose


            # Build the query string
            $queryString = ($DevicesList | ForEach-Object { "id=$_" }) -join "&"
            $queryString = "?$queryString"

            # ID uses a '+' sign, it needs to be replaced with '%2B' to avoid 404 resource not found error 
            # (URL encoding not working: $encodedQueryString = [System.Web.HttpUtility]::UrlEncode($queryString) )
            $encodedQueryString = $queryString.replace('+', '%2B')

            $Uri = $COMServerLocationsUri + "/" + $ServerLocation.locationId + "/servers" + $encodedQueryString
       
            # Remove Devices to location  
            try {

                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -Body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {
                   
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully unassigned from server"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesTrackingList | Where-Object { $_.serialnumber -eq $Object.Server -or $_.servername -eq $Object.Server }

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be unassigned from server!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf ) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more server locations failed to unassign successfully!"

          
            }
            
            Return $ObjectStatusList
        
        }

    }
}




#EndRegion


#Region --- SETTINGS ---

Function Get-HPECOMSetting {
    <#
    .SYNOPSIS
    Retrieve the list of settings.

    .DESCRIPTION
    This Cmdlet returns a collection of settings that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name 
    Optional parameter that can be used to specify the name of a setting to display.

    .PARAMETER Category 
    Optional parameter that can be used to specify a category of server settings to display.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMSetting -Region us-west

    Return all server settings resources located in the western US region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name 'DLV24-ESX8.0-Installation'
   
    Return the server settings resource named 'DLV24-ESX8.0-Installation' located in the central EU region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category Os
   
    Return the server settings resources for the OS category located in the Central EU region.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

   #>
    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$Name,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $categories = @('Bios', 'Os', 'Firmware', 'ExternalStorage', 'IloSettings', 'Storage')
                
                $filteredCategories = $categories | Where-Object { $_ -like "$wordToComplete*" }

                return $filteredCategories | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }

            })]
        [ValidateScript({
                $validOptions = @('Bios', 'Os', 'Firmware', 'ExternalStorage', 'IloSettings', 'Storage')
                
                if ($validOptions -contains $_) {
                    $True
                }
                else {
                    throw "'$_' is not a valid option."
                }
                
            })]    
        [String]$Category,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command
  
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $_bundles = Get-HPECOMFirmwareBundle -Region $Region 

    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
           
        if ($Name) {
            $Uri = $COMSettingsUri + "?filter=name eq '$name'"

        }
        elseif ($Category) {

            switch ($Category) {
                Bios { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'BIOS'"
                }
                Os { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'OS'"
                }                
                Firmware { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'FIRMWARE'"
                }                
                ExternalStorage { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'EXTERNAL_STORAGE'"
                }                
                IloSettings { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'ILO_SETTINGS'"
                }                
                Storage { 
                    $Uri = $COMSettingsUri + "?filter=category eq 'STORAGE'"
                }

            }
        }
        else {
            $Uri = $COMSettingsUri   

        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction Stop
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            
            if ($Name) {
                $CollectionList = $CollectionList | Where-Object name -eq $Name
            }

            $allFirmware = $allbios = $allstorage = $allos = $allIlosettings = $allExternalStorage = $true

            foreach ($setting in $CollectionList) {
                
                $_settings = $setting.settings

                # When firmware category
                if ($_settings.DEFAULT) {
                    # if ($setting.category -eq "FIRMWARE") {

                    foreach ($Item in $_settings.DEFAULT) {
                        
                        foreach ($property in $item.PSObject.Properties) {

                            $setting | Add-Member -type NoteProperty -name $property.Name -value $property.Value

                        } 
                    }                                 
                
                }
                # When other categories
                else {

                    $_Gens = ($setting.settings | gm -MemberType NoteProperty).name  # it's where GEN10, GEN11 are usually provided for firmware server settings

                    foreach ($Gen in $_Gens) {

                        $_settings = $setting.settings.$($Gen)
                        
                        foreach ($property in $setting.settings.$($Gen)) {
                                
                            $_bundleName = $_bundles | Where-Object id -eq $property.id | ForEach-Object displayName

                            $_propertyName = $Gen + "FirmwareBundle"

                            $setting | Add-Member -type NoteProperty -name $_propertyName -value $_bundleName
                                
                        } 
                    }                   
                }   
                
                # Detect object type for object repackage 
                if ("FIRMWARE" -ne $setting.Category) {
                    $allFirmware = $false
                }
                
                if ("BIOS" -ne $setting.Category) {
                    $allbios = $false                   
                }
                
                if ("STORAGE" -ne $setting.Category) {
                    $allstorage = $false
                }

                if ("OS" -ne $setting.Category) {
                    $allos = $false
                }

                if ("ILO_SETTINGS" -ne $setting.Category) {
                    $allIlosettings = $false
                }

                if ("EXTERNAL_STORAGE" -ne $setting.Category) {
                    $allExternalStorage = $false
                }
            }         


            if ($allstorage) { 
                    
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.STORAGE"   
            } 
            elseif ($allos) {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.OS"   
            }
            elseif ($allExternalStorage) {
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.EXTERNAL_STORAGE"   
            }
            elseif ($allIlosettings) {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.ILO_SETTINGS"   
            }
            elseif ($allbios) {
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.BIOS"   
            }   
            elseif ($allFirmware) {
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings.FIRMWARE"    
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Settings"    
                
            }

            $ReturnData = $ReturnData | Sort-Object { $_.name }
        
            return $ReturnData 
                
        }
        else {

            return
                
        }     

    
    }
}


Function New-HPECOMSettingServerBios {
    <#
    .SYNOPSIS
    Configure a bios server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new bios server setting set either with a workload profile or a customized one with provided parameters.
    Bios settings enable you to apply a consistent bios configuration to servers in a group.

    For a detailed description of all iLO BIOS attributes parameters:
    - For iLO6, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo6/ilo6_159/ilo6_bios_resourcedefns159/
    - For iLO5, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo5/ilo5_304/ilo5_bios_resourcedefns304/

    Note: If a parameter is incompatible with your iLO generation or server platform, 'Invoke-HPECOMGroupBiosConfiguration' will return an error message stating "Apply BIOS settings failed".
          To get more detailed information about the parameters that caused these errors, access the iLO Redfish API using a GET request to /redfish/v1/Systems/1/Bios/ and inspect the @Redfish.Settings.Messages property.
    
    Note: If one or several unsupported parameters are selected, the other BIOS settings will still be applied successfully. Unsupported parameters will be ignored without affecting the application of the other settings.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Specifies the name of the bios server setting to set.

    .PARAMETER Description
    Specifies a description of the bios server setting.

    .PARAMETER WorkloadProfileName
    Name of a pre-defined workload profile:
        - Decision Support
        - General Peak Frequency Compute
        - General Power Efficient Compute
        - General Throughput Compute
        - Graphic Processing
        - High Performance Compute (HPC)
        - I/O Throughput
        - Low Latency
        - Mission Critical
        - My-Bios-For-AI
        - Transactional Application Processing
        - Virtual Radio Access Network (vRAN)
        - Virtualization - Max Performance
        - Virtualization - Power Efficient

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance"

    This example shows how to create a new BIOS setting named "Custom-Bios-For-ESX" in the eu-central region. It sets a description and uses the "Virtualization - Max Performance" workload profile.

    .EXAMPLE
    New-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance" `
      -AdminName Albert -AdminEmail "alb@domain.com" -AsrTimeoutMinutes Timeout10 -AutoPowerOn AlwaysPowerOn -CoreBoosting:$true -F11BootMenu:$False -ThermalConfig OptimalCooling 

    This example sets a customized BIOS configuration for "Custom-Bios-For-ESX" in the eu-central region. In addition to the settings from Example 1, it includes admin details (AdminName and AdminEmail), various BIOS feature configurations such as ASR timeout, auto power on, core boosting, F11 boot menu, and thermal configuration for optimal cooling.

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the bios server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ilo6')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Decision Support', 'General Peak Frequency Compute', 'General Power Efficient Compute', 'General Throughput Compute', 'Graphic Processing', 'High Performance Compute (HPC)', 'I/O Throughput', 'Low Latency', 'Mission Critical', 'Transactional Application Processing', 'Virtual Radio Access Network (vRAN)', 'Virtualization - Max Performance', 'Virtualization - Power Efficient')
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Decision Support', 'General Peak Frequency Compute', 'General Power Efficient Compute', 'General Throughput Compute', 'Graphic Processing', 'High Performance Compute (HPC)', 'I/O Throughput', 'Low Latency', 'Mission Critical', 'Transactional Application Processing', 'Virtual Radio Access Network (vRAN)', 'Virtualization - Max Performance', 'Virtualization - Power Efficient')]

        [String]$WorkloadProfileName,
        
        [bool]$AccessControlService,
        [bool]$AcpiHpet,
        [bool]$AcpiRootBridgePxm,
        [bool]$AcpiSlit,
        [bool]$AdjSecPrefetch,
        [string]$AdminEmail,
        [String]$AdminName,
        [string]$AdminOtherInfo,
        # Name of the server administrator
        [string]$AdminPhone,

        [bool]$AdvCrashDumpMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')]
        [String]$AdvancedMemProtection,

        [bool]$AllowLoginWithIlo,
        [bool]$Amd5LevelPage,
        [bool]$AmdCdma,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('800us', '18us')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('800us', '18us')]
        [String]$AmdCstC2Latency,

        [bool]$AmdDmaRemapping,
        [bool]$AmdL1Prefetcher,
        [bool]$AmdL2Prefetcher,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [String]$AmdMemPStates,
        
        [bool]$AmdMemoryBurstRefresh,
        [bool]$AmdPeriodicDirectoryRinse,
        [bool]$AmdSecureMemoryEncryption,
        [bool]$AmdSecureNestedPaging,
        [bool]$AmdVirtualDrtmDevice,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32' )
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32')]
        [String]$AmdXGMILinkSpeed,

        [bool]$ApplicationPowerBoost,

        # Use this option to configure the Automatic Server Recovery option, which enables the system to automatically reboot if the server locks up.
        [bool]$AsrStatus,

        # When Automatic Server Recovery is enabled, you can use this option to set the time to wait before rebooting the server in the event of an operating system crash or server lockup.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')]
        [string]$AsrTimeoutMinutes,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Locked', 'Unlocked')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Locked', 'Unlocked')]
        [String]$AssetTagProtection,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')]
        [String]$AutoPowerOn,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')]
        [string]$BootOrderPolicy,

        [bool]$ChannelInterleaving,
        [bool]$CollabPowerControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('LomsAndSlots', 'LomsOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('LomsAndSlots', 'LomsOnly', 'Disabled')]
        [string]$ConsistentDevNaming,

        [bool]$CoreBoosting,

        # Enter a message to be displayed on POST screen during system startup. This feature limits POST screen messaging to 62 characters, special characters are also accepted.
        [ValidateScript({
                if ($_.Length -le 62) {
                    $True
                }
                if ($_ -match '^[a-zA-Z0-9]+$') {
                    $true
                } 
                elseif ($_.Length -gt 62) {
                    throw "The POST screen message cannot have more than 62 characters!"

                }
                elseif ($_ -notmatch '^[a-zA-Z0-9]+$') {
                    throw "The POST screen message cannot contain special characters!"
                }
            })]
        [string]$CustomPostMessage,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Manual')]
        [string]$CustomPstate0,
            
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceEnabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'ForceEnabled', 'Disabled')]
        [string]$DataFabricCStateEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')]
        [string]$DaylightSavingsTime,
         
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DeterminismCtrlAuto', 'DeterminismCtrlManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DeterminismCtrlAuto', 'DeterminismCtrlManual')]            
        [string]$DeterminismControl,        

        [bool]$DcuIpPrefetcher,
        [bool]$DcuStreamPrefetcher,
        [bool]$Dhcpv4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]
        [string]$DirectToUpi,

        [bool]$DramControllerPowerDown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]            
        [string]$DynamicPowerCapping,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AspmL1Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AspmL1Enabled', 'Disabled')]            
        [string]$EmbNicAspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]            
        [string]$EmbNicEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1')]
        [string]$EmbNicLinkSpeed,
        
        [bool]$EmbNicPCIeOptionROM,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$EmbSas1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AllTargets', 'TwentyFourTargets', 'NoTargets')]
        [string]$EmbSas1Boot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSas1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$EmbSas1LinkSpeed,
        
        [bool]$EmbSas1PcieOptionROM,
        [bool]$EmbSata1Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata1Enable,
        
        [bool]$EmbSata1PCIeOptionROM,
        [bool]$EmbSata2Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata2Enable,
        
        [bool]$EmbSata2PCIeOptionROM,

        [bool]$EmbSata3Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata3Enable,
        
        [bool]$EmbSata3PCIeOptionROM,
        [bool]$EmbSata4Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata4Enable,
        
        [bool]$EmbSata4PCIeOptionROM,
               
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AlwaysDisabled', 'AlwaysEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AlwaysDisabled', 'AlwaysEnabled')]
        [string]$EmbVideoConnection,
        
        [bool]$EmbeddedDiagnostics,
        [bool]$EmbeddedIpxe,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')]
        [string]$EmbeddedSata,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$EmbeddedSerialPort,
        
        [bool]$EmbeddedUefiShell,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Physical', 'Virtual')]
        [string]$EmsConsole,
        
        # This attribute is a problem because in iLO5, value is an integer
        [Parameter (ParameterSetName = 'ilo6')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')]
        [string]$EnabledCoresPerProcIlo6,

        [Parameter (ParameterSetName = 'ilo5')]
        [int]$EnabledCoresPerProcIlo5,

        [bool]$EnergyEfficientTurbo,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')]
        [string]$EnergyPerfBias,

        [bool]$EnhancedProcPerf,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ASHRAE3', 'ASHRAE4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ASHRAE3', 'ASHRAE4')]
        [string]$ExtendedAmbientTemp,

        [bool]$ExtendedMemTest,
        [bool]$F11BootMenu,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'CardConfig')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'CardConfig')]
        [string]$FCScanPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Shutdown', 'Allow')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Shutdown', 'Allow')]
        [string]$FanFailPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EnableMessaging', 'DisableMessaging')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EnableMessaging', 'DisableMessaging')]
        [string]$FanInstallReq,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$FlexLom1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$FlexLom1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$FlexLom1LinkSpeed,

        [bool]$FlexLom1PCIeOptionROM,
         

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('12Hours', '24Hours')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('12Hours', '24Hours')]
        [string]$HourFormat,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')]
        [string]$HttpSupport,

        [bool]$HwPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('P0', 'P1', 'P2', 'P3', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('P0', 'P1', 'P2', 'P3', 'Auto')]
        [string]$InfinityFabricPstate,
        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DmiGen1', 'DmiGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DmiGen1', 'DmiGen2')]            
        [string]$IntelDmiLinkFreq,
        
        [bool]$IntelNicDmaChannels,
        [bool]$IntelPerfMonitoring,
        [bool]$IntelProcVtd,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Base', 'Config1', 'Config2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Base', 'Config1', 'Config2')]
        [string]$IntelSpeedSelect,

        [bool]$IntelTxt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MinUpiSpeed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MinUpiSpeed')]
        [string]$IntelUpiFreq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'SingleLink')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'SingleLink')]
        [string]$IntelUpiLinkEn,

        [bool]$IntelUpiPowerManagement,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('VmdDirectAssignEnabledAll', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('VmdDirectAssignEnabledAll', 'Disabled')]
        [string]$IntelVmdDirectAssign,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')]
        [string]$IntelVmdSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'Standard', 'Premium')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'Standard', 'Premium')]
        [string]$IntelVrocSupport,
                
        [bool]$IntelligentProvisioning,
        [bool]$InternalSDCardSlot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PowerCycle', 'PowerDown', 'WarmBoot')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PowerCycle', 'PowerDown', 'WarmBoot')]
        [string]$IpmiWatchdogTimerAction,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')]
        [string]$IpmiWatchdogTimerStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')]
        [string]$IpmiWatchdogTimerTimeout,
        
        [string]$Ipv4Address,
        [string]$Ipv4Gateway,
        [string]$Ipv4PrimaryDNS,
        [string]$Ipv4SubnetMask,
        [string]$Ipv6Address,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Automatic', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Automatic', 'Manual')]
        [string]$Ipv6ConfigPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DuidLlt', 'DUID-LLT')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DuidLlt', 'DUID-LLT')]
        [string]$Ipv6Duid,

        [string]$Ipv6Gateway,
        [string]$Ipv6PrimaryDNS,
        [string]$Ipv6SecondaryDNS,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$IpxeAutoStartScriptLocation,
        
        
        [bool]$IpxeBootOrder,
        [bool]$IpxeScriptAutoStart,
        [bool]$IpxeScriptVerification,
        [string]$IpxeStartupUrl,
        [bool]$LastLevelCacheAsNUMANode,
        

        [bool]$LLCDeadLineAllocation,
        [bool]$LlcPrefetch,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Low', 'Medium', 'High', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Low', 'Medium', 'High', 'Disabled')]
        [string]$LocalRemoteThreshold,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')]
        [string]$MaxMemBusFreqMHz,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')]
        [string]$MaxPcieSpeed,

        [bool]$MemClearWarmReset,
        [bool]$MemFastTraining,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')]
        [string]$MemMirrorMode,
        
        [bool]$MemPatrolScrubbing,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Refreshx1', 'Refreshx2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Refreshx1', 'Refreshx2')]
        [string]$MemRefreshRate,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$MemoryControllerInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'AllMemory')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'AllMemory')]
        [string]$MemoryRemap,

        [bool]$MicrosoftSecuredCoreSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6Retention', 'C6NonRetention', 'NoState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6Retention', 'C6NonRetention', 'NoState')]
        [string]$MinProcIdlePkgState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6', 'C1E', 'NoCStates')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6', 'C1E', 'NoCStates')]
        [string]$MinProcIdlePower,

        [int]$MinimumSevAsid,

        [bool]$MixedPowerSupplyReporting,
        [bool]$NetworkBootRetry,
        [int]$NetworkBootRetryCount,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot5,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot6,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot7,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot8,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot9,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot10,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot11,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot12,

        [bool]$NodeInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Flat', 'Clustered')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Flat', 'Clustered')]
        [string]$NumaGroupSizeOpt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')]
        [string]$NumaMemoryDomainsPerSocket,
        
        [bool]$NvDimmNMemFunctionality,
        [bool]$NvDimmNMemInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')]
        [string]$NvDimmNSanitizePolicy,

        [bool]$NvdimmLabelSupport,
        [bool]$NvmeOptionRom,
        [bool]$Ocp1AuxiliaryPower,
        [bool]$Ocp2AuxiliaryPower,
        [bool]$OmitBootDeviceEvent,
        [bool]$OpportunisticSelfRefresh,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Manual')]
        [string]$PackagePowerLimitControlMode,

        [int]$PackagePowerLimitValue,
        [int]$PatrolScrubDuration,

        [bool]$PciPeerToPeerSerialization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Medium', 'High')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Medium', 'High')]
        [string]$PciResourcePadding,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot20Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot20Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot20Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot20LinkSpeed,

        [bool]$PciSlot20OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot19Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot19Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot19Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot19LinkSpeed,

        [bool]$PciSlot19OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot18Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot18Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot18Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot18LinkSpeed,

        [bool]$PciSlot18OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot17Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot17Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot17Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot17LinkSpeed,

        [bool]$PciSlot17OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot16Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot16Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot16Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot16LinkSpeed,

        [bool]$PciSlot16OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot15Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot15Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot15Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot15LinkSpeed,

        [bool]$PciSlot15OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot14Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot14Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot14Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot14LinkSpeed,

        [bool]$PciSlot14OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot13Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot13Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot13Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot13LinkSpeed,

        [bool]$PciSlot13OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot12Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot12Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot12Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot12LinkSpeed,

        [bool]$PciSlot12OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot11Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot11Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot11Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot11LinkSpeed,

        [bool]$PciSlot11OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot10Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot10Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot10Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot10LinkSpeed,

        [bool]$PciSlot10OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot9Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot9Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot9Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot9LinkSpeed,

        [bool]$PciSlot9OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot8Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot8Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot8Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot8LinkSpeed,

        [bool]$PciSlot8OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot7Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot7Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot7Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot7LinkSpeed,

        [bool]$PciSlot7OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot6Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot6Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot6Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot6LinkSpeed,

        [bool]$PciSlot6OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot5Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot5Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot5Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot5LinkSpeed,

        [bool]$PciSlot5OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot4Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot4Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot4Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot4LinkSpeed,

        [bool]$PciSlot4OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot3Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot3Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot3Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot3LinkSpeed,

        [bool]$PciSlot3OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot2Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot2Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot2Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot2LinkSpeed,

        [bool]$PciSlot2OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot1Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot1LinkSpeed,
        
        [bool]$PciSlot1OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerformanceDeterministic', 'PowerDeterministic')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerformanceDeterministic', 'PowerDeterministic')]
        [string]$PerformanceDeterminism,
        
        [bool]$PersistentMemAddressRangeScrub,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')]
        [string]$PersistentMemBackupPowerPolicy,

        [bool]$PersistentMemScanMem,
        [bool]$PlatformCertificate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FirmwareFirst', 'OSFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('FirmwareFirst', 'OSFirst')]
        [string]$PlatformRASPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PostAsrOff', 'PostAsrOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PostAsrOff', 'PostAsrOn')]
        [string]$PostAsr,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')]
        [string]$PostAsrDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Serial', 'All')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Serial', 'All')]
        [string]$PostBootProgress,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')]
        [string]$PostDiscoveryMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delayed20Sec', 'Delayed2Sec', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Delayed20Sec', 'Delayed2Sec', 'Disabled')]
        [string]$PostF1Prompt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('QuietMode', 'VerboseMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('QuietMode', 'VerboseMode')]
        [string]$PostScreenMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DisplayAll', 'DisplayEmbeddedOnly')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DisplayAll', 'DisplayEmbeddedOnly')]
        [string]$PostVideoSupport,
        
        [bool]$PowerButton,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')]
        [string]$PowerOnDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')]
        [string]$PowerRegulator,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                        'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                        'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                        'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                        'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort2', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')]
        [string]$PreBootNetwork,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'IPv4', 'IPv6')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'IPv4', 'IPv6')]
        [string]$PrebootNetworkEnvPolicy,
        
        [string]$PrebootNetworkProxy,
        [bool]$ProcAes,
        [bool]$ProcAMDBoost,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')]
        [string]$ProcAMDBoostControl,
        
        [int]$ProcAmdFmax,
        [bool]$ProcAmdIoVt,
        [bool]$ProcHyperthreading,
        [bool]$ProcSMT,
        [bool]$ProcTurbo,
        [bool]$ProcVirtualization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Enabled', 'ForceEnabled', 'Disabled', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Enabled', 'ForceEnabled', 'Disabled', 'Auto')]
        [string]$ProcX2Apic,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Level1', 'Level2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Level1', 'Level2')]
        [string]$ProcessorConfigTDPLevel,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Auto-tuned', 'Manual-tuned')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Auto-tuned', 'Manual-tuned')]
        [string]$ProcessorJitterControl,
        
        [int]$ProcessorJitterControlFrequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')]
        [string]$ProcessorJitterControlOptimization,

        [string]$Pstate0Frequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupply,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplyGpuDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplySystemDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')]
        [string]$RemovableFlashBootSeq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CurrentRom', 'BackupRom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CurrentRom', 'BackupRom')]
        [string]$RomSelection,

        [bool]$SanitizeAllNvDimmN,
        [bool]$SataSanitize,
        [bool]$SataSecureErase,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Ghesv1Support', 'Ghesv2Support')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Ghesv1Support', 'Ghesv2Support')]
        [string]$SciRasSupport,

        [bool]$SecStartBackupImage,
        [bool]$SecureBootStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')]
        [string]$SerialConsoleBaudRate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')]
        [string]$SerialConsoleEmulation,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'Physical', 'Virtual')]
        [string]$SerialConsolePort,
        
        [string]$ServerAssetTag,
        [bool]$ServerConfigLockStatus,
        [string]$ServerOtherInfo,
        [string]$ServerPrimaryOs,
        [string]$ServiceEmail,
        [string]$ServiceName,
        [string]$ServiceOtherInfo,
        [string]$ServicePhone,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('GUI', 'Text', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('GUI', 'Text', 'Auto')]
        [string]$SetupBrowserSelection,     

        [bool]$Slot1MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot4,

        [bool]$Slot2MctpBroadcastSupport,        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot4,

        [bool]$Slot3MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot4,

        [bool]$Slot4MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot4,

        [bool]$Slot5MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot4,

        [bool]$Slot6MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot4,
 
        [bool]$Slot7MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot4,

        [bool]$Slot8MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot4,
            
        [bool]$Slot9MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot4,

        [bool]$Slot10MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]    
        [string]$Slot10NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
  
        [string]$Slot10NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]     
        [string]$Slot10NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]      
        [string]$Slot10NicBoot4,

        [bool]$Slot11MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot4,


        [bool]$Slot12MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot4,


        [bool]$Slot13MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot4,


        [bool]$Slot14MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot4,


        [bool]$Slot15MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot4,


        [bool]$Slot16MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot4,

        [bool]$Slot17MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot4,

        [bool]$Slot18MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot4,

        [bool]$Slot19MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot4,

        [bool]$Slot20MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot1StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot2StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot3StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot4StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot5StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot6StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot7StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot8StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot9StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot10StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot11StorageBoot,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot12StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot13StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot14StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot15StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot16StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot17StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot18StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot19StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot20StorageBoot,

        [bool]$SpeculativeLockScheduling,
        [bool]$Sriov,


        [bool]$StaleAtoS,
        # When enabled, Sub-NUMA Clustering divides the processor's cores, cache, and memory into multiple NUMA domains. Enabling this feature can increase performance for workloads that are NUMA aware and optimized. Note: When this option is enabled, up to 1GB of system memory may become unavailable.
        
        [bool]$SubNumaClustering,

        [bool]$TPM2EndorsementDisable,
        [bool]$TPM2StorageDisable,

        # Use this option to select the fan cooling solution for the system. Optimal Cooling provides the most efficient solution by configuring fan speeds to the minimum required speed to provide adequate cooling. Increased Cooling runs fans at higher speeds to provide additional cooling. Select Increased Cooling when third-party storage controllers are cabled to the embedded hard drive cage, or if the system is experiencing thermal issues that cannot be resolved. Maximum cooling provides the maximum cooling available on this platform. Enhanced CPU Cooling runs the fans at a higher speed to provide additional cooling to the processors. Selecting Enhanced CPU Cooling may improve system performance with certain processor intensive workloads.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')]
        [string]$ThermalConfig,

        [bool]$ThermalShutdown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Utc', 'Local')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Utc', 'Local')]
        [string]$TimeFormat,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')]
        [string]$TimeZone,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceStatus,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Clear')]
        [string]$Tpm2Operation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')]
        [string]$TpmActivePcrs,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')]
        [string]$TpmChipId,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'NonFipsMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'NonFipsMode', 'FipsMode')]
        [string]$TpmFips,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'RegularMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'RegularMode', 'FipsMode')]
        [string]$TpmFipsModeSwitch,
                        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Tpm12', 'Tpm20')]
        [string]$TpmModeSwitchOperation,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Enable', 'Disable', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Enable', 'Disable', 'Clear')]
        [string]$TpmOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotPresent', 'PresentDisabled', 'PresentEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotPresent', 'PresentDisabled', 'PresentEnabled')]
        [string]$TpmState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoTpm', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoTpm', 'Tpm12', 'Tpm20')]
        [string]$TpmType,
        
        [bool]$TpmUefiOpromMeasuring,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Hidden', 'Visible')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Hidden', 'Visible')]
        [string]$TpmVisibility,

        [bool]$TransparentSecureMemoryEncryption,
        [bool]$UefiOptimizedBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')]
        [string]$UefiSerialDebugLevel,

        [bool]$UefiShellBootOrder,
        [bool]$UefiShellPhysicalPresenceKeystroke,
        [bool]$UefiShellScriptVerification,
        [bool]$UefiShellStartup,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$UefiShellStartupLocation,
        
        [string]$UefiShellStartupUrl,
        [bool]$UefiShellStartupUrlFromDhcp,
        [bool]$UefiVariableAccessFwControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Maximum', 'Minimum')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Maximum', 'Minimum')]
        [string]$UncoreFreqScaling,

        [bool]$UpiPrefetcher,
        [string]$UrlBootFile,
        [string]$UrlBootFile2,
        [bool]$UsbBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')]
        [string]$UsbControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('English', 'Japanese', 'Chinese')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('English', 'Japanese', 'Chinese')]
        [string]$UtilityLang,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptionalVideoOnly', 'BothVideoEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptionalVideoOnly', 'BothVideoEnabled')]
        [string]$VideoOptions,

        [bool]$VirtualInstallDisk,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$VirtualSerialPort,
        
        
        [bool]$VlanControl,
        [int]$VlanId,
        [int]$VlanPriority,
        [bool]$WakeOnLan,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Enabled', 'Disabled')]
        [string]$XptPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIForceLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIMaxLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('SoftwareInitiator', 'AdapterInitiator')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('SoftwareInitiator', 'AdapterInitiator')]
        [string]$iSCSIPolicy,

        [bool]$iSCSISoftwareInitiator,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewBiosSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Storage

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {
            Throw "Error! '$Name' setting already exists in the COM '$Region' region!"

        }


        # Build payload

        
        if ($WorkloadProfileName) {

            if ($WorkloadProfileName -eq "Virtual Radio Access Network (vRAN)") {
                $WorkloadProfileName = "vRAN"
            }
            
        }
        
        $Attributes = @{ 

            WorkloadProfile = $WorkloadProfileName
            
        }



        #Region Booleaan parameters   

        $boolParametersList = @(
            'AccessControlService',
            'AcpiHpet',
            'AcpiRootBridgePxm',
            'AcpiSlit',
            'AdjSecPrefetch',
            'AdvCrashDumpMode',
            'AllowLoginWithIlo',
            'Amd5LevelPage',
            'AmdCdma',
            'AmdDmaRemapping',
            'AmdL1Prefetcher',
            'AmdL2Prefetcher',
            'AmdMemoryBurstRefresh',
            'AmdPeriodicDirectoryRinse',
            'AmdSecureMemoryEncryption',
            'AmdSecureNestedPaging',
            'AmdVirtualDrtmDevice',
            'ApplicationPowerBoost',
            'AsrStatus',
            'ChannelInterleaving',
            'CollabPowerControl',
            'CoreBoosting',
            'DcuIpPrefetcher',
            'DcuStreamPrefetcher',
            'Dhcpv4',
            'DramControllerPowerDown',
            'EmbNicPCIeOptionROM',
            'EmbSas1PcieOptionROM',
            'EmbSata1Aspm',
            'EmbSata1PCIeOptionROM',
            'EmbSata2Aspm',
            'EmbSata2PCIeOptionROM',
            'EmbSata3Aspm',
            'EmbSata3PCIeOptionROM',
            'EmbSata4Aspm',
            'EmbSata4PCIeOptionROM',
            'EmbeddedDiagnostics',
            'EmbeddedIpxe',
            'EmbeddedUefiShell',
            'EnergyEfficientTurbo',
            'EnhancedProcPerf',
            'ExtendedMemTest',
            'F11BootMenu',
            'FlexLom1PCIeOptionROM',
            'HwPrefetcher',
            'IntelNicDmaChannels',
            'IntelPerfMonitoring',
            'IntelProcVtd',
            'IntelTxt',
            'IntelUpiPowerManagement',
            'IntelligentProvisioning',
            'InternalSDCardSlot',
            'IpxeBootOrder',
            'IpxeScriptAutoStart',
            'IpxeScriptVerification',
            'LastLevelCacheAsNUMANode',
            'LLCDeadLineAllocation',
            'LlcPrefetch',
            'MemClearWarmReset',
            'MemFastTraining',
            'MemPatrolScrubbing',
            'MicrosoftSecuredCoreSupport',
            'MixedPowerSupplyReporting',
            'NetworkBootRetry',
            'NodeInterleaving',
            'NvDimmNMemFunctionality',
            'NvDimmNMemInterleaving',
            'NvdimmLabelSupport',
            'NvmeOptionRom',
            'Ocp1AuxiliaryPower',
            'Ocp2AuxiliaryPower',
            'OmitBootDeviceEvent',
            'OpportunisticSelfRefresh',
            'PciPeerToPeerSerialization',
            'PciSlot20OptionROM',
            'PciSlot19OptionROM',
            'PciSlot18OptionROM',
            'PciSlot17OptionROM',
            'PciSlot16OptionROM',
            'PciSlot15OptionROM',
            'PciSlot14OptionROM',
            'PciSlot13OptionROM',
            'PciSlot12OptionROM',
            'PciSlot11OptionROM',
            'PciSlot10OptionROM',
            'PciSlot9OptionROM',
            'PciSlot8OptionROM',
            'PciSlot7OptionROM',
            'PciSlot6OptionROM',
            'PciSlot5OptionROM',
            'PciSlot4OptionROM',
            'PciSlot3OptionROM',
            'PciSlot2OptionROM',
            'PciSlot1OptionROM',
            'PersistentMemAddressRangeScrub',
            'PersistentMemScanMem',
            'PlatformCertificate',
            'PowerButton',
            'ProcAes',
            'ProcAMDBoost',
            'ProcAmdIoVt',
            'ProcHyperthreading',
            'ProcSMT',
            'ProcTurbo',
            'ProcVirtualization',
            'SanitizeAllNvDimmN',
            'SataSanitize',
            'SataSecureErase',
            'SecStartBackupImage',
            'SecureBootStatus',
            'ServerConfigLockStatus',
            'Slot1MctpBroadcastSupport',
            'Slot2MctpBroadcastSupport',
            'Slot3MctpBroadcastSupport',
            'Slot4MctpBroadcastSupport',
            'Slot5MctpBroadcastSupport',
            'Slot6MctpBroadcastSupport',
            'Slot7MctpBroadcastSupport',
            'Slot8MctpBroadcastSupport',
            'Slot9MctpBroadcastSupport',
            'Slot10MctpBroadcastSupport',
            'Slot11MctpBroadcastSupport',
            'Slot12MctpBroadcastSupport',
            'Slot13MctpBroadcastSupport',
            'Slot14MctpBroadcastSupport',
            'Slot15MctpBroadcastSupport',
            'Slot16MctpBroadcastSupport',
            'Slot17MctpBroadcastSupport',
            'Slot18MctpBroadcastSupport',
            'Slot19MctpBroadcastSupport',
            'Slot20MctpBroadcastSupport',
            'SpeculativeLockScheduling',
            'Sriov',
            'StaleAtoS',
            'SubNumaClustering',
            'TPM2EndorsementDisable',
            'TPM2StorageDisable',
            'ThermalShutdown',
            'TpmUefiOpromMeasuring',
            'TransparentSecureMemoryEncryption',
            'UefiOptimizedBoot',
            'UefiShellBootOrder',
            'UefiShellPhysicalPresenceKeystroke',
            'UefiShellScriptVerification',
            'UefiShellStartup',
            'UefiShellStartupUrlFromDhcp',
            'UefiVariableAccessFwControl',
            'UpiPrefetcher',
            'UsbBoot',
            'VirtualInstallDisk',
            'VlanControl',
            'WakeOnLan',
            'iSCSISoftwareInitiator'

        )
       
        $RequireCustomProfile = $False

        foreach ($boolparameter in $boolParametersList) {
        
            if ($PSBoundParameters.ContainsKey($boolparameter)) {
    
                $RequireCustomProfile = $True
    
                if ($PSBoundParameters[$boolparameter] -eq $True) {
        
                    $Attributes."$boolparameter" = "Enabled"
        
                }
                else {
                    $Attributes."$boolparameter" = "Disabled"
        
                }
            }        
        }

        #EndRegion


        #Region String + Integer parameters

        $stringparametersList = @(
            'AdminEmail',
            'AdminName',
            'AdminOtherInfo',
            'AdminPhone',
            'AdvancedMemProtection',
            'AmdCstC2Latency',
            'AmdMemPStates',
            'AmdXGMILinkSpeed',
            'AsrTimeoutMinutes',
            'AssetTagProtection',
            'AutoPowerOn',
            'BootOrderPolicy',
            'ConsistentDevNaming',
            'CustomPostMessage',
            'CustomPstate0',
            'DataFabricCStateEnable',
            'DaylightSavingsTime',
            'DeterminismControl',
            'DirectToUpi',
            'DynamicPowerCapping',
            'EmbNicAspm',
            'EmbNicEnable',
            'EmbNicLinkSpeed',
            'EmbSas1Aspm',
            'EmbSas1Boot',
            'EmbSas1Enable',
            'EmbSas1LinkSpeed',
            'EmbSata1Enable',
            'EmbSata2Enable',
            'EmbSata3Enable',
            'EmbSata4Enable',
            'EmbVideoConnection',
            'EmbeddedSata',
            'EmbeddedSerialPort',
            'EmsConsole',
            # 'EnabledCoresPerProcIlo6', # Removed as iLO5 and 6 do not use the same value types
            # 'EnabledCoresPerProcIlo5',
            'EnergyPerfBias',
            'ExtendedAmbientTemp',
            'FCScanPolicy',
            'FanFailPolicy',
            'FanInstallReq',
            'FlexLom1Aspm',
            'FlexLom1Enable',
            'FlexLom1LinkSpeed',
            'HourFormat',
            'HttpSupport',
            'InfinityFabricPstate',
            'IntelDmiLinkFreq',
            'IntelSpeedSelect',
            'IntelUpiFreq',
            'IntelUpiLinkEn',
            'IntelVmdDirectAssign',
            'IntelVmdSupport',
            'IntelVrocSupport',
            'IpmiWatchdogTimerAction',
            'IpmiWatchdogTimerStatus',
            'IpmiWatchdogTimerTimeout',
            'Ipv4Address',
            'Ipv4Gateway',
            'Ipv4PrimaryDNS',
            'Ipv4SubnetMask',
            'Ipv6Address',
            'Ipv6ConfigPolicy',
            'Ipv6Duid',
            'Ipv6Gateway',
            'Ipv6PrimaryDNS',
            'Ipv6SecondaryDNS',
            'IpxeAutoStartScriptLocation',
            'IpxeStartupUrl',
            'LocalRemoteThreshold',
            'MaxMemBusFreqMHz',
            'MaxPcieSpeed',
            'MemMirrorMode',
            'MemRefreshRate',
            'MemoryControllerInterleaving',
            'MemoryRemap',
            'MinProcIdlePkgState',
            'MinProcIdlePower',
            'MinimumSevAsid',
            'NetworkBootRetryCount',
            'NicBoot1',
            'NicBoot2',
            'NicBoot3',
            'NicBoot4',
            'NicBoot5',
            'NicBoot6',
            'NicBoot7',
            'NicBoot8',
            'NicBoot9',
            'NicBoot10',
            'NicBoot11',
            'NicBoot12',
            'NumaGroupSizeOpt',
            'NumaMemoryDomainsPerSocket',
            'NvDimmNSanitizePolicy',
            'PackagePowerLimitControlMode',
            'PackagePowerLimitValue',
            'PatrolScrubDuration',
            'PciResourcePadding',
            'PciSlot20Aspm',
            'PciSlot20Bifurcation',
            'PciSlot20Enable',
            'PciSlot20LinkSpeed',
            'PciSlot19Aspm',
            'PciSlot19Bifurcation',
            'PciSlot19Enable',
            'PciSlot19LinkSpeed',
            'PciSlot18Aspm',
            'PciSlot18Bifurcation',
            'PciSlot18Enable',
            'PciSlot18LinkSpeed',
            'PciSlot17Aspm',
            'PciSlot17Bifurcation',
            'PciSlot17Enable',
            'PciSlot17LinkSpeed',
            'PciSlot16Aspm',
            'PciSlot16Bifurcation',
            'PciSlot16Enable',
            'PciSlot16LinkSpeed',
            'PciSlot15Aspm',
            'PciSlot15Bifurcation',
            'PciSlot15Enable',
            'PciSlot15LinkSpeed',
            'PciSlot14Aspm',
            'PciSlot14Bifurcation',
            'PciSlot14Enable',
            'PciSlot14LinkSpeed',
            'PciSlot13Aspm',
            'PciSlot13Bifurcation',
            'PciSlot13Enable',
            'PciSlot13LinkSpeed',
            'PciSlot12Aspm',
            'PciSlot12Bifurcation',
            'PciSlot12Enable',
            'PciSlot12LinkSpeed',
            'PciSlot11Aspm',
            'PciSlot11Bifurcation',
            'PciSlot11Enable',
            'PciSlot11LinkSpeed',
            'PciSlot10Aspm',
            'PciSlot10Bifurcation',
            'PciSlot10Enable',
            'PciSlot10LinkSpeed',
            'PciSlot9Aspm',
            'PciSlot9Bifurcation',
            'PciSlot9Enable',
            'PciSlot9LinkSpeed',
            'PciSlot8Aspm',
            'PciSlot8Bifurcation',
            'PciSlot8Enable',
            'PciSlot8LinkSpeed',
            'PciSlot7Aspm',
            'PciSlot7Bifurcation',
            'PciSlot7Enable',
            'PciSlot7LinkSpeed',
            'PciSlot6Aspm',
            'PciSlot6Bifurcation',
            'PciSlot6Enable',
            'PciSlot6LinkSpeed',
            'PciSlot5Aspm',
            'PciSlot5Bifurcation',
            'PciSlot5Enable',
            'PciSlot5LinkSpeed',
            'PciSlot4Aspm',
            'PciSlot4Bifurcation',
            'PciSlot4Enable',
            'PciSlot4LinkSpeed',
            'PciSlot3Aspm',
            'PciSlot3Bifurcation',
            'PciSlot3Enable',
            'PciSlot3LinkSpeed',
            'PciSlot2Aspm',
            'PciSlot2Bifurcation',
            'PciSlot2Enable',
            'PciSlot2LinkSpeed',
            'PciSlot1Aspm',
            'PciSlot1Bifurcation',
            'PciSlot1Enable',
            'PciSlot1LinkSpeed',
            'PerformanceDeterminism',
            'PersistentMemBackupPowerPolicy',
            'PlatformRASPolicy',
            'PostAsr',
            'PostAsrDelay',
            'PostBootProgress',
            'PostDiscoveryMode',
            'PostF1Prompt',
            'PostScreenMode',
            'PostVideoSupport',
            'PowerOnDelay',
            'PowerRegulator',
            'PreBootNetwork',
            'PrebootNetworkEnvPolicy',
            'PrebootNetworkProxy',
            'ProcAMDBoostControl',
            'ProcAmdFmax',
            'ProcX2Apic',
            'ProcessorConfigTDPLevel',
            'ProcessorJitterControl',
            'ProcessorJitterControlFrequency',
            'ProcessorJitterControlOptimization',
            'Pstate0Frequency',
            'RedundantPowerSupply',
            'RedundantPowerSupplyGpuDomain',
            'RedundantPowerSupplySystemDomain',
            'RemovableFlashBootSeq',
            'RomSelection',
            'SciRasSupport',
            'SerialConsoleBaudRate',
            'SerialConsoleEmulation',
            'SerialConsolePort',
            'ServerAssetTag',
            'ServerOtherInfo',
            'ServerPrimaryOs',
            'ServiceEmail',
            'ServiceName',
            'ServiceOtherInfo',
            'ServicePhone',
            'SetupBrowserSelection',
            'Slot1NicBoot1',
            'Slot1NicBoot2',
            'Slot1NicBoot3',
            'Slot1NicBoot4',
            'Slot2NicBoot1',
            'Slot2NicBoot2',
            'Slot2NicBoot3',
            'Slot2NicBoot4',
            'Slot3NicBoot1',
            'Slot3NicBoot2',
            'Slot3NicBoot3',
            'Slot3NicBoot4',
            'Slot4NicBoot1',
            'Slot4NicBoot2',
            'Slot4NicBoot3',
            'Slot4NicBoot4',
            'Slot5NicBoot1',
            'Slot5NicBoot2',
            'Slot5NicBoot3',
            'Slot5NicBoot4',
            'Slot6NicBoot1',
            'Slot6NicBoot2',
            'Slot6NicBoot3',
            'Slot6NicBoot4',
            'Slot7NicBoot1',
            'Slot7NicBoot2',
            'Slot7NicBoot3',
            'Slot7NicBoot4',
            'Slot8NicBoot1',
            'Slot8NicBoot2',
            'Slot8NicBoot3',
            'Slot8NicBoot4',
            'Slot9NicBoot1',
            'Slot9NicBoot2',
            'Slot9NicBoot3',
            'Slot9NicBoot4',
            'Slot10NicBoot1',
            'Slot10NicBoot2',
            'Slot10NicBoot3',
            'Slot10NicBoot4',
            'Slot11NicBoot1',
            'Slot11NicBoot2',
            'Slot11NicBoot3',
            'Slot11NicBoot4',
            'Slot12NicBoot1',
            'Slot12NicBoot2',
            'Slot12NicBoot3',
            'Slot12NicBoot4',
            'Slot13NicBoot1',
            'Slot13NicBoot2',
            'Slot13NicBoot3',
            'Slot13NicBoot4',
            'Slot14NicBoot1',
            'Slot14NicBoot2',
            'Slot14NicBoot3',
            'Slot14NicBoot4',
            'Slot15NicBoot1',
            'Slot15NicBoot2',
            'Slot15NicBoot3',
            'Slot15NicBoot4',
            'Slot16NicBoot1',
            'Slot16NicBoot2',
            'Slot16NicBoot3',
            'Slot16NicBoot4',
            'Slot17NicBoot1',
            'Slot17NicBoot2',
            'Slot17NicBoot3',
            'Slot17NicBoot4',
            'Slot18NicBoot1',
            'Slot18NicBoot2',
            'Slot18NicBoot3',
            'Slot18NicBoot4',
            'Slot19NicBoot1',
            'Slot19NicBoot2',
            'Slot19NicBoot3',
            'Slot19NicBoot4',
            'Slot20NicBoot1',
            'Slot20NicBoot2',
            'Slot20NicBoot3',
            'Slot20NicBoot4',
            'Slot1StorageBoot',
            'Slot2StorageBoot',
            'Slot3StorageBoot',
            'Slot4StorageBoot',
            'Slot5StorageBoot',
            'Slot6StorageBoot',
            'Slot7StorageBoot',
            'Slot8StorageBoot',
            'Slot9StorageBoot',
            'Slot10StorageBoot',
            'Slot11StorageBoot',
            'Slot12StorageBoot',
            'Slot13StorageBoot',
            'Slot14StorageBoot',
            'Slot15StorageBoot',
            'Slot16StorageBoot',
            'Slot17StorageBoot',
            'Slot18StorageBoot',
            'Slot19StorageBoot',
            'Slot20StorageBoot',
            'ThermalConfig',
            'TimeFormat',
            'TimeZone',
            'Tpm20SoftwareInterfaceOperation',
            'Tpm20SoftwareInterfaceStatus',
            'Tpm2Operation',
            'TpmActivePcrs',
            'TpmChipId',
            'TpmFips',
            'TpmFipsModeSwitch',
            'TpmModeSwitchOperation',
            'TpmOperation',
            'TpmState',
            'TpmType',
            'TpmVisibility',
            'UefiSerialDebugLevel',
            'UefiShellStartupLocation',
            'UefiShellStartupUrl',
            'UncoreFreqScaling',
            'UrlBootFile',
            'UrlBootFile2',
            'UsbControl',
            'UtilityLang',
            'VideoOptions',
            'VirtualSerialPort',
            'VlanId',
            'VlanPriority',
            'XptPrefetcher',
            'XGMIForceLinkWidth',
            'XGMIMaxLinkWidth',
            'iSCSIPolicy'
        )

        foreach ($stringparameter in $stringparametersList) {
            
            if ($PSBoundParameters.ContainsKey($stringparameter)) {
                
                $RequireCustomProfile = $True

                $param1Value = $PSBoundParameters[$stringparameter]

                $Attributes."$stringparameter" = $param1Value
            }
        }


        if ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo6')) {

            $RequireCustomProfile = $True

            $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo6
        } 
        elseif ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo5')) {

            $RequireCustomProfile = $True

            $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo5
            
        }



        if ($AsrTimeoutMinutes) {
            $Attributes.AsrStatus = "Enabled"

        }


        if ($SubNumaClustering) {
            # Options that must be enabled when Sub-Numa Clustering (SNC) is enabled:
            $Attributes.XptPrefetcher = "Enabled"
            $Attributes.UpiPrefetcher = "Enabled"
        }

        #EndRegion

           

        # Build paylaod

        if ($RequireCustomProfile) {
            
            $Default = @{ 
                redfishData                 = @{
                    Attributes = $Attributes
                }
                enableCustomWorkloadProfile = $True
            }
        }
        else {
            
            $Default = @{ 
                redfishData = @{
                    Attributes = $Attributes
                }
            }

        }

        $Settings = @{ 
            DEFAULT = $Default
        }

        $payload = @{ 
            name           = $Name
            category       = "BIOS"
            description    = $Description
            platformFamily = "ANY"
            settings       = $Settings                  
        }

        $payload = ConvertTo-Json $payload -Depth 10 

        try {

            $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

            if (-not $WhatIf ) {
    
                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                "[{0}] Bios server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Bios server setting successfully created in $Region region"


            }
        }
        catch {

            if (-not $WhatIf) {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Bios server setting cannot be created!"
                $objStatus.Exception = $_.Exception.message 

            }
        } 

        [void] $NewBiosSettingStatus.add($objStatus)

        

    
    }
    
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewBiosSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more bios server settings failed the creation attempt!"
          
            }
            
            Return $NewBiosSettingStatus
        
        }

    }
}


Function Set-HPECOMSettingServerBios {
    <#
    .SYNOPSIS
    Update a bios server setting resource in a specified region.
    
    .DESCRIPTION
    This Cmdlet modifies a bios server setting resource in a given region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.
    
    For a detailed description of all iLO BIOS attributes parameters:
    - For iLO6, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo6/ilo6_159/ilo6_bios_resourcedefns159/
    - For iLO5, see https://servermanagementportal.ext.hpe.com/docs/redfishservices/ilos/ilo5/ilo5_304/ilo5_bios_resourcedefns304/

    Note: If a parameter is incompatible with your iLO generation or server platform, 'Invoke-HPECOMGroupBiosConfiguration' will return an error message stating "Apply BIOS settings failed".
          To get more detailed information about the parameters that caused these errors, access the iLO Redfish API using a GET request to /redfish/v1/Systems/1/Bios/ and inspect the @Redfish.Settings.Messages property.

    Note: If one or several unsupported parameters are selected, the other BIOS settings will still be applied successfully. Unsupported parameters will be ignored without affecting the application of the other settings.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Specifies the name of the bios server setting to set.

    .PARAMETER Description
    Specifies a description of the bios server setting.

    .PARAMETER WorkloadProfileName
    Name of a pre-defined workload profile:
        - Decision Support
        - General Peak Frequency Compute
        - General Power Efficient Compute
        - General Throughput Compute
        - Graphic Processing
        - High Performance Compute (HPC)
        - I/O Throughput
        - Low Latency
        - Mission Critical
        - My-Bios-For-AI
        - Transactional Application Processing
        - Virtual Radio Access Network (vRAN)
        - Virtualization - Max Performance
        - Virtualization - Power Efficient

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance"

    This example shows how to modify a BIOS setting named "Custom-Bios-For-ESX" in the eu-central region. The command updates the description and sets the workload profile to "Virtualization - Max Performance" while preserving all other existing settings.

    .EXAMPLE
    Set-HPECOMSettingServerBios -Region eu-central -Name "Custom-Bios-For-ESX" -Description "Description..." -WorkloadProfileName "Virtualization - Max Performance" `
      -AdminName Albert -AdminEmail "alb@domain.com" -AsrTimeoutMinutes Timeout10 -AutoPowerOn AlwaysPowerOn -CoreBoosting:$true -F11BootMenu:$False -ThermalConfig OptimalCooling 

    This example modifies a customized BIOS configuration for "Custom-Bios-For-ESX" in the eu-central region. it sets new admin details (AdminName and AdminEmail), various new BIOS feature configurations such as ASR timeout, auto power on, core boosting, F11 boot menu, and thermal configuration for optimal cooling.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name Custom-Bios-For-ESX | Set-HPECOMSettingServerBios -NewName "Custom-Bios-For-ESX8" -FanFailPolicy Shutdown -PowerRegulator DynamicPowerSavings

    This example retrieves an existing BIOS setting named 'Custom-Bios-For-ESX' in the eu-central region and updates it. The command renames it to 'Custom-Bios-For-ESX8', sets the fan fail policy to Shutdown, and adjusts the power regulator to DynamicPowerSavings while preserving all other existing settings.
    
    .INPUTS
    System.Collections.ArrayList
        List of bios server settings from 'Get-HPECOMSetting -Category Bios'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the bios server setting attempted to be updated
        * Region - The name of the region
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ilo6')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Decision Support', 'General Peak Frequency Compute', 'General Power Efficient Compute', 'General Throughput Compute', 'Graphic Processing', 'High Performance Compute (HPC)', 'I/O Throughput', 'Low Latency', 'Mission Critical', 'Transactional Application Processing', 'Virtual Radio Access Network (vRAN)', 'Virtualization - Max Performance', 'Virtualization - Power Efficient')
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$WorkloadProfileName,
        
        [bool]$AccessControlService,
        [bool]$AcpiHpet,
        [bool]$AcpiRootBridgePxm,
        [bool]$AcpiSlit,
        [bool]$AdjSecPrefetch,
        [string]$AdminEmail,
        [String]$AdminName,
        [string]$AdminOtherInfo,
        # Name of the server administrator
        [string]$AdminPhone,

        [bool]$AdvCrashDumpMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('FastFaultTolerantADDDC', 'AdvancedEcc', 'OnlineSpareAdvancedEcc', 'MirroredAdvancedEcc')]
        [String]$AdvancedMemProtection,

        [bool]$AllowLoginWithIlo,
        [bool]$Amd5LevelPage,
        [bool]$AmdCdma,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('800us', '18us')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('800us', '18us')]
        [String]$AmdCstC2Latency,

        [bool]$AmdDmaRemapping,
        [bool]$AmdL1Prefetcher,
        [bool]$AmdL2Prefetcher,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [String]$AmdMemPStates,
        
        [bool]$AmdMemoryBurstRefresh,
        [bool]$AmdPeriodicDirectoryRinse,
        [bool]$AmdSecureMemoryEncryption,
        [bool]$AmdSecureNestedPaging,
        [bool]$AmdVirtualDrtmDevice,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $WorkloadProfiles = @('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32' )
                $filteredWorkloadProfiles = $WorkloadProfiles | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredWorkloadProfiles | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AmdXGMILinkSpeed16', 'AmdXGMILinkSpeed18', 'AmdXGMILinkSpeed25', 'AmdXGMILinkSpeed32')]
        [String]$AmdXGMILinkSpeed,

        [bool]$ApplicationPowerBoost,

        # Use this option to configure the Automatic Server Recovery option, which enables the system to automatically reboot if the server locks up.
        [bool]$AsrStatus,

        # When Automatic Server Recovery is enabled, you can use this option to set the time to wait before rebooting the server in the event of an operating system crash or server lockup.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Timeout5', 'Timeout10', 'Timeout15', 'Timeout20', 'Timeout30')]
        [string]$AsrTimeoutMinutes,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Locked', 'Unlocked')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Locked', 'Unlocked')]
        [String]$AssetTagProtection,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AlwaysPowerOn', 'AlwaysPowerOff', 'RestoreLastState')]
        [String]$AutoPowerOn,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RetryIndefinitely', 'AttemptOnce', 'ResetAfterFailed')]
        [string]$BootOrderPolicy,

        [bool]$ChannelInterleaving,
        [bool]$CollabPowerControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('LomsAndSlots', 'LomsOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('LomsAndSlots', 'LomsOnly', 'Disabled')]
        [string]$ConsistentDevNaming,

        [bool]$CoreBoosting,

        # Enter a message to be displayed on POST screen during system startup. This feature limits POST screen messaging to 62 characters, special characters are also accepted.
        [ValidateScript({
                if ($_.Length -le 62) {
                    $True
                }
                if ($_ -match '^[a-zA-Z0-9]+$') {
                    $true
                } 
                elseif ($_.Length -gt 62) {
                    throw "The POST screen message cannot have more than 62 characters!"

                }
                elseif ($_ -notmatch '^[a-zA-Z0-9]+$') {
                    throw "The POST screen message cannot contain special characters!"
                }
            })]
        [string]$CustomPostMessage,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Manual')]
        [string]$CustomPstate0,
            
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceEnabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'ForceEnabled', 'Disabled')]
        [string]$DataFabricCStateEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DaylightSavingsTimeEnabled', 'DaylightSavingsTimeDisabled', 'Enabled', 'Disabled')]
        [string]$DaylightSavingsTime,
         
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DeterminismCtrlAuto', 'DeterminismCtrlManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('DeterminismCtrlAuto', 'DeterminismCtrlManual')]            
        [string]$DeterminismControl,        

        [bool]$DcuIpPrefetcher,
        [bool]$DcuStreamPrefetcher,
        [bool]$Dhcpv4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]
        [string]$DirectToUpi,

        [bool]$DramControllerPowerDown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Enabled', 'Disabled')]            
        [string]$DynamicPowerCapping,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AspmL1Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'AspmL1Enabled', 'Disabled')]            
        [string]$EmbNicAspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]            
        [string]$EmbNicEnable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1')]
        [string]$EmbNicLinkSpeed,
        
        [bool]$EmbNicPCIeOptionROM,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$EmbSas1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('AllTargets', 'TwentyFourTargets', 'NoTargets')]
        [string]$EmbSas1Boot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSas1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$EmbSas1LinkSpeed,
        
        [bool]$EmbSas1PcieOptionROM,
        [bool]$EmbSata1Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata1Enable,
        
        [bool]$EmbSata1PCIeOptionROM,
        [bool]$EmbSata2Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata2Enable,
        
        [bool]$EmbSata2PCIeOptionROM,

        [bool]$EmbSata3Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata3Enable,
        
        [bool]$EmbSata3PCIeOptionROM,
        [bool]$EmbSata4Aspm,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$EmbSata4Enable,
        
        [bool]$EmbSata4PCIeOptionROM,
               
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AlwaysDisabled', 'AlwaysEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AlwaysDisabled', 'AlwaysEnabled')]
        [string]$EmbVideoConnection,
        
        [bool]$EmbeddedDiagnostics,
        [bool]$EmbeddedIpxe,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EmbeddedSata', 'IntelVrocSata', 'Ahci', 'Raid')]
        [string]$EmbeddedSata,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$EmbeddedSerialPort,
        
        [bool]$EmbeddedUefiShell,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Physical', 'Virtual')]
        [string]$EmsConsole,
        
        # This attribute is a problem because in iLO5, value is an integer
        [Parameter (ParameterSetName = 'ilo6')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CoresPerProc0', 'CoresPerProc2', 'CoresPerProc4', 'CoresPerProc6', 'CoresPerProc8', 'CoresPerProc12', 'CoresPerProc16', 'CoresPerProc20', 'CoresPerProc24', 'CoresPerProc28', 'CoresPerProc32', 'CoresPerProc36', 'CoresPerProc40', 'CoresPerProc48', 'CoresPerProc56', 'CoresPerProc60', 'CoresPerProc64', 'CoresPerProc72', 'CoresPerProc80', 'CoresPerProc84', 'CoresPerProc96', 'CoresPerProc112')]
        [string]$EnabledCoresPerProcIlo6,

        [Parameter (ParameterSetName = 'ilo5')]
        [int]$EnabledCoresPerProcIlo5,

        [bool]$EnergyEfficientTurbo,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('MaxPerf', 'BalancedPerf', 'BalancedPower', 'PowerSavingsMode')]
        [string]$EnergyPerfBias,

        [bool]$EnhancedProcPerf,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ASHRAE3', 'ASHRAE4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ASHRAE3', 'ASHRAE4')]
        [string]$ExtendedAmbientTemp,

        [bool]$ExtendedMemTest,
        [bool]$F11BootMenu,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'CardConfig')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'CardConfig')]
        [string]$FCScanPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Shutdown', 'Allow')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Shutdown', 'Allow')]
        [string]$FanFailPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('EnableMessaging', 'DisableMessaging')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('EnableMessaging', 'DisableMessaging')]
        [string]$FanInstallReq,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$FlexLom1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$FlexLom1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$FlexLom1LinkSpeed,

        [bool]$FlexLom1PCIeOptionROM,
         

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('12Hours', '24Hours')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('12Hours', '24Hours')]
        [string]$HourFormat,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'HttpsOnly', 'HttpOnly', 'Disabled')]
        [string]$HttpSupport,

        [bool]$HwPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('P0', 'P1', 'P2', 'P3', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('P0', 'P1', 'P2', 'P3', 'Auto')]
        [string]$InfinityFabricPstate,
        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DmiGen1', 'DmiGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DmiGen1', 'DmiGen2')]            
        [string]$IntelDmiLinkFreq,
        
        [bool]$IntelNicDmaChannels,
        [bool]$IntelPerfMonitoring,
        [bool]$IntelProcVtd,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Base', 'Config1', 'Config2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Base', 'Config1', 'Config2')]
        [string]$IntelSpeedSelect,

        [bool]$IntelTxt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MinUpiSpeed')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MinUpiSpeed')]
        [string]$IntelUpiFreq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'SingleLink')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'SingleLink')]
        [string]$IntelUpiLinkEn,

        [bool]$IntelUpiPowerManagement,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('VmdDirectAssignEnabledAll', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('VmdDirectAssignEnabledAll', 'Disabled')]
        [string]$IntelVmdDirectAssign,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IntelVmdEnabledAll', 'IntelVmdEnabledIndividual', 'Disabled')]
        [string]$IntelVmdSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'Standard', 'Premium')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'Standard', 'Premium')]
        [string]$IntelVrocSupport,
                
        [bool]$IntelligentProvisioning,
        [bool]$InternalSDCardSlot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PowerCycle', 'PowerDown', 'WarmBoot')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PowerCycle', 'PowerDown', 'WarmBoot')]
        [string]$IpmiWatchdogTimerAction,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('IpmiWatchdogTimerOff', 'IpmiWatchdogTimerOn')]
        [string]$IpmiWatchdogTimerStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Timeout10Min', 'Timeout15Min', 'Timeout20Min', 'Timeout30Min')]
        [string]$IpmiWatchdogTimerTimeout,
        
        [string]$Ipv4Address,
        [string]$Ipv4Gateway,
        [string]$Ipv4PrimaryDNS,
        [string]$Ipv4SubnetMask,
        [string]$Ipv6Address,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Automatic', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Automatic', 'Manual')]
        [string]$Ipv6ConfigPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'DuidLlt', 'DUID-LLT')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'DuidLlt', 'DUID-LLT')]
        [string]$Ipv6Duid,

        [string]$Ipv6Gateway,
        [string]$Ipv6PrimaryDNS,
        [string]$Ipv6SecondaryDNS,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$IpxeAutoStartScriptLocation,
        
        
        [bool]$IpxeBootOrder,
        [bool]$IpxeScriptAutoStart,
        [bool]$IpxeScriptVerification,
        [string]$IpxeStartupUrl,
        [bool]$LastLevelCacheAsNUMANode,
        

        [bool]$LLCDeadLineAllocation,
        [bool]$LlcPrefetch,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Low', 'Medium', 'High', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Low', 'Medium', 'High', 'Disabled')]
        [string]$LocalRemoteThreshold,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'MaxMemBusFreq4800', 'MaxMemBusFreq4400', 'MaxMemBusFreq4000', 'MaxMemBusFreq3600', 'MaxMemBusFreq3200', 'MaxMemBusFreq2933', 'MaxMemBusFreq2667', 'MaxMemBusFreq2400', 'MaxMemBusFreq2133', 'MaxMemBusFreq1867')]
        [string]$MaxMemBusFreqMHz,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerPortCtrl', 'PcieGen1', 'PcieGen2', 'PcieGen3', 'PcieGen4')]
        [string]$MaxPcieSpeed,

        [bool]$MemClearWarmReset,
        [bool]$MemFastTraining,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Full', 'PartialOsConfig', 'PartialFirst4GB', 'Partial10PercentAbove4GB', 'Partial20PercentAbove4GB')]
        [string]$MemMirrorMode,
        
        [bool]$MemPatrolScrubbing,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Refreshx1', 'Refreshx2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Refreshx1', 'Refreshx2')]
        [string]$MemRefreshRate,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Auto', 'Disabled')]
        [string]$MemoryControllerInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'AllMemory')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'AllMemory')]
        [string]$MemoryRemap,

        [bool]$MicrosoftSecuredCoreSupport,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6Retention', 'C6NonRetention', 'NoState')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6Retention', 'C6NonRetention', 'NoState')]
        [string]$MinProcIdlePkgState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('C6', 'C1E', 'NoCStates')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('C6', 'C1E', 'NoCStates')]
        [string]$MinProcIdlePower,

        [int]$MinimumSevAsid,

        [bool]$MixedPowerSupplyReporting,
        [bool]$NetworkBootRetry,
        [int]$NetworkBootRetryCount,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot5,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot6,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot7,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot8,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot9,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot10,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('NetworkBoot', 'Disabled')]
        [string]$NicBoot11,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [string]$NicBoot12,

        [bool]$NodeInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Flat', 'Clustered')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Flat', 'Clustered')]
        [string]$NumaGroupSizeOpt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OneMemoryDomainPerSocket', 'TwoMemoryDomainsPerSocket', 'FourMemoryDomainsPerSocket', 'Auto')]
        [string]$NumaMemoryDomainsPerSocket,
        
        [bool]$NvDimmNMemFunctionality,
        [bool]$NvDimmNMemInterleaving,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'SanitizeAndRebootSystem', 'SanitizeAndShutdownSystem', 'SanitizeAndBootToFirmwareUI', 'SanitizeToFactoryDefaults')]
        [string]$NvDimmNSanitizePolicy,

        [bool]$NvdimmLabelSupport,
        [bool]$NvmeOptionRom,
        [bool]$Ocp1AuxiliaryPower,
        [bool]$Ocp2AuxiliaryPower,
        [bool]$OmitBootDeviceEvent,
        [bool]$OpportunisticSelfRefresh,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Manual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Manual')]
        [string]$PackagePowerLimitControlMode,

        [int]$PackagePowerLimitValue,
        [int]$PatrolScrubDuration,

        [bool]$PciPeerToPeerSerialization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Medium', 'High')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Medium', 'High')]
        [string]$PciResourcePadding,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot20Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot20Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot20Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot20LinkSpeed,

        [bool]$PciSlot20OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot19Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot19Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot19Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot19LinkSpeed,

        [bool]$PciSlot19OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot18Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot18Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot18Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot18LinkSpeed,

        [bool]$PciSlot18OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot17Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot17Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot17Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot17LinkSpeed,

        [bool]$PciSlot17OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot16Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot16Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot16Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot16LinkSpeed,

        [bool]$PciSlot16OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot15Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot15Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot15Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot15LinkSpeed,

        [bool]$PciSlot15OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot14Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot14Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot14Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot14LinkSpeed,

        [bool]$PciSlot14OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot13Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot13Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot13Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot13LinkSpeed,

        [bool]$PciSlot13OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot12Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot12Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot12Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot12LinkSpeed,

        [bool]$PciSlot12OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot11Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot11Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot11Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot11LinkSpeed,

        [bool]$PciSlot11OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot10Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot10Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot10Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot10LinkSpeed,

        [bool]$PciSlot10OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot9Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot9Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot9Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot9LinkSpeed,

        [bool]$PciSlot9OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot8Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot8Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot8Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot8LinkSpeed,

        [bool]$PciSlot8OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot7Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot7Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot7Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot7LinkSpeed,

        [bool]$PciSlot7OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot6Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot6Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot6Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot6LinkSpeed,

        [bool]$PciSlot6OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot5Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot5Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot5Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot5LinkSpeed,

        [bool]$PciSlot5OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot4Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot4Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot4Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot4LinkSpeed,

        [bool]$PciSlot4OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot3Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot3Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot3Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot3LinkSpeed,

        [bool]$PciSlot3OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot2Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot2Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot2Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot2LinkSpeed,

        [bool]$PciSlot2OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'AspmL1Enabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'AspmL1Enabled')]
        [string]$PciSlot1Aspm,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'NoBifurcation', 'SlotBifurcated', 'SlotDualBifurcated')]
        [string]$PciSlot1Bifurcation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled')]
        [string]$PciSlot1Enable,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'PcieGen1', 'PcieGen2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]        
        [ValidateSet('Auto', 'PcieGen1', 'PcieGen2')]
        [string]$PciSlot1LinkSpeed,
        
        [bool]$PciSlot1OptionROM,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PerformanceDeterministic', 'PowerDeterministic')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PerformanceDeterministic', 'PowerDeterministic')]
        [string]$PerformanceDeterminism,
        
        [bool]$PersistentMemAddressRangeScrub,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('WaitForBackupPower', 'BootWithoutBackupPower', 'UseExternalBackupPower')]
        [string]$PersistentMemBackupPowerPolicy,

        [bool]$PersistentMemScanMem,
        [bool]$PlatformCertificate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('FirmwareFirst', 'OSFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('FirmwareFirst', 'OSFirst')]
        [string]$PlatformRASPolicy,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('PostAsrOff', 'PostAsrOn')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('PostAsrOff', 'PostAsrOn')]
        [string]$PostAsr,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Delay30Min', 'Delay20Min', 'Delay15Min', 'Delay10Min')]
        [string]$PostAsrDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Serial', 'All')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Serial', 'All')]
        [string]$PostBootProgress,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'ForceFullDiscovery', 'ForceFastDiscovery')]
        [string]$PostDiscoveryMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Delayed20Sec', 'Delayed2Sec', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Delayed20Sec', 'Delayed2Sec', 'Disabled')]
        [string]$PostF1Prompt,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('QuietMode', 'VerboseMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('QuietMode', 'VerboseMode')]
        [string]$PostScreenMode,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DisplayAll', 'DisplayEmbeddedOnly')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DisplayAll', 'DisplayEmbeddedOnly')]
        [string]$PostVideoSupport,
        
        [bool]$PowerButton,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoDelay', 'Random', 'Delay15Sec', 'Delay30Sec', 'Delay45Sec', 'Delay60Sec')]
        [string]$PowerOnDelay,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('DynamicPowerSavings', 'StaticLowPower', 'StaticHighPerf', 'OsControl')]
        [string]$PowerRegulator,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                        'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                        'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                        'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                        'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'EmbNicPort1', 'EmbNicPort2', 'EmbNicPort3', 'EmbNicPort4', 'EmbNicPort5', 'EmbNicPort6', 'EmbNicPort7', 'EmbNicPort8', 'FlexLom1Port1', 'FlexLom1Port2', 'FlexLom1Port3', 'FlexLom1Port4', 'FlexLom1Port5', 'FlexLom1Port6', 'FlexLom1Port7', 'FlexLom1Port8', `
                'Slot1NicPort1', 'Slot1NicPort2', 'Slot1NicPort3', 'Slot1NicPort4', 'Slot1NicPort5', 'Slot1NicPort6', 'Slot1NicPort7', 'Slot1NicPort8', 'Slot2NicPort1', 'Slot2NicPort2', 'Slot2NicPort3', 'Slot2NicPort4', 'Slot2NicPort5', 'Slot2NicPort6', 'Slot2NicPort7', 'Slot2NicPort8', `
                'Slot3NicPort1', 'Slot3NicPort2', 'Slot3NicPort3', 'Slot3NicPort4', 'Slot3NicPort5', 'Slot3NicPort6', 'Slot3NicPort7', 'Slot3NicPort8', 'Slot4NicPort1', 'Slot4NicPort2', 'Slot4NicPort3', 'Slot4NicPort4', 'Slot4NicPort5', 'Slot4NicPort6', 'Slot4NicPort7', 'Slot4NicPort8', `
                'Slot5NicPort1', 'Slot5NicPort2', 'Slot5NicPort3', 'Slot5NicPort4', 'Slot5NicPort5', 'Slot5NicPort6', 'Slot5NicPort7', 'Slot5NicPort8', 'Slot6NicPort1', 'Slot6NicPort2', 'Slot6NicPort3', 'Slot6NicPort4', 'Slot6NicPort5', 'Slot6NicPort6', 'Slot6NicPort7', 'Slot6NicPort8', `
                'Slot7NicPort1', 'Slot7NicPort2', 'Slot7NicPort3', 'Slot7NicPort4', 'Slot7NicPort5', 'Slot7NicPort6', 'Slot7NicPort7', 'Slot7NicPort8', 'Slot8NicPort1', 'Slot8NicPort2', 'Slot8NicPort3', 'Slot8NicPort4', 'Slot8NicPort5', 'Slot8NicPort6', 'Slot8NicPort7', 'Slot8NicPort8')]
        [string]$PreBootNetwork,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'IPv4', 'IPv6')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'IPv4', 'IPv6')]
        [string]$PrebootNetworkEnvPolicy,
        
        [string]$PrebootNetworkProxy,
        [bool]$ProcAes,
        [bool]$ProcAMDBoost,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AmdFmaxBoostAuto', 'AmdFmaxBoostManual')]
        [string]$ProcAMDBoostControl,
        
        [int]$ProcAmdFmax,
        [bool]$ProcAmdIoVt,
        [bool]$ProcHyperthreading,
        [bool]$ProcSMT,
        [bool]$ProcTurbo,
        [bool]$ProcVirtualization,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Enabled', 'ForceEnabled', 'Disabled', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Enabled', 'ForceEnabled', 'Disabled', 'Auto')]
        [string]$ProcX2Apic,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Normal', 'Level1', 'Level2')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Normal', 'Level1', 'Level2')]
        [string]$ProcessorConfigTDPLevel,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'Auto-tuned', 'Manual-tuned')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'Auto-tuned', 'Manual-tuned')]
        [string]$ProcessorJitterControl,
        
        [int]$ProcessorJitterControlFrequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimizedForThroughput', 'OptimizedForLatency', 'ZeroLatency')]
        [string]$ProcessorJitterControlOptimization,

        [string]$Pstate0Frequency,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupply,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplyGpuDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BalancedMode', 'HighEfficiencyAuto', 'HighEfficiencyOddStandby', 'HighEfficiencyEvenStandby')]
        [string]$RedundantPowerSupplySystemDomain,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('InternalSdCardFirst', 'InternalKeysFirst', 'ExternalKeysFirst')]
        [string]$RemovableFlashBootSeq,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('CurrentRom', 'BackupRom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('CurrentRom', 'BackupRom')]
        [string]$RomSelection,

        [bool]$SanitizeAllNvDimmN,
        [bool]$SataSanitize,
        [bool]$SataSecureErase,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Ghesv1Support', 'Ghesv2Support')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Ghesv1Support', 'Ghesv2Support')]
        [string]$SciRasSupport,

        [bool]$SecStartBackupImage,
        [bool]$SecureBootStatus,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('BaudRate9600', 'BaudRate19200', 'BaudRate38400', 'BaudRate57600', 'BaudRate115200')]
        [string]$SerialConsoleBaudRate,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]    
        [ValidateSet('Vt100', 'Ansi', 'Vt100Plus', 'VtUtf8')]
        [string]$SerialConsoleEmulation,


        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Disabled', 'Physical', 'Virtual')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Disabled', 'Physical', 'Virtual')]
        [string]$SerialConsolePort,
        
        [string]$ServerAssetTag,
        [bool]$ServerConfigLockStatus,
        [string]$ServerOtherInfo,
        [string]$ServerPrimaryOs,
        [string]$ServiceEmail,
        [string]$ServiceName,
        [string]$ServiceOtherInfo,
        [string]$ServicePhone,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('GUI', 'Text', 'Auto')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('GUI', 'Text', 'Auto')]
        [string]$SetupBrowserSelection,     

        [bool]$Slot1MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot1NicBoot4,

        [bool]$Slot2MctpBroadcastSupport,        

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot2NicBoot4,

        [bool]$Slot3MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot3NicBoot4,

        [bool]$Slot4MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot4NicBoot4,

        [bool]$Slot5MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot5NicBoot4,

        [bool]$Slot6MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot6NicBoot4,
 
        [bool]$Slot7MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot7NicBoot4,

        [bool]$Slot8MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        
        [string]$Slot8NicBoot4,
            
        [bool]$Slot9MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot9NicBoot4,

        [bool]$Slot10MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]    
        [string]$Slot10NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
  
        [string]$Slot10NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]     
        [string]$Slot10NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]      
        [string]$Slot10NicBoot4,

        [bool]$Slot11MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot11NicBoot4,


        [bool]$Slot12MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot12NicBoot4,


        [bool]$Slot13MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot13NicBoot4,


        [bool]$Slot14MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot14NicBoot4,


        [bool]$Slot15MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot15NicBoot4,


        [bool]$Slot16MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot16NicBoot4,

        [bool]$Slot17MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot17NicBoot4,

        [bool]$Slot18MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot18NicBoot4,

        [bool]$Slot19MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot19NicBoot4,

        [bool]$Slot20MctpBroadcastSupport,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot1,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot2,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot3,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NetworkBoot', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NetworkBoot', 'Disabled')]
        [string]$Slot20NicBoot4,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot1StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot2StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot3StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot4StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot5StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot6StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot7StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot8StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot9StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot10StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot11StorageBoot,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot12StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot13StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot14StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot15StorageBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot16StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot17StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot18StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot19StorageBoot,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('AllTargets', 'TwentyFourTargets', 'ThirtyTwoTargets', 'NoTargets')]
        [string]$Slot20StorageBoot,

        [bool]$SpeculativeLockScheduling,
        [bool]$Sriov,


        [bool]$StaleAtoS,
        # When enabled, Sub-NUMA Clustering divides the processor's cores, cache, and memory into multiple NUMA domains. Enabling this feature can increase performance for workloads that are NUMA aware and optimized. Note: When this option is enabled, up to 1GB of system memory may become unavailable.
        
        [bool]$SubNumaClustering,

        [bool]$TPM2EndorsementDisable,
        [bool]$TPM2StorageDisable,

        # Use this option to select the fan cooling solution for the system. Optimal Cooling provides the most efficient solution by configuring fan speeds to the minimum required speed to provide adequate cooling. Increased Cooling runs fans at higher speeds to provide additional cooling. Select Increased Cooling when third-party storage controllers are cabled to the embedded hard drive cage, or if the system is experiencing thermal issues that cannot be resolved. Maximum cooling provides the maximum cooling available on this platform. Enhanced CPU Cooling runs the fans at a higher speed to provide additional cooling to the processors. Selecting Enhanced CPU Cooling may improve system performance with certain processor intensive workloads.
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptimalCooling', 'IncreasedCooling', 'MaxCooling', 'EnhancedCPUCooling')]
        [string]$ThermalConfig,

        [bool]$ThermalShutdown,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Utc', 'Local')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Utc', 'Local')]
        [string]$TimeFormat,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UtcM12', 'UtcM11', 'UtcM10', 'UtcM9 ', 'UtcM8', 'UtcM7', 'UtcM6', 'UtcM5', 'UtcM430', 'UtcM4', 'UtcM330', 'UtcM3', 'UtcM2', 'UtcM1', 'Utc0 ', 'UtcP1', 'UtcP2', 'UtcP3', 'UtcP330', 'UtcP4', 'UtcP430', 'UtcP5', 'UtcP530', 'UtcP545', 'UtcP6', 'UtcP630', 'UtcP7', 'UtcP8', 'UtcP9', 'UtcP930', 'UtcP10', 'UtcP11', 'UtcP12', 'UtcP13', 'UtcP14', 'Unspecified')]
        [string]$TimeZone,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Fifo', 'Crb')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Fifo', 'Crb')]
        [string]$Tpm20SoftwareInterfaceStatus,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Clear')]
        [string]$Tpm2Operation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'Sha1', 'Sha256', 'Sha1Sha256', 'Sha256Sha384')]
        [string]$TpmActivePcrs,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('None', 'StMicroGen10', 'IntelPttFTpm', 'NationzTpm20', 'STMicroGen10Plus', 'STMicroGen11')]
        [string]$TpmChipId,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotSpecified', 'NonFipsMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotSpecified', 'NonFipsMode', 'FipsMode')]
        [string]$TpmFips,
                
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'RegularMode', 'FipsMode')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'RegularMode', 'FipsMode')]
        [string]$TpmFipsModeSwitch,
                        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Tpm12', 'Tpm20')]
        [string]$TpmModeSwitchOperation,
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoAction', 'Enable', 'Disable', 'Clear')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoAction', 'Enable', 'Disable', 'Clear')]
        [string]$TpmOperation,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NotPresent', 'PresentDisabled', 'PresentEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NotPresent', 'PresentDisabled', 'PresentEnabled')]
        [string]$TpmState,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('NoTpm', 'Tpm12', 'Tpm20')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('NoTpm', 'Tpm12', 'Tpm20')]
        [string]$TpmType,
        
        [bool]$TpmUefiOpromMeasuring,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Hidden', 'Visible')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Hidden', 'Visible')]
        [string]$TpmVisibility,

        [bool]$TransparentSecureMemoryEncryption,
        [bool]$UefiOptimizedBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Disabled', 'ErrorsOnly', 'Medium', 'Network', 'Verbose', 'Custom')]
        [string]$UefiSerialDebugLevel,

        [bool]$UefiShellBootOrder,
        [bool]$UefiShellPhysicalPresenceKeystroke,
        [bool]$UefiShellScriptVerification,
        [bool]$UefiShellStartup,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'AttachedMedia', 'NetworkLocation')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'AttachedMedia', 'NetworkLocation')]
        [string]$UefiShellStartupLocation,
        
        [string]$UefiShellStartupUrl,
        [bool]$UefiShellStartupUrlFromDhcp,
        [bool]$UefiVariableAccessFwControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Maximum', 'Minimum')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Maximum', 'Minimum')]
        [string]$UncoreFreqScaling,

        [bool]$UpiPrefetcher,
        [string]$UrlBootFile,
        [string]$UrlBootFile2,
        [bool]$UsbBoot,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('UsbEnabled', 'UsbDisabled', 'ExternalUsbDisabled', 'InternalUsbDisabled')]
        [string]$UsbControl,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('English', 'Japanese', 'Chinese')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('English', 'Japanese', 'Chinese')]
        [string]$UtilityLang,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('OptionalVideoOnly', 'BothVideoEnabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('OptionalVideoOnly', 'BothVideoEnabled')]
        [string]$VideoOptions,

        [bool]$VirtualInstallDisk,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Com1Irq4', 'Com2Irq3', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Com1Irq4', 'Com2Irq3', 'Disabled')]
        [string]$VirtualSerialPort,
        
        
        [bool]$VlanControl,
        [int]$VlanId,
        [int]$VlanPriority,
        [bool]$WakeOnLan,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'Enabled', 'Disabled')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'Enabled', 'Disabled')]
        [string]$XptPrefetcher,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIForceLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Auto', 'x4', 'x8', 'x16')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('Auto', 'x4', 'x8', 'x16')]
        [string]$XGMIMaxLinkWidth,

        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('SoftwareInitiator', 'AdapterInitiator')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet('SoftwareInitiator', 'AdapterInitiator')]
        [string]$iSCSIPolicy,

        [bool]$iSCSISoftwareInitiator,

        [Switch]$WhatIf
      
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingBiosStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Bios
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord SettingNotFoundInCOM ObjectNotFound -TargetObject 'Setting' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID


            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
        
                if ($SettingResource.description) {
                            
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }       

        
            if (-not $PSBoundParameters.ContainsKey('WorkloadProfileName')) {
        
                if ($SettingResource.redfishData.Attributes.WorkloadProfile) {
                            
                    $WorkloadProfileName = $SettingResource.redfishData.Attributes.WorkloadProfile
                }

            }
            elseif ($WorkloadProfileName) {

                if ($WorkloadProfileName -eq "Virtual Radio Access Network (vRAN)") {
                    $WorkloadProfileName = "vRAN"
                }
            }


          
        
            $Attributes = @{ 

                WorkloadProfile = $WorkloadProfileName
                
            }



            #Region Booleaan parameters   

            $boolParametersList = @(
                'AccessControlService',
                'AcpiHpet',
                'AcpiRootBridgePxm',
                'AcpiSlit',
                'AdjSecPrefetch',
                'AdvCrashDumpMode',
                'AllowLoginWithIlo',
                'Amd5LevelPage',
                'AmdCdma',
                'AmdDmaRemapping',
                'AmdL1Prefetcher',
                'AmdL2Prefetcher',
                'AmdMemoryBurstRefresh',
                'AmdPeriodicDirectoryRinse',
                'AmdSecureMemoryEncryption',
                'AmdSecureNestedPaging',
                'AmdVirtualDrtmDevice',
                'ApplicationPowerBoost',
                'AsrStatus',
                'ChannelInterleaving',
                'CollabPowerControl',
                'CoreBoosting',
                'DcuIpPrefetcher',
                'DcuStreamPrefetcher',
                'Dhcpv4',
                'DramControllerPowerDown',
                'EmbNicPCIeOptionROM',
                'EmbSas1PcieOptionROM',
                'EmbSata1Aspm',
                'EmbSata1PCIeOptionROM',
                'EmbSata2Aspm',
                'EmbSata2PCIeOptionROM',
                'EmbSata3Aspm',
                'EmbSata3PCIeOptionROM',
                'EmbSata4Aspm',
                'EmbSata4PCIeOptionROM',
                'EmbeddedDiagnostics',
                'EmbeddedIpxe',
                'EmbeddedUefiShell',
                'EnergyEfficientTurbo',
                'EnhancedProcPerf',
                'ExtendedMemTest',
                'F11BootMenu',
                'FlexLom1PCIeOptionROM',
                'HwPrefetcher',
                'IntelNicDmaChannels',
                'IntelPerfMonitoring',
                'IntelProcVtd',
                'IntelTxt',
                'IntelUpiPowerManagement',
                'IntelligentProvisioning',
                'InternalSDCardSlot',
                'IpxeBootOrder',
                'IpxeScriptAutoStart',
                'IpxeScriptVerification',
                'LastLevelCacheAsNUMANode',
                'LLCDeadLineAllocation',
                'LlcPrefetch',
                'MemClearWarmReset',
                'MemFastTraining',
                'MemPatrolScrubbing',
                'MicrosoftSecuredCoreSupport',
                'MixedPowerSupplyReporting',
                'NetworkBootRetry',
                'NodeInterleaving',
                'NvDimmNMemFunctionality',
                'NvDimmNMemInterleaving',
                'NvdimmLabelSupport',
                'NvmeOptionRom',
                'Ocp1AuxiliaryPower',
                'Ocp2AuxiliaryPower',
                'OmitBootDeviceEvent',
                'OpportunisticSelfRefresh',
                'PciPeerToPeerSerialization',
                'PciSlot20OptionROM',
                'PciSlot19OptionROM',
                'PciSlot18OptionROM',
                'PciSlot17OptionROM',
                'PciSlot16OptionROM',
                'PciSlot15OptionROM',
                'PciSlot14OptionROM',
                'PciSlot13OptionROM',
                'PciSlot12OptionROM',
                'PciSlot11OptionROM',
                'PciSlot10OptionROM',
                'PciSlot9OptionROM',
                'PciSlot8OptionROM',
                'PciSlot7OptionROM',
                'PciSlot6OptionROM',
                'PciSlot5OptionROM',
                'PciSlot4OptionROM',
                'PciSlot3OptionROM',
                'PciSlot2OptionROM',
                'PciSlot1OptionROM',
                'PersistentMemAddressRangeScrub',
                'PersistentMemScanMem',
                'PlatformCertificate',
                'PowerButton',
                'ProcAes',
                'ProcAMDBoost',
                'ProcAmdIoVt',
                'ProcHyperthreading',
                'ProcSMT',
                'ProcTurbo',
                'ProcVirtualization',
                'SanitizeAllNvDimmN',
                'SataSanitize',
                'SataSecureErase',
                'SecStartBackupImage',
                'SecureBootStatus',
                'ServerConfigLockStatus',
                'Slot1MctpBroadcastSupport',
                'Slot2MctpBroadcastSupport',
                'Slot3MctpBroadcastSupport',
                'Slot4MctpBroadcastSupport',
                'Slot5MctpBroadcastSupport',
                'Slot6MctpBroadcastSupport',
                'Slot7MctpBroadcastSupport',
                'Slot8MctpBroadcastSupport',
                'Slot9MctpBroadcastSupport',
                'Slot10MctpBroadcastSupport',
                'Slot11MctpBroadcastSupport',
                'Slot12MctpBroadcastSupport',
                'Slot13MctpBroadcastSupport',
                'Slot14MctpBroadcastSupport',
                'Slot15MctpBroadcastSupport',
                'Slot16MctpBroadcastSupport',
                'Slot17MctpBroadcastSupport',
                'Slot18MctpBroadcastSupport',
                'Slot19MctpBroadcastSupport',
                'Slot20MctpBroadcastSupport',
                'SpeculativeLockScheduling',
                'Sriov',
                'StaleAtoS',
                'SubNumaClustering',
                'TPM2EndorsementDisable',
                'TPM2StorageDisable',
                'ThermalShutdown',
                'TpmUefiOpromMeasuring',
                'TransparentSecureMemoryEncryption',
                'UefiOptimizedBoot',
                'UefiShellBootOrder',
                'UefiShellPhysicalPresenceKeystroke',
                'UefiShellScriptVerification',
                'UefiShellStartup',
                'UefiShellStartupUrlFromDhcp',
                'UefiVariableAccessFwControl',
                'UpiPrefetcher',
                'UsbBoot',
                'VirtualInstallDisk',
                'VlanControl',
                'WakeOnLan',
                'iSCSISoftwareInitiator'

            )
        


            foreach ($boolparameter in $boolParametersList) {
            
                if ($PSBoundParameters.ContainsKey($boolparameter)) {
               
                    if ($PSBoundParameters[$boolparameter] -eq $True) {
            
                        $Attributes."$boolparameter" = "Enabled"
            
                    }
                    else {
                        $Attributes."$boolparameter" = "Disabled"
            
                    }
                }     
                elseif (-not $PSBoundParameters.ContainsKey($boolparameter)) {
                    
                    if ($SettingResource.redfishData.Attributes."$boolparameter") {
                            
                        $Attributes."$boolparameter" = $SettingResource.redfishData.Attributes."$boolparameter"
                    }

                }   
            }

            #EndRegion


            #Region String + Integer parameters

            $stringparametersList = @(
                'AdminEmail',
                'AdminName',
                'AdminOtherInfo',
                'AdminPhone',
                'AdvancedMemProtection',
                'AmdCstC2Latency',
                'AmdMemPStates',
                'AmdXGMILinkSpeed',
                'AsrTimeoutMinutes',
                'AssetTagProtection',
                'AutoPowerOn',
                'BootOrderPolicy',
                'ConsistentDevNaming',
                'CustomPostMessage',
                'CustomPstate0',
                'DataFabricCStateEnable',
                'DaylightSavingsTime',
                'DeterminismControl',
                'DirectToUpi',
                'DynamicPowerCapping',
                'EmbNicAspm',
                'EmbNicEnable',
                'EmbNicLinkSpeed',
                'EmbSas1Aspm',
                'EmbSas1Boot',
                'EmbSas1Enable',
                'EmbSas1LinkSpeed',
                'EmbSata1Enable',
                'EmbSata2Enable',
                'EmbSata3Enable',
                'EmbSata4Enable',
                'EmbVideoConnection',
                'EmbeddedSata',
                'EmbeddedSerialPort',
                'EmsConsole',
                # 'EnabledCoresPerProcIlo6', # Removed as iLO5 and 6 do not use the same value types
                # 'EnabledCoresPerProcIlo5',
                'EnergyPerfBias',
                'ExtendedAmbientTemp',
                'FCScanPolicy',
                'FanFailPolicy',
                'FanInstallReq',
                'FlexLom1Aspm',
                'FlexLom1Enable',
                'FlexLom1LinkSpeed',
                'HourFormat',
                'HttpSupport',
                'InfinityFabricPstate',
                'IntelDmiLinkFreq',
                'IntelSpeedSelect',
                'IntelUpiFreq',
                'IntelUpiLinkEn',
                'IntelVmdDirectAssign',
                'IntelVmdSupport',
                'IntelVrocSupport',
                'IpmiWatchdogTimerAction',
                'IpmiWatchdogTimerStatus',
                'IpmiWatchdogTimerTimeout',
                'Ipv4Address',
                'Ipv4Gateway',
                'Ipv4PrimaryDNS',
                'Ipv4SubnetMask',
                'Ipv6Address',
                'Ipv6ConfigPolicy',
                'Ipv6Duid',
                'Ipv6Gateway',
                'Ipv6PrimaryDNS',
                'Ipv6SecondaryDNS',
                'IpxeAutoStartScriptLocation',
                'IpxeStartupUrl',
                'LocalRemoteThreshold',
                'MaxMemBusFreqMHz',
                'MaxPcieSpeed',
                'MemMirrorMode',
                'MemRefreshRate',
                'MemoryControllerInterleaving',
                'MemoryRemap',
                'MinProcIdlePkgState',
                'MinProcIdlePower',
                'MinimumSevAsid',
                'NetworkBootRetryCount',
                'NicBoot1',
                'NicBoot2',
                'NicBoot3',
                'NicBoot4',
                'NicBoot5',
                'NicBoot6',
                'NicBoot7',
                'NicBoot8',
                'NicBoot9',
                'NicBoot10',
                'NicBoot11',
                'NicBoot12',
                'NumaGroupSizeOpt',
                'NumaMemoryDomainsPerSocket',
                'NvDimmNSanitizePolicy',
                'PackagePowerLimitControlMode',
                'PackagePowerLimitValue',
                'PatrolScrubDuration',
                'PciResourcePadding',
                'PciSlot20Aspm',
                'PciSlot20Bifurcation',
                'PciSlot20Enable',
                'PciSlot20LinkSpeed',
                'PciSlot19Aspm',
                'PciSlot19Bifurcation',
                'PciSlot19Enable',
                'PciSlot19LinkSpeed',
                'PciSlot18Aspm',
                'PciSlot18Bifurcation',
                'PciSlot18Enable',
                'PciSlot18LinkSpeed',
                'PciSlot17Aspm',
                'PciSlot17Bifurcation',
                'PciSlot17Enable',
                'PciSlot17LinkSpeed',
                'PciSlot16Aspm',
                'PciSlot16Bifurcation',
                'PciSlot16Enable',
                'PciSlot16LinkSpeed',
                'PciSlot15Aspm',
                'PciSlot15Bifurcation',
                'PciSlot15Enable',
                'PciSlot15LinkSpeed',
                'PciSlot14Aspm',
                'PciSlot14Bifurcation',
                'PciSlot14Enable',
                'PciSlot14LinkSpeed',
                'PciSlot13Aspm',
                'PciSlot13Bifurcation',
                'PciSlot13Enable',
                'PciSlot13LinkSpeed',
                'PciSlot12Aspm',
                'PciSlot12Bifurcation',
                'PciSlot12Enable',
                'PciSlot12LinkSpeed',
                'PciSlot11Aspm',
                'PciSlot11Bifurcation',
                'PciSlot11Enable',
                'PciSlot11LinkSpeed',
                'PciSlot10Aspm',
                'PciSlot10Bifurcation',
                'PciSlot10Enable',
                'PciSlot10LinkSpeed',
                'PciSlot9Aspm',
                'PciSlot9Bifurcation',
                'PciSlot9Enable',
                'PciSlot9LinkSpeed',
                'PciSlot8Aspm',
                'PciSlot8Bifurcation',
                'PciSlot8Enable',
                'PciSlot8LinkSpeed',
                'PciSlot7Aspm',
                'PciSlot7Bifurcation',
                'PciSlot7Enable',
                'PciSlot7LinkSpeed',
                'PciSlot6Aspm',
                'PciSlot6Bifurcation',
                'PciSlot6Enable',
                'PciSlot6LinkSpeed',
                'PciSlot5Aspm',
                'PciSlot5Bifurcation',
                'PciSlot5Enable',
                'PciSlot5LinkSpeed',
                'PciSlot4Aspm',
                'PciSlot4Bifurcation',
                'PciSlot4Enable',
                'PciSlot4LinkSpeed',
                'PciSlot3Aspm',
                'PciSlot3Bifurcation',
                'PciSlot3Enable',
                'PciSlot3LinkSpeed',
                'PciSlot2Aspm',
                'PciSlot2Bifurcation',
                'PciSlot2Enable',
                'PciSlot2LinkSpeed',
                'PciSlot1Aspm',
                'PciSlot1Bifurcation',
                'PciSlot1Enable',
                'PciSlot1LinkSpeed',
                'PerformanceDeterminism',
                'PersistentMemBackupPowerPolicy',
                'PlatformRASPolicy',
                'PostAsr',
                'PostAsrDelay',
                'PostBootProgress',
                'PostDiscoveryMode',
                'PostF1Prompt',
                'PostScreenMode',
                'PostVideoSupport',
                'PowerOnDelay',
                'PowerRegulator',
                'PreBootNetwork',
                'PrebootNetworkEnvPolicy',
                'PrebootNetworkProxy',
                'ProcAMDBoostControl',
                'ProcAmdFmax',
                'ProcX2Apic',
                'ProcessorConfigTDPLevel',
                'ProcessorJitterControl',
                'ProcessorJitterControlFrequency',
                'ProcessorJitterControlOptimization',
                'Pstate0Frequency',
                'RedundantPowerSupply',
                'RedundantPowerSupplyGpuDomain',
                'RedundantPowerSupplySystemDomain',
                'RemovableFlashBootSeq',
                'RomSelection',
                'SciRasSupport',
                'SerialConsoleBaudRate',
                'SerialConsoleEmulation',
                'SerialConsolePort',
                'ServerAssetTag',
                'ServerOtherInfo',
                'ServerPrimaryOs',
                'ServiceEmail',
                'ServiceName',
                'ServiceOtherInfo',
                'ServicePhone',
                'SetupBrowserSelection',
                'Slot1NicBoot1',
                'Slot1NicBoot2',
                'Slot1NicBoot3',
                'Slot1NicBoot4',
                'Slot2NicBoot1',
                'Slot2NicBoot2',
                'Slot2NicBoot3',
                'Slot2NicBoot4',
                'Slot3NicBoot1',
                'Slot3NicBoot2',
                'Slot3NicBoot3',
                'Slot3NicBoot4',
                'Slot4NicBoot1',
                'Slot4NicBoot2',
                'Slot4NicBoot3',
                'Slot4NicBoot4',
                'Slot5NicBoot1',
                'Slot5NicBoot2',
                'Slot5NicBoot3',
                'Slot5NicBoot4',
                'Slot6NicBoot1',
                'Slot6NicBoot2',
                'Slot6NicBoot3',
                'Slot6NicBoot4',
                'Slot7NicBoot1',
                'Slot7NicBoot2',
                'Slot7NicBoot3',
                'Slot7NicBoot4',
                'Slot8NicBoot1',
                'Slot8NicBoot2',
                'Slot8NicBoot3',
                'Slot8NicBoot4',
                'Slot9NicBoot1',
                'Slot9NicBoot2',
                'Slot9NicBoot3',
                'Slot9NicBoot4',
                'Slot10NicBoot1',
                'Slot10NicBoot2',
                'Slot10NicBoot3',
                'Slot10NicBoot4',
                'Slot11NicBoot1',
                'Slot11NicBoot2',
                'Slot11NicBoot3',
                'Slot11NicBoot4',
                'Slot12NicBoot1',
                'Slot12NicBoot2',
                'Slot12NicBoot3',
                'Slot12NicBoot4',
                'Slot13NicBoot1',
                'Slot13NicBoot2',
                'Slot13NicBoot3',
                'Slot13NicBoot4',
                'Slot14NicBoot1',
                'Slot14NicBoot2',
                'Slot14NicBoot3',
                'Slot14NicBoot4',
                'Slot15NicBoot1',
                'Slot15NicBoot2',
                'Slot15NicBoot3',
                'Slot15NicBoot4',
                'Slot16NicBoot1',
                'Slot16NicBoot2',
                'Slot16NicBoot3',
                'Slot16NicBoot4',
                'Slot17NicBoot1',
                'Slot17NicBoot2',
                'Slot17NicBoot3',
                'Slot17NicBoot4',
                'Slot18NicBoot1',
                'Slot18NicBoot2',
                'Slot18NicBoot3',
                'Slot18NicBoot4',
                'Slot19NicBoot1',
                'Slot19NicBoot2',
                'Slot19NicBoot3',
                'Slot19NicBoot4',
                'Slot20NicBoot1',
                'Slot20NicBoot2',
                'Slot20NicBoot3',
                'Slot20NicBoot4',
                'Slot1StorageBoot',
                'Slot2StorageBoot',
                'Slot3StorageBoot',
                'Slot4StorageBoot',
                'Slot5StorageBoot',
                'Slot6StorageBoot',
                'Slot7StorageBoot',
                'Slot8StorageBoot',
                'Slot9StorageBoot',
                'Slot10StorageBoot',
                'Slot11StorageBoot',
                'Slot12StorageBoot',
                'Slot13StorageBoot',
                'Slot14StorageBoot',
                'Slot15StorageBoot',
                'Slot16StorageBoot',
                'Slot17StorageBoot',
                'Slot18StorageBoot',
                'Slot19StorageBoot',
                'Slot20StorageBoot',
                'ThermalConfig',
                'TimeFormat',
                'TimeZone',
                'Tpm20SoftwareInterfaceOperation',
                'Tpm20SoftwareInterfaceStatus',
                'Tpm2Operation',
                'TpmActivePcrs',
                'TpmChipId',
                'TpmFips',
                'TpmFipsModeSwitch',
                'TpmModeSwitchOperation',
                'TpmOperation',
                'TpmState',
                'TpmType',
                'TpmVisibility',
                'UefiSerialDebugLevel',
                'UefiShellStartupLocation',
                'UefiShellStartupUrl',
                'UncoreFreqScaling',
                'UrlBootFile',
                'UrlBootFile2',
                'UsbControl',
                'UtilityLang',
                'VideoOptions',
                'VirtualSerialPort',
                'VlanId',
                'VlanPriority',
                'XptPrefetcher',
                'XGMIForceLinkWidth',
                'XGMIMaxLinkWidth',
                'iSCSIPolicy'
            )

            foreach ($stringparameter in $stringparametersList) {
                
                if ($PSBoundParameters.ContainsKey($stringparameter)) {
                    
                    $param1Value = $PSBoundParameters[$stringparameter]

                    $Attributes."$stringparameter" = $param1Value
                }
                elseif (-not $PSBoundParameters.ContainsKey($stringparameter)) {

                    if ($SettingResource.redfishData.Attributes."$stringparameter") {
                            
                        $Attributes."$stringparameter" = $SettingResource.redfishData.Attributes."$stringparameter"
                    }

                }

            }


            if ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo6')) {

                $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo6
            } 
            elseif ($PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo5')) {

                $Attributes.EnabledCoresPerProc = $EnabledCoresPerProcIlo5
                
            }
            elseif (-not $PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo5') -and -not $PSBoundParameters.ContainsKey('EnabledCoresPerProcIlo6')) {

                if ($SettingResource.redfishData.Attributes.EnabledCoresPerProc) {
                    
                    $Attributes.EnabledCoresPerProc = $SettingResource.redfishData.Attributes.EnabledCoresPerProc
                }

            }



            if ($AsrTimeoutMinutes) {
                $Attributes.AsrStatus = "Enabled"

            }


            if ($SubNumaClustering) {
                # Options that must be enabled when Sub-Numa Clustering (SNC) is enabled:
                $Attributes.XptPrefetcher = "Enabled"
                $Attributes.UpiPrefetcher = "Enabled"
            }

            #EndRegion

            

            # Build paylaod

            if ($Attributes.length -gt 1) {
                
                $RequireCustomProfile = $True #$SettingResource.enableCustomWorkloadProfile
            }

            if ($RequireCustomProfile) {
                
                $Default = @{ 
                    redfishData                 = @{
                        Attributes = $Attributes
                    }
                    enableCustomWorkloadProfile = $True
                }
            }
            else {
                
                $Default = @{ 
                    redfishData = @{
                        Attributes = $Attributes
                    }
                }

            }

            $Settings = @{ 
                DEFAULT = $Default
            }

            $payload = @{ 
                name           = $Name
                category       = "BIOS"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                if (-not $WhatIf ) {
        
                    "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Bios server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                        
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Bios server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Bios server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingBiosStatus.add($objStatus)
    
    }
    
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingBiosStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more bios server settings failed the modification attempt!"
          
            }
            
            Return $SetServerSettingBiosStatus
        
        }

    }
}


Function New-HPECOMSettingServerInternalStorage {
    <#
    .SYNOPSIS
    Configures an internal storage server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new internal storage server setting with specified RAID type and size.
    Internal storage server settings enable consistent storage configurations across servers in a group.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Specifies the name of the internal storage server setting.

    .PARAMETER Description
    Provides a description for the internal storage server setting.

    .PARAMETER RAID
    Specifies the RAID type:
        - RAID0: Uses disk striping, optimized for I/O speed and efficient physical disk capacity use, but offers no data redundancy. Utilizes one drive.
        - RAID1: Uses disk mirroring, optimized for data redundancy and I/O speed, but uses more physical disks. Utilizes two drives.
        - RAID5: Uses disk striping with parity, optimized for performance and fault tolerance. Utilizes three drives.
        
    .PARAMETER SizeinGB
    Specifies the OS volume size in GB. A suitable disk(s) will be selected and the volume created.

    .PARAMETER EntireDisk
    A switch parameter that specifies using the entire disk when creating the volume.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. Useful for understanding the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID-1" -RAID RAID1 -Description "My RAID1 server setting for the OS" -SizeinGB 100 

    Creates a new RAID1 internal storage server setting named 'RAID-1' with a size of 100GB in the central European region.

    .EXAMPLE
    New-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID-5" -RAID RAID5 -EntireDisk 

    Creates a new RAID5 internal storage server setting named 'RAID-5' in the central European region, utilizing the entire disk.

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the internal storage server setting attempted to be created.
        * Region - The name of the region.
        * Status - The creation attempt's status (Failed for HTTP error return; Complete if successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.

     

    #>


    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $RAIDs = @('RAID0', 'RAID1', 'RAID5')
                $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredRAIDs | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RAID0', 'RAID1', 'RAID5')]
        [String]$RAID,
        
        [Parameter (Mandatory, ParameterSetName = 'Size')]
        [Int]$SizeinGB,

        [Parameter (Mandatory, ParameterSetName = 'EntireDisk')]
        [Switch]$EntireDisk,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingInternalStorageStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Storage

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {
            Throw "Error! '$Name' setting already exists in the COM '$Region' region!"

        }


        # Build payload

        if ($EntireDisk) {
            $SizeinGB = -1
        }

        $Settings = @{ 
            DEFAULT = @{
                raidType       = $RAID
                volumeSizeInGB = $SizeinGB
            }
        }

        $payload = @{ 
            name           = $Name
            category       = "STORAGE"
            description    = $Description
            platformFamily = "ANY"
            settings       = $Settings                  
        }

        $payload = ConvertTo-Json $payload -Depth 10 

        try {

            $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

            if (-not $WhatIf ) {
    
                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                "[{0}] Internal storage server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Internal storage server setting successfully created in $Region region"


            }
        }
        catch {

            if (-not $WhatIf) {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Internal storage server setting cannot be created!"
                $objStatus.Exception = $_.Exception.message 

            }
        } 

        [void] $NewServerSettingInternalStorageStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingInternalStorageStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more internal storage server settings failed the creation attempt!"
          
            }
            
            Return $NewServerSettingInternalStorageStatus
        
        }

    }
}


Function Set-HPECOMSettingServerInternalStorage {
    <#
    .SYNOPSIS
    Update an internal storage server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies an internal storage server setting resource in a given region. If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.

    .PARAMETER Name
    Specifies the name of the internal storage server setting to update.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER NewName 
    Specifies the new name for the internal storage server setting.

    .PARAMETER Description
    Specifies a new description of the internal storage server setting.

    .PARAMETER RAID
    Specifies the RAID type:
        - RAID0: Uses disk striping. Optimized for I/O speed and efficient use of physical disk capacity, but provides no data redundancy.
        - RAID1: Uses disk mirroring. Optimized for data redundancy and I/O speed, but uses more physical disk drives.
        - RAID5: Uses disk striping with parity. Optimized for performance and fault tolerance.

    .PARAMETER SizeinGB
    Specifies OS volume size in GB. When used, a suitable disk(s) will be selected and the volume will be created.

    .PARAMETER EntireDisk
    Switch parameter to specify the use of the entire disk. When used, a volume would be created using all the disks on the server.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID1" -NewName "RAID-1"

    This example updates the name of the internal storage server setting from "RAID1" to "RAID-1" in the "eu-central" region.

    .EXAMPLE
    Set-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID1" -Description "Local storage settings using RAID1 and entire disk for OS"
    
    This example updates the description of the internal storage server setting "RAID1" in the "eu-central" region, describing it as "Local storage settings using RAID1 and entire disk for OS".

    .EXAMPLE
    Set-HPECOMSettingServerInternalStorage -Region eu-central -Name "RAID1" -NewName "RAID-5" -RAID RAID5 -SizeinGB 150
    
    This example changes the name of the internal storage server setting from "RAID1" to "RAID-5", sets the RAID type to RAID5, and specifies the OS volume size as 150 GB in the "eu-central" region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category Storage | Set-HPECOMSettingServerInternalStorage -EntireDisk 
    
    This example retrieves all storage settings from the "eu-central" region and pipes them to update the internal storage server setting to use the entire disk.

    .INPUTS
    System.Collections.ArrayList
        List of internal storage server settings from 'Get-HPECOMSetting -Category Storage'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the internal storage server setting attempted to be updated
        * Region - The name of the region
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        # [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $RAIDs = @('RAID0', 'RAID1', 'RAID5')
                $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredRAIDs | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('RAID0', 'RAID1', 'RAID5')]
        [String]$RAID,
        
        [Parameter (ParameterSetName = 'Size')]
        [Int]$SizeinGB,

        [Parameter (ParameterSetName = 'EntireDisk')]
        [switch]$EntireDisk,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingInternalStorageStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Storage
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord SettingNotFoundInCOM ObjectNotFound -TargetObject 'Setting' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }            

            if (-not $EntireDisk -and -not $SizeinGB) {
                $SizeinGB = $SettingResource.settings.default.volumeSizeInGB
            }
            elseif ($EntireDisk) {
                $SizeinGB = -1
            }

            if (-not $RAID) {
                $RAID = $SettingResource.settings.default.raidType
            }

            # Build payload

            $Settings = @{ 
                DEFAULT = @{
                    raidType       = $RAID
                    volumeSizeInGB = $SizeinGB
                }
            }

            $payload = @{ 
                name           = $Name
                category       = "STORAGE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Internal storage server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Internal storage server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Internal storage server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingInternalStorageStatus.add($objStatus)

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingInternalStorageStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more internal storage server settings failed the modification attempt!"
          
            }
            
            Return $SetServerSettingInternalStorageStatus
        
        }

    }
}



Function New-HPECOMSettingServerOSImage {
    <#
    .SYNOPSIS
    Configure an OS image configuration server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new operating system image configuration server setting.
    OS image configurations enable consistent OS installations across servers in a group.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Specifies the name of the OS image configuration server setting.

    .PARAMETER Description
    Provides a description for the OS image configuration server setting.

    .PARAMETER OperatingSystem
    Specifies the operating system:
        - VMware ESXi
        - Microsoft Windows
        - Red Hat Enterprise Linux
        - Suse Linux

    Note: Compute Ops Management can detect completion of operating system install via HPE Agentless Management Service. 
          Ensure that the operating system image includes HPE Agentless Management Service utility.
    
    .PARAMETER OSImageURL
    Specifies the full URL location of the OS image.

    Example: https://hostname.domain.com/ImageName.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. 
          Ensure that iLO can access the virtual media URL and that there are no connectivity issues

    .PARAMETER UnattendedInstallationFileImageUrl
    Specifies the full URL location of the ISO file for the unattended installation file image.

    Example: https://hostname.domain.com/kickstart.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. 
          Ensure that iLO can access the virtual media URL and that there are no connectivity issues

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region  us-west -Name OS-ESX -Description "My ESX OS image SS" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx.iso" 

    This command creates a new OS image configuration server setting named 'OS-ESX' using a single image containing OS and unattended installation file from the URL 'https://domain.com/esx8.iso' in the 'us-west' region.

    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region us-west -Name OS-ESX -Description "My ESX 8 OS image configuration" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx8.iso" -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso" 
    
    This command creates a new OS image configuration server setting named 'OS-ESX' using a separate image for OS from the URL 'https://domain.com/esx8.iso' and for the unattended file from the URL 'https://domain.com/esx_ks.iso'.

    .INPUTS
    Pipeline input is not supported.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the OS image configuration server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

     
    
   #>

    [CmdletBinding()]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $RAIDs = @('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX')
                $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredRAIDs | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX')]
        [String]$OperatingSystem,
        
        [Parameter (Mandatory, ParameterSetName = 'SingleImage')]
        [Parameter (Mandatory, ParameterSetName = 'SeparateImages')]
        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$OSImageURL,

        [Parameter (Mandatory, ParameterSetName = 'SeparateImages')]
        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$UnattendedInstallationFileImageUrl,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingOSImageConfigurationStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Os

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {
            Throw "Error! '$Name' setting already exists in the COM '$Region' region!"

        }
        
        # Build payload

        if ($UnattendedInstallationFileImageUrl) {

            $Settings = @{ 
                DEFAULT = @{
                    osType                        = $OperatingSystem
                    mediaUrl                      = $OSImageURL
                    unattendedInstallationFileUrl = $UnattendedInstallationFileImageUrl

                }
            }
        }
        else {
            
            $Settings = @{ 
                DEFAULT = @{
                    osType   = $OperatingSystem
                    mediaUrl = $OSImageURL
                }
            }
        }


        $payload = @{ 
            name           = $Name
            category       = "OS"
            description    = $Description
            platformFamily = "ANY"
            settings       = $Settings                  
        }

        $payload = ConvertTo-Json $payload -Depth 10 

        try {

            $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

            if (-not $WhatIf ) {
    
                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                "[{0}] OS image configuration server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "OS image configuration server setting successfully created in $Region region"


            }
        }
        catch {

            if (-not $WhatIf) {

                $objStatus.Status = "Failed"
                $objStatus.Details = "OS image configuration server setting cannot be created!"
                $objStatus.Exception = $_.Exception.message 

            }
        } 

        [void] $NewServerSettingOSImageConfigurationStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingOSImageConfigurationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more OS image configuration server settings failed the creation attempt!"
          
            }
            
            Return $NewServerSettingOSImageConfigurationStatus
        
        }

    }
}



Function Set-HPECOMSettingServerOSImage {
    <#
    .SYNOPSIS
    Update the configuration of an OS image server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies an OS image configuration server setting resource in a designated Compute Ops Management (COM) region. If certain parameters are not specified, the cmdlet retains their existing settings and only updates those that are provided.

    .PARAMETER Name
    Specifies the name of the OS image configuration server setting to update.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER NewName 
    Specifies the new name for the OS image configuration server setting.

    .PARAMETER Description
    Specifies a new description for the OS image configuration server setting.

    .PARAMETER OperatingSystem
    Specifies the new operating system:
        - VMware ESXi
        - Microsoft Windows
        - Red Hat Enterprise Linux
        - SUSE Linux

    Note: Compute Ops Management can detect the completion of an operating system install via HPE Agentless Management Service. Ensure that the OS image includes this utility.

    .PARAMETER OSImageURL
    Specifies the new full URL location of the OS image.

    Example: https://hostname.domain.com/ImageName.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. Ensure that iLO can access the virtual media URL without any connectivity issues.

    .PARAMETER UnattendedInstallationFileImageUrl
    Specifies the new full URL location of the ISO file for the unattended installation file image.

    Example: https://hostname.domain.com/kickstart.iso

    Note: Compute Ops Management uses the iLO virtual media feature for operating system installation. Ensure that iLO can access the virtual media URL without any connectivity issues.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMSettingServerOSImage -Region eu-central -Name OS_ESXi -NewName ESXi_800

    This command updates the name of the OS image configuration server setting from 'OS_ESXi' to 'ESXi_800' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerOSImage -Region eu-central -Name OS_ESXi -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso"
    
    This command updates the URL for the unattended installation file image to "https://domain.com/esx_ks.iso" for the OS image configuration named 'OS_ESXi' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerOSImage -Region eu-central -Name OS_ESXi -Description "OS Image for ESXi 8.00" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.lab/deployment/esxi80u2/VMware-ESXi-8.0.2-22380479-HPE-802.0.0.11.4.0.14-Sep2023.iso" -UnattendedInstallationFileImageUrl ""
    
    This command updates multiple parameters for the OS image configuration named 'OS_ESXi':
     - Sets the description to "OS Image for ESXi 8.00"
     - Specifies the operating system as 'VMware ESXi'
     - Updates the OS image URL to the provided link
     - Clears the unattended installation file image URL
    This modification is applied in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category OS | Set-HPECOMSettingServerOSImage -Description "My new description"
    
    This command first retrieves all OS image configuration settings in the 'eu-central' region using 'Get-HPECOMSetting'.
    It then pipes the retrieved settings into 'Set-HPECOMSettingServerOSImage' to update the description of each setting to "My new description".

    .INPUTS
    System.Collections.ArrayList
    List of internal OS image configuration settings from 'Get-HPECOMSetting -Category OS'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the OS image configuration server setting attempted to be updated.
        * Region - The name of the region.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information regarding any exceptions generated during the operation.

    #>

    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $RAIDs = @('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX')
                $filteredRAIDs = $RAIDs | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredRAIDs | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('MICROSOFT_WINDOWS', 'VMWARE_ESXI', 'RHEL', 'SUSE_LINUX')]
        [String]$OperatingSystem,
        
        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$OSImageURL,

        [ValidateScript({
                if ($_ -match "^(http|https)://[^\s/$.?#].[^\s]*$") {
                    $true
                }
                elseif ($_ -eq "") { 
                    $true
                }
                else {
                    throw "The value '$($_)' is not a valid URL."
                }
            })]
        [string]$UnattendedInstallationFileImageUrl,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Os
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord SettingNotFoundInCOM ObjectNotFound -TargetObject 'Setting' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }            

          
            if (-not $OperatingSystem) {
                $OperatingSystem = $SettingResource.settings.default.osType
            }

            #  -UnattendedInstallationFileImageUrl "" must work as the unattended file is not mandatory so it should remove the UnattendedInstallationFileImageUrl if present
            if (-not $PSBoundParameters.ContainsKey('UnattendedInstallationFileImageUrl') ) {

                if ($SettingResource.settings.default.unattendedInstallationFileUrl) {

                    $UnattendedInstallationFileImageUrl = $SettingResource.settings.default.unattendedInstallationFileUrl
                }

            }

            if (-not $OSImageURL) {
                $OSImageURL = $SettingResource.settings.default.mediaUrl
            }

        
            if ($UnattendedInstallationFileImageUrl) {

                $Settings = @{ 
                    DEFAULT = @{
                        osType                        = $OperatingSystem
                        mediaUrl                      = $OSImageURL
                        unattendedInstallationFileUrl = $UnattendedInstallationFileImageUrl

                    }
                }
            }
            else {
            
                $Settings = @{ 
                    DEFAULT = @{
                        osType   = $OperatingSystem
                        mediaUrl = $OSImageURL
                    }
                }
            }


            $payload = @{ 
                name           = $Name
                category       = "OS"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] OS Image server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "OS Image server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "OS Image server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingStatus.add($objStatus)

        
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more OS Image server settings failed the modification attempt!"
          
            }
            
            Return $SetServerSettingStatus
        
        }

    }
}



Function New-HPECOMSettingServerFirmware {
    <#
    .SYNOPSIS
    Configure a firmware server setting.

    .DESCRIPTION
    This Cmdlet creates a new firmware baseline server setting with baseline and hotfix or patch settings.
    Firmware server settings enable you to apply consistent firmware configurations to servers in a group. 
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Specifies the name of the firmware server setting.

    .PARAMETER Description
    Specifies a description for the firmware server setting.

    .PARAMETER Gen10FirmwareBundleReleaseVersion
    Specifies the name of a baseline SPP or hotfix/patch bundle for Gen10/Gen10+ servers. 
    
    .PARAMETER Gen11FirmwareBundleReleaseVersion
    Specifies the name of a baseline SPP or hotfix/patch bundle for Gen11 servers. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM. 
   
    .EXAMPLE
    $Gen10_Firmware_Bundle = Get-HPECOMFirmwareBundle -Region eu-central -Generation 10 | select -first 1 | ForEach-Object releaseversion
    $Gen11_Firmware_Bundle = Get-HPECOMFirmwareBundle -Region eu-central -Generation 11 | select -first 1 | ForEach-Object releaseversion

    New-HPECOMSettingServerFirmware -Region eu-central -Name Latest_Firmware_Bundle -Description "Server setting to update servers to latest firmware bundle" -Gen10FirmwareBundleReleaseVersion $Gen10_Firmware_Bundle -Gen11FirmwareBundleReleaseVersion $Gen11_Firmware_Bundle

    Create a new firmware server setting using dynamically retrieved firmware bundle release versions for Gen10/Gen10+ and Gen11 servers.

    .EXAMPLE
    New-HPECOMSettingServerFirmware -Region us-west -Name SPP-2024.04.00.01 -Description "Server setting to update servers to 2024-04-00-01 firmware bundle" -Gen10FirmwareBundleReleaseVersion 2024.04.00.01 -Gen11FirmwareBundleReleaseVersion 2024.04.00.01 

    Create a new firmware server setting using specified firmware bundle release versions for Gen10 and Gen11 servers.
       
    .INPUTS
    Pipeline input is not supported.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the firmware server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.


    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Together')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory, ParameterSetName = 'Gen10Baseline')]
        [Parameter (ParameterSetName = 'Together')]
        [String]$Gen10FirmwareBundleReleaseVersion,

        [Parameter (Mandatory, ParameterSetName = 'Gen11Baseline')]
        [Parameter (ParameterSetName = 'Together')]
        [String]$Gen11FirmwareBundleReleaseVersion,
        
        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingFirmwareStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Firmware

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {
            Throw "Error! '$Name' setting already exists in the COM '$Region' region!"

        }
        
        # Build payload

        if ($Gen10FirmwareBundleReleaseVersion -and -not $Gen11FirmwareBundleReleaseVersion) {

            try {
                $Gen10FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen10FirmwareBundleReleaseVersion -Generation 10).id
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $Gen10FirmwareBundleID) {

                # Must return a message if SN/Name not found
                
                $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion
                $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
            
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
            else {
                
                $Settings = @{ 
                    GEN10 = @{
                        id = $Gen10FirmwareBundleID
    
                    }
                }
            }

        }
        elseif ($Gen10FirmwareBundleReleaseVersion -and $Gen11FirmwareBundleReleaseVersion) {

            try {
                $Gen10FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen10FirmwareBundleReleaseVersion -Generation 10).id
                $Gen11FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen11FirmwareBundleReleaseVersion -Generation 11).id
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $Gen10FirmwareBundleID) {

                # Must return a message if not found
                
                $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion
                $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
            
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
            elseif (-not $Gen10FirmwareBundleID -and -not $Gen11FirmwareBundleID) {
                
                # Must return a message if not found
                
                $ErrorMessage = "Firmware bundles '{0}' and '{1}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion, $Gen11FirmwareBundleReleaseVersion
                $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
            
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)                

            }
            elseif (-not $Gen11FirmwareBundleID) {

                # Must return a message if not found
                
                $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen11FirmwareBundleReleaseVersion
                $ErrorRecord = New-ErrorRecord FirmwareBundlesNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen11FirmwareBundleReleaseVersion.GetType().Name
            
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
            else {
            
                $Settings = @{ 
                    GEN10 = @{
                        id = $Gen10FirmwareBundleID

                    }
                    GEN11 = @{
                        id = $Gen11FirmwareBundleID

                    }
                }
            }
        }
        elseif ($Gen11FirmwareBundleReleaseVersion -and -not $Gen10FirmwareBundleReleaseVersion ) {

            try {
                $Gen11FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen11FirmwareBundleReleaseVersion -Generation 11).id
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            if (-not $Gen11FirmwareBundleID) {

                # Must return a message if SN/Name not found
                
                $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen11FirmwareBundleReleaseVersion
                $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen11FirmwareBundleReleaseVersion.GetType().Name
            
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
            else {
            
                $Settings = @{ 
                    GEN11 = @{
                        id = $Gen11FirmwareBundleID

                    }
                }
            }
        }

        $payload = @{ 
            name           = $Name
            category       = "FIRMWARE"
            description    = $Description
            platformFamily = "ANY"
            settings       = $Settings                  
        }

        $payload = ConvertTo-Json $payload -Depth 10 

        try {

            $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

            if (-not $WhatIf ) {
    
                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                "[{0}] Firmware server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Firmware server setting successfully created in $Region region"


            }
        }
        catch {

            if (-not $WhatIf) {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Firmware server setting cannot be created!"
                $objStatus.Exception = $_.Exception.message 

            }
        } 

        [void] $NewServerSettingFirmwareStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingFirmwareStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Firmware server settings failed the creation attempt!"
          
            }
            
            Return $NewServerSettingFirmwareStatus
        
        }

    }
}


Function Set-HPECOMSettingServerFirmware {
    <#
    .SYNOPSIS
    Updates the configuration of a firmware server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies a firmware server setting resource within a designated Compute Ops Management (COM) region. If certain parameters are not specified, the cmdlet retains their existing settings and only updates those that are provided.

    .PARAMETER Name
    Specifies the name of the firmware server setting to update.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER NewName 
    Specifies the new name for the firmware server setting.

    .PARAMETER Description
    Provides a new description for the firmware server setting.

    .PARAMETER Gen10FirmwareBundleReleaseVersion
    Specifies the release version of the new baseline SPP or hotfix/patch bundle for Gen10/Gen10+ servers. 

    .PARAMETER Gen11FirmwareBundleReleaseVersion
    Specifies the release version of the new baseline SPP or hotfix/patch bundle for Gen11 servers. 

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the native REST API calls utilized by COM.

    .EXAMPLE
    Set-HPECOMSettingServerFirmware -Region eu-central -Name ESXi_firmware_baseline_24_04_Gen10 -NewName ESXi_firmware_baseline

    This example updates the name of the firmware server setting from 'ESXi_firmware_baseline_24_04_Gen10' to 'ESXi_firmware_baseline' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerFirmware -Region eu-central -Name ESXi_firmware_baseline_24_04_Gen10 -Gen11FirmwareBundleReleaseVersion 2024.04.00.01

    This example updates the Gen11 firmware bundle release version of the server setting named 'ESXi_firmware_baseline_24_04_Gen10' to '2024.04.00.01' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerFirmware -Region eu-central -Name RHEL_firmware_baseline_2024_04_00_01 -Gen10FirmwareBundleReleaseVersion "2024.04.00.01" -Gen11FirmwareBundleReleaseVersion 2024.04.00.01 

    This example updates both the Gen10 and Gen11 firmware bundle release versions of the server setting named 'RHEL_firmware_baseline_2024_04_00_01' to '2024.04.00.01' in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Category FIRMWARE -Name WIN_firmware_baseline | Set-HPECOMSettingServerFirmware -Description "FW server settings for 2024.04.00.02 Gen10 bundle" -Gen10FirmwareBundleReleaseVersion "2024.04.00.02"

    This example uses pipeline input to update the description and Gen10 firmware bundle release version of the server setting named 'WIN_firmware_baseline' retrieved from the 'eu-central' region.

    .INPUTS
    System.Collections.ArrayList
        List of firmware settings from 'Get-HPECOMSetting -Category FIRMWARE'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the firmware server setting attempted to be updated.
        * Region - The name of the region.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information regarding any exceptions generated during the operation.

    #>
    
    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [String]$Gen10FirmwareBundleReleaseVersion,

        [String]$Gen11FirmwareBundleReleaseVersion,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category Firmware
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord SettingNotFoundInCOM ObjectNotFound -TargetObject 'Setting' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }     
            
            # Using containsKey to allow removing an already set parameter using -Gen10FirmwareBundleReleaseVersion ""
            if (-not $PSBoundParameters.ContainsKey('Gen10FirmwareBundleReleaseVersion') ) {
                
                if ($SettingResource.settings.GEN10.id) {

                    $Gen10FirmwareBundleID = $SettingResource.settings.GEN10.id
                    $Gen10FirmwareBundleReleaseVersion = $True
                }
            }
            elseif ($PSBoundParameters.ContainsKey('Gen10FirmwareBundleReleaseVersion')) {
                
                try {
                    $Gen10FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen10FirmwareBundleReleaseVersion -Generation 10).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }
    
                if (-not $Gen10FirmwareBundleID) {
    
                    # Must return a message if SN/Name not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen10FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen10FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
                
            }

            if (-not $PSBoundParameters.ContainsKey('Gen11FirmwareBundleReleaseVersion') ) {
                
                if ($SettingResource.settings.GEN11.id) {

                    $Gen11FirmwareBundleID = $SettingResource.settings.GEN11.id
                    $Gen11FirmwareBundleReleaseVersion = $True

                }
            }
            elseif ($PSBoundParameters.ContainsKey('Gen11FirmwareBundleReleaseVersion')) {

                try {
                    $Gen11FirmwareBundleID = (Get-HPECOMFirmwareBundle -Region $Region -IsActive -ReleaseVersion $Gen11FirmwareBundleReleaseVersion -Generation 11).id
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                    
                }
    
                if (-not $Gen11FirmwareBundleID) {
    
                    # Must return a message if SN/Name not found
                    
                    $ErrorMessage = "Firmware bundle '{0}' cannot be found in the Compute Ops Management instance!" -f $Gen11FirmwareBundleReleaseVersion
                    $ErrorRecord = New-ErrorRecord FirmwareBundleNotFoundInCOM ObjectNotFound -TargetObject 'Firmware-bundles' -Message $ErrorMessage -TargetType $Gen11FirmwareBundleReleaseVersion.GetType().Name
                
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }
            }


            if ($Gen10FirmwareBundleReleaseVersion -and -not $Gen11FirmwareBundleReleaseVersion) {

                $Settings = @{ 
                    GEN10 = @{
                        id = $Gen10FirmwareBundleID
    
                    }
                }
            }

            elseif ($Gen10FirmwareBundleReleaseVersion -and $Gen11FirmwareBundleReleaseVersion) {
                
                $Settings = @{ 
                    GEN10 = @{
                        id = $Gen10FirmwareBundleID
    
                    }
                    GEN11 = @{
                        id = $Gen11FirmwareBundleID
    
                    }
                }
            }

            elseif ($Gen11FirmwareBundleReleaseVersion -and -not $Gen10FirmwareBundleReleaseVersion ) {
                
                $Settings = @{ 
                    GEN11 = @{
                        id = $Gen11FirmwareBundleID
    
                    }
                }

            }  


            $payload = @{ 
                name           = $Name
                category       = "FIRMWARE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] Firmware server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Firmware server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Firmware server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more firmware server settings failed the modification attempt!"
          
            }
            
            Return $SetServerSettingStatus
        
        }

    }
}


Function New-HPECOMSettingServerExternalStorage {
    <#
    .SYNOPSIS
    Configures an external storage server setting.

    .DESCRIPTION
    This Cmdlet is used to create a new external storage server setting to utilize an external storage resource managed within Data Ops Manager.
    External storage server settings enable you to apply a consistent external storage configuration to servers in a group.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name
    Specifies the name of the external storage server setting.

    .PARAMETER Description
    Provides a description for the external storage server setting.

    .PARAMETER HostOSType
    Specifies the OS installed on the server:
        - UNKNOWN
        - AIX
        - APPLE
        - CITRIX_HYPERVISOR
        - HP_UX
        - IBM_VIO_SERVER
        - INFORM
        - NETAPP
        - OE_LINUX_UEK
        - OPENVMS
        - ORACLE_VM
        - RHE_LINUX
        - RHE_VIRTUALIZATION
        - SOLARIS
        - SUSE_LINUX
        - SUSE_VIRTUALIZATION
        - UBUNTU
        - VMWARE_ESXI
        - WINDOWS_SERVER
   
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region  us-west -Name OS-ESX -Description "My ESX OS image SS" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx.iso" 

    This command creates a new OS image configuration server setting named 'OS-ESX' using a single image containing OS and unattended installation file from the URL 'https://domain.com/esx8.iso' in the 'us-west' region.

    .EXAMPLE
    New-HPECOMSettingServerOSImage -Region us-west -Name OS-ESX -Description "My ESX 8 OS image configuration" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx8.iso" -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso" 
    
    This command creates a new OS image configuration server setting named 'OS-ESX' using a separate image for OS from the URL 'https://domain.com/esx8.iso' and for the unattended file from the URL 'https://domain.com/esx_ks.iso'.

    .INPUTS
    Pipeline input is not supported.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - The name of the external storage server setting attempted to be created
        * Region - The name of the region
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Together')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER"
                )
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER")]
        [String]$HostOSType,

        
        [Switch]$WhatIf
       
    ) 
    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $NewServerSettingFirmwareStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category ExternalStorage

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($SettingResource) {
            Throw "Error! '$Name' setting already exists in the COM '$Region' region!"

        }
        
        # Build payload
        $Settings = @{ 
            DEFAULT = @{
                externalStorageHostOs = $HostOSType

            }
        }

        $payload = @{ 
            name           = $Name
            category       = "EXTERNAL_STORAGE"
            description    = $Description
            platformFamily = "ANY"
            settings       = $Settings                  
        }

        $payload = ConvertTo-Json $payload -Depth 10 

        try {

            $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

            if (-not $WhatIf ) {
    
                "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                "[{0}] Firmware server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Firmware server setting successfully created in $Region region"


            }
        }
        catch {

            if (-not $WhatIf) {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Firmware server setting cannot be created!"
                $objStatus.Exception = $_.Exception.message 

            }
        } 

        [void] $NewServerSettingFirmwareStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($NewServerSettingFirmwareStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more Firmware server settings failed the creation attempt!"
          
            }
            
            Return $NewServerSettingFirmwareStatus
        
        }

    }
}


Function Set-HPECOMSettingServerExternalStorage {
    <#
    .SYNOPSIS
    Updates the configuration of an external storage server setting resource in a specified region.

    .DESCRIPTION
    This Cmdlet modifies an external storage server setting resource within a designated Compute Ops Management (COM) region. If certain parameters are not specified, the cmdlet retains their existing settings and only updates those that are provided.

    .PARAMETER Name
    Specifies the name of the external storage server setting to update.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER NewName 
    Specifies the new name for the external storage server setting.

    .PARAMETER Description
    Provides a new description for the external storage server setting.

    .PARAMETER HostOSType
    Specifies the OS installed on the server. 

    "UNKNOWN" "AIX" "APPLE" "CITRIX_HYPERVISOR" "HP_UX" "IBM_VIO_SERVER" "INFORM" "NETAPP" "OE_LINUX_UEK" "OPENVMS" "ORACLE_VM" "RHE_LINUX" "RHE_VIRTUALIZATION" "SOLARIS" "SUSE_LINUX" "SUSE_VIRTUALIZATION" "UBUNTU" "VMWARE_ESXI" "WINDOWS_SERVER"
        
    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the native REST API calls utilized by COM.

    .EXAMPLE
    Set-HPECOMSettingServerExternalStorage -Region eu-central -Name AI -NewName AI-External-Storage

    This example updates the name of the external storage server setting from 'AI' to 'AI-External-Storage' in the 'eu-central' region.

    .EXAMPLE
    Set-HPECOMSettingServerExternalStorage -Region eu-central -Name AI-External-Storage -Description "External storage for AI hosts" -HostOSType RHE_LINUX    

    This example updates the description to 'External storage for AI hosts' and sets the host OS type to 'RHE_LINUX' for the external storage server setting named 'AI-External-Storage' in the 'eu-central' region.

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name AI -Category ExternalStorage | Set-HPECOMSettingServerExternalStorage -Description "External storage for VMware hosts" -NewName "WMWARE-External-Storage"

    This example uses pipeline input to update the description to 'External storage for VMware hosts' and the name to 'WMWARE-External-Storage' for the external storage server setting named 'AI' retrieved from the 'eu-central' region.

    .INPUTS
    System.Collections.ArrayList
    List of external storage settings from 'Get-HPECOMSetting -Category ExternalStorage'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Name - The name of the external storage server setting attempted to be updated.
        * Region - The name of the region.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information regarding any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'EntireDisk')]
    Param( 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -le 100 })]
        [String]$Name,  

        [ValidateScript({ $_.Length -le 100 })]
        [String]$NewName,
        
        [ValidateScript({ $_.Length -le 1000 })]
        [String]$Description,    
        
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Values = @("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER"
                )
                $FilteredValues = $Values | Where-Object { $_ -like "$wordToComplete*" }
                return $FilteredValues | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet("UNKNOWN", "AIX", "APPLE", "CITRIX_HYPERVISOR", "HP_UX", "IBM_VIO_SERVER", "INFORM", "NETAPP", "OE_LINUX_UEK", "OPENVMS", "ORACLE_VM", "RHE_LINUX", "RHE_VIRTUALIZATION", "SOLARIS", "SUSE_LINUX", "SUSE_VIRTUALIZATION", "UBUNTU", "VMWARE_ESXI", "WINDOWS_SERVER")]
        [String]$HostOSType,

        [Switch]$WhatIf
       
    ) 
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMSettingsUri
        $SetServerSettingStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
    
        try {
            $SettingResource = Get-HPECOMSetting -Region $Region -Name $Name -Category ExternalStorage
            $SettingID = $SettingResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }


        if (-not $SettingResource) {
            
            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Setting '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                $ErrorRecord = New-ErrorRecord SettingNotFoundInCOM ObjectNotFound -TargetObject 'Setting' -Message $ErrorMessage -TargetType $Name.GetType().Name
                $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Setting cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $Uri = $COMSettingsUri + "/" + $SettingID

            # Conditionally add properties
            if ($NewName) {
                $Name = $NewName
            }

            if (-not $PSBoundParameters.ContainsKey('Description')) {
	    
                if ($SettingResource.description) {
                              
                    $Description = $SettingResource.description
                }
                else {
                    $Description = $Null
                }
            }     
            
            if (-not $PSBoundParameters.ContainsKey('HostOSType') ) {
                
                if ($SettingResource.settings.default.externalStorageHostOs) {

                    $HostOSType = $SettingResource.settings.default.externalStorageHostOs
                }
            }
         

            # Build payload
            $Settings = @{ 
                DEFAULT = @{
                    externalStorageHostOs = $HostOSType
                }
            }

            $payload = @{ 
                name           = $Name
                category       = "EXTERNAL_STORAGE"
                description    = $Description
                platformFamily = "ANY"
                settings       = $Settings                  
            }

            $payload = ConvertTo-Json $payload -Depth 10 

            try {

                $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 


                if (-not $WhatIf ) {
    
                    "[{0}] Setting update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

                    "[{0}] External storage server setting '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "External storage server setting successfully updated in $Region region"


                }
            }
            catch {

                if (-not $WhatIf) {

                    $objStatus.Status = "Failed"
                    $objStatus.Details = "External storage server setting cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 

                }
            } 
        }

        [void] $SetServerSettingStatus.add($objStatus)

        

    
    }
    
    End {
       

        if (-not $WhatIf ) {

            if ($SetServerSettingStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more external storage server settings failed the modification attempt!"
          
            }
            
            Return $SetServerSettingStatus
        
        }

    }
}

# NOT IMPLEMENTED YET
# Function New-HPECOMSettingOneViewApplianceSettings {
#     <#
#     .SYNOPSIS
#     Configure a OneView appliance settings.

#     .DESCRIPTION
#     This Cmdlet creates a new setting for OneView appliances settings
    
#     Appliance settings allow you to create a set of common configuration preferences that you can easily apply to one or more appliances in a Compute Ops Management group.
    
#     .PARAMETER Region 
#     Specifies the Compute Ops Management region.

#     .PARAMETER Name
#     Specifies the name of the external storage server setting.

#     .PARAMETER Description
#     Specifies a description of the external storage server setting.

#     .PARAMETER HostOSType
#     Specifies the OS installed on the server. 

#     "UNKNOWN" "AIX" "APPLE" "CITRIX_HYPERVISOR" "HP_UX" "IBM_VIO_SERVER" "INFORM" "NETAPP" "OE_LINUX_UEK" "OPENVMS" "ORACLE_VM" "RHE_LINUX" "RHE_VIRTUALIZATION" "SOLARIS" "SUSE_LINUX" "SUSE_VIRTUALIZATION" "UBUNTU" "VMWARE_ESXI" "WINDOWS_SERVER"
    
#     .PARAMETER WhatIf 
#     Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
#     .EXAMPLE
#     New-HPECOMSettingServerOSImage -Region  us-west -Name OS-ESX -Description "My ESX OS image SS" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx.iso" 

#     This command creates a new OS image configuration server setting named 'OS-ESX' using a single image containing OS and unattended installation file from the URL 'https://domain.com/esx8.iso' in the 'us-west' region.

#     .EXAMPLE
#     New-HPECOMSettingServerOSImage -Region us-west -Name OS-ESX -Description "My ESX 8 OS image configuration" -OperatingSystem VMWARE_ESXI -OSImageURL "https://domain.com/esx8.iso" -UnattendedInstallationFileImageUrl "https://domain.com/esx_ks.iso" 
    
#     This command creates a new OS image configuration server setting named 'OS-ESX' using a separate image for OS from the URL 'https://domain.com/esx8.iso' and for the unattended file from the URL 'https://domain.com/esx_ks.iso'.

#     .INPUTS
#     Pipeline input is not supported.
    
#     .OUTPUTS
#     System.Collections.ArrayList
#         A custom status object or array of objects containing the following PsCustomObject keys:
#         * Name - The name of the external storage server setting attempted to be created
#         * Region - The name of the region
#         * Status - Status of the creation attempt (Failed for HTTP error return; Complete if creation is successful; Warning if no action is needed)
#         * Details - More information about the status 
#         * Exception: Information about any exceptions generated during the operation.

    
#    #>
#     [CmdletBinding(DefaultParameterSetName = 'Together')]
#     Param( 
#         [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
#         [ArgumentCompleter({
#                 param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
#                 # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
#                 $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
#                     [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
#                 }
#             })]
#         [String]$Region,

#         [Parameter (Mandatory)]
#         [ValidateScript({ $_.Length -le 100 })]
#         [String]$Name,  
        
#         [ValidateScript({ $_.Length -le 1000 })]
#         [String]$Description,    
        

        
#         [Switch]$WhatIf
       
#     ) 
#     Begin {
        
#         $Caller = (Get-PSCallStack)[1].Command

#         "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

#         $Uri = $COMSettingsUri
#         $NewServerSettingFirmwareStatus = [System.Collections.ArrayList]::new()
        
#     }
    
#     Process {
        
#         "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

#         # Build object for the output
#         $objStatus = [pscustomobject]@{
  
#             Name      = $Name
#             Region    = $Region                            
#             Status    = $Null
#             Details   = $Null
#             Exception = $Null
#         }
    
        
#         # Build payload
#         $Settings = @{ 
#             DEFAULT = @{
#                 externalStorageHostOs = $HostOSType

#             }
#         }

#         $payload = @{ 
#             name           = $Name
#             category       = "EXTERNAL_STORAGE"
#             description    = $Description
#             platformFamily = "ANY"
#             settings       = $Settings                  
#         }

#         $payload = ConvertTo-Json $payload -Depth 10 

#         try {

#             $_resp = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -ContentType "application/json" -WhatIfBoolean $WhatIf 

#             if (-not $WhatIf ) {
    
#                 "[{0}] Response returned: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_resp | Write-Verbose

#                 "[{0}] Firmware server setting '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose
                    
#                 $objStatus.Status = "Complete"
#                 $objStatus.Details = "Firmware server setting successfully created in $Region region"


#             }
#         }
#         catch {

#             if (-not $WhatIf) {

#                 $objStatus.Status = "Failed"
#                 $objStatus.Details = "Firmware server setting cannot be created!"
#                 $objStatus.Exception = $_.Exception.message 

#             }
#         } 

#         [void] $NewServerSettingFirmwareStatus.add($objStatus)

        

    
#     }
    
#     End {
       

#         if (-not $WhatIf ) {

#             if ($NewServerSettingFirmwareStatus | Where-Object { $_.Status -eq "Failed" }) {
  
#                 write-error "One or more Firmware server settings failed the creation attempt!"
          
#             }
            
#             Return $NewServerSettingFirmwareStatus
        
#         }

#     }
# }



Function Remove-HPECOMSetting {
    <#
    .SYNOPSIS
    Remove a server setting from a region.

    .DESCRIPTION
    This Cmdlet can be used to remove a server setting resource from a region using its name property.       
        
    .PARAMETER Name 
    Name of the server setting to remove. 
    
    .PARAMETER Region 
    Name of the region where to remove a server setting. 

    .PARAMETER Force
    Switch parameter to force the removal. 
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMSetting -Region eu-central -Name 'RAID1' 
    
    Remove the server setting named 'RAID1' from the central EU region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central -Name RAID-1 | Remove-HPECOMSetting 

    Remove server setting 'RAID-1' from the western central EU region. 

    .EXAMPLE 
    Get-HPECOMSetting -Region us-west | Where-Object {$_.name -eq 'RAID1' -or $_.name -eq 'RAID5'} | Remove-HPECOMSetting
    
    Remove server setting 'RAID1' and 'RAID5' from the western US region. 

    .EXAMPLE
    Get-HPECOMSetting -Region eu-central | Remove-HPECOMSetting -Force

    Remove all server settings from the central EU region using the force removal. 

    .INPUTS
    System.Collections.ArrayList
        List of server settings from 'Get-HPECOMSetting'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the server setting attempted to be removed
        * Region - Name of the region
        * Status - Status of the removal attempt (Failed for http error return; Complete if removal is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveSettingstatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
                
        try {
            $settingResource = Get-HPECOMSetting -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
                     
        $settingID = $settingResource.id

        
        if (-not $settingID) {

            # Must return a message if not found

            if ($WhatIf) {

                $ErrorMessage = "Server setting '{0}' cannot be found in the Compute Ops Management instance!" -f $Name       
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Server setting cannot be found in the Compute Ops Management instance!"
            }
        }
        elseif ($settingID -match "00000000-0000-0000-0000") {

            if ($WhatIf) {

                $ErrorMessage = "Server setting '{0}' is an HPE pre-defined setting and cannot be removed from the Compute Ops Management instance!" -f $Name       
                Write-warning $ErrorMessage
                return
            
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "This server setting is an HPE pre-defined setting that cannot be removed from the Compute Ops Management instance!"
            }
        }
        else {
            
            if ($Force) {

                $Uri = $COMSettingsUri + "/" + $settingID + "?Force=true"
            }
            else {
                
                $Uri = $COMSettingsUri + "/" + $settingID
            }

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {
                    
                    "[{0}] Server setting removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Server setting '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Server setting successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Server setting cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveSettingstatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveSettingstatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more settings has failed!"

          
            }
            
            Return $RemoveSettingstatus
        }


    }
}






#EndRegion


#Region --- SERVERS ---

Function Get-HPECOMServer {
    <#
    .SYNOPSIS
    Retrieve the list of servers.
    
    .DESCRIPTION
    This Cmdlet returns a collection of server resources in the specified region. Switch parameters can be used to retrieve specific data such as alerts, external storage details, notification status, security parameters, adapter to switch port mapping, and to check the presence of storage volume for OS installation.
    
    For server inventory data, you must use 'Get-HPECOMServerInventory'.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.
    
    .PARAMETER Name 
    Specifies the host name of the server to display. 
    
    .PARAMETER Model 
    Optional parameter that can be used to display a specific server model only, such as 'ProLiant DL380 Gen11', 'ProLiant DL365 Gen11', etc. 
    Partial model names are not supported.
    
    .PARAMETER ConnectionType
    Optional parameter that can be used to display servers based on the connection type (Direct or OneView).
    
    .PARAMETER ConnectedState
    A Boolean value (True or False). When set to True, only servers that are connected to HPE GreenLake will be displayed. When set to False, only servers that are not connected will be displayed.
    
    .PARAMETER PowerState
    A value of ON or OFF. When set to ON, only servers that are powered on will be displayed. When set to OFF, only servers that are powered off will be displayed.

    .PARAMETER Limit 
    This parameter allows you to define a limit on the number of servers to be displayed. 
    
    .PARAMETER ShowGroupMembership 
    Optional parameter that can be used to get the server group membership.

    .PARAMETER ShowGroupFirmwareCompliance
    Optional parameter that can be used when a server is a member of a group to get the group firmware compliance. 
    This parameter allows you to check if the server is compliant with the group's firmware baseline (if any).
      
    .PARAMETER ShowGroupFirmwareDeviation
    Optional parameter that can be used when a server is member of a group to get the group firmware deviation.
    This parameter can be useful for identifying deviations from the group's firmware baseline (if any), ensuring that the server is up to date and compliant with the group (if any).

    .PARAMETER ShowLocation 
    Optional parameter that can be used to get the server location.
    
    .PARAMETER ShowAlerts 
    Optional parameter that can be used to get the server alerts. 
    
    .PARAMETER ShowNotificationStatus 
    Optional parameter that can be used to get the server notification status. 
    
    .PARAMETER ShowSecurityParameters 
    Optional parameter that can be used to get the server security parameters. 

    .PARAMETER ShowSecurityParametersDetails 
    Optional parameter that can be used to get the server security parameter details. 
    
    .PARAMETER ShowAdapterToSwitchPortMappings 
    Optional parameter that can be used to get the network connectivity of the adapter port to the connected switch port of the server. 
    
    .PARAMETER ShowAutoiLOFirmwareUpdateStatus
    Optional parameter that can be used to get the status of the automatic iLO firmware update configuration.

    .PARAMETER ShowExternalStorageDetails 
    Optional parameter that can be used to get the server external storage details. 
   
    .PARAMETER CheckifserverHasStorageVolume 
    Optional parameter that can be used to validate the presence of a storage volume for the server 
    specified for operating system installation. The response returned is a boolean.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central

    Returns data for all servers located in the Central European region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Limit 50

    Returns the first 50 servers located in the Central European region. 
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name sles15sp4

    Returns the server data for the server named 'sles15sp4' located in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab 

    Returns the server data for the server with the name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowGroupMembership

    This command returns the group membership of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMserver -Region eu-central -Name ESX-1 -ShowGroupFirmwareCompliance 

    This command returns the group firmware compliance report of the server with name 'ESX-1' if it is a member of a group with a compatible firmware baseline.

    .EXAMPLE
    Get-HPECOMserver -Region eu-central -Name ESX-1 -ShowGroupFirmwareDeviation 

    This command returns the firmware components of the server with name 'ESX-1' that have deviations from the group's firmware baseline if it is a member of a group with a compatible firmware baseline.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowAlerts

    This command returns the alerts of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ShowLocation

    This command returns the location of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowLocation

    This command returns the location of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowNotificationStatus

    This command returns the notification status of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ShowSecurityParameters

    This command returns the security parameters of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowSecurityParameters

    This command returns the security parameters of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowSecurityParametersDetails

    This command returns the security parameters details of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowAdapterToSwitchPortMappings

    This command returns the adapter to switch port mappings of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ShowAutoiLOFirmwareUpdateStatus

    This command returns the auto iLO firmware update status of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowAutoiLOFirmwareUpdateStatus

    This command returns the auto iLO firmware update status of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -ShowExternalStorageDetails

    This command returns the external storage details of the server with name 'ESX-1.domain.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectedState False
    
    Lists all servers that are not connected to Compute Ops Management.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectedState True -PowerState ON

    Lists all servers that are powered on and connected to Compute Ops Management.
    
    .EXAMPLE
    Get-HPECOMServer -Region us-west -Model "ProLiant DL325 Gen10 Plus" -PowerState ON 

    Lists all ProLiant DL325 Gen10 Plus servers that are powered on.
    
    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name ESX-1.domain.lab -CheckIfServerHasStorageVolume

    This command returns a True or False to indicate if the server with name 'ESX-1.domain.lab' has a storage volume for OS installation.

    .EXAMPLE
    "ESX-1", "ESX-2" | Get-HPECOMServer -Region eu-central

    Returns all servers that match the names given in the pipeline.

    .EXAMPLE
    "ESX-1", "ESX-2" | Get-HPECOMServer -Region eu-central -ShowSecurityParameters

    Retrieves server security parameters for the two servers with the specified names in the pipeline.

    .EXAMPLE
    Get-HPECOMServer -Limit 2 | Get-HPECOMServer -Region eu-central -ShowNotificationStatus 
    
    Gets the first two servers in HPE GreenLake and passes their names into the pipeline to retrieve their server notification status.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's names.
    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

#>

    [CmdletBinding(DefaultParameterSetName = 'ByName')]
    Param( 
    
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ByName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupMembershipName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupFirmwareCompliance')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupFirmwareDeviation')]
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'Location')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AlertsName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ExternalStorageDetailsName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'NotificationStatusName')]
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SecurityParameters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SecurityParametersDetailsName')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [String]$Name,
    
        # Parameter sets are different from Get-HPECOMServerBySerialNumber as a server name is not unique like a serial number is.
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'GroupMembershipName')]
        [Parameter (ParameterSetName = 'GroupFirmwareCompliance')]
        [Parameter (ParameterSetName = 'GroupFirmwareDeviation')]
        [Parameter (ParameterSetName = 'Location')]
        [Parameter (ParameterSetName = 'AlertsName')]
        [Parameter (ParameterSetName = 'NotificationStatusName')]
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [String]$Model,
       
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'GroupMembershipName')]       
        [Parameter (ParameterSetName = 'GroupFirmwareCompliance')]
        [Parameter (ParameterSetName = 'GroupFirmwareDeviation')]
        [Parameter (ParameterSetName = 'Location')]
        [Parameter (ParameterSetName = 'AlertsName')]
        [Parameter (ParameterSetName = 'NotificationStatusName')]
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Direct', 'OneView')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Direct', 'OneView')]
        [String]$ConnectionType,

        
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'GroupMembershipName')]
        [Parameter (ParameterSetName = 'GroupFirmwareCompliance')]
        [Parameter (ParameterSetName = 'GroupFirmwareDeviation')]
        [Parameter (ParameterSetName = 'Location')]
        [Parameter (ParameterSetName = 'AlertsName')]
        [Parameter (ParameterSetName = 'NotificationStatusName')]
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('True', 'False')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('True', 'False')]
        [String]$ConnectedState,

        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'GroupMembershipName')]
        [Parameter (ParameterSetName = 'GroupFirmwareCompliance')]
        [Parameter (ParameterSetName = 'GroupFirmwareDeviation')]
        [Parameter (ParameterSetName = 'Location')]
        [Parameter (ParameterSetName = 'AlertsName')]
        [Parameter (ParameterSetName = 'NotificationStatusName')]
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('ON', 'OFF')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('ON', 'OFF')]
        [String]$PowerState,
    
        [Parameter (ParameterSetName = 'ByName')]
        [Parameter (ParameterSetName = 'Other')]
        [Parameter (ParameterSetName = 'GroupMembershipName')]
        [Parameter (ParameterSetName = 'GroupFirmwareCompliance')]
        [Parameter (ParameterSetName = 'GroupFirmwareDeviation')]
        [Parameter (ParameterSetName = 'Location')]
        [Parameter (ParameterSetName = 'AlertsName')]
        [Parameter (ParameterSetName = 'NotificationStatusName')]
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Parameter (ParameterSetName = 'ExternalStorageDetailsName')]
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [ValidateScript({ $_ -le 100 })]
        [int]$Limit,

        [Parameter (ParameterSetName = 'GroupMembershipName')]
        [Switch]$ShowGroupMembership,

        [Parameter (ParameterSetName = 'GroupFirmwareCompliance')]
        [Switch]$ShowGroupFirmwareCompliance,
    
        [Parameter (ParameterSetName = 'GroupFirmwareDeviation')]
        [Switch]$ShowGroupFirmwareDeviation,

        [Parameter (ParameterSetName = 'Location')]
        [Switch]$ShowLocation,
    
        [Parameter (ParameterSetName = 'AlertsName')]
        [Switch]$ShowAlerts,
    
        [Parameter (ParameterSetName = 'NotificationStatusName')]
        [Switch]$ShowNotificationStatus,
        
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Switch]$ShowSecurityParameters,
        
        [Parameter (ParameterSetName = 'SecurityParametersDetailsName')]
        [Switch]$ShowSecurityParametersDetails,
        
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsName')]
        [Switch]$ShowAdapterToSwitchPortMappings,
        
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Switch]$ShowAutoiLOFirmwareUpdateStatus,
        
        [Parameter (ParameterSetName = 'ExternalStorageDetailsName')]
        [Switch]$ShowExternalStorageDetails,
        
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeName')]
        [Switch]$CheckIfServerHasStorageVolume,

        [Switch]$WhatIf
        
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $COMServersUri 
   
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($Name) {       

            # $Uri = $COMServersUri + "?filter=name eq '$Name'"   # Filter that supports only serial numbers
            $Uri = $COMServersUri + "?filter=host/hostname eq '$Name'"  
        }
        else {
            
            $Uri = $COMServersUri 

        }       
        


           
        if ($PSBoundParameters.ContainsKey('Model')) {

            if ($Uri -match "\?filter=" ) {
                
                $Uri = $Uri + " and hardware/model eq '$Model'"

            }
            else {

                $Uri = $Uri + "?filter=hardware/model eq '$Model'"

            }
        }
       
        if ($PSBoundParameters.ContainsKey('ConnectedState')) {

            if ($ConnectedState -eq 'True') {	
    
                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and state/connected eq true"

                }
                else {
                    $Uri = $Uri + "?filter=state/connected eq true"

                }
            }
            else {

                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and state/connected eq false"

                }
                else {
                    $Uri = $Uri + "?filter=state/connected eq false"

                }
            }
        }

        if ($PSBoundParameters.ContainsKey('PowerState')) {

            if ($PowerState -eq 'ON') {    

                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and hardware/powerState eq 'ON'"

                }
                else {
                    $Uri = $Uri + "?filter=hardware/powerState eq 'ON'"

                }               
            }
            else {

                if ($Uri -match "\?filter=" ) {

                    $Uri = $Uri + " and hardware/powerState eq 'OFF'"

                }
                else {
                    $Uri = $Uri + "?filter=hardware/powerState eq 'OFF'"

                }   
            }
        }

        if ($PSBoundParameters.ContainsKey('Limit')) {
            
            if ($Uri -match "\?") {
                
                $Uri = $Uri + "&limit=$Limit"

            }
            else {
            
                $Uri = $Uri + "?limit=$Limit"

            }

        }


        # Set $Uri
        if (        $ShowGroupMembership `
                -or ($ShowLocation -and $Name) `
                -or $ShowAlerts `
                -or $ShowExternalStorageDetails `
                -or $ShowNotificationStatus `
                -or ($ShowSecurityParameters -and $Name) `
                -or $ShowSecurityParametersDetails `
                -or $ShowAdapterToSwitchPortMappings `
                -or $CheckifserverHasStorageVolume `
                # -or $ShowAutoiLOFirmwareUpdateStatus `
        ) {
                

            try {
                [Array]$Server = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region

                if ($Null -eq $Server) { 
                
                    Return
           
                }
                elseif ($server.count -gt 1) {
                    throw "Multiple servers found with the name '$Name'. Please refine your query to return only one server or use the serial number with 'Get-HPECOMServerBySerialNumber' to retrieve the server details."
                }
                else {
                    
                    $ServerID = $Server.id
                        
                    "[{0}] ID found for server name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $ServerID | Write-Verbose
                        
                }
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
       
        
        
      
        # NOT SUPPORTED FILTER
        #   if ($PSBoundParameters.ContainsKey('ConnectionType')) {

        #     if ($ConnectionType -eq 'Direct') {	
        #         # If $Uri contains a query parameter            
        #         if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "&filter=connectionType eq 'DIRECT'"
        #         }
        #         elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {

        #             $Uri = $Uri + "?filter=connectionType eq 'DIRECT'"

        #         }
        #         else {

        #             $Uri = $Uri + " and connectionType eq 'DIRECT'"

        #         }
        #     }
        #     else {
        #         # If $Uri contains a query parameter            
        #         if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "&filter=connectionType eq 'ONEVIEW'"
        #         }
        #         elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "?filter=connectionType eq 'ONEVIEW'"
                
        #         }
        #         else {
                
        #             $Uri = $Uri + " and connectionType eq 'ONEVIEW'"
                
        #         }
        #     }
        # }

     
        # Requests using $ServerID in URI
        if ($ShowGroupMembership) {

            $Uri = $COMServersUIDoorwayUri + "/" + $ServerID 

            try {
                $GroupName = (Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf).group_.name

                if ($GroupName) {

                    "[{0}] Group name is '{1}''" -f $MyInvocation.InvocationName.ToString().ToUpper(), $GroupName | Write-Verbose
                    $_Resp = Get-HPECOMGroup -Region $Region -Name $GroupName
                    
                    if (-not $Whatif) {
                        Return $_Resp
                    }
                }
                else {
                    
                    "[{0}] Server is not member of a group!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                     
                    if (-not $Whatif) {
                        Return
                    }
                }
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

            # $Uri = $COMServersUri + "/" + $ServerID 

            # try {
            #     [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
            # }
            # catch {
            #     $PSCmdlet.ThrowTerminatingError($_)
                   
            # }
            
           
            # # Add GroupName to $CollectionList
            # $CollectionList | Add-Member -MemberType NoteProperty -Name 'associatedGroupname' -Value $GroupName -Force


        }
        elseif ($ShowLocation -and $Name) {

            $Uri = $COMServersUIDoorwayUri + "/" + $ServerID 

            try {
                $CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                
                # "[{0}] Server '{1}' data from UI Doorway: `n{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID, ($CollectionList | Out-String) | Write-Verbose

                $CollectionList = [PSCustomObject]$CollectionList.locationInfo_

                "[{0}] Server '{1}' location Info data from UI Doorway: `n{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID, ($CollectionList | Out-String) | Write-Verbose

                # "[{0}] Object type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($CollectionList.GetType().FullName ) | Write-Verbose

                if ($CollectionList.name) {
                    "[{0}] Location name is '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CollectionList.name | Write-Verbose
                }
                else {
                    "[{0}] Server location is not set!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                }
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }



        }
        elseif ($ShowAlerts) {

            $Uri = $COMServersUri + "/" + $ServerID + "/alerts"

            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

        }
        elseif ($ShowExternalStorageDetails) {

            $Uri = $COMServersUri + "/" + $ServerID + "/external-storage-details"

            
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction SilentlyContinue
            }

            catch {    
                return
            }
        }
        elseif ($CheckifserverHasStorageVolume) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/analyze-os-install"
            $Payload = @{id = $ServerID } | ConvertTo-Json

            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method POST -Uri $Uri -Body $payload -Region $Region -WhatIfBoolean $WhatIf
            
                return $CollectionList.serverHasStorageVolume
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }   
        elseif ($ShowNotificationStatus) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/notifications"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        elseif (($ShowSecurityParameters -and $Name) -or $ShowSecurityParametersDetails) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/security-parameters"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        elseif ($ShowAdapterToSwitchPortMappings) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/tor-port-mappings"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        # Request with no $ServerID in URI
        else {

            try {
                [Array]$AllCollection = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
               
            }


            if ($Null -ne $AllCollection) {     
                            
                $CollectionList = $AllCollection
        
            }

        }

        $ReturnData = @()
               
        # Format response with Repackage Object With Type
        if ($Null -ne $CollectionList) {     
            
            # Add region and serverName to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serverName -value $_.name }

                                       
            if ($ShowAlerts) {

                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.Alert"    
                
            }
            elseif ($ShowExternalStorageDetails) {

                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.ExternalStorageDetails"    
                
            }
            elseif ($ShowNotificationStatus) {
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.NotificationStatus"    
                
            }
            elseif ($ShowSecurityParameters -and $Name) {
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.Id -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.Id -split '\+')[1]}

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.SecurityParameters"   
                
            }   
            elseif ($ShowSecurityParametersDetails) {
       
                $NewCollectionList = [System.Collections.ArrayList]::new()

                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.Id -split '\+')[1]).name

                foreach ($IloSecurityParam in $CollectionList.IloSecurityParams) {
                    # Add serial number and region to object
                    $IloSecurityParam | Add-Member -type NoteProperty -name serialNumber -value ($CollectionList.Id -split '\+')[1]  
                    $IloSecurityParam | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                    $IloSecurityParam | Add-Member -type NoteProperty -name region -value $Region

                    [void]$NewCollectionList.add($IloSecurityParam)
                }     

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters.Details"    
                
            }                       
            elseif ($ShowAdapterToSwitchPortMappings) {
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}        
         
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.AdapterToSwitchPortMappings"    
                
            } 
            elseif ($ShowGroupMembership) {

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.GroupMembership"    
                
            }       
            elseif ($ShowLocation -and $Name) {

                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.Id -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.Id -split '\+')[1]}
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Server.Location"    
                
            }  
            else {
                
                $NewCollectionList = [System.Collections.ArrayList]::new()

                if ($ShowLocation -and -not $Name){
                    
                    try {

                        $_Devices = Get-HPEGLDevice 
                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                            
                    }

                    foreach ($Item in $CollectionList) {

                        # Add serial number to object
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.Id -split '\+')[1]  

                        if ($_Devices) {

                            $LocationName = ($_Devices | Where-Object serial_number -eq $Item.serialNumber).location_name
                                                
                            # Add location name to object
                            $Item | Add-Member -type NoteProperty -name Location -value $LocationName
                            
                            [void]$NewCollectionList.add($Item)
                            
                        }
                    }
                }
                else {

                    foreach ($Item in $CollectionList) {
    
                        # "[{0}] item found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Item | Write-Verbose
                        
                        # Add serial number to object
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.Id -split '\+')[1]  
    
                        if ($ShowGroupFirmwareCompliance) {
    
                            try {
                                
                                $_GroupName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serialNumber -ShowGroupMembership ).Groupname
                                    
                                if ($_GroupName) {
        
                                    $_Resp = Get-HPECOMGroupFirmwareCompliance -Region $Region -GroupName $_GroupName -ServerSerialNumber $Item.serialNumber 
        
                                    [void]$NewCollectionList.add($_Resp)
                                    
                                }
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                                
                            }
                        }
                        elseif ($ShowGroupFirmwareDeviation){
    
                            try {
                                    
                                $_GroupName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serialNumber -ShowGroupMembership ).Groupname
                                
                                if ($_GroupName) {
    
                                    $_Resp = Get-HPECOMGroupFirmwareCompliance -Region $Region -GroupName $_GroupName -ServerSerialNumber $Item.serialNumber -Deviations

                                    # # Add serial number and servername to object
                                    $_Resp | Add-Member -type NoteProperty -name serialNumber -value $Item.serialNumber
                                    $_Resp | Add-Member -type NoteProperty -name serverName -value $Item.ServerName 
                                    
                                    [void]$NewCollectionList.add($_Resp)
                                    
                                }
                               
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                                
                            }
    
                        }
                        elseif ($ShowSecurityParameters){
    
                            try {

                                $Uri = $COMServersUri + "/" + $Item.ID + "/security-parameters"

                                $_ServerSecurityParameters = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

                                # # Add serial number and servername to object
                                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($Item.id -split '\+')[1]).name
                                $_ServerSecurityParameters | Add-Member -type NoteProperty -name serverName -value $_ServerName 
                                $_ServerSecurityParameters | Add-Member -type NoteProperty -name serialNumber -value ($Item.id -split '\+')[1]
  
                                [void]$NewCollectionList.add($_ServerSecurityParameters)

                            }
                            catch {
                                # Error 404 with OneView servers, case 5385212183 

                                # $PSCmdlet.ThrowTerminatingError($_)
                                
                            }
    
                        }
                        else {
                            [void]$NewCollectionList.add($Item)
    
                        }
    
                    }      
                }

                
                if ($ConnectionType) {

                    $NewCollectionList = $NewCollectionList | where-Object ConnectionType -eq $ConnectionType
                    
                }

                if ( $ShowLocation) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.Location"   
                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                elseif ($ShowSecurityParameters) {
                   
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters"    
                    $ReturnData = $ReturnData | Sort-Object name, serialNumber 
                } 
                elseif ($ShowAutoiLOFirmwareUpdateStatus ) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.autoIloFwUpdateStatus"    
                    $ReturnData = $ReturnData | Sort-Object name, serialNumber 
   
                }
                elseif ($ShowGroupFirmwareDeviation) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Groups.Compliance.Deviations"   

                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                elseif (-not $ShowGroupFirmwareCompliance) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers"   
                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                else {
                    $ReturnData = $NewCollectionList
                }
            }

            if (-not $WhatIf) {
                
                return $ReturnData 

            }
           
        }
        else {

            return
                
        }         
    }
}

Function Get-HPECOMServerBySerialNumber {
    <#
    .SYNOPSIS
    Retrieve the list of servers.
    
    .DESCRIPTION
    This Cmdlet returns a collection of server resources in the specified region. Switch parameters can be used to retrieve specific data such as alerts, external storage details, notification status, security parameters, adapter to switch port mapping, and to check the presence of storage volume for OS installation.
    
    For server inventory data, you must use 'Get-HPECOMServerInventory'.

    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER SerialNumber 
    Specifies the serial number of the server to display. 
        
    .PARAMETER Model 
    Optional parameter that can be used to display a specific server model only, such as 'ProLiant DL380 Gen11', 'ProLiant DL365 Gen11', etc. 
    Partial model names are not supported.
    
    .PARAMETER ConnectionType
    Optional parameter that can be used to display servers based on the connection type (Direct or OneView).
    
    .PARAMETER ConnectedState
    A Boolean value (True or False). When set to True, only servers that are connected to HPE GreenLake will be displayed. When set to False, only servers that are not connected will be displayed.
    
    .PARAMETER PowerState
    A value of ON or OFF. When set to ON, only servers that are powered on will be displayed. When set to OFF, only servers that are powered off will be displayed.

    .PARAMETER Limit 
    This parameter allows you to define a limit on the number of servers to be displayed. 
    
    .PARAMETER ShowGroupMembership 
    Optional parameter that can be used to get the server group membership.

    .PARAMETER ShowGroupFirmwareCompliance
    Optional parameter that can be used when a server is a member of a group to get the group firmware compliance. 
    This parameter allows you to check if the server is compliant with the group's firmware baseline (if any).
      
    .PARAMETER ShowGroupFirmwareDeviation
    Optional parameter that can be used when a server is member of a group to get the group firmware deviation.
    This parameter can be useful for identifying deviations from the group's firmware baseline (if any), ensuring that the server is up to date and compliant with the group (if any).

    .PARAMETER ShowLocation 
    Optional parameter that can be used to get the server location.
    
    .PARAMETER ShowAlerts 
    Optional parameter that can be used to get the server alerts. 
    
    .PARAMETER ShowNotificationStatus 
    Optional parameter that can be used to get the server notification status. 
    
    .PARAMETER ShowSecurityParameters 
    Optional parameter that can be used to get the server security parameters. 

    .PARAMETER ShowSecurityParametersDetails 
    Optional parameter that can be used to get the server security parameter details. 
    
    .PARAMETER ShowAdapterToSwitchPortMappings 
    Optional parameter that can be used to get the network connectivity of the adapter port to the connected switch port of the server. 
    
    .PARAMETER ShowAutoiLOFirmwareUpdateStatus
    Optional parameter that can be used to get the status of the automatic iLO firmware update configuration.

    .PARAMETER ShowExternalStorageDetails 
    Optional parameter that can be used to get the server external storage details. 
   
    .PARAMETER CheckifserverHasStorageVolume 
    Optional parameter that can be used to validate the presence of a storage volume for the server 
    specified for operating system installation. The response returned is a boolean.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central

    Returns data for all servers located in the Central European region. 

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Limit 50

    Returns the first 50 servers located in the Central European region. 
    
    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F 

    Returns the server data for the server with the serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowGroupMembership

    This command returns the group membership of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowGroupFirmwareCompliance 

    This command returns the group firmware compliance report of the server serial number 'CZJ3200B7F' if it is a member of a group with a compatible firmware baseline.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowGroupFirmwareDeviation 

    This command returns the firmware components of the server serial number 'CZJ3200B7F' that have deviations from the group's firmware baseline if it is a member of a group with a compatible firmware baseline.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowAlerts

    This command returns the alerts of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -ShowLocation

    This command returns the location of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowLocation

    This command returns the location of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowNotificationStatus

    This command returns the notification status of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowSecurityParameters

    This command returns the security parameters of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -ShowSecurityParametersDetails

    This command returns the security parameters of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowSecurityParametersDetails

    This command returns the security parameters details of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowAdapterToSwitchPortMappings

    This command returns the adapter to switch port mappings of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -ShowAutoiLOFirmwareUpdateStatus

    This command returns the auto iLO firmware update status of all servers in the Central European region.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowAutoiLOFirmwareUpdateStatus

    This command returns the auto iLO firmware update status of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -ShowExternalStorageDetails

    This command returns the external storage details of the server with serial number 'CZJ3200B7F'.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region us-west -ConnectedState False
    
    Lists all servers that are not connected to Compute Ops Management.

    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region us-west -ConnectedState True -PowerState ON

    Lists all servers that are powered on and connected to Compute Ops Management.
    
    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region us-west -Model "ProLiant DL325 Gen10 Plus" -PowerState ON 

    Lists all ProLiant DL325 Gen10 Plus servers that are powered on.
    
    .EXAMPLE
    Get-HPECOMServerBySerialNumber -Region eu-central -SerialNumber CZJ3200B7F -CheckIfServerHasStorageVolume

    This command returns a True or False output to indicate if the server with serial number 'CZJ3200B7F' has a storage volume for OS installation.

    .EXAMPLE
    "CZ24050752", "CZ24050751" | Get-HPECOMServerBySerialNumber -Region eu-central

    Returns all servers that match the serial numbers given in the pipeline.

    .EXAMPLE
    "CZ24050752", "CZ24050751" | Get-HPECOMServerBySerialNumber -Region eu-central -ShowSecurityParameters

    Retrieves server security parameters for the two servers with the specified serial numbers in the pipeline.

    .EXAMPLE
    Get-HPECOMServer -Limit 2 | Get-HPECOMServerBySerialNumber -Region eu-central -ShowNotificationStatus 
    
    Gets the first two servers in HPE GreenLake and passes their serial numbers into the pipeline to retrieve 
    their server notification status.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.
    System.Collections.ArrayList
        List of servers retrieved using 'Get-HPECOMServer -Name $Name' or 'Get-HPECOMServerBySerialNumber -SerialNumber $Serialnumber'.

#>

    [CmdletBinding(DefaultParameterSetName = 'BySerialNumber')]
    Param( 
    
        [Parameter(Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'BySerialNumber')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupMembershipSN')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupFirmwareComplianceSN')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'GroupFirmwareDeviationSN')]
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'Location')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AlertsSN')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'CheckifserverHasStorageVolumeSN')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'ExternalStorageDetailsSN')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'NotificationStatusSN')]
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SecurityParameters')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SecurityParametersDetailsSN')]
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AdapterToSwitchPortMappingsSN')]
        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Alias ('serial_number')]
        [String]$SerialNumber,
    
        [Parameter (ParameterSetName = 'Other')]
        [String]$Model,
       
        [Parameter (ParameterSetName = 'Other')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Direct', 'OneView')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Direct', 'OneView')]
        [String]$ConnectionType,
        
        [Parameter (ParameterSetName = 'Other')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('True', 'False')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('True', 'False')]
        [String]$ConnectedState,

        [Parameter (ParameterSetName = 'Other')]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('ON', 'OFF')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('ON', 'OFF')]
        [String]$PowerState,
    
        [Parameter (ParameterSetName = 'Other')]
        [ValidateScript({ $_ -le 100 })]
        [int]$Limit,

        [Parameter (ParameterSetName = 'GroupMembershipSN')]
        [Switch]$ShowGroupMembership,

        [Parameter (ParameterSetName = 'GroupFirmwareComplianceSN')]
        [Switch]$ShowGroupFirmwareCompliance,
    
        [Parameter (ParameterSetName = 'GroupFirmwareDeviationSN')]
        [Switch]$ShowGroupFirmwareDeviation,
    
        [Parameter (ParameterSetName = 'Location')]
        [Switch]$ShowLocation,
    
        [Parameter (ParameterSetName = 'AlertsSN')]
        [Switch]$ShowAlerts,
    
        [Parameter (ParameterSetName = 'NotificationStatusSN')]
        [Switch]$ShowNotificationStatus,
        
        [Parameter (ParameterSetName = 'SecurityParameters')]
        [Switch]$ShowSecurityParameters,
        
        [Parameter (ParameterSetName = 'SecurityParametersDetailsSN')]
        [Switch]$ShowSecurityParametersDetails,
        
        [Parameter (ParameterSetName = 'AdapterToSwitchPortMappingsSN')]
        [Switch]$ShowAdapterToSwitchPortMappings,
        
        [Parameter (ParameterSetName = 'AutoiLOFirmwareUpdateStatus')]
        [Switch]$ShowAutoiLOFirmwareUpdateStatus,
        
        [Parameter (ParameterSetName = 'ExternalStorageDetailsSN')]
        [Switch]$ShowExternalStorageDetails,
        
        [Parameter (ParameterSetName = 'CheckifserverHasStorageVolumeSN')]
        [Switch]$CheckIfServerHasStorageVolume,

        [Switch]$WhatIf
        
    ) 

    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command
        
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
      
      
    }
      
      
    Process {
      
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
           

        # Set $Uri
        if (        $ShowGroupMembership `
                -or ($ShowLocation -and $SerialNumber) `
                -or $ShowAlerts `
                -or $ShowExternalStorageDetails `
                -or $ShowNotificationStatus `
                -or ($ShowSecurityParameters -and $SerialNumber)`
                -or $ShowSecurityParametersDetails `
                -or $ShowAdapterToSwitchPortMappings `
                -or $CheckifserverHasStorageVolume `
                # -or $ShowAutoiLOFirmwareUpdateStatus `
        ) {
                
            # Get server ID using SN or Name
            if ($SerialNumber) {

                $Uri = $COMServersUri + "?filter=hardware/serialNumber eq '$SerialNumber'"
                
            }
           

            try {
                [Array]$Server = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region


                if ($Null -eq $Server) { 
                
                    Return
           
                }
                else {
                    
                    $ServerID = $Server.id
                    
                    if ($SerialNumber) {
                        
                        "[{0}] ID found for server serial number '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $ServerID | Write-Verbose
                        
                        
                    }
                }
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
        }
        elseif ($SerialNumber) {       
            
            $Uri = $COMServersUri + "?filter=hardware/serialNumber eq '$SerialNumber'"
   
        }
        else {
            
            $Uri = $COMServersUri 

        }       
        
        
        if ($PSBoundParameters.ContainsKey('Model')) {
            
            if ($Uri -match "\?") {
                
                $Uri = $Uri + "&filter=hardware/model eq '$Model'"

            }
            else {
            
                $Uri = $Uri + "?filter=hardware/model eq '$Model'"

            }
   
        }


        

        if ($PSBoundParameters.ContainsKey('ConnectedState')) {

            if ($ConnectedState -eq 'True') {	
                # If $Uri contains a query parameter            
                if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
                    $Uri = $Uri + "&filter=state/connected eq true"
                }
                elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {

                    $Uri = $Uri + "?filter=state/connected eq true"

                }
                else {

                    $Uri = $Uri + " and state/connected eq true"

                }
            }
            else {
                # If $Uri contains a query parameter            
                if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
                    $Uri = $Uri + "&filter=state/connected eq false"
                }
                elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {
                
                    $Uri = $Uri + "?filter=state/connected eq false"
                
                }
                else {
                
                    $Uri = $Uri + " and state/connected eq false"
                
                }
            }
        }

        if ($PSBoundParameters.ContainsKey('PowerState')) {

            if ($PowerState -eq 'ON') {    
                
                # If $Uri contains a query parameter            
                if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
                    $Uri = $Uri + "&filter=hardware/powerState eq 'ON'"
                }
                elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {

                    $Uri = $Uri + "?filter=hardware/powerState eq 'ON'"

                }
                else {

                    $Uri = $Uri + " and hardware/powerState eq 'ON'"

                }
            }
            else {
                # If $Uri contains a query parameter            
                if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
                    $Uri = $Uri + "&filter=hardware/powerState eq 'OFF'"
                }
                elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {
                
                    $Uri = $Uri + "?filter=hardware/powerState eq 'OFF'"
                
                }
                else {
                
                    $Uri = $Uri + " and hardware/powerState eq 'OFF'"
                
                }
            }
        }

        if ($PSBoundParameters.ContainsKey('Limit')) {
            
            if ($Uri -match "\?") {
                
                $Uri = $Uri + "&limit=$Limit"

            }
            else {
            
                $Uri = $Uri + "?limit=$Limit"

            }

        }

        # NOT SUPPORTED FILTER
        #   if ($PSBoundParameters.ContainsKey('ConnectionType')) {

        #     if ($ConnectionType -eq 'Direct') {	
        #         # If $Uri contains a query parameter            
        #         if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "&filter=connectionType eq 'DIRECT'"
        #         }
        #         elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {

        #             $Uri = $Uri + "?filter=connectionType eq 'DIRECT'"

        #         }
        #         else {

        #             $Uri = $Uri + " and connectionType eq 'DIRECT'"

        #         }
        #     }
        #     else {
        #         # If $Uri contains a query parameter            
        #         if ($Uri -match "\?limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "&filter=connectionType eq 'ONEVIEW'"
        #         }
        #         elseif ($Uri -notmatch "limit=" -and $Uri -notmatch "filter=" ) {
                
        #             $Uri = $Uri + "?filter=connectionType eq 'ONEVIEW'"
                
        #         }
        #         else {
                
        #             $Uri = $Uri + " and connectionType eq 'ONEVIEW'"
                
        #         }
        #     }
        # }

     
        # Requests using $ServerID in URI
        if ($ShowGroupMembership) {

            $Uri = $COMServersUIDoorwayUri + "/" + $ServerID 

            try {
                $GroupName = (Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf).group_.name

                if ($GroupName) {

                    "[{0}] Group name is '{1}''" -f $MyInvocation.InvocationName.ToString().ToUpper(), $GroupName | Write-Verbose
                    $_Resp = Get-HPECOMGroup -Region $Region -Name $GroupName
                    
                    if (-not $Whatif) {
                        Return $_Resp
                    }
                }
                else {
                    
                    "[{0}] Server is not member of a group!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                     
                    if (-not $Whatif) {
                        Return
                    }
                }
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

            
            # $Uri = $COMServersUri + "/" + $ServerID 

            # try {
            #     [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
            # }
            # catch {
            #     $PSCmdlet.ThrowTerminatingError($_)
                   
            # }
            
           
            # # Add GroupName to $CollectionList
            # $CollectionList | Add-Member -MemberType NoteProperty -Name 'associatedGroupname' -Value $GroupName -Force


        }
        elseif ($ShowLocation -and $SerialNumber) {

            $Uri = $COMServersUIDoorwayUri + "/" + $ServerID 

            try {
                $CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                
                # "[{0}] Server '{1}' data from UI Doorway: `n{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID, ($CollectionList | Out-String) | Write-Verbose

                $CollectionList = [PSCustomObject]$CollectionList.locationInfo_

                "[{0}] Server '{1}' location Info data from UI Doorway: `n{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID, ($CollectionList | Out-String) | Write-Verbose

                # "[{0}] Object type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($CollectionList.GetType().FullName ) | Write-Verbose

                if ($CollectionList.name) {
                    "[{0}] Location name is '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CollectionList.name | Write-Verbose
                }
                else {
                    "[{0}] Server location is not set!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                    
                }
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }



        }
        elseif ($ShowAlerts) {

            $Uri = $COMServersUri + "/" + $ServerID + "/alerts"

            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

        }
        elseif ($ShowExternalStorageDetails) {

            $Uri = $COMServersUri + "/" + $ServerID + "/external-storage-details"

            
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction SilentlyContinue
            }

            catch {    
                return
            }
        }
        elseif ($CheckifserverHasStorageVolume) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/analyze-os-install"
            $Payload = @{id = $ServerID } | ConvertTo-Json

            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method POST -Uri $Uri -Body $payload -Region $Region -WhatIfBoolean $WhatIf
            
                return $CollectionList.serverHasStorageVolume
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }   
        elseif ($ShowNotificationStatus) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/notifications"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        elseif (($ShowSecurityParameters -and $SerialNumber ) -or $ShowSecurityParametersDetails) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/security-parameters"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        elseif ($ShowAdapterToSwitchPortMappings) {
                            
            $Uri = $COMServersUri + "/" + $ServerID + "/tor-port-mappings"
           
            try {
                [Array]$CollectionList = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                            
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                    
            }
                    
        }
        # Request with no $ServerID in URI
        else {

            try {
                [Array]$AllCollection = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
               
            }


            if ($Null -ne $AllCollection) {     
                            
                $CollectionList = $AllCollection
        
            }

        }

        $ReturnData = @()
               
        # Format response with Repackage Object With Type
        if ($Null -ne $CollectionList) {     
            
            # Add region and serverName to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
            $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serverName -value $_.name }
           
                            
            if ($ShowAlerts) {
                
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.Alert"    
                
            }
            elseif ($ShowExternalStorageDetails) {

                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}
            
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.ExternalStorageDetails"    
                
            }
            elseif ($ShowNotificationStatus) {
                
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.NotificationStatus"    
                
            }
            elseif ($ShowSecurityParameters -and $SerialNumber) {
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.Id -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.Id -split '\+')[1]}

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.SecurityParameters"    
                
            }   
            elseif ($ShowSecurityParametersDetails) {
       
                $NewCollectionList = [System.Collections.ArrayList]::new()

                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.Id -split '\+')[1]).name

                foreach ($IloSecurityParam in $CollectionList.IloSecurityParams) {
                    # Add serial number and region to object
                    $IloSecurityParam | Add-Member -type NoteProperty -name serialNumber -value ($CollectionList.Id -split '\+')[1]  
                    $IloSecurityParam | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                    $IloSecurityParam | Add-Member -type NoteProperty -name region -value $Region

                    [void]$NewCollectionList.add($IloSecurityParam)
                }     

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters.Details"    
                
            }                       
            elseif ($ShowAdapterToSwitchPortMappings) {
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.serverId -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.serverId -split '\+')[1]}        
         
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.AdapterToSwitchPortMappings"    
                
            } 
            elseif ($ShowGroupMembership) {
 
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.GroupMembership"    
                
            }       
            elseif ($ShowLocation -and $SerialNumber) {
               
                # Add serial number and servername to object
                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($CollectionList.Id -split '\+')[1]).name
                $CollectionList | Add-Member -type NoteProperty -name serverName -value $_ServerName -Force
                $CollectionList | ForEach-Object { $_ | Add-Member -type NoteProperty -name serialNumber -value ($_.Id -split '\+')[1]}
           
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Server.Location"    
                
            }
            else {
                
                $NewCollectionList = [System.Collections.ArrayList]::new()

                if ($ShowLocation -and -not $SerialNumber){

                    try {

                        $_Devices = Get-HPEGLDevice 
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                            
                    }

                    foreach ($Item in $CollectionList) {

                        # Add serial number to object
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.Id -split '\+')[1]  

                        if ($_Devices) {

                            $LocationName = ($_Devices | Where-Object serial_number -eq $Item.serialNumber).location_name
                                                
                            # Add location name to object
                            $Item | Add-Member -type NoteProperty -name Location -value $LocationName
                            
                            [void]$NewCollectionList.add($Item)
                            
                        }
                    }
                }
                else {
                    
                    foreach ($Item in $CollectionList) {
    
                        # "[{0}] item found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Item | Write-Verbose
                        
                        # Add serial number to object
                        $Item | Add-Member -type NoteProperty -name serialNumber -value ($Item.Id -split '\+')[1]  
    
                        if ($ShowGroupFirmwareCompliance) {
    
                            try {
                                
                                $_GroupName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serialNumber -ShowGroupMembership ).Groupname
                                    
                                if ($_GroupName) {
        
                                    $_Resp = Get-HPECOMGroupFirmwareCompliance -Region $Region -GroupName $_GroupName -ServerSerialNumber $Item.serialNumber 
                                    
                                    [void]$NewCollectionList.add($_Resp)
                                    
                                }
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                                
                            }
                        }
                        elseif ($ShowGroupFirmwareDeviation){
    
                            try {
                                    
                                $_GroupName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $Item.serialNumber -ShowGroupMembership ).Groupname
                                
                                if ($_GroupName) {
                                    
                                    $_Resp = Get-HPECOMGroupFirmwareCompliance -Region $Region -GroupName $_GroupName -ServerSerialNumber $Item.serialNumber -Deviations
                                    
                                    # # Add serial number and servername to object
                                    $_Resp | Add-Member -type NoteProperty -name serialNumber -value $Item.serialNumber
                                    $_Resp | Add-Member -type NoteProperty -name serverName -value $Item.ServerName 
                                    
                                    [void]$NewCollectionList.add($_Resp)
                                    
                                }
                               
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                                
                            }
    
                        }
                        elseif ($ShowSecurityParameters){
    
                            try {

                                $Uri = $COMServersUri + "/" + $Item.ID + "/security-parameters"

                                $_ServerSecurityParameters = Invoke-HPECOMWebRequest -Method GET -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf
                                
                                # # Add serial number and servername to object
                                $_ServerName = (Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber  ($Item.id -split '\+')[1]).name
                                $_ServerSecurityParameters | Add-Member -type NoteProperty -name serverName -value $_ServerName 
                                $_ServerSecurityParameters | Add-Member -type NoteProperty -name serialNumber -value ($Item.id -split '\+')[1]
                                
                                [void]$NewCollectionList.add($_ServerSecurityParameters)

                            }
                            catch {
                                # Error 404 with OneView servers, case 5385212183 

                                # $PSCmdlet.ThrowTerminatingError($_)
                                
                            }
    
                        }
                        else {
                            [void]$NewCollectionList.add($Item)
    
                        }
    
                    }     
                }


                if ($ConnectionType) {

                    $NewCollectionList = $NewCollectionList | where-Object ConnectionType -eq $ConnectionType
                    
                }               
             

                if ( $ShowLocation) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.Location"   
                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                elseif ($ShowSecurityParameters) {
                   
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.SecurityParameters"    
                    $ReturnData = $ReturnData | Sort-Object name, serialNumber 
                } 
                elseif ($ShowAutoiLOFirmwareUpdateStatus ) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers.autoIloFwUpdateStatus"    
                    $ReturnData = $ReturnData | Sort-Object name, serialNumber 
   
                }
                elseif ($ShowGroupFirmwareDeviation) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Groups.Compliance.Deviations"   

                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                elseif (-not $ShowGroupFirmwareCompliance) {

                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $NewCollectionList -ObjectName "COM.Servers"   
                    $ReturnData = $ReturnData | Sort-Object name, { $_.hardware.serialNumber }
                } 
                else {
                    $ReturnData = $NewCollectionList
                }
            }

            if (-not $WhatIf) {
                
                return $ReturnData 

            }
           
        }
        else {

            return
                
        }         
    }
}


Function Enable-HPECOMServerAutoiLOFirmwareUpdate {
    <#
    .SYNOPSIS
    Enable the automatic iLO firmware update.

    .DESCRIPTION
    This Cmdlet can be used to enable the iLO automatic firmware update for a specified server in a region.    
        
    .PARAMETER Region 
    Name of the region where to enable the automatic iLO firmware update

    .PARAMETER SerialNumber
    Serial number of the server on which the iLO automatic firmware update preference will be enabled.
    
    .PARAMETER Name
    Name of the server on which the iLO automatic firmware update preference will be enabled.   

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
  
    .EXAMPLE
    Enable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central -SerialNumber 2M240400JN 

    This command enables the automatic iLO firmware update for the server with the serial number "2M240400JN" located in the "eu-central" region. 

    .EXAMPLE 
    Enable-HPECOMServerAutoiLOFirmwareUpdate -Region us-west -Name  'HOL45' 

    This command enables the automatic iLO firmware update for the server with the name "HOL45" located in the "us-west" region.

    .EXAMPLE
    Get-HPECOMServer -Region us-west | Enable-HPECOMServerAutoiLOFirmwareUpdate 

    This command enables the automatic iLO firmware update for all servers located in the "us-west" region. 

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Enable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central 

    This command enables the automatic iLO firmware update for the servers with the serial numbers "CZ12312312" and "DZ12312312" located in the "eu-central" region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the server where to enable the automatic iLO firmware update
        * Region - Name of the region 
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [alias('serial_number')]
        [String]$SerialNumber,
        
        [Parameter (Mandatory, ParameterSetName = 'Name')]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {
              
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $EnableServerAutoiLOFirmwareUpdatetatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($SerialNumber) {

                $ParamUsed = $SerialNumber
                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber

            } 
            elseif ($Name) {

                $ParamUsed = $Name
                $_server = Get-HPECOMServer -Region $Region -Name $Name

            }
      

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $ParamUsed
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
        
        if (-not $_server) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
                Write-Warning $ErrorMessage

            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Server cannot be found in the Compute Ops Management instance!"
            }              

        }
        else {

            # ID uses a '+' sign, it needs to be replaced with '%2B' to avoid 404 resource not found error (URL encoding not working: $encodedServerID = [System.Web.HttpUtility]::UrlEncode($_serverId) )
            $ServerID = $_server.id.replace('+', '%2B') 
            "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID | Write-Verbose
            
            $Uri = $COMServersUri + "?id=" + $ServerID 
            "[{0}] URI: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                autoIloFwUpdate = $true    
            }          
          
            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {

                    "[{0}] Server auto iLO firmware enable raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                    "[{0}] Server auto iLO firmware '{1}' successfully enabled in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Server auto iLO firmware successfully enabled in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Server auto iLO firmware cannot be enabled!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $EnableServerAutoiLOFirmwareUpdatetatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($EnableServerAutoiLOFirmwareUpdatetatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed the Auto iLO firmware enable attempt!"
          
            }
            
            Return $EnableServerAutoiLOFirmwareUpdatetatus
        }


    }
}


Function Disable-HPECOMServerAutoiLOFirmwareUpdate {
    <#
    .SYNOPSIS
    Disable the automatic iLO firmware update.

    .DESCRIPTION
    This Cmdlet can be used to disable the iLO automatic firmware update for a specified server in a region.    
        
    .PARAMETER Region 
    Name of the region where to disable the automatic iLO firmware update

    .PARAMETER SerialNumber
    Serial number of the server on which the iLO automatic firmware update preference will be disabled.
    
    .PARAMETER Name
    Name of the server on which the iLO automatic firmware update preference will be disabled.   

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
  
    .EXAMPLE
    Disable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central -SerialNumber 2M240400JN 

    This command disables the automatic iLO firmware update for the server with the serial number "2M240400JN" located in the "eu-central" region. 

    .EXAMPLE
    Disable-HPECOMServerAutoiLOFirmwareUpdate -Region us-west -Name 'HOL45' 

    This command disables the automatic iLO firmware update for the server with the name "HOL45" located in the "us-west" region. 

    .EXAMPLE
    Get-HPECOMServer -Region us-west | Disable-HPECOMServerAutoiLOFirmwareUpdate

    This command disables the automatic iLO firmware update for all servers in the "us-west" region. 

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Disable-HPECOMServerAutoiLOFirmwareUpdate -Region eu-central 

    This command disables the automatic iLO firmware update for the servers with the serial numbers "CZ12312312" and "DZ12312312" located in the "eu-central" region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the server where to disable the automatic iLO firmware update
        * Region - Name of the region 
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'SerialNumber')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName, ParameterSetName = 'SerialNumber')]
        [alias('serial')]
        [String]$SerialNumber,
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Name')]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
              
        $EnableServerAutoiLOFirmwareUpdatetatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {

            if ($SerialNumber) {

                $ParamUsed = $SerialNumber
                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber

            } 
            elseif ($Name) {

                $ParamUsed = $Name
                $_server = Get-HPECOMServer -Region $Region -Name $Name

            }
      

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $ParamUsed
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
        
        if (-not $_server) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ParamUsed
                Write-Warning $ErrorMessage
                # $ErrorRecord = New-ErrorRecord ServerNotFoundInCOM ObjectNotFound -TargetObject 'Server' -Message $ErrorMessage -TargetType $ParamUsed.GetType().Name
                # $PSCmdlet.ThrowTerminatingError($ErrorRecord)
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Server cannot be found in the Compute Ops Management instance!"
            }              

        }
        else {

            # ID uses a '+' sign, it needs to be replaced with '%2B' to avoid 404 resource not found error (URL encoding not working: $encodedServerID = [System.Web.HttpUtility]::UrlEncode($_serverId) )
            $ServerID = $_server.id.replace('+', '%2B') 
            "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServerID | Write-Verbose
            
            $Uri = $COMServersUri + "?id=" + $ServerID 
            "[{0}] URI: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose

            # Build payload
            $payload = ConvertTo-Json -Depth 10 @{
                autoIloFwUpdate = $false    
            }          
          
            # Set resource
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $payload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 

                
                if (-not $WhatIf) {
                    
                    "[{0}] Server auto iLO firmware disable raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Server auto iLO firmware '{1}' successfully disabled in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Server auto iLO firmware successfully disabled in $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Server auto iLO firmware cannot be disabled!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }           
        }

        [void] $EnableServerAutoiLOFirmwareUpdatetatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($EnableServerAutoiLOFirmwareUpdatetatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more servers failed the Auto iLO firmware disable attempt!"
          
            }
            
            Return $EnableServerAutoiLOFirmwareUpdatetatus
        }


    }
}

#EndRegion


#Region --- EMAIL NOTIFICATION POLICY ---

Function Get-HPECOMEmailNotificationPolicy {
    <#
    .SYNOPSIS
    Get the email notification policy preference that is applied when servers are activated for management.

    .DESCRIPTION
    This Cmdlet returns the user preferences for the current user that are available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER SerialNumber
    Specifies the serial number of the server on which the email notification preferences will be retrieved.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMUserPreference -Region us-west

    Return the user preferences for the current user. 

    .EXAMPLE
    Get-HPECOMUserPreference -Region  eu-central -SerialNumber CZ12312312 


    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    
    
   #>
    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [String]$SerialNumber,


        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        if ($SerialNumber) {
            
            try {

                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $SerialNumber

            }
            catch {
                
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            if (-not $_server) {

                Return

            }
            else {
                
                $_serverId = $_server.id

                "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverId | Write-Verbose

                $Uri = $COMServersUri + "/" + $_serverId + "/notifications"  
                
            }

        }
        else {
            
            $Uri = $COMUserPreferencesUri            
        }


        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction Stop
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region

            if ($SerialNumber) {
                
                $CollectionList | Add-Member -type NoteProperty -name serialNumber -value $SerialNumber
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Servers.NotificationStatus"    


            }
            else {

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.User.Preferences"    
            }

    
            # $ReturnData = $ReturnData #| Sort-Object { $_.updatedAt }
        
            return $ReturnData 
                
        }
        else {

            Write-Warning "Looks like email notification policy preference has not been configured. See Set-HPECOMUserEmailNotification"
            return
                
        }     

    
    }
}



Function Enable-HPECOMEmailNotificationPolicy {
    <#
    .SYNOPSIS
    Enable a service instance email notification policy in a region.

    .DESCRIPTION   
    Compute Ops Management supports email notification policies that users can enable for each service instance. When enabled, the email notification policy preference settings are applied when a server is assigned to a service instance.

    HPE GreenLake user account holders can configure an email notification policy for each service instance in a workspace. Notifications are sent to the email address that is associated with the user account that is used to configure the policy.
        
    Note: If a server you configure for automatic support case creation or integration with ServiceNow experiences a supported service event, the support case ID or ServiceNow incident ID is included in the server notification.   
    
    .PARAMETER Region 
    Name of the region where the email notification preferences will be enabled
    
    .PARAMETER ServerSerialNumber
    Specifies the serial number of the server on which the email notification preferences will be enabled.
    
    Note: Changing the email notification preferences at the individual server level does not reapply the service instance email notification policy.

    Note: Servers managed by HPE OneView are not supported.
        
    .PARAMETER ServiceEventIssues 
    Enables notifications for service events. A service event is a failure requiring an HPE support case and possibly a service repair.
    
    .PARAMETER ServiceEventAndCriticalIssues
    Enables notifications for service events and other critical severity events.

    .PARAMETER ServiceEventAndCriticalAndWarningIssues
    Enables notifications for service events and events of critical or warning severity.

    .PARAMETER DailySummary
    Enables a daily email summarizing the health of all servers configured for daily notifications. This email includes a summary of server health status values and potential actions such as activating or connecting servers, resolving subscription issues, and available firmware updates.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServiceEventIssues -DailySummary

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications (service event issues) and daily summary notifications.
    
    .EXAMPLE
    Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServiceEventAndCriticalIssues

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events and critical issues, without daily summary notifications.

    .EXAMPLE
    Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServerSerialNumber CZ12312312 -ServiceEventAndCriticalAndWarningIssues 

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events and critical issues for the server with serial number 'CZ12312312'.    

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name 'ESX-2.lab' | Enable-HPECOMEmailNotificationPolicy -ServiceEventAndCriticalIssues

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events and critical issues for the server with the name 'ESX-2.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectedState True -Model "ProLiant DL360 Gen10 Plus" | Enable-HPECOMEmailNotificationPolicy -DailySummary 

    Subscribe the user account, used with 'Connect-HPEGL', to daily summary notifications for all servers with the model 'ProLiant DL360 Gen10 Plus' that are connected.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Enable-HPECOMEmailNotificationPolicy -Region eu-central -ServiceEventIssues

    Subscribe the user account, used with 'Connect-HPEGL', to server notifications for service events for the servers with serial numbers 'CZ12312312' and 'DZ12312312'.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * User - Email address of the current user
        * Server - Serial number of the server on which the email notification preferences will be enabled
        * Region - Name of the region where the email notification preferences will be enabled
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'ServiceEvent')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [alias('serialnumber')]
        [String]$ServerSerialNumber,
        
        [Parameter (ParameterSetName = 'ServiceEvent')]       
        [Switch]$ServiceEventIssues,

        [Parameter (ParameterSetName = 'ServiceEventAndCriticalIssues')]       
        [Switch]$ServiceEventAndCriticalIssues,

        [Parameter (ParameterSetName = 'ServiceEventAndCriticalAndWarningIssues')]       
        [Switch]$ServiceEventAndCriticalAndWarningIssues,

        [Switch]$DailySummary,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
  

        $EnableEmailPreferencesStatus = [System.Collections.ArrayList]::new()

        if ($ServiceEventIssues) {
            $criticalNotification = $true
            $warningNotification = $false
            $criticalNonServiceNotification = $false
        }
        elseif ($ServiceEventAndCriticalIssues) {
            $criticalNotification = $true
            $warningNotification = $false
            $criticalNonServiceNotification = $True
        } 
        elseif ($ServiceEventAndCriticalAndWarningIssues) {
            $criticalNotification = $true
            $warningNotification = $true
            $criticalNonServiceNotification = $True
        
        }
        else {
            $criticalNotification = $false
            $warningNotification = $false
            $criticalNonServiceNotification = $false
        }


        if ($DailySummary) {
            $healthNotification = $True

        }
        else {
            $healthNotification = $False

        }


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       

        # Check if at least one of the switches is used
        if (-not $DailySummary -and -not ($ServiceEventIssues -or $ServiceEventAndCriticalIssues -or $ServiceEventAndCriticalAndWarningIssues)) {
            Write-Error "You must specify either a service event notification or -DailySummary, or both."
            return
        }
                
        if ($ServerSerialNumber) {
            
            try {

                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            if (-not $_server) {

                # Must return a message if not found                    
                $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ServerSerialNumber
                Write-Warning $ErrorMessage

            }
            else {

                $_serverId = $_server.id

                "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverId | Write-Verbose

                try {

                    $_serverNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region -SerialNumber $ServerSerialNumber
        
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                    
        
                if ($_serverNotifications) {
    
                    $Uri = $COMServersUri + "/" + $_serverId + "/notifications"

                    $Method = "PUT"
    
                    # Build object for the output
                    $objStatus = [pscustomobject]@{
            
                        Email     = $HPEGreenLakeSession.username
                        Server    = $ServerSerialNumber
                        Region    = $Region                            
                        Status    = $Null
                        Details   = $Null
                        Exception = $Null
                    }

    
                    if (-not $ServiceEventIssues -and -not $ServiceEventAndCriticalIssues -and -not $ServiceEventAndCriticalAndWarningIssues ) {
    
                        $criticalNotification = $_serverNotifications.criticalNotification  
                        $warningNotification = $_serverNotifications.warningNotification
                        $criticalNonServiceNotification = $_serverNotifications.criticalNonServiceNotification
                    }
                  
                    if (-not $DailySummary) {
                        $healthNotification = $_serverNotifications.healthNotification  
                    }
    
                }
                else {
    
                    Write-Error "You cannot specify a server serial number at this time as no user email notification policy exists yet!"
                    return
        
                }
            }
        }
        else {

            try {

                $_userNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
                
    
            if ($_userNotifications) {

                $Uri = $COMUserPreferencesUri + "/" + $_userNotifications.id
                $Method = "PUT"

                if (-not $ServiceEventIssues -and -not $ServiceEventAndCriticalIssues -and -not $ServiceEventAndCriticalAndWarningIssues ) {

                    $criticalNotification = $_userNotifications.criticalNotification  
                    $warningNotification = $_userNotifications.warningNotification
                    $criticalNonServiceNotification = $_userNotifications.criticalNonServiceNotification
                }
              
                if (-not $DailySummary) {
                    $healthNotification = $_userNotifications.healthNotification  
                }

            }
            else {

                $Uri = $COMUserPreferencesUri
                $Method = "POST"
    
            }

            # Build object for the output
            $objStatus = [pscustomobject]@{

                Email     = $HPEGreenLakeSession.username
                Server    = "All unless an individual definition has been configured"
                Region    = $Region                            
                Status    = $Null
                Details   = $Null
                Exception = $Null
            }
        }
        
        $Payload = @{
            criticalNotification           = $criticalNotification
            criticalNonServiceNotification = $criticalNonServiceNotification 
            warningNotification            = $warningNotification
            healthNotification             = $healthNotification
        }   




        # Convert the hashtable to JSON
        $jsonPayload = $Payload | ConvertTo-Json


        # Set resource
        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method $Method -body $jsonPayload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                
            if (-not $WhatIf) {

                "[{0}] Email notification policy modification raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Email notification policy successfully modified in '{1}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Email notification policy successfully modified in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Email notification policy cannot be modified!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           
        

        [void] $EnableEmailPreferencesStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {
           
            Return $EnableEmailPreferencesStatus
        }


    }
}



Function Disable-HPECOMEmailNotificationPolicy {
    <#
    .SYNOPSIS
    Disable a service instance email notification policy in a region.

    .DESCRIPTION   
    This Cmdlet disables email notification policies for a specified service instance within a designated region.
    
    .PARAMETER Region 
    The name of the region where the email notification preferences will be disabled.
        
    .PARAMETER SerialNumber
    Specifies the serial number of the server on which the email notification preferences will be disabled.
    
    Note: Changing the email notification preferences at the individual server level does not reapply the service instance email notification policy.

    Note: Servers managed by HPE OneView are not supported.
        
    .PARAMETER AllServiceEvents
    Disables all notifications for service events and issues. 
    
    .PARAMETER DailySummary
    Disables the daily email summary.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.
   
    .EXAMPLE
    Disable-HPECOMEmailNotificationPolicy -Region eu-central  -AllServiceEvents -DailySummary

    Unsubscribe the user account, used with 'Connect-HPEGL', from all server notifications and the daily summary notifications.

    .EXAMPLE
    Disable-HPECOMEmailNotificationPolicy -Region eu-central -SerialNumber CZ12312312 -AllServiceEvents

    Unsubscribe the user account, used with 'Connect-HPEGL', from all server notifications for the server with serial number 'CZ12312312'.    

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -Name 'ESX-2.lab' | Disable-HPECOMEmailNotificationPolicy -DailySummary

    Unsubscribe the user account, used with 'Connect-HPEGL', from the daily summary notifications for the server with the name 'ESX-2.lab'.

    .EXAMPLE
    Get-HPECOMServer -Region eu-central -ConnectedState True -Model "ProLiant DL360 Gen10 Plus" | Disable-HPECOMEmailNotificationPolicy -DailySummary 

    Unsubscribe the user account, used with 'Connect-HPEGL', from the daily summary notifications for all servers with the model 'ProLiant DL360 Gen10 Plus' that are connected.

    .EXAMPLE
    "CZ12312312", "DZ12312312" | Disable-HPECOMEmailNotificationPolicy -Region eu-central -AllServiceEvents

    Unsubscribe the user account, used with 'Connect-HPEGL', from all server notifications for the servers with serial numbers 'CZ12312312' and 'DZ12312312'.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the server's serial numbers.

    System.Collections.ArrayList
        List of servers from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * User - Email address of the current user
        * Server - Serial number of the server on which the email notification preferences will be disabled
        * Region - Name of the region where the email notification preferences will be disabled
        * Status - Status of the modification attempt (Failed for http error return; Complete if modification is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ValueFromPipeline, ValueFromPipelineByPropertyName)] 
        [alias('serialnumber')]
        [String]$ServerSerialNumber,
        
        [Switch]$AllServiceEvents,
        
        [Switch]$DailySummary,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $DisableEmailPreferencesStatus = [System.Collections.ArrayList]::new()

        if ($AllServiceEvents) {
            $criticalNotification = $false
            $warningNotification = $false
            $criticalNonServiceNotification = $false
        }

       
        if ($DailySummary) {
            $healthNotification = $False

        }


    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        # Check if at least one of the switches is used
        if (-not $AllServiceEvents -and -not $DailySummary) {
            Write-Error "You must specify either -AllServiceEvents, -DailySummary, or both."
            return
        }
    
        if ($ServerSerialNumber) {
            
            try {

                $_server = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $ServerSerialNumber

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            
            if (-not $_server) {

                # Must return a message if not found
                $ErrorMessage = "Server '{0}' cannot be found in the Compute Ops Management instance!" -f $ServerSerialNumber
                Write-Warning $ErrorMessage

            }
            else {

                $_serverId = $_server.id

                "[{0}] Server ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_serverId | Write-Verbose


                try {

                    $_serverNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region -SerialNumber $ServerSerialNumber
        
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                    
        
                if ($_serverNotifications) {
    
                    $Uri = $COMServersUri + "/" + $_serverId + "/notifications"

                    $Method = "PUT"
    
                    # Build object for the output
                    $objStatus = [pscustomobject]@{
            
                        Email     = $HPEGreenLakeSession.username
                        Server    = $ServerSerialNumber
                        Region    = $Region                            
                        Status    = $Null
                        Details   = $Null
                        Exception = $Null
                    }

    
                    if (-not $ServiceEventIssues -and -not $ServiceEventAndCriticalIssues -and -not $ServiceEventAndCriticalAndWarningIssues ) {
    
                        $criticalNotification = $_serverNotifications.criticalNotification  
                        $warningNotification = $_serverNotifications.warningNotification
                        $criticalNonServiceNotification = $_serverNotifications.criticalNonServiceNotification
                    }
                  
                    if (-not $DailySummary) {
                        $healthNotification = $_serverNotifications.healthNotification  
                    }
    
                }
                else {
    
                    Write-Error "You cannot specify a server serial number at this time as no user email notification policy exists yet!"
                    return
        
                }
               
            }
        }
        else {

            try {

                $_userNotifications = Get-HPECOMEmailNotificationPolicy -Region $Region
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
                
    
            if ($_userNotifications) {

                $Uri = $COMUserPreferencesUri + "/" + $_userNotifications.id
                $Method = "PUT"

                if (-not $AllServiceEvents) {

                    $criticalNotification = $_userNotifications.criticalNotification  
                    $warningNotification = $_userNotifications.warningNotification
                    $criticalNonServiceNotification = $_userNotifications.criticalNonServiceNotification
                }

                if (-not $DailySummary) {
                    $healthNotification = $_userNotifications.healthNotification  
                }

            }
            else {

                $Uri = $COMUserPreferencesUri
                $Method = "POST"

    
            }

            # Build object for the output
            $objStatus = [pscustomobject]@{

                Email     = $HPEGreenLakeSession.username
                Server    = "All unless an individual definition has been configured"
                Region    = $Region                            
                Status    = $Null
                Details   = $Null
                Exception = $Null
            }
        }
        
        $Payload = @{
            criticalNotification           = $criticalNotification
            criticalNonServiceNotification = $criticalNonServiceNotification 
            warningNotification            = $warningNotification
            healthNotification             = $healthNotification
        }   


        # Convert the hashtable to JSON
        $jsonPayload = $Payload | ConvertTo-Json


        # Set resource
        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method $Method -body $jsonPayload -ContentType "application/json" -WhatIfBoolean $WhatIf 

                
            if (-not $WhatIf) {

                "[{0}] Email notification policy modification raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Email notification policy successfully modified in '{1}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Email notification policy successfully modified in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Email notification policy cannot be modified!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           
        

        [void] $DisableEmailPreferencesStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {
           
            Return $DisableEmailPreferencesStatus
        }


    }
}


#EndRegion


#Region --- Webhooks ---

Function Get-HPECOMWebhook {
    <#
    .SYNOPSIS
    Retrieve webhook resources in the specified region.

    .DESCRIPTION
    This Cmdlet retrieves a collection of webhooks available in the specified region.
    
    .PARAMETER Region 
    Specifies the Compute Ops Management region.

    .PARAMETER Name 
    An optional parameter to specify the name of a webhook to display.

    .PARAMETER Deliveries
    An optional switch parameter to retrieve details of the most recent deliveries attempted. 
    Compute Ops Management stores the ten most recent deliveries and the five most recent failures.
    
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west 

    Returns a collection of webhooks available in the western US region.

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west -Name 'Webhook event for server shutdown'

    Returns the webhook resource named 'Webhook event for server shutdown' located in the western US region. 

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west -Name 'Webhook event for server shutdown' -Deliveries
    
    Returns the most recent deliveries attempted by the webhook named 'Webhook event for server shutdown'.
    
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.


    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Region')]
    Param( 

        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (ParameterSetName = 'Region')]
        [Parameter (Mandatory, ParameterSetName = 'Deliveries')]
        [String]$Name,

        [Parameter (ParameterSetName = 'Deliveries')]
        [Switch]$Deliveries,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        if ($Name -and -not $Deliveries) {
            $Uri = $COMWebhooksUri + "?filter=name eq '$Name'"
            
        }
        elseif ($Deliveries) {
            
            $Uri = $COMWebhooksUri + "?filter=name eq '$Name'"
            
            try {
                [Array]$Webhook = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region
                
                $WebhookID = $Webhook.id
                
                "[{0}] ID found for Webhook name '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $WebhookID | Write-Verbose
                
                if ($Null -eq $WebhookID) { Throw "Webhook with this name cannot be found!" }
                
                $Uri = $COMWebhooksUri + "/" + $WebhookID + "/deliveries"
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
            
        }
        else {

            $Uri = $COMWebhooksUri     
            
        }

        try {
            [Array]$CollectionList = Invoke-HPECOMWebRequest -Method Get -Uri $Uri -Region $Region -WhatIfBoolean $WhatIf -ErrorAction Stop
    
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
                   
        }           
        

        $ReturnData = @()
       
        if ($Null -ne $CollectionList) {   

            # Add region to object
            $CollectionList | Add-Member -type NoteProperty -name region -value $Region
                        
            if ($Deliveries) {

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Webhooks.Deliveries"    
            }
            else {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "COM.Webhooks"    
                $ReturnData = $ReturnData | Sort-Object name
            }   
        
            return $ReturnData 
                
        }
        else {

            return
                
        }         
    }
}


Function New-HPECOMWebhook {
    <#
    .SYNOPSIS
    Creates a new webhook in a specified region.

    .DESCRIPTION
    This Cmdlet can be used to create a new webhook with a destination endpoint and an OData configuration for event filtering.
        
    .PARAMETER Region 
    Specifies the name of the region where the webhook will be created.

    .PARAMETER Name 
    Specifies the name of the webhook to create. 
    
    .PARAMETER EventFilter  
    Specifies the OData configuration for events to receive.
    
    Filters use OData style filters as described in https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/guide/#filtering 

    The general syntax for an OData filter looks like 'property op value' with:
     - 'property' refers to the field or property to filter on in the entity.
     - 'op' is the operator, such as eq (equals), ne (not equal), gt (greater than), ge (greater or equal), lt (less than), le (less or equal), etc.
     - 'value' is the value to compare against the property.

    Filtering examples:

    - To receive webhooks for group and server events only:         
        type eq 'compute-ops/group' or type eq 'compute-ops/server'
    - To receive webhooks for all servers that are shut down:       
        type eq 'compute-ops/server' and old/hardware/powerState eq 'ON' and changed/hardware/powerState eq True
    - To receive webhooks for all servers that get disconnect from COM:
        type eq 'compute-ops/server' and old/state/connected eq True and changed/state/connected eq True
    -To receive webhooks for all jobs that run a server firmware update:
        type eq 'compute-ops/job' and contains(name, 'FirmwareUpdate.New') and new/state eq 'RUNNING'
    - To receive webhooks for all servers that transition to an unhealthy status:
        type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True
    - To receive webhooks for all events within a specified group:
        type eq 'compute-ops/group' and contains(name, 'Production')
    - To receive webhooks for all new firmware bundles that are available:
        type eq 'compute-ops/firmware-bundle' and operation eq 'Created'
    - To receive webhooks for all servers added to COM that require activation:
        type eq 'compute-ops/server' and operation eq 'Created'
    - To receive webhooks for all new servers added and connected to COM:
        type eq 'compute-ops/server' and old/state/connected eq False and changed/state/connected eq True
   
    For more information about COM webhooks, see https://jullienl.github.io/Implementing-webhooks-with-COM/ 

    .PARAMETER Destination 
    Specifies the HTTPS webhook endpoint capable of receiving HTTP GET and POST requests.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    New-HPECOMWebhook -Region eu-central -Name "Webhook for servers that disconnect" `
    -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
    -EventFilter "type eq 'compute-ops/alert' and old/hardware/powerState eq 'ON' and changed/hardware/powerState eq True"

    This example creates a webhook named "Webhook for servers that disconnect" in the `eu-central` region. 
    The webhook will send events to the specified destination URL when a server's hardware power state changes from 'ON'. 
    The filter criteria are defined using OData syntax.

    .EXAMPLE
    New-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" `
    -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
    -EventFilter "type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True"

    This example creates a webhook named "Webhook for servers that become unhealthy" in the `eu-central` region. 
    The webhook will trigger when servers transition from a healthy state (`OK`) to an unhealthy state. 
    The events will be sent to the specified destination URL, filtered according to the provided OData criteria.

    .EXAMPLE
    New-HPECOMWebhook -Region eu-central -Name "Webhook for new activated servers" `
    -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
    -EventFilter "type eq 'compute-ops/server' and old/state/connected eq False and changed/state/connected eq True"

    This example creates a webhook named "Webhook for new activated servers" in the `eu-central` region. 
    This webhook will send notifications to the given destination URL whenever new servers are activated and connected to COM. 
    The filter ensures that the event captures the change in connection state from `False` to `True`.

    .INPUTS
    Pipeline input is not supported

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the webhook attempted to be created
        * Region - Name of the region where to create the webhook
        * Status - Status of the creation attempt (Failed for http error return; Complete if creation is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                # Regex pattern to validate OData filter strings with multiple 'and'/'or' conditions
                if ($_ -match "^\s*([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false))(\s+(and|or)\s+([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false)))*\s*$") {
                    return $true
                }
                else {
                    throw "The filter string '$_' is not a valid OData filter."
                }
            })]
        [String]$EventFilter,
        
        [Parameter (Mandatory)] 
        [ValidateScript({
                if ($_ -match '^https?:\/\/[a-zA-Z0-9-\.]+\.[a-z]{2,4}(/\S*)?$') {
                    return $true
                }
                else {
                    throw "The URL '$_' is not a valid HTTP/HTTPS URL."
                }
            })]
        [String]$Destination,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $CreateWebhookStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $Uri = $COMWebhooksUri

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($WebhookResource) {
            Throw "Error! '$Name' webhook already exists in the COM '$Region' region!"


        }

                     
        # Build payload
        $payload = ConvertTo-Json @{
            name        = $Name
            destination = $Destination
            state       = "ENABLED"
            eventFilter = $EventFilter
            headers     = @{}
        }
            


        try {
            $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method POST -body $payload -WhatIfBoolean $WhatIf 

            
            if (-not $WhatIf) {

                "[{0}] Webhook creation raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                
                "[{0}] Webhook '{1}' successfully created in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                $objStatus.Status = "Complete"
                $objStatus.Details = "Webhook successfully created in $Region region"

            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be created!"
                $objStatus.Exception = $_.Exception.message 
            }
        }           


        [void] $CreateWebhookStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($CreateWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more webhooks failed the creation attempt!"
          
            }
            
            Return $CreateWebhookStatus
        }


    }
}


Function Set-HPECOMWebhook {
    <#
    .SYNOPSIS
    Update an existing webhook in a specified region.

    .DESCRIPTION
    This Cmdlet is used to update an existing webhook to modify its destination, its OData filtering configuration, or to re-initiate the verification handshake. 
    If a parameter is not provided, the cmdlet retains the current settings and only updates the provided parameters.
        
    .PARAMETER Region
    Specifies the region where the webhook to be updated is located.

    .PARAMETER Name
    Specifies the name of the webhook to update.

    .PARAMETER NewName
    Specifies the new name for the webhook.

    .PARAMETER EventFilter
    Specifies the new OData filter configuration for events to receive.

    Filters use OData style filters as described in [HPE Developer Documentation](https://developer.greenlake.hpe.com/docs/greenlake/services/compute-ops-mgmt/public/guide/#filtering).

    The general syntax for an OData filter is 'property op value', where:
    - `property` refers to the field or property to filter on within the entity.
    - `op` is the operator, such as eq (equals), ne (not equal), gt (greater than), ge (greater or equal), lt (less than), le (less or equal), etc.
    - `value` is the value to compare against the property.

    Filtering examples:

    - To receive webhooks for group and server events only:         
        type eq 'compute-ops/group' or type eq 'compute-ops/server'
    - To receive webhooks for all servers that are shut down:       
        type eq 'compute-ops/server' and old/hardware/powerState eq 'ON' and changed/hardware/powerState eq True
    - To receive webhooks for all servers that get disconnect from COM:
        type eq 'compute-ops/server' and old/state/connected eq True and changed/state/connected eq True
    -To receive webhooks for all jobs that run a server firmware update:
        type eq 'compute-ops/job' and contains(name, 'FirmwareUpdate.New') and new/state eq 'RUNNING'
    - To receive webhooks for all servers that transition to an unhealthy status:
        type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True
    - To receive webhooks for all events within a specified group:
        type eq 'compute-ops/group' and contains(name, 'Production')
    - To receive webhooks for all new firmware bundles that are available:
        type eq 'compute-ops/firmware-bundle' and operation eq 'Created'
    - To receive webhooks for all servers added to COM that require activation:
        type eq 'compute-ops/server' and operation eq 'Created'
    - To receive webhooks for all new servers added and connected to COM:
        type eq 'compute-ops/server' and old/state/connected eq False and changed/state/connected eq True
   
    For more information about COM webhooks, see https://jullienl.github.io/Implementing-webhooks-with-COM/ 

    .PARAMETER Destination
    Specifies the new HTTPS webhook endpoint that is able to receive HTTP GET and POST requests.

    .PARAMETER RetryWebhookHandshake
    Re-initiates the webhook verification handshake.
    
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "New_webhook" -NewName "Webhook for servers that become unhealthy" `
     -Destination "https://hook.eu2.make.com/baea2fa0f8be4d546445c98253392058" `
     -EventFilter "type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True"

    This example updates an existing webhook named "New_webhook" to a new name "Webhook for servers that become unhealthy" in the `eu-central` region. 
    The webhook will send events to the specified destination URL when a server's health summary transitions from `OK` to unhealthy (`True`), using the specified OData filter.

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" -RetryWebhookHandshake

    This example re-initiates the verification handshake for the webhook named "Webhook for servers that become unhealthy" in the `eu-central` region.

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" -Destination "https://hook.us1.make.com/wwedws2fa0f8be4d546445c98253392058"

    This example updates the destination URL for the webhook named "Webhook for servers that become unhealthy" in the `eu-central` region. 

    .EXAMPLE
    Set-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" -EventFilter "type eq 'compute-ops/server' and old/hardware/health/summary eq 'OK' and changed/hardware/health/summary eq True"

    This example updates the OData filter configuration for the webhook named "Webhook for servers that become unhealthy" in the `eu-central` region.

    .EXAMPLE
    Get-HPECOMWebhook -Region eu-central | Set-HPECOMWebhook  -RetryWebhookHandshake 

    This example re-initiates the verification handshake for all webhooks in the `eu-central` region.

    .EXAMPLE
    "POSH_webhook_Alert", "POSH_webhook_firmwarebundle" | Set-HPECOMWebhook -Region eu-central  -RetryWebhookHandshake 

    This example re-initiates the verification handshake for the webhooks named "POSH_webhook_Alert" and "POSH_webhook_firmwarebundle" in the `eu-central` region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the webhooks's names.

    System.Collections.ArrayList
        List of webhooks from 'Get-HPECOMWebhook'.

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object or array of objects containing the following properties:
        * Name - Name of the webhook attempted to be set.
        * Region - Name of the region where the webhook is updated.
        * Status - Status of the modification attempt (Failed if an HTTP error occurs; Complete if successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.

      
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [ValidateScript({ $_.Length -lt 256 })]
        [String]$Name,

        [ValidateScript({ $_.Length -lt 256 })]
        [String]$NewName,
        
        [ValidateScript({
                # Regex pattern to validate OData filter strings with multiple 'and'/'or' conditions
                if ($_ -match "^\s*([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false))(\s+(and|or)\s+([\w/]+ (eq|ne|gt|lt|ge|le) '.+'|[\w/]+ eq (true|false)))*\s*$") {
                    return $true
                }
                else {
                    throw "The filter string '$_' is not a valid OData filter."
                }
            })]
        [String]$EventFilter,
        
        [ValidateScript({
                if ($_ -match '^https?:\/\/[a-zA-Z0-9-\.]+\.[a-z]{2,4}(/\S*)?$') {
                    return $true
                }
                else {
                    throw "The URL '$_' is not a valid HTTP/HTTPS URL."
                }
            })]
        [String]$Destination,

        [Switch]$RetryWebhookHandshake,
        
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $CreateWebhookStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name
            $WebhookID = $WebhookResource.id
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        "[{0}] Webhook ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $WebhookID | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        if (-not $WebhookID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Webhook '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-Warning $ErrorMessage
                # $ErrorRecord = New-ErrorRecord WebhookNotFoundInCOM ObjectNotFound -TargetObject 'Webhook' -Message $ErrorMessage -TargetType $Name.GetType().Name
                # $PSCmdlet.ThrowTerminatingError($ErrorRecord )
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $Uri = $COMWebhooksUri + "/" + $WebhookID

            $Payload = @{}

            # Conditionally add properties
            if ($NewName) {
                $Payload.name = $NewName
            }
            else {
                $Payload.name = $Name
               
            }

            if ($Destination) {
                $Payload.destination = $Destination
            }
            else {
                $Payload.destination = $WebhookResource.destination
            }

            if ($RetryWebhookHandshake) {
                $Payload.state = "ENABLED"
            }
            else {
                $Payload.state = $WebhookResource.state
            }

            if ($EventFilter) {
                $Payload.eventFilter = $EventFilter
            }
            else {
                $Payload.eventFilter = $WebhookResource.eventFilter
            }

            # Convert the hashtable to JSON
            $jsonPayload = $Payload | ConvertTo-Json
           
            try {
               
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method PATCH -body $jsonPayload -ContentType "application/merge-patch+json" -WhatIfBoolean $WhatIf 
                              
                if (-not $WhatIf) {
                   
                    "[{0}] Webhook update raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                   
                    "[{0}] Webhook '{1}' successfully updated in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                   
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook successfully updated in $Region region"
                   
                }
                
            }
            catch {
                
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Webhook cannot be updated!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           
        }


        [void] $CreateWebhookStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($CreateWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more webhooks failed the updated attempt!"
          
            }
            
            Return $CreateWebhookStatus
        }


    }
}


Function Send-HPECOMWebhookTest {
    <#
   
    .SYNOPSIS
    Simulate a webhook by sending a typical resource object to its configured endpoint URL.

    .DESCRIPTION
    This Cmdlet can simulate a webhook by sending a resource object that matches the filtering configuration of an existing webhook to its configured endpoint URL.

    This test is useful for validating communication between COM and the webhook destination endpoint. It also helps capture data content and test the flow of your automation process.

    .PARAMETER Region 
    The name of the region where the webhook is located. 

    .PARAMETER Name 
    The name of the webhook to be used for the sending test. 
   
    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to COM instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Send-HPECOMWebhookTest -Region eu-central -Name "Webhook event for servers that are disconnected"

    Sends a typical resource object that matches the filtering configuration (i.e. a server resource object in this case) of the existing webhook named 'Webhook event for servers that are disconnected' located in the 'eu-central' region to the destination endpoint.
    
    .EXAMPLE
    Get-HPECOMWebhook -Region eu-central | Send-HPECOMWebhookTest

    Sends a typical resource object that matches the filtering configuration of all existing webhooks in the 'eu-central' region to their respective destination endpoints.

    .EXAMPLE
    "Webhook event for servers that are disconnected", "Webhook event for servers that are unhealthy" | Send-HPECOMWebhookTest -Region eu-central

    Sends a typical resource object that matches the filtering configuration of the webhooks named 'Webhook event for servers that are disconnected' and 'Webhook event for servers that are unhealthy' located in the 'eu-central' region to their respective destination endpoints.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the webhooks's names.

    System.Collections.ArrayList
        List of webhooks from 'Get-HPECOMWebhook'.

   .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - The name of the webhook used for the sending test.
        * Region - The name of the region where the webhook is located.
        * Status - The status of the send test attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed). 
        * Details - Additional information about the status. 
        * Exception - Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $CreateWebhookStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }

        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name
            $WebhookID = $WebhookResource.id


        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)

        }

        "[{0}] Webhook ID found: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $WebhookID | Write-Verbose

        if (-not $WebhookID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Webhook '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-Warning $ErrorMessage
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be found in the Compute Ops Management instance!"
            }
        }
        else {

            $EventFilter = $WebhookResource.eventFilter
            $Destination = $WebhookResource.destination


            # Define the regex pattern to match the resource type of webhook filter
            $pattern = "type eq '([^']*)'"

            # Use the -match operator to apply the pattern and capture the webhook resource type value
            if ($EventFilter -match $pattern) {
                
                # Extract the full type value (e.g. 'compute-ops/server')
                $fullTypeValue = $matches[1]

                # Extract the part after the last slash (e.g. 'server')
                $typeValue = $fullTypeValue -split '/' | Select-Object -Last 1

                "[{0}] Extracted webhook resource type: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $typeValue | Write-Verbose

            }
            else {
                throw "The webhook test cannot be sent as the webhook resource type cannot be extracted from the webhook filter definition."
            }

            # Object to send creation
            switch ($typeValue) {
                server { 
                    $Object = Get-HPECOMServer -Region $Region -Limit 1 

                }
                alert { 
                    $_SerialNumber = Get-HPECOMServer -Region $Region | select -First 1 | ForEach-Object serialNumber
                    $Object = Get-HPECOMServerBySerialNumber -Region $Region -SerialNumber $_SerialNumber -ShowAlerts | select -First 1

                }                
                group { 
                    $Object = Get-HPECOMGroup -Region $Region | Where-Object { $_.devices.count -gt 1 } | select -first 1

                }                
                server-setting { 
                    $Object = Get-HPECOMSetting -Region $Region -Category Firmware | select -First 1

                }                
                job { 
                    $Object = Get-HPECOMJob -Region $Region | select -First 1

                }                
                compliance { 
                    $_name = Get-HPECOMGroup -Region $Region | Where-Object { $_.devices.count -gt 1 } | select -first 1 | ForEach-Object name
                    $Object = Get-HPECOMGroup -Region $Region -Name $_name -ShowCompliance | select -First 1

                }
                firmware-bundle { 
                    $Object = Get-HPECOMFirmwareBundle -Region $Region | select -First 1

                }

            }
         
            $jsonPayload = ConvertTo-Json -Depth 20 -InputObject $Object

            "[{0}] Webhook test object that will be sent: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $jsonPayload | Write-Verbose

            
           
            try {

                if ($WhatIf) {

                    Invoke-RestMethodWhatIf -Uri $Destination -Method POST -Body $jsonPayload -ContentType "application/json" -Cmdlet Invoke-RestMethod


                } 
                else {

                    $Response = Invoke-RestMethod -Uri $Destination -method POST -body $jsonPayload -ContentType "application/json" 
                }
               
                              
                if (-not $WhatIf) {
                   
                    "[{0}] Webhook test raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose
                   
                    "[{0}] Webhook '{1}' test successfully send to '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Destination | Write-Verbose
                   
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook test successfully sent to '$Destination' using a resource object of type '$typeValue'."
                   
                }
                
            }
            catch {

                $errorResponse = $_.Exception.Response
                
                if ($errorResponse) {
                
                    $statusCode = $errorResponse.StatusCode
                
                    if (-not $WhatIf -and $statusCode -eq 410) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Error: The destination webhook '$Destination' is no longer available!"
                        $objStatus.Exception = $_.Exception.message 

                    } 
                    elseif (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Webhook test sent to '$Destination' using a resource object of type '$typeValue' was not accepted!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }                  
            }


            [void] $CreateWebhookStatus.add($objStatus)

        }
    }


    end {

        if (-not $WhatIf) {

            if ($CreateWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more webhooks test failed the test attempt!"
          
            }
            
            Return $CreateWebhookStatus
        }


    }
}


Function Remove-HPECOMWebhook {
    <#
    .SYNOPSIS
    Removes a webhook resource from a specified region.

    .DESCRIPTION
    This Cmdlet removes a webhook resource from a specific region using its name property.

    .PARAMETER Name 
    The name of the webhook to remove. 

    .PARAMETER Region 
    The name of the region where the webhook should be removed.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to COM instead of executing the request. This option is useful for understanding the inner workings of the native REST API calls used by COM.

    .EXAMPLE
    Remove-HPECOMWebhook -Region eu-central -Name "Webhook for servers that become unhealthy" 
    
    Removes the webhook named 'Webhook for servers that become unhealthy' from the central EU region.

    .EXAMPLE
    Get-HPECOMWebhook -Region us-west -Name "Webhook for servers that become unhealthy" | Remove-HPECOMWebhook 

    Removes the webhook named 'Webhook for servers that become unhealthy' from the western US region.

    .EXAMPLE
    Get-HPECOMWebhook -Region eu-central | Remove-HPECOMWebhook 

    Removes all webhooks from the central EU region.

    .EXAMPLE
    "POSH_webhook_Alert", "POSH_webhook_firmwarebundle" | Remove-HPECOMWebhook -Region eu-central 
    
    Removes the webhooks named 'POSH_webhook_Alert' and 'POSH_webhook_firmwarebundle' from the central EU region.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the webhooks's names.

    System.Collections.ArrayList
        A list of webhooks retrieved from 'Get-HPECOMWebhook'. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following properties:  
        * Name - The name of the webhook attempted to be removed.
        * Region - The name of the region where the webhook was removed.
        * Status - The status of the removal attempt (Failed for HTTP error; Complete if removal is successful; Warning if no action is needed).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)] 
        [ValidateScript({
                if ($HPECOMAPICredentialRegions -contains $_) {
                    $true
                }
                else {
                    Throw "The COM region '$_' is not provisioned in this workspace!"
                }
            })]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                # Filter region based on $HPECOMAPICredentialRegions global variable and create completions
                $HPECOMAPICredentialRegions | Where-Object { $_ -like "$wordToComplete*" } | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [String]$Region,  

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveWebhookStatus = [System.Collections.ArrayList]::new()
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
              
        try {
            $WebhookResource = Get-HPECOMWebhook -Region $Region -Name $Name
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            
            Name      = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
        }
        
        $WebhookID = $WebhookResource.id

        
        if (-not $WebhookID) {

            # Must return a message if not found
            if ($WhatIf) {
                
                $ErrorMessage = "Webhook '{0}' cannot be found in the Compute Ops Management instance!" -f $Name
                Write-warning $ErrorMessage
                return

            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Webhook cannot be found in the Compute Ops Management instance!"
            }

        }
        else {
            
            $Uri = $COMWebhooksUri + "/" + $WebhookID

            # Removal task  
            try {
                $Response = Invoke-HPECOMWebRequest -Region $Region -Uri $Uri -method DELETE -WhatIfBoolean $WhatIf 

                if (-not $WhatIf) {

                    "[{0}] Webhook removal raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Response | Write-Verbose

                    "[{0}] Webhook '{1}' successfully deleted from '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Webhook successfully deleted from $Region region"

                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Webhook cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
        [void] $RemoveWebhookStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveWebhookStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more webhooks has failed!"

          
            }
            
            Return $RemoveWebhookStatus
        }


    }
}

#EndRegion




#EndRegion



#Region ------------------- GLP -------------------

#Region --- DEVICE ---

Function Get-HPEGLdevice {
    <#
    .SYNOPSIS
    Retrieve device resource(s).

    .DESCRIPTION
    This Cmdlet returns a collection of device resources, individual device statistics, or specific devices with specified parameters such as serial numbers. 

    .PARAMETER PartNumber
    Specifies the part number associated with the resources.

    .PARAMETER SerialNumber
    Specifies the serial number associated with the resources.

    .PARAMETER ShowRequireAssignment
    Optional parameter to display devices that lack a service assignment.

    .PARAMETER ShowRequireSubscription
    Optional parameter to display devices that do not have a subscription tier.

    .PARAMETER ShowComputeReadyForCOMIloConnection
    Optional parameter to display devices that are ready for an iLO connection to a Compute Ops Management instance.

    .PARAMETER ShowArchived
    Optional parameter to display only archived devices.

    .PARAMETER ShowNotArchived 
    Optional parameter to hide archived devices.

    .PARAMETER SearchString
    Specifies a case-insensitive search string for device searches. The SearchString value can be either a full or partial match of the property. 
    Supported properties for the search include: serial number, model, and MAC address.

    .PARAMETER FilterByDeviceType
    Specifies the device type, such as STORAGE, COMPUTE, or SWITCH.

    .PARAMETER Location
    Specifies the location name.

    .PARAMETER ContactName
    Specifies the service delivery contact name.

    .PARAMETER ShowTags
    Optional parameter to display device tags.

    .PARAMETER Limit
    Defines the number of devices to be displayed.

    .PARAMETER ShowStats
    Optional parameter to display device statistics.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls.

    .EXAMPLE
    Get-HPEGLdevice

    Return all device resources.

    .EXAMPLE
    Get-HPEGLdevice -Limit 200

    Return the first 200 device resources.

    .EXAMPLE
    Get-HPEGLdevice -SerialNumber CN70490RXP

    Return the device resource with the serial number "CN70490RXP".

    .EXAMPLE
    Get-HPEGLdevice -PartNumber "P38471-B21"

    Return all device resources with the part number "P38471-B21".

    .EXAMPLE
    Get-HPEGLdevice -ShowStats

    Return device statistics.

    .EXAMPLE
    Get-HPEGLdevice | Where-Object { $_.part_number -eq "HF20" }

    Return a device resource with the part number "HF20".

    .EXAMPLE
    Get-HPEGLdevice -FilterByDeviceType STORAGE

    Return all device resources with the device type "STORAGE".

    .EXAMPLE
    Get-HPEGLdevice -Location "Houston-Datacenter"

    Return all device resources assigned to the "Houston-Datacenter" location.

    .EXAMPLE
    Get-HPEGLdevice -ShowRequireAssignment -SearchString DL360

    Return all DL360 device resources that require a service assignment.

    .EXAMPLE
    Get-HPEGLDevice -ShowComputeReadyForCOMIloConnection

    Return all compute device resources that are ready to connect to a Compute Ops Management instance using 'Connect-HPEGLDeviceComputeiLOtoCOM'.

    .EXAMPLE
    Get-HPEGLdevice -ShowRequireSubscription -ShowRequireAssignment

    Return all device resources that require both a subscription and a service assignment.

    .EXAMPLE
    Get-HPEGLdevice -ShowTags

    Return all device resources with tag information.

    .EXAMPLE
    Get-HPEGLDevice -ShowArchived

    Return all archived devices.

    .EXAMPLE
    "J12345605X", "J13134413T", "J21233335W", "J2123333S" | Get-HPEGLdevice

    Return all devices matching the given serial numbers from the pipeline.

    .EXAMPLE
    Get-HPECOMServer -Region us-west -ConnectionType Direct | Get-HPEGLdevice -ShowTags
    
    Retrieve a list of HPE COM servers from the 'us-west' region with a direct connection type (not OneView) and then get the corresponding devices, displaying their tags.
    This example demonstrates how to chain the output of 'Get-HPECOMServer' to 'Get-HPEGLdevice'. The -ShowTags parameter is used to display the tags associated with each device.
    
    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects representing the device's serial numbers.
    System.Collections.ArrayList
        List of device(s) from 'Get-HPECOMServer' or 'Get-HPECOMServerBySerialNumber'.

    #>

    [CmdletBinding(DefaultParameterSetName = "NotArchived")]
    Param( 
        
        [Parameter (ParameterSetName = 'Archived', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter (ParameterSetName = 'NotArchived', ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,  

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$PartNumber, 

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowRequireAssignment,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowRequireSubscription,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowComputeReadyForCOMIloConnection,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowTags,

        [Parameter (ParameterSetName = 'Archived')]
        [Switch]$ShowArchived,

        [Parameter (ParameterSetName = 'NotArchived')]
        [Switch]$ShowNotArchived,

        [Parameter(ParameterSetName = 'Stats')]
        [Switch]$ShowStats,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$SearchString,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('ACCESS POINT', 'GATEWAY', 'SERVER', 'STORAGE', 'SWITCH')]
        [String]$FilterByDeviceType,

        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$Location,
        
        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [ValidateNotNullOrEmpty()]
        [String]$ContactName,
        
        [Parameter (ParameterSetName = 'Archived')]
        [Parameter (ParameterSetName = 'NotArchived')]
        [int]$Limit,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        $SerialNumbersList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        if ($SerialNumber) {
            
            # Add serial number to the serial numbers list
            [void]$SerialNumbersList.Add($SerialNumber)

        
        }


    }
    End {
        

        if ($limit) {

            if ($SearchString) {
                $Uri = $DevicesUri + "?search_string=$SearchString&limit=$Limit"

            }
            else {
                $Uri = $DevicesUri + "?limit=$Limit"
            }



            try {
                [Array]$AllCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -WhatIfBoolean $WhatIf
    
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                   
            }

        }
        else {            

            $Uri = $DevicesUri + "/filter"

            if ($SearchString) {

                $body = @{
                    unassigned_only    = $false
                    archive_visibility = "ALL"
                    search_string      = $SearchString
                } | ConvertTo-Json

            }
            else {
                
                $body = @{
                    unassigned_only    = $false
                    archive_visibility = "ALL"
                } | ConvertTo-Json 
    
            }
            

            try {

                [Array]$AllCollection = Invoke-HPEGLWebRequest -Method POST -Uri $Uri -Body $Body -WhatIfBoolean $WhatIf 
                
            }
            catch {
           
                $PSCmdlet.ThrowTerminatingError($_)
               
            }
           
        }           


        $ReturnData = @()
       
        if ($ShowStats) {
            
            $Uri = $DevicesStatsUri
            
            try {
                [Array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -WhatIfBoolean $WhatIf
                
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Device.stat"         
                return $ReturnData 

            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
                       
        }
       
        else {        

            if ($Null -ne $AllCollection.devices) {     

                $CollectionList = $AllCollection.devices 

                If ($SerialNumbersList) {
    
                    "[{0}] Serial numbers list: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($SerialNumbersList | out-string) | Write-Verbose

                    # Filter devices based on serial numbers
                    $CollectionList = $CollectionList | Where-Object { $SerialNumbersList -contains $_.Serial_Number }
        
                }
                
 

                if ($PartNumber) {

                    $CollectionList = $CollectionList | Where-Object part_number -eq $PartNumber

                }   

                if ($ShowRequireAssignment) {

                    $CollectionList = $CollectionList | Where-Object { -not $_.application_instance_id }

                }   

                if ($ShowRequireSubscription) {

                    $CollectionList = $CollectionList | Where-Object { -not $_.subscription_key }

                }   

                if ($ShowComputeReadyForCOMIloConnection) {

                    $CollectionList = $CollectionList | Where-Object { $_.application_name -eq "Compute Ops Management" -and $_.subscription_key -and $_.application_instance_id }

                }                   

                if ($ShowArchived) {

                    $CollectionList = $CollectionList | Where-Object { $_.archived }

                }   

                if ($ShowNotArchived) {

                    $CollectionList = $CollectionList | Where-Object { -not $_.archived }

                }   
          
                if ($Location) {

                    $CollectionList = $CollectionList | Where-Object location_name -eq $Location

                }   

                if ($ContactName) {

                    $CollectionList = $CollectionList | Where-Object contact_name -eq $ContactName

                }   


                if ($FilterByDeviceType) {

                    switch ($FilterByDeviceType) {
                        "ACCESS POINT" { $_DeviceType = "AP" }
                        "GATEWAY" { $_DeviceType = "GATEWAY" }
                        "SERVER" { $_DeviceType = "COMPUTE" }
                        "STORAGE" { $_DeviceType = "STORAGE" }
                        "SWITCH" { $_DeviceType = "SWITCH" }
                    }

                    $CollectionList = $CollectionList | Where-Object device_type -match $_DeviceType

                }

                if ($ShowTags) {
       
                    $CollectionList = $CollectionList | Where-Object tags
       
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Device.Tag"         
                    $ReturnData = $ReturnData | Sort-Object { $_.serial_number }

                    return $ReturnData 
            
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Device"    
    
                $ReturnData = $ReturnData | Sort-Object { $_.serial_number }
        
                return $ReturnData 
                
            }
            else {

                return
                
            }     

        }
    
    }
}


Function Add-HPEGLDeviceCompute {
    <#
    .SYNOPSIS
    Add compute device(s) to HPE GreenLake.

    .DESCRIPTION
    This Cmdlet adds compute device(s) to the currently connected HPE GreenLake workspace. It can optionally add tags during the onboarding process. 
    
    Note: Devices to be added must be on the Compute Ops Management supported servers list. For more details, refer to the [supported servers list](https://support.hpe.com/hpesc/public/docDisplay?docId=sd00001293en_us&page=GUID-BC7D1D1B-AE36-4F00-A1FB-C1B9E01DF101).

    .PARAMETER SerialNumber
    Specifies the serial number of the device to be added. This value can be retrieved from the HPE iLO RedFish API.

    .PARAMETER PartNumber
    Specifies the part number of the device to be added. This value can be retrieved from the HPE iLO RedFish API.

    .PARAMETER Tags
    Optional parameter to add tags to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

    Supported tags example:
        - "Country=US"
        - "Country=US,State=TX,App=Grafana" 
        - "Country=US, State =TX ,App= Grafana "
            -> Produces the same result as the previous example.
        - "Private note=this is my tag note value,Email=Chris@email.com,City=New York" 
        - "Private note = this is my tag note value , Email = Chris@email.com , City=New York "
            -> Produces the same result as the previous example.   

    Refer to HPE GreenLake tagging specifications:
    https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
        - Resources that support tagging can have up to 25 tags per resource.
        - Tag keys and values are case-insensitive.
        - There can be only one value for a particular tag key for a given resource.
        - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
        - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
        - Tag keys must have 1-128 characters.
        - Tag values can have a maximum of 256 characters.
        - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceCompute -SerialNumber "123456789012" -PartNumber "879991-B21" -Tags "Country=US, Hypersior App=ESXi, City=New York"
    
    Adds a compute device to the currently connected HPE GreenLake workspace using a serial number and part number and assigns three tags.

    .EXAMPLE
    Import-Csv Compute_Devices.csv | Add-HPEGLDeviceCompute -Tags "Location=Houston"
    
    Adds all compute devices listed in a `Compute_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns the same location tag to all devices.

    The content of the CSV file must use the following format:
        SerialNumber, PartNumber
        WGX2380BLC, P55181-B21
        DZ12312312, P55182-B21
        CZ12312312, P54277-B21
      
    .EXAMPLE
    Import-Csv .\Compute_Devices_Tags.csv -Delimiter ";"  | Add-HPEGLDeviceCompute  
    
    Adds all compute devices listed in a `Compute_Devices_Tags.csv` file to the currently connected HPE GreenLake workspace and assigns tags as defined in the 'Tags' column of the CSV file.

    The content of the CSV file must use the following format:
        SerialNumber; PartNumber; Tags
        WGX2380BLC; P55181-B21; Country=US, State=CA, App=RH
        EZ12312312; P55182-B21; State=TX, Role=Production
        CZ12312312; P54277-B21
        7LKY2323233LM; P54277-B21; City=New York

        Note that for `CZ12312312`, no tags are assigned in this example.

    .EXAMPLE
    # Example when you don't have the serial numbers and part numbers but only the iLO IP addresses and credentials.

    $iLO_collection = import-csv Private\iLOs.csv -Delimiter ";"  
    Import-Module HPEiLOCmdlets 

    $ComputeDevicesToAdd = @()

    ForEach ($iLO in $iLO_Collection) {
        try {
            $session = Connect-HPEiLO -Address $iLO.IP -username $iLO.Username -password $iLO.Password -DisableCertificateAuthentication -ErrorAction Stop
            $HPEiLOSystemInfo = Get-HPEiLOSystemInfo -Connection $session 

            $SerialNumber = $HPEiLOSystemInfo.SerialNumber
            $PartNumber = $HPEiLOSystemInfo.sku
            $Tags = $iLO.Tags
            
            $ComputeDevicesToAdd += [PSCustomObject]@{SerialNumber = $SerialNumber; PartNumber = $PartNumber; Tags = $Tags }

            Disconnect-HPEiLO -Connection $session
        }
        catch {
            "iLO {0} cannot be added ! Check your IP or credentials !" -f $iLO.IP
            continue
        }
    }

    $ComputeDevicesToAdd  | Add-HPEGLDeviceCompute 

    Sample script to add all compute devices listed in an `iLOs.csv` file to the currently connected HPE GreenLake workspace. Device information (part number and serial number) is retrieved using the HPEiLOCmdlets module with the IP and credentials provided in the CSV file. Optionally, tags can also be provided.

    The content of the iLOs.csv file must use the following format:
        IP; Username; Password; Tags
        192.168.1.44; demo; password; Country=FR, State=PACA, App=RH
        192.168.0.40; Administrator; P@ssw0rd; State=Texas, Role=production
        192.168.3.194; Admin; Password!    
        
        Note that for `192.168.3.194`, no tags are assigned in this example.

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = '123456789012'; PartNumber = 'P55181-B21'},
        [PSCustomObject]@{SerialNumber = '123432356789'; PartNumber = 'P54277-B21'}
    )

    $devices | Add-HPEGLDeviceCompute -Tags "Country=US, Department=Marketing"
    
    Adds all compute devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them two identical tags.

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = '123456789012'; PartNumber = 'P55181-B21'; Tags = 'Country=US, State=PACA, App=RH' },
        [PSCustomObject]@{SerialNumber = '123432356789'; PartNumber = 'P54277-B21'; Tags = 'State=Texas, Role=production' }
    )

    $devices | Add-HPEGLDeviceCompute 
    
    Adds all compute devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them different tags.

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber, partnumber and tags properties. 

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be added
        * PartNumber - Part number of the device attempted to be added
        * TagsAdded - List of tags to assign to the device (if any)
        * Status - Status of the device onboarding attempt (Failed for HTTP error return; Complete if onboarding is successful; Warning if no action is needed) 
        * Details - More information about the onboarding status of the device, which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - Error - More information on a warning or failed status error.
        * Exception - Information about any exceptions generated during the operation.

    #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('part_number')]
        [String]$PartNumber,

        [Parameter (ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesAddUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesToAddList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            PartNumber   = $PartNumber
            TagsAdded    = $Tags
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        
        foreach ($DeviceToAdd in $ObjectStatusList) {
            
            
            $ErrorFoundInTags = $False

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAdd.SerialNumber
            
            
            if ( $Device) {

                $DeviceToAdd.Status = "Warning"
                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device already present in the HPE GreenLake workspace!" }
                $DeviceToAdd.TagsAdded = $Null
                
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' already present in the HPE GreenLake workspace!" -f $DeviceToAdd.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {
                
                if ($DeviceToAdd.TagsAdded) {
                    
                    "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber, $DeviceToAdd.TagsAdded | Write-Verbose

                    $splittedtags = $DeviceToAdd.TagsAdded.split(",")

                    if ($splittedtags.Length -gt 25) {
                        
                        $DeviceToAdd.Status = "Failed"
                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }
                        $DeviceToAdd.TagsAdded = $Null
                        $ErrorFoundInTags = $True


                        if ($WhatIf) {
                            $ErrorMessage = "Device '{0}' is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAdd.SerialNumber
                            Write-warning $ErrorMessage
                            continue
                        }
                    }
                    else {

                        # Object for the tracking object
                        $TagsList = [System.Collections.ArrayList]::new()
                        # Object for the payload
                        $TagsArray = @{}
                                
                        foreach ($tag in $splittedtags) {
    
                            # Check tag format, if format is not <tagname>=<value>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                                
                                $splittedtagName = $tag.TrimEnd().TrimStart()
    
                                $DeviceToAdd.Status = "Failed"
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }
                                $DeviceToAdd.TagsAdded = $Null
                                $ErrorFoundInTags = $True
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}' tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAdd.SerialNumber, $splittedtagName
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
    
                                $tagname = $tag.split('=')[0]
        
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tagname.TrimEnd().TrimStart()
        
                                if ($tagname.Length -gt 128) {
        
                                    $DeviceToAdd.Status = "Failed"
                                    $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }
                                    $DeviceToAdd.TagsAdded = $Null
                                    $ErrorFoundInTags = $True
        
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}' tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAdd.SerialNumber, $tagname
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {
                                    
                                    $tagvalue = $tag.split('=')[1]
                                    
                                    # Remove space at the begining and at the end of the string if any
                                    $tagvalue = $tagvalue.TrimEnd().TrimStart()
            
                                    if ($tagvalue.Length -gt 256) {
            
                                        $DeviceToAdd.Status = "Failed"
                                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }
                                        $DeviceToAdd.TagsAdded = $Null
                                        $ErrorFoundInTags = $True
            
                                        if ($WhatIf) {
                                            $ErrorMessage = "Device '{0}' tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAdd.SerialNumber, $tagvalue
                                            Write-warning $ErrorMessage
                                            break
                                        }
                                    }
                                    else {
    
                                        $TagsArray.$tagname = $tagvalue 
                
                                        $TagsList += [PSCustomObject]@{
                                            name  = $tagname
                                            value = $tagvalue 
                                        }
                                    }
                                }
                            }
                        } 
                    }


                    if ($TagsList -and -not $ErrorFoundInTags) {
                        
                        $DeviceToAdd.TagsAdded = $TagsList
                    }
    
                }
                else {
    
                    "[{0}] {1}: No tags to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber | Write-Verbose
    
                }
                
                

                # Build DeviceList object

                if (-not $ErrorFoundInTags) {

                    # If tags
                    if ($DeviceToAdd.TagsAdded) {
                    
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            tags         = $TagsArray 
                        }
                    }
                    # If no tags
                    else {
                        
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            
                        }
                    }
    
                    [void]$DevicesToAddList.Add($DeviceList)
                }

            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        if ($DevicesToAddList) {

            # Build payload
            $payload = [PSCustomObject]@{
                compute = $DevicesToAddList 
                network = @()
                storage = @()
            } | ConvertTo-Json -Depth 5
            

            # Add device
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Complete"

                            if ($DeviceToAdd.TagsAdded) {
                                
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = $DeviceToAdd.TagsAdded.count; Error = $Null }
                            }
                            else {
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = $Null }

                            }

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Failed"
                            $DeviceToAdd.TagsAdded = $Null
                            $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device cannot be added to the HPE GreenLake workspace!" }
                            $DeviceToAdd.Exception = $_.Exception.message 

                        }
                    }
                }
            }      
        }
    
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the onboarding attempt!"
            
            }

            Return $ObjectStatusList
        }

    }
}
        

Function Connect-HPEGLDeviceComputeiLOtoCOM {
    <#
    .SYNOPSIS
    Connect the HPE iLO interface of HPE GreenLake compute device(s) to Compute Ops Management.

    .DESCRIPTION
    This Cmdlet connects the iLO of a compute device to the assigned Compute Ops Management instance. 
    Before utilizing this cmdlet, the compute device must be assigned to a Compute Ops Management instance and attached to a valid subscription key using `Add-HPEGLDeviceToService` and `Set-HPEGLDeviceSubscription`.
    You can use 'Get-HPEGLDevice -ShowComputeReadyForCOMIloConnection' to get all compute devices ready to be connected to Compute Ops Management.
    
    .PARAMETER SerialNumber
    Specifies the serial number of the device to be connected to Compute Ops Management.

    .PARAMETER IloIP
    Specifies the iLO IP address or hostname of the device to be connected to Compute Ops Management.
    
    .PARAMETER IloCredential
    A PSCredential object comprising the username and password associated with the iLO of the device that is being added.
    
    .PARAMETER IloProxyServer
    (Optional) Enables iLO web proxy. Specifies the hostname or IP address of the web proxy server.
    
    .PARAMETER IloProxyPort
    (Optional) Specifies the iLO web proxy port number. The range of valid port values in iLO is from 1 to 65535.
    
    .PARAMETER IloProxyUserName
    (Optional) Specifies the iLO web proxy username, if applicable.
    
    .PARAMETER IloProxyPassword
    (Optional) Specifies the iLO web proxy password, if applicable, as a SecureString.

    .PARAMETER DisconnectiLOfromOneView
    If present, this switch parameter disconnects a system managed by HPE OneView in order to connect it to Compute Ops Management. If absent, the connection to Compute Ops Management will fail if the system is already managed by HPE OneView.
    
    .EXAMPLE
    $iLO_credential = Get-Credential 
    Connect-HPEGLDeviceComputeiLOtoCOM -SerialNumber "123456789012" -IloIP "192.168.0.21" -IloCredential $iLO_credential
    
    Connect the iLO at 192.168.0.21 of compute device "123456789012" to the currently assigned Compute Ops Management instance.
    
    .EXAMPLE
    Connect-HPEGLDeviceComputeiLOtoCOM -SerialNumber "123456789012" -IloIP "192.168.1.151" -IloCredential $iLO_credential -IloProxyServer "web-proxy.domain.com" -IloProxyPort 8080

    Connect the iLO at 192.168.1.151 of compute device "123456789012" to the currently assigned Compute Ops Management instance through a web proxy.

    .EXAMPLE
    $iLO_secureString_Proxy_Password = Read-Host -Prompt "Enter the proxy password" -AsSecureString
    Connect-HPEGLDeviceComputeiLOtoCOM -SerialNumber "123456789012" -IloIP "192.168.0.21" -IloCredential $iLO_credential -IloProxyServer "web-proxy.domain.com" -IloProxyPort 8080 -IloProxyUserName "admin" -IloProxyPassword $iLO_secureString_Proxy_Password

    Connect the iLO at 192.168.0.21 of compute device "123456789012" to the currently assigned Compute Ops Management instance through a web proxy using a username and password.

    .EXAMPLE
    $iLO_credential = Get-Credential 
    Import-Csv Private\iLOs-List-To-Connect-To-COM.csv | Connect-HPEGLDeviceComputeiLOtoCOM -IloCredential $iLO_credential

    Connect all compute device iLOs listed in the `iLOs-List-To-Connect-To-COM.csv` file to the Compute Ops Management instance assigned to them.

    The content of the CSV file must use the following format:
        SerialNumber, IP
        DZ12312312, 192.188.2.151
        CZ12312312, 192.188.2.152

    .INPUTS
    None. You cannot pipe objects to this Cmdlet directly.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * iLO - iLO IP address of the device to connect to Compute Ops Management.
        * SerialNumber - Serial number of the device.
        * Status - Status of the iLO connection and configuration attempt (Failed for error; Complete if successful; Warning if no action is needed).
        * Details - More information about the status.
        * iLOConnectionStatus - Status of the iLO connection attempt to Compute Ops Management (Failed for HTTP error return; Complete if successful).
        * iLOConnectionDetails - More information about the iLO connection attempt status.
        * ProxySettingsStatus - Status of the iLO Proxy configuration attempt (Failed for HTTP error return; Complete if successful).
        * ProxySettingsDetails - More information about the iLO Proxy configuration status.
        * Exception - Information about any exceptions generated during the operation.
#>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({ [String]::IsNullOrEmpty($_) -or
                $_ -match [Net.IPAddress]$_ })]
        [Alias ('IP')]
        [IPAddress]$IloIP,
  
        [Parameter (Mandatory)]
        [ValidateNotNullOrEmpty()]
        [PSCredential]$iLOCredential,

        [String]$IloProxyServer,
  
        [Int]$IloProxyPort,
  
        [String]$IloProxyUserName,
  
        [System.Security.SecureString]$IloProxyPassword,

        [Switch]$DisconnectiLOfromOneView

  
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $iLOConnectionStatus = [System.Collections.ArrayList]::new()

        try {
            $devices = Get-HPEGLdevice 
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

    
    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Create object for the output
        $objStatus = [pscustomobject]@{
  
            iLO                  = $IloIP
            SerialNumber         = $SerialNumber
            Status               = $Null
            Details              = $Null
            iLOConnectionStatus  = $Null
            iLOConnectionDetails = $Null
            ProxySettingsStatus  = $Null
            ProxySettingsDetails = $Null
            Exception            = $Null
        }

        # Test if device present
        $device = $devices | Where-Object serial_number -eq $SerialNumber
        
        if ( -not $device) {
            # Must return a message if device is not found
            $objStatus.Status = "Warning"
            $objStatus.Details = "Device is not present in the HPE GreenLake workspace"
    
        }
        elseif (-not $device.ccs_region) {
            # Must return a message if device is not assigned to COM
            $objStatus.Status = "Warning"
            $objStatus.Details = "Device is not assigned to any service instance!"
    
        }
        elseif (-not $device.subscription_key) {
            # Must return a message if device has no subscription
            $objStatus.Status = "Warning"
            $objStatus.Details = "Device has not been attached to any subscription!"
    
        }
        else {       

            # Connection to iLO
  
            If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {

                add-type -TypeDefinition  @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@

                [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

            }


            $iLOBaseURL = "https://$IloIP"
                
            $AddURI = "/redfish/v1/SessionService/Sessions/"
                
            $url = $iLOBaseURL + $AddURI

            $IloUsername = $iLOCredential.UserName
            $IlodecryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($iLOCredential.Password))
                
            $Body = [System.Collections.Hashtable]@{
                UserName = $IloUserName
                Password = $IlodecryptPassword
            } | ConvertTo-Json 
                
            # Create iLO session     
            "[{0}] '{1}' -- Attempting an iLO session creation!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
            "[{0}] '{1}' -- Method: POST - URI: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $url | Write-Verbose
            "[{0}] '{1}' -- Body content: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $Body | Write-Verbose

            try {

                If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {
        
                    $response = Invoke-WebRequest -Method POST -Uri $url -Body $Body -Headers $Headers -ContentType "Application/json" -ErrorAction Stop

                    
                }
                else {
                    $response = Invoke-WebRequest -Method POST -Uri $url -Body $Body -Headers $Headers -ContentType "Application/json" -SkipCertificateCheck -ErrorAction Stop
                    
                }
                
                $XAuthToken = (($response.RawContent -split "[`r`n]" | select-string -Pattern 'X-Auth-Token' ) -split " ")[1]
                
                "[{0}] '{1}' -- Received status code response: '{2}' - Description: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose              
                "[{0}] '{1}' -- Raw response: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $IloIP, $response | Write-Verbose

                "[{0}] '{1}' -- iLO session created successfully!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
    
            }
            catch {
                $objStatus.iLOConnectionStatus = "Failed"
                $objStatus.iLOConnectionDetails = "iLO connection error! Check your iLO IP or credential!"
                $objStatus.Exception = $_.Exception.message 

                "[{0}] '{1}' -- iLO session cannot be created!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
                $objStatus.Status = "Failed"
                [void] $OnboardingDevicesStatus.add($objStatus)
                return
            }
            
            # Get System information
                  
            $Headers = [System.Collections.Hashtable]@{
                'X-Auth-Token'  = $XAuthToken
                'Content-Type'  = 'application/json'
                'OData-Version' = '4.0'    
            }
    
            "[{0}] '{1}' -- Getting iLO generation " -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
              
            $AddURI = "/redfish/v1/Managers/1/"

            If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {
                $iLOGeneration = (Invoke-RestMethod -Method GET -Uri ($iLObaseURL + $AddURI) -Headers $Headers).model
            }
            else {
                $iLOGeneration = (Invoke-RestMethod -Method GET -Uri ($iLObaseURL + $AddURI) -Headers $Headers -SkipCertificateCheck).model
                
            } 

            if ($iLOGeneration -eq "iLO 5" -or $iLOGeneration -eq "iLO 6") {       

                #-----------------------------------------------------------Enable iLO Proxy settings if needed-----------------------------------------------------------------------------

                if ($IloProxyServer) {

                    "[{0}] '{1}' -- iLO '{2}' attempting iLO proxy server settings" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose

                    $AddURI = "/redfish/v1/Managers/1/NetworkProtocol/"

                    $url = ( $iLObaseURL + $AddURI)


                    if ($IloProxyUserName -and $IloProxyPassword) {
                        
                        $Ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($IloProxyPassword)
                        $IloProxyPasswordPlainText = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($Ptr)

                        $Body = [System.Collections.Hashtable]@{
                            Oem = @{
                                Hpe = @{
                                    WebProxyConfiguration = @{
                                        ProxyServer   = $IloProxyServer
                                        ProxyPort     = $IloProxyPort
                                        ProxyUserName = $IloProxyUserName
                                        ProxyPassword = $IloProxyPasswordPlainText
                                    }
                                }
                            }
                        } | ConvertTo-Json -d 9

                    }
                    else {

                        $Body = [System.Collections.Hashtable]@{
                            Oem = @{
                                Hpe = @{
                                    WebProxyConfiguration = @{
                                        ProxyServer = $IloProxyServer
                                        ProxyPort   = $IloProxyPort
                                    }
                                }
                            }
                        } | ConvertTo-Json -d 9

                    }

                    "[{0}] '{1}' -- iLO '{2}' - Method: POST - URI: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $url | Write-Verbose
                    "[{0}] '{1}' -- iLO '{2}' - Hearders content: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($Headers | Out-String) | Write-Verbose
                    "[{0}] '{1}' -- iLO '{2}' - Body content: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $Body | Write-Verbose

                    try {
            
                        If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {
                            $Response = Invoke-RestMethod -Method PATCH -Uri $url -Headers $Headers -Body $Body -ErrorAction Stop
                        }
                        else {
                            $Response = Invoke-RestMethod -Method PATCH -Uri $url -Headers $Headers -Body $Body -ErrorAction Stop -SkipCertificateCheck
                        }

                        "[{0}] '{1}' -- iLO '{2}' - Raw response: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($Response | Out-String) | Write-Verbose

                        $msg = $response.error.'@Message.ExtendedInfo'.MessageId
                  
                        "[{0}] '{1}' -- iLO '{2}' - Response: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $msg | Write-Verbose
       
                        if ($msg -match "Success") {
                            "[{0}] '{1}' -- iLO '{2}' proxy server settings modified successfully!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                            $objStatus.ProxySettingsStatus = "Complete"
                            $objStatus.ProxySettingsDetails = "iLO proxy server settings modified successfully!"
                        }
                 
  
                    }
                    catch {

                        $err = (New-Object System.IO.StreamReader( $_.Exception.Response.GetResponseStream() )).ReadToEnd() 
                        $msg = $err.error.'@Message.ExtendedInfo'.MessageId

                        "[{0}] '{1}' -- iLO '{2}' proxy server settings cannot be configured! Error: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $msg | Write-Verbose


                        $objStatus.ProxySettingsStatus = "Failed"
                        $objStatus.ProxySettingsDetails = $_.Exception.message 

                    }
                }

                
                #----------------------------------------------------------Connect iLOs to Compute Ops Management -----------------------------------------------------------------------------

                "{0} -- Attempting to connect iLO '{1}' to Compute Ops Management!" -f $SerialNumber, $IloIP | Write-Verbose
            
                # If -DisconnectiLOfromOneView switch used: disconnect iLO from Oneview
                if ($DisconnectiLOfromOneView) { 
                    $OverrideManager = $True 
                } 
                else {
                    $OverrideManager = $False
                }
  
  
                $Body = [System.Collections.Hashtable]@{
                    ActivationKey   = $HPEGreenLakeSession.workspaceId
                    OverrideManager = $OverrideManager
                } | ConvertTo-Json 
                        
                        
                $AddURI = "/redfish/v1/Managers/1/Actions/Oem/Hpe/HpeiLO.EnableCloudConnect"

                $url = ( $iLObaseURL + $AddURI)
        
            
                "[{0}] '{1}' -- iLO '{2}' - Method: POST - URI: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $url | Write-Verbose
                "[{0}] '{1}' -- iLO '{2}' - Hearders content: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($Headers | Out-String) | Write-Verbose
                "[{0}] '{1}' -- iLO '{2}' - Body content: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $Body | Write-Verbose
       
                
                
                try {
                    
                    $counter = 1

                    # Define the spinning cursor characters
                    $spinner = @('|', '/', '-', '\')
                    
                    # Use padding to ensure the entire line is overwritten
                    $clearLine = " " * 150

                    If ( ($PSVersionTable.PSVersion.ToString()).Split('.')[0] -eq 5) {

                        $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers).Oem.Hpe.CloudConnect.CloudConnectStatus

                        if ($CloudConnectStatus -ne "Connected") {
                            
                            do {
                                
                                $iLOConnectiontoCOMRresponse = Invoke-RestMethod -Method POST -Uri $url -Body $Body -Headers $Headers -ErrorAction Stop 
                                
                                $subcounter = 0
                                
                                do {
                                    
                                    $subcounter++
                                    
                                    $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers).Oem.Hpe.CloudConnect.CloudConnectStatus
                                    "[{0}] '{1}' -- iLO '{2}' - Connection to COM status: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $CloudConnectStatus | Write-Verbose
                                    
                                    # Calculate the current spinner character
                                    $spinnerChar = $spinner[$subcounter % $spinner.Length]
                                    # Display the spinner character, replacing the previous content
                                    "`r$clearLine`r[{0}] -- iLO '{1}' - Connection to COM status: '{2}'  $spinnerChar  " -f $SerialNumber, $IloIP, $CloudConnectStatus | Write-Host -NoNewline -ForegroundColor Yellow
                                    
                                    sleep -Milliseconds 500
                                    
                                } while ($CloudConnectStatus -eq "ConnectionInProgress")
                                
                                # Increment counter
                                $counter++
                                
                            } until ($CloudConnectStatus -eq "Connected" -or $counter -gt 10)
                        }
                        else {
                            $msg = "AlreadyConnected"
                        }
                    }
                    else {

                        $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers -SkipCertificateCheck).Oem.Hpe.CloudConnect.CloudConnectStatus

                        if ($CloudConnectStatus -ne "Connected") {
                            
                            do {
                            
                                $iLOConnectiontoCOMRresponse = Invoke-RestMethod -Method POST -Uri $url -Body $Body -Headers $Headers -ErrorAction Stop -SkipCertificateCheck
                                
                                $subcounter = 0
                                
                                do {
                                    
                                    $subcounter++
                                    
                                    $CloudConnectStatus = (Invoke-RestMethod -Method GET -uri ( $iLObaseURL + "/redfish/v1/Managers/1/") -Headers $Headers -SkipCertificateCheck).Oem.Hpe.CloudConnect.CloudConnectStatus
                                    "[{0}] '{1}' -- iLO '{2}' - Connection to COM status: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $CloudConnectStatus | Write-Verbose
                                    
                                    # Calculate the current spinner character
                                    $spinnerChar = $spinner[$subcounter % $spinner.Length]
                                    # Display the spinner character, replacing the previous content
                                    "`r$clearLine`r[{0}] -- iLO '{1}' - Connection to COM status: '{2}'  $spinnerChar  " -f $SerialNumber, $IloIP, $CloudConnectStatus | Write-Host -NoNewline -ForegroundColor Yellow
                                    
                                    sleep -Milliseconds 500
                                    
                                } while ($CloudConnectStatus -eq "ConnectionInProgress")
                                
                                # Increment counter
                                $counter++
                            
                            } until ($CloudConnectStatus -eq "Connected" -or $counter -gt 10)


                        }
                        else {
                            $msg = "AlreadyConnected"
                        }
                    }
                    
                    if ($iLOConnectiontoCOMRresponse) {
                        "[{0}] '{1}' -- iLO '{2}' - Raw response: `n{3}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, ($iLOConnectiontoCOMRresponse | Out-String) | Write-Verbose
                        $msg = $iLOConnectiontoCOMRresponse.error.'@Message.ExtendedInfo'.MessageId
                        "[{0}] '{1}' -- iLO '{2}' - Response: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $msg | Write-Verbose
                    }
                    
                    
                    if ($msg -match "Success") {
                        "`r$clearLine`r[{0}] -- iLO '{1}' - Connected!" -f $SerialNumber, $IloIP, $CloudConnectStatus | Write-Host -ForegroundColor Yellow
                        "[{0}] '{1}' -- iLO '{2}' successfully connected to Compute Ops Management!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.iLOConnectionStatus = "Complete"
                        $objStatus.iLOConnectionDetails = "iLO successfully connected to Compute Ops Management!"
                    }
                    elseif ($msg -eq "AlreadyConnected") {
                        "[{0}] '{1}' -- iLO '{2}' already connected to Compute Ops Management!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP | Write-Verbose
                        $objStatus.iLOConnectionStatus = "Complete"
                        $objStatus.iLOConnectionDetails = "iLO is already connected to Compute Ops Management!"
                    }

                    if ($counter -gt 10) {
                        "`r$clearLine`r[{0}] -- iLO '{1}' - Failed!" -f $SerialNumber, $IloIP, $CloudConnectStatus | Write-Host -ForegroundColor Yellow
                        $objStatus.iLOConnectionStatus = "Failed"
                        $objStatus.iLOConnectionDetails = "iLO cannot be connected to Compute Ops Management! Check the iLO event log for more information."
                        $objStatus.Status = "Failed"

                    }


                }
                catch {
                         
                    "`r$clearLine`r[{0}] -- iLO '{1}' - Failed!" -f $SerialNumber, $IloIP, $CloudConnectStatus | Write-Host -ForegroundColor Yellow
                    
                    $err = (New-Object System.IO.StreamReader( $_.Exception.Response.GetResponseStream() )).ReadToEnd() 
                    $msg = $err.error.'@Message.ExtendedInfo'.MessageId

                    "[{0}] '{1}' -- iLO '{2}' cannot be connected to Compute Ops Management! Error: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, $IloIP, $msg | Write-Verbose
                
                    $objStatus.iLOConnectionStatus = "Failed"
                    $objStatus.iLOConnectionDetails = "iLO cannot be connected to Compute Ops Management! iLO seems to be under the control of HPE Oneview! To force the connection, use -DisconnectiLOfromOneView switch"
                    $objStatus.Exception = "Error: '{0}'" -f $msg
                    $objStatus.Status = "Failed"
                    [void] $OnboardingDevicesStatus.add($objStatus)
                    return
                }
    
            
            }
            else {
  
                "[{0}] '{1}' -- iLO is not supported by HPE GreenLake! Skipping server..." -f $MyInvocation.InvocationName.ToString().ToUpper(), $iLOIP | Write-Verbose
      
                $objStatus.OnboardingStatus = "Error" 
                $objStatus.OnboardingDetails = "Only iLO5 and iLO6 are supported by HPE GreenLake"
            }   
            
            if ($objStatus.PSobject.Properties.value -contains "Failed") {
  
                $objStatus.Status = "Failed"
          
            }
            else {
                $objStatus.Status = "Complete"
    
            }

        }

        [void] $iLOConnectionStatus.add($objStatus)
      
    }

    end {

        if ($iLOConnectionStatus | Where-Object { $_.Status -eq "Failed" }) {

            write-error "One or more iLO failed to connect to Compute Ops Management!"
        
        }
        
        Return $iLOConnectionStatus
    }
        
}


Function Add-HPEGLDeviceStorage {
    <#
    .SYNOPSIS
    Add storage device(s) to HPE GreenLake. 

    .DESCRIPTION
    This Cmdlet adds storage device(s) to the currently connected HPE GreenLake workspace. It can optionally add tags during the onboarding process.  
    Devices must meet the requirements of the Data Services and be on the list of supported systems.    
   
    .PARAMETER SerialNumber
    Serial number of the storage device to be added. 
    The serial number can be found in the order confirmation email or in the email received after you activate the storage device software. 
    For Nimble devices, it can be retrieved from the Storage System UI or the pull-out tab.

    .PARAMETER PartNumber 
    Part number of the device to be added. 

   .PARAMETER Tags
    Optional parameter to add tags to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

    Supported tags example:
        - "Country=US"
        - "Country=US,State=TX,App=Grafana" 
        - "Country=US, State =TX ,App= Grafana "
            -> Produces the same result as the previous example.
        - "Private note=this is my tag note value,Email=Chris@email.com,City=New York" 
        - "Private note = this is my tag note value , Email = Chris@email.com , City=New York "
            -> Produces the same result as the previous example.  

    Refer to HPE GreenLake tagging specifications:
    https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
        - Resources that support tagging can have up to 25 tags per resource.
        - Tag keys and values are case-insensitive.
        - There can be only one value for a particular tag key for a given resource.
        - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
        - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
        - Tag keys must have 1-128 characters.
        - Tag values can have a maximum of 256 characters.
        - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceStorage -SerialNumber "123456789012" -PartNumber "879991-B21" -Tags "Country=US, Hypersior App=ESXi, City=New York"
    
    Adds a storage device to the currently connected HPE GreenLake workspace using a serial number and part number and assigns three tags.

    .EXAMPLE
    Import-Csv Storage_Devices.csv  | Add-HPEGLDeviceStorage -Tags "Location=Houston"

    Adds all storage devices listed in a `Storage_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns the same location tag to all devices.

    The content of the CSV file must use the following format:
        SerialNumber, PartNumber
        AF-23454852, Pxxxxx-B21
        AF-32331565, Pxxxxx-B21
        AF-32331597, Pxxxxx-B21
 
    .EXAMPLE
    Import-Csv Storage_Devices.csv -Delimiter ";"  | Add-HPEGLDeviceStorage 
    
    Adds all storage devices listed in a `Storage_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns tags as defined in the 'Tags' column of the CSV file.

    The content of the CSV file must use the following format:
        SerialNumber; PartNumber; Tags
        AF-23454852; Pxxxxx-B21; Country=US, State=PACA, App=RH
        AF-32331565; Pxxxxx-B21; State=Texas, Role=production
        AF-32331597; Pxxxxx-B21

        Note that for `AF-32331597`, no tags are assigned in this example.              

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = 'AF-23454852'; PartNumber = 'Pxxxxx-B21' },
        [PSCustomObject]@{SerialNumber = 'AF-32331565'; PartNumber = 'Pxxxxx-B21' }
    )

    $devices | Add-HPEGLDeviceStorage
    
    Add all storage devices (2) listed in $devices with the specified serial number and part number keys.
    
    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = '123456789012'; PartNumber = 'Pxxxxx-B21'; Tags = 'Country=US, State=PACA, App=RH' },
        [PSCustomObject]@{SerialNumber = '123432356789'; PartNumber = 'Pxxxxx-B21'; Tags = 'State=Texas, Role=production' }
    )

    $devices | Add-HPEGLDeviceStorage 
    
    Adds all storage devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them different tags.

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber, partnumber and tags properties. 

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be added
        * PartNumber - Part number of the device attempted to be added
        * TagsAdded - List of tags to assign to the device (if any)
        * Status - Status of the device onboarding attempt (Failed for HTTP error return; Complete if onboarding is successful; Warning if no action is needed) 
        * Details - More information about the onboarding status of the device, which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - Error - More information on a warning or failed status error.
        * Exception - Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
        
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('part_number')]
        [String]$PartNumber,

        [Parameter (ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesAddUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesToAddList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build tracking object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            PartNumber   = $PartNumber
            TagsAdded    = $Tags
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

       
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        
        foreach ($DeviceToAdd in $ObjectStatusList) {
            
            
            $ErrorFoundInTags = $False

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAdd.SerialNumber
            
            
            if ( $Device) {

                $DeviceToAdd.Status = "Warning"
                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device already present in the HPE GreenLake workspace!" }
                $DeviceToAdd.TagsAdded = $Null
                
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' already present in the HPE GreenLake workspace!" -f $DeviceToAdd.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {
                
                if ($DeviceToAdd.TagsAdded) {
                    
                    "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber, $DeviceToAdd.TagsAdded | Write-Verbose

                    $splittedtags = $DeviceToAdd.TagsAdded.split(",")

                    if ($splittedtags.Length -gt 25) {
                        
                        $DeviceToAdd.Status = "Failed"
                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }
                        $DeviceToAdd.TagsAdded = $Null
                        $ErrorFoundInTags = $True


                        if ($WhatIf) {
                            $ErrorMessage = "Device '{0}' is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAdd.SerialNumber
                            Write-warning $ErrorMessage
                            continue
                        }
                    }
                    else {

                        # Object for the tracking object
                        $TagsList = [System.Collections.ArrayList]::new()
                        # Object for the payload
                        $TagsArray = @{}
                                
                        foreach ($tag in $splittedtags) {
    
                            # Check tag format, if format is not <tagname>=<value>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                                
                                $splittedtagName = $tag.TrimEnd().TrimStart()
    
                                $DeviceToAdd.Status = "Failed"
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }
                                $DeviceToAdd.TagsAdded = $Null
                                $ErrorFoundInTags = $True
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}' tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAdd.SerialNumber, $splittedtagName                                   
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
    
                                $tagname = $tag.split('=')[0]
        
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tagname.TrimEnd().TrimStart()
        
                                if ($tagname.Length -gt 128) {
        
                                    $DeviceToAdd.Status = "Failed"
                                    $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }
                                    $DeviceToAdd.TagsAdded = $Null
                                    $ErrorFoundInTags = $True
                                    
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}' tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAdd.SerialNumber, $tagname
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {
                                    
                                    $tagvalue = $tag.split('=')[1]
                                    
                                    # Remove space at the begining and at the end of the string if any
                                    $tagvalue = $tagvalue.TrimEnd().TrimStart()
            
                                    if ($tagvalue.Length -gt 256) {
            
                                        $DeviceToAdd.Status = "Failed"
                                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }
                                        $DeviceToAdd.TagsAdded = $Null
                                        $ErrorFoundInTags = $True
            
                                        if ($WhatIf) {
                                            $ErrorMessage = "Device '{0}' tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAdd.SerialNumber, $tagvalue
                                            Write-warning $ErrorMessage
                                            break
                                        }
                                    }
                                    else {
    
                                        $TagsArray.$tagname = $tagvalue 
                
                                        $TagsList += [PSCustomObject]@{
                                            name  = $tagname
                                            value = $tagvalue 
                                        }
                                    }
                                }
                            }
                        } 
                    }


                    if ($TagsList -and -not $ErrorFoundInTags) {
                        
                        $DeviceToAdd.TagsAdded = $TagsList
                    }
    
                }
                else {
    
                    "[{0}] {1}: No tags to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber | Write-Verbose
    
                }
                
                

                # Build DeviceList object

                if (-not $ErrorFoundInTags) {

                    # If tags
                    if ($DeviceToAdd.TagsAdded) {
                    
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            tags         = $TagsArray 
                        }
                    }
                    # If no tags
                    else {
                        
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            partNumber   = $DeviceToAdd.PartNumber 
                            
                        }
                    }
    
                    [void]$DevicesToAddList.Add($DeviceList)
                }

            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        if ($DevicesToAddList) {

            # Build payload
            $payload = [PSCustomObject]@{
                compute = @()
                network = @()
                storage = $DevicesToAddList 

            } | ConvertTo-Json -Depth 5
            

            # Add device
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Complete"

                            if ($DeviceToAdd.TagsAdded) {
                                
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = $DeviceToAdd.TagsAdded.count; Error = $Null }
                            }
                            else {
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = $Null }

                            }

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Failed"
                            $DeviceToAdd.TagsAdded = $Null
                            $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device cannot be added to the HPE GreenLake workspace!" }
                            $DeviceToAdd.Exception = $_.Exception.message 

                        }
                    }
                }
            }      
        }
    
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the onboarding attempt!"
            
            }

            Return $ObjectStatusList
        }

    }
}


Function Add-HPEGLDeviceNetwork {
    <#
    .SYNOPSIS
    Add network device(s) to HPE GreenLake. 

    .DESCRIPTION
    This Cmdlet adds network device(s) to the currently connected HPE GreenLake workspace. It can optionally add tags during the onboarding process.  
    Devices must meet the requirements of the Data Services and be on the list of supported systems.    
   
    .PARAMETER SerialNumber
    Serial number of the network device to be added. 
    The serial number can be found in the order confirmation email or in the email received after you activate the network device software. 
    For Nimble devices, it can be retrieved from the network System UI or the pull-out tab.

    .PARAMETER MacAddress 
    Media access control (MAC) address of the device to be added. Most network devices have MAC address on the front or back of the hardware.

    .PARAMETER Tags
    Optional parameter to add tags to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

    Supported tags example:
        - "Country=US"
        - "Country=US,State=TX,App=Grafana" 
        - "Country=US, State =TX ,App= Grafana "
            -> Produces the same result as the previous example.
        - "Private note=this is my tag note value,Email=Chris@email.com,City=New York" 
        - "Private note = this is my tag note value , Email = Chris@email.com , City=New York "
            -> Produces the same result as the previous example.  

    Refer to HPE GreenLake tagging specifications:
    https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
        - Resources that support tagging can have up to 25 tags per resource.
        - Tag keys and values are case-insensitive.
        - There can be only one value for a particular tag key for a given resource.
        - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
        - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
        - Tag keys must have 1-128 characters.
        - Tag values can have a maximum of 256 characters.
        - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.
    
    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceNetwork -SerialNumber "123456789012" -MACAddress "aa:bb:cc:dd:ee:ff"  -Tags "Country=US, Hypersior App=ESXi, City=New York"
    
    Adds a network device to the currently connected HPE GreenLake workspace using a serial number and part number and assigns three tags.

    .EXAMPLE
    Import-Csv Network_Devices.csv  | Add-HPEGLDeviceNetwork -Tags "Location=Houston"

    Adds all network devices listed in a `Network_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns the same location tag to all devices.

    The content of the CSV file must use the following format:
        SerialNumber, MACAddress
        A-23434324,	aa:bb:cc:dd:ee:ff
        A-53234730,	11:bb:22:dd:33:78
        A-58976464,	ff:bb:e3:d2:34:23
 
    .EXAMPLE
    Import-Csv Network_Devices.csv -Delimiter ";"  | Add-HPEGLDeviceNetwork 
    
    Adds all network devices listed in a `Network_Devices.csv` file to the currently connected HPE GreenLake workspace and assigns tags as defined in the 'Tags' column of the CSV file.

    The content of the CSV file must use the following format:
        SerialNumber; MACAddress; Tags
        A-23434324;	aa:bb:cc:dd:ee:ff; Country=US, State=PACA, App=RH
        A-53234730;	11:bb:22:dd:33:78; State=Texas, Role=production
        A-58976464;	ff:bb:e3:d2:34:23

        Note that for `A-58976464`, no tags are assigned in this example.              

    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = 'A-53234730'; MACAddress = 'aa:bb:cc:dd:ee:ff' },
        [PSCustomObject]@{SerialNumber = 'A-58976464'; MACAddress = '11:bb:22:dd:33:78' }
    )

    $devices | Add-HPEGLDeviceNetwork
    
    Add all network devices (2) listed in $devices with the specified serial number and part number keys.
    
    .EXAMPLE
    $devices = @(
        [PSCustomObject]@{SerialNumber = 'A-53234730'; MACAddress = 'aa:bb:cc:dd:ee:ff'; Tags = 'Country=US, State=PACA, App=RH' },
        [PSCustomObject]@{SerialNumber = 'A-58976464'; MACAddress = '11:bb:22:dd:33:78'; Tags = 'State=Texas, Role=production' }
    )

    $devices | Add-HPEGLDeviceNetwork 
    
    Adds all network devices (2) listed in `$devices` with the specified serial numbers and part numbers and assigns them different tags.

    .INPUTS
    System.Collections.ArrayList
        List of Device(s) with serialnumber, MACAddress and tags properties. 

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be added
        * PartNumber - Part number of the device attempted to be added
        * TagsAdded - List of tags to assign to the device (if any)
        * Status - Status of the device onboarding attempt (Failed for HTTP error return; Complete if onboarding is successful; Warning if no action is needed) 
        * Details - More information about the onboarding status of the device, which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - Error - More information on a warning or failed status error.
        * Exception - Information about any exceptions generated during the operation.

   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateScript({
                if ( $_ -match "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$") {
                    $True
                } 
                else {
                    throw "Input '$_' is not in a valid MAC address format. Expected format is 'aa:bb:cc:dd:ee:ff'"
                }
            })]  
        [Alias ('mac_address')]
        [String]$MacAddress,

        [Parameter (ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesAddUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesToAddList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            MACAddress   = $MacAddress
            TagsAdded    = $Tags
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

            
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)



    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        
        foreach ($DeviceToAdd in $ObjectStatusList) {
            
            
            $ErrorFoundInTags = $False

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAdd.SerialNumber
            
            
            if ( $Device) {

                $DeviceToAdd.Status = "Warning"
                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device already present in the HPE GreenLake workspace!" }
                $DeviceToAdd.TagsAdded = $Null
                
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' already present in the HPE GreenLake workspace!" -f $DeviceToAdd.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {
                
                if ($DeviceToAdd.TagsAdded) {
                    
                    "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber, $DeviceToAdd.TagsAdded | Write-Verbose

                    $splittedtags = $DeviceToAdd.TagsAdded.split(",")

                    if ($splittedtags.Length -gt 25) {
                        
                        $DeviceToAdd.Status = "Failed"
                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }
                        $DeviceToAdd.TagsAdded = $Null
                        $ErrorFoundInTags = $True


                        if ($WhatIf) {
                            $ErrorMessage = "Device '{0}' is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAdd.SerialNumber
                            Write-warning $ErrorMessage
                            continue
                        }
                    }
                    else {

                        # Object for the tracking object
                        $TagsList = [System.Collections.ArrayList]::new()
                        # Object for the payload
                        $TagsArray = @{}
                                
                        foreach ($tag in $splittedtags) {
    
                            # Check tag format, if format is not <tagname>=<value>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                                
                                $splittedtagName = $tag.TrimEnd().TrimStart()
    
                                $DeviceToAdd.Status = "Failed"
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }
                                $DeviceToAdd.TagsAdded = $Null
                                $ErrorFoundInTags = $True
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}' tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAdd.SerialNumber, $splittedtagName
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
    
                                $tagname = $tag.split('=')[0]
        
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tagname.TrimEnd().TrimStart()
        
                                if ($tagname.Length -gt 128) {
        
                                    $DeviceToAdd.Status = "Failed"
                                    $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }
                                    $DeviceToAdd.TagsAdded = $Null
                                    $ErrorFoundInTags = $True
        
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}' tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAdd.SerialNumber, $tagname
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {
                                    
                                    $tagvalue = $tag.split('=')[1]
                                    
                                    # Remove space at the begining and at the end of the string if any
                                    $tagvalue = $tagvalue.TrimEnd().TrimStart()
            
                                    if ($tagvalue.Length -gt 256) {
            
                                        $DeviceToAdd.Status = "Failed"
                                        $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }
                                        $DeviceToAdd.TagsAdded = $Null
                                        $ErrorFoundInTags = $True
            
                                        if ($WhatIf) {
                                            $ErrorMessage = "Device '{0}' tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAdd.SerialNumber, $tagvalue
                                            Write-warning $ErrorMessage
                                            break
                                        }
                                    }
                                    else {
    
                                        $TagsArray.$tagname = $tagvalue 
                
                                        $TagsList += [PSCustomObject]@{
                                            name  = $tagname
                                            value = $tagvalue 
                                        }
                                    }
                                }
                            }
                        } 
                    }


                    if ($TagsList -and -not $ErrorFoundInTags) {
                        
                        $DeviceToAdd.TagsAdded = $TagsList
                    }
    
                }
                else {
    
                    "[{0}] {1}: No tags to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAdd.serialnumber | Write-Verbose
    
                }
                
                

                # Build DeviceList object

                if (-not $ErrorFoundInTags) {

                    # If tags
                    if ($DeviceToAdd.TagsAdded) {
                    
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            macAddress   = $DeviceToAdd.macAddress 
                            tags         = $TagsArray 
                        }
                    }
                    # If no tags
                    else {
                        
                        $DeviceList = [PSCustomObject]@{
                            serialNumber = $DeviceToAdd.SerialNumber
                            macAddress   = $DeviceToAdd.macAddress 
                            
                        }
                    }
    
                    [void]$DevicesToAddList.Add($DeviceList)
                }

            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        if ($DevicesToAddList) {

            # Build payload
            $payload = [PSCustomObject]@{
                compute = @()
                network = $DevicesToAddList 
                storage = @()

            } | ConvertTo-Json -Depth 5
            

            # Add device
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Complete"

                            if ($DeviceToAdd.TagsAdded) {
                                
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = $DeviceToAdd.TagsAdded.count; Error = $Null }
                            }
                            else {
                                $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = $Null }

                            }

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($DeviceToAdd in $ObjectStatusList) {

                        $AddedDevice = $DevicesToAddList | Where-Object serialNumber -eq $DeviceToAdd.SerialNumber

                        If ($AddedDevice) {

                            $DeviceToAdd.Status = "Failed"
                            $DeviceToAdd.TagsAdded = $Null
                            $DeviceToAdd.Details = [PSCustomObject]@{TagsAdded = 0; Error = "Device cannot be added to the HPE GreenLake workspace!" }
                            $DeviceToAdd.Exception = $_.Exception.message 

                        }
                    }
                }
            }      
        }
    
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the onboarding attempt!"
            
            }

            Return $ObjectStatusList
        }

    }
} 


Function Disable-HPEGLDevice {
    <#
    .SYNOPSIS
    Archive device(s) in HPE GreenLake.

    .DESCRIPTION
    This Cmdlet archives device(s) in HPE GreenLake. Archiving devices will remove all service assignments and will remove them from your inventory list.

    .PARAMETER SerialNumber 
    Serial number of the device to be archived. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Disable-HPEGLDevice -SerialNumber CNX2380BLC

    Archive the device with the serial number 'CNX2380BLC'.

    .EXAMPLE
    Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString DL360 | Disable-HPEGLDevice -WhatIf

    Archive all DL360 server devices found in the HPE GreenLake workspace.

    .EXAMPLE
    'CNX2380BLC', '7CE244P9LM' | Disable-HPEGLDevice

    Archive the list of devices with serial numbers 'CNX2380BLC' and '7CE244P9LM' provided in the pipeline.

    .INPUTS
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be archived 
        * Status - Status of the archiving attempt (Failed for http error return; Complete if archiving is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesUri  

        $ArchivedDevicesStatus = [System.Collections.ArrayList]::new()
        $DevicesToArchivedList = [System.Collections.ArrayList]::new()



    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

                  
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
          
        }

      
        # Add tracking object to the list of object status list
        [void]$ArchivedDevicesStatus.Add($objStatus)     

   
    }

    end {        

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] Devices to archive: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ArchivedDevicesStatus.SerialNumber | Write-Verbose

        foreach ($DeviceToArchive in $ArchivedDevicesStatus) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToArchive.SerialNumber

            if ( -not $Device) {
                
                $DeviceToArchive.Status = "Failed"
                $DeviceToArchive.Details = "Device cannot be found in the HPE GreenLake workspace!"
                
                # Must return a message if device not found
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $DeviceToArchive.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            elseif ( $Device.archived ) {
                # Must return a message if device already archived
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is already disabled (archived)!" -f $DeviceToArchive.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
                else {
                    
                    $DeviceToArchive.Status = "Warning"
                    $DeviceToArchive.Details = "Device already disabled (archived)!"
                

                }


            }
            else {

                # Create the device list object 
                if ($device.mac_address) {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $true
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                        mac_address   = $device.mac_address
                    }
                    [void]$DevicesToArchivedList.Add($DeviceList)

                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $true
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                    }
                    [void]$DevicesToArchivedList.Add($DeviceList)
                }
            }

        }

        if ($DevicesToArchivedList) {

            $payload = [PSCustomObject]@{
                devices = $DevicesToArchivedList
            } | ConvertTo-Json -Depth 5


            try {

                Invoke-HPEGLWebRequest -Uri $Uri -Method 'PATCH' -Body $payload -WhatIfBoolean $WhatIf | Out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToArchive in $ArchivedDevicesStatus) {
                    
                        $DeviceToArchive.Status = "Complete"
                        $DeviceToArchive.Details = "Device successfully disabled (archived)"
                    }
                }
            }
            catch {

                if (-not $WhatIf) {
                    
                    foreach ($DeviceToArchive in $ArchivedDevicesStatus) {

                        $DeviceToArchive.Status = "Failed"
                        $DeviceToArchive.Details = "Device could not be disabled (archived)!"
                        $DeviceToArchive.Exception = $_.Exception.message

                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($ArchivedDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the disabling attempt!"
          
            }

            Return $ArchivedDevicesStatus
        }
    }
}


Function Enable-HPEGLDevice {
    <#
    .SYNOPSIS
    Unarchive device(s) in HPE GreenLake.

    .DESCRIPTION
    This Cmdlet unarchives device(s) in HPE GreenLake console. Unarchiving devices will make devices available for assignment and subscription.      

    .PARAMETER SerialNumber 
    Serial number of the device to be unarchived. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Enable-HPEGLDevice -SerialNumber "CNX2380BLC"

    Unarchive the device with the serial number CNX2380BLC.
    
    .EXAMPLE
    Get-HPEGLdevice -ShowArchived | Enable-HPEGLDevice

    Unarchive all archived devices found in the HPE GreenLake workspace.

    .EXAMPLE
    'CNX2380BLC', '7CE244P9LM' | Enable-HPEGLDevice

    Unarchive the list of devices with serial numbers 'CNX2380BLC' and '7CE244P9LM' provided in the pipeline.

    .INPUTS
    System.Collections.ArrayList
        List of archived devices from 'Get-HPEGLdevice -ShowArchived'. 
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers.        

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device attempted to be unarchived 
        * Status - Status of the unarchiving attempt (Failed for http error return; Complete if unarchiving is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Uri = $DevicesUri  

        $UnarchivedDevicesStatus = [System.Collections.ArrayList]::new()
        $DevicesToUnarchivedList = [System.Collections.ArrayList]::new()

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
          
        }

      

        # Add tracking object to the list of object status list
        [void]$UnarchivedDevicesStatus.Add($objStatus)     



    }

    end {

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] Devices to unarchive: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($UnarchivedDevicesStatus.SerialNumber | out-string) | Write-Verbose

        foreach ($DeviceToUnarchive in $UnarchivedDevicesStatus) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToUnarchive.SerialNumber

            if ( -not $Device) {
                
                $DeviceToUnarchive.Status = "Failed"
                $DeviceToUnarchive.Details = "Device cannot be found in the HPE GreenLake workspace!"
                
                # Must return a message if device not found
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $DeviceToUnarchive.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
                 
            }
            elseif (-not $device.archived ) {
                # Must return a message if device is not archived
            
                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is already enabled (unarchived)!" -f $DeviceToUnarchive.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
                else {
                    $DeviceToUnarchive.Status = "Warning"
                    $DeviceToUnarchive.Details = "Device is already enabled (unarchived)!"
                        
                }

            }
            else {
            
                # Create the device list object 
                if ($device.mac_address) {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $false
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                        mac_address   = $device.mac_address
                    }
                    [void]$DevicesToUnarchivedList.Add($DeviceList)

                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        archive       = $false
                        serial_number = $device.serial_number
                        part_number   = $device.part_number
                        device_type   = $device.device_type
                    }
                    [void]$DevicesToUnarchivedList.Add($DeviceList)
                }
            }
        }

            
        if ($DevicesToUnarchivedList) {

            $payload = [PSCustomObject]@{
                devices = $DevicesToUnarchivedList
            } | ConvertTo-Json -Depth 5


            try {

                Invoke-HPEGLWebRequest -Uri $Uri -Method 'PATCH' -Body $payload -WhatIfBoolean $WhatIf | Out-Null

                if (-not $WhatIf) {

                    foreach ($DeviceToUnarchive in $UnarchivedDevicesStatus) {
                    
                        $DeviceToUnarchive.Status = "Complete"
                        $DeviceToUnarchive.Details = "Device successfully enabled (unarchived)"
                    }
                }
            }
            catch {

                if (-not $WhatIf) {
                    
                    foreach ($DeviceToUnarchive in $UnarchivedDevicesStatus) {

                        $DeviceToUnarchive.Status = "Failed"
                        $DeviceToUnarchive.Details = "Device could not be enabled (unarchived)!"
                        $DeviceToUnarchive.Exception = $_.Exception.message

                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($UnarchivedDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the enabling attempt!"
        
            }

            Return $UnarchivedDevicesStatus
        }


    }
   
}


Function Add-HPEGLDeviceTag {
    <#
.SYNOPSIS
Add tag(s) to a device.

.DESCRIPTION
This cmdlet adds one or more tags to a specified device available in the workspace. If a tag with the same name already exists on the device, the cmdlet deletes the existing tag and recreates it with the new value.

.PARAMETER SerialNumber
The serial number of the device to which tags must be added. This value can be retrieved using 'Get-HPEGLDevice'.

.PARAMETER Tags
Tags to be added to the device. Tags must meet the following string format: <Name>=<Value>, <Name>=<Value>.

Supported tags example:
    - "Country=US"
    - "Country=US,State=TX,App=Grafana" 
    - "Country=US, State =TX ,App= Grafana "
        -> Produces the same result as the previous example.
    - "Note=this is my tag note value,Email=Chris@email.com,City=New York" 
    - "Note = this is my tag note value , Email = Chris@email.com , City=New York "
        -> Produces the same result as the previous example.  

Refer to HPE GreenLake tagging specifications:
https://support.hpe.com/hpesc/public/docDisplay?docId=a00120892en_us&docLocale=en_US&page=GUID-1E4DDAEA-E799-418F-90C8-30CE6A2873AB.html
    - Resources that support tagging can have up to 25 tags per resource.
    - Tag keys and values are case-insensitive.
    - There can be only one value for a particular tag key for a given resource.
    - Null is not allowed as a possible value for a tag key; instead, an empty string ("") will be supported to enable customers to use tag key-value pairs for labeling.
    - System-defined tags are allowed and start with the prefix "hpe:". User-defined tags cannot start with this prefix.
    - Tag keys must have 1-128 characters.
    - Tag values can have a maximum of 256 characters.
    - Allowed characters include letters, numbers, spaces representable in UTF-8, and the following characters: _ . : + - @.

.PARAMETER WhatIf
Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

.EXAMPLE
Add-HPEGLDeviceTag -SerialNumber CWERX2380BLC -Tags "Department=HR"

Adds the tag 'Department=HR' to the device with serial number 'CWERX2380BLC'. 

.EXAMPLE
Add-HPEGLDeviceTag -SerialNumber CWERX2380BLC -Tags "Country=US, App=VMware"

Adds the tags 'Country=US' and 'App=VMware' to the device with serial number 'CWERX2380BLC'.

.EXAMPLE
'CNX2380BLC', 'MXQ73200W1', 'EZ12312312' | Add-HPEGLDeviceTag -Tags "Department=HR, Apps=RHEL"

Adds the tags 'Department=HR' and 'Apps=RHEL' to the list of devices with the specified serial numbers defined in the pipeline.

.EXAMPLE
Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString DL360 | Add-HPEGLDeviceTag -Tags "Country=US, Apps=VMware ESX"

Adds the tags 'Country=US' and 'Apps=VMware ESX' to all DL360 server devices found in the workspace.

.EXAMPLE
Import-Csv Tests/Network_Devices.csv | Add-HPEGLDeviceTag -Tags "Country=US, City=New York"

Adds two tags to all devices listed in a "Network_Devices.csv" file containing at least a SerialNumber column.

.EXAMPLE
Import-Csv .\Compute_Devices_Tags.csv -Delimiter ";"  | Add-HPEGLDeviceTag 

Adds tags to all devices listed in a `Compute_Devices_Tags.csv` file containing at least two columns, SerialNumber and Tags.

The content of the CSV file must use the following format:
    SerialNumber; Tags
    7LKY2323233LM; Country=US, State=CA, App=RH
    CZ123QWE456; State=TX, Role=Production
    CZ122QWE533; City=New York

.INPUTS
System.Collections.ArrayList
    List of devices(s) from 'Get-HPEGLDevice'.
System.String, System.String[]
    A single string object or a list of string objects representing the device's serial numbers.

.OUTPUTS
System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
    * SerialNumber - The serial number of the device to which tags were attempted to be added.
    * PartNumber - The part number of the device.
    * DeviceType - The type of the device.
    * TagsAdded - List of tags that have been added.
    * TagsDeleted - List of tags that have been deleted.
    * TagsUnmodified - List of tags that have not been modified.
    * Status - The status of the tagging attempt (Failed for HTTP error return; Warning if tagging is incomplete; Complete if tagging is successful).
    * Details - More information about the status which includes a PSCustomObject with:
          - TagsAdded - The number of tags added to the device.
          - TagsDeleted - The number of tags deleted.
          - TagsUnmodified - The number of tags that have not been modified.
          - Error - More information on a warning or failed status error.
    * Exception - Information about any exceptions generated during the operation.
#>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [String]$Tags,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesATagsUri + "?only_validate=false"
        
        $AddTagsDevicesStatus = [System.Collections.ArrayList]::new()
        
        $DevicesWithTagsToAddList = [System.Collections.ArrayList]::new()
        $ObjectStatusList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
    
        # Build object for the output
        $objStatus = [pscustomobject]@{
          
            SerialNumber   = $SerialNumber
            PartNumber     = $Null
            DeviceType     = $Null
            TagsAdded      = $Tags
            TagsDeleted    = $Null
            TagsUnmodified = $Null
            Status         = $Null
            Details        = $Null
            Exception      = $Null
                  
        }
        
      
        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {

        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] List of devices where to add tags: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ObjectStatusList.serialnumber | Write-Verbose

        foreach ($DeviceToAddTags in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToAddTags.SerialNumber

            if ( -not $Device) {
                # Must return a message if device not found
                $DeviceToAddTags.Status = "Failed"
                $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Device cannot be found in the HPE GreenLake workspace!" }               

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $DeviceToAddTags.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {

                "[{0}] {1}: Object TagsAdded content: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $DeviceToAddTags.serialnumber, $DeviceToAddTags.TagsAdded | Write-Verbose

                $splittedtags = $DeviceToAddTags.TagsAdded.split(",")

                if ($splittedtags.Length -gt 25) {
                    
                    $DeviceToAddTags.Status = "Failed"
                    $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Too many tags defined ! A maximum of 25 tags per resource is supported!" }               

                    if ($WhatIf) {
                        $ErrorMessage = "Device '{0}' is defined with too many tags! A maximum of 25 tags per resource is supported!" -f $DeviceToAddTags.SerialNumber
                        Write-warning $ErrorMessage
                        continue
                    }
                }
                else {

                    # Object for the tracking object
                    $TagsList = [System.Collections.ArrayList]::new()
                    # Object for the payload
                    $TagsArray = @{}
                            
                    foreach ($tag in $splittedtags) {

                        # Check tag format, if format is not <tagname>=<value>, return error
                        if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+\=[\p{L}\p{Nd}_ .:+\-@]+$') {
                            
                            $splittedtagName = $tag.TrimEnd().TrimStart()

                            $DeviceToAddTags.Status = "Failed"
                            $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" }               

                            if ($WhatIf) {
                                $ErrorMessage = "Device '{0}' tag '{1}' format not supported! Expected format is <tagname>=<value>, <tagname>=<value>!" -f $DeviceToAddTags.SerialNumber, $splittedtagName
                                Write-warning $ErrorMessage
                                break
                            }
                        }
                        else {

                            $tagname = $tag.split('=')[0]
    
                            # Remove space at the begining and at the end of the string if any
                            $tagname = $tagname.TrimEnd().TrimStart()
    
                            if ($tagname.Length -gt 128) {
    
                                $DeviceToAddTags.Status = "Failed"
                                $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Tag name '$tagname' is over 128 characters! Tag names can have a maximum of 128 characters!" }               
    
                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}' tag name '{1}' is over 128 characters! Tag names can have a maximum of 128 characters!" -f $DeviceToAddTags.SerialNumber, $tagname
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
                                
                                $tagvalue = $tag.split('=')[1]
                                
                                # Remove space at the begining and at the end of the string if any
                                $tagvalue = $tagvalue.TrimEnd().TrimStart()
        
                                if ($tagvalue.Length -gt 256) {
        
                                    $DeviceToAddTags.Status = "Failed"
                                    $DeviceToAddTags.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Tag value '$tagvalue' is over 256 characters! Tag values can have a maximum of 256 characters!" }     

        
                                    if ($WhatIf) {
                                        $ErrorMessage = "Device '{0}' tag value '{1}' is over 256 characters! Tag values can have a maximum of 256 characters!" -f $DeviceToAddTags.SerialNumber, $tagvalue
                                        Write-warning $ErrorMessage
                                        break
                                    }
                                }
                                else {

                                    $TagsList += [PSCustomObject]@{
                                        name  = $tagname
                                        value = $tagvalue 
                                    }
                                }
                            }
                        }
                    } 
                }

                # Remove all tags from the tracking object as we will create a new tag status based on device state
                $DeviceToAddTags.TagsAdded = $Null


                $DeviceToAddTags.PartNumber = $Device.Part_Number
                $DeviceToAddTags.DeviceType = $Device.Device_Type

                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
            
                }

                # Building the list of devices object where to add tags
                [void]$DevicesWithTagsToAddList.Add($DeviceList)

                # Capturing Tags that already exist
                $ExistingTags = $Device.tags

                if ($ExistingTags) {
                    "[{0}] {1}: Existing tags: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, ($ExistingTags | Out-String) | write-verbose
                }
                else {
                    "[{0}] {1}: No existing tag!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber | write-verbose

                }

                # Payload objects
                $TagsUnmodified = [System.Collections.ArrayList]::new()
                $TagsToBeCreated = [System.Collections.ArrayList]::new()
                $TagsToBeDeleted = [System.Collections.ArrayList]::new()
                        
                
                foreach ($_Tag in $TagsList) {                
                    
                    "[{0}] Tag requested to be added: {1}={2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name, $_Tag.value | write-verbose

                    if ($ExistingTags) {

                        # If tag name to add is equal to exisitng tag name
                        If ($ExistingTags | Where-Object name -eq $_tag.name) {

                            "[{0}] '{1}' tag is present" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name | write-verbose
                            
                            # If tag value to add is equal to existing tag value
                            if ($_tag.value -eq (($ExistingTags | Where-Object name -eq $_tag.name).value)) {
                                
                                "[{0}] Tag '{1}' value is equal to the one already set: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name, $_Tag.value | write-verbose

                                [void]$TagsUnmodified.Add($_Tag)

                                $DeviceToAddTags.TagsUnmodified = $TagsUnmodified    
                                $DeviceToAddTags.Status = "Warning"

                            }
                            else {

                                "[{0}] Tag '{1}' value is not equal to the one already set: {2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name, $_Tag.value | write-verbose

                                # A modification is a two steps process"
                                #  1- Delete the exisiting tag (must be added to the delete tag list)
                                #  2- Create a new tag using the same name but this time with the new value (must be added to the create tag list)
                                
                                #  1 
                                $_TagToDelete = [System.Collections.HashTable]@{
                                    name  = ($ExistingTags | Where-Object name -eq $_tag.name).name
                                    value = ($ExistingTags | Where-Object name -eq $_tag.name).value
                                }
                                
                                [void]$TagsToBeDeleted.Add($_TagToDelete)
                                
                                #  2
                                [void]$TagsToBeCreated.Add($_Tag)
                                
                                # Add tags to the tracking object
                                $DeviceToAddTags.TagsAdded = $TagsToBeCreated                       
                                $DeviceToAddTags.TagsDeleted = $TagsToBeDeleted                       



                            }
                        }
                        elseif ($ExistingTags | Where-Object name -ne $_tag.name) {

                            "[{0}] '{1}' tag is not present" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name | write-verbose

                            [void]$TagsToBeCreated.Add($_Tag)

                            # Add created tag to the tracking object
                            $DeviceToAddTags.TagsAdded = $TagsToBeCreated                       


                        }
                    }
                    else {

                        "[{0}] '{1}' tag to add" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag.name | write-verbose

                        [void]$TagsToBeCreated.Add($_Tag)

                        # Add created tag to the tracking object
                        $DeviceToAddTags.TagsAdded = $TagsToBeCreated                       

                    }
                }        
            }
        }

        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose
       
        
        # Removing objects where status is failed (condition when device is not found or tags are not supported)
        $ObjectStatusListForFoundDevices = $ObjectStatusList | Where-Object { $_.Status -ne "Failed" }
        
        "[{0}] List of objects where status is not failed in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListforFoundDevices | Out-String) | Write-Verbose
        
        "[{0}] Grouping objects based on identical TagsAdded / TagsDeleted property values" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        # Create a unique key for each object based on TagsDeleted
        $ObjectStatusListForFoundDevices | ForEach-Object {
            $TagsDeleteduniqueKey = ($_.TagsDeleted | Sort-Object name, value | ForEach-Object { "$($_.name)=$($_.value)" }) -join ";"
            $TagsAddeduniqueKey = ($_.TagsAdded | Sort-Object name, value | ForEach-Object { "$($_.name)=$($_.value)" }) -join ";"
            $uniqueKey = "$TagsDeleteduniqueKey;$TagsAddeduniqueKey"
            Add-Member -InputObject $_ -MemberType NoteProperty -Name UniqueKey -Value $uniqueKey
        }

        # Group objects based on the unique key
        $groupedObjects = $ObjectStatusListForFoundDevices | Group-Object -Property UniqueKey

        # Remove the UniqueKey property from each object in $groupedObjects
        $groupedObjects | ForEach-Object {
            $_.Group | ForEach-Object {
                $_ | ForEach-Object { $_.PSObject.Properties.Remove('UniqueKey') }

            }
        }
        
        "[{0}] List of object groups with devices found: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($groupedObjects | Out-String) | Write-Verbose

        foreach ($Group in $groupedObjects ) {
            
            "[{0}] Group being processed: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Group | Out-String) | Write-Verbose

            $ListOfDevicesWithMatchingTagsAddedAndModified = $DevicesWithTagsToAddList | Where-Object serial_number -in $Group.group.SerialNumber 

            if ($Group.Count -eq 1 ) {
                $ListOfDevicesWithMatchingTagsAddedAndModified = @($ListOfDevicesWithMatchingTagsAddedAndModified)
            }

            $TagsToBeCreated = $Group.group[0].TagsAdded
            
            if ($Group.group[0].TagsDeleted ) {
                $TagsToBeDeleted = $Group.group[0].TagsDeleted 
            }
            else {
                $TagsToBeDeleted = @()
            }
                
            # Build payload
            $payload = [PSCustomObject]@{
                devices     = $ListOfDevicesWithMatchingTagsAddedAndModified 
                create_tags = $TagsToBeCreated
                delete_tags = $TagsToBeDeleted
            } 
            

            # Add tags
            try {

                $SkipSubsequentRequestWithWhatIf = $False

                if ( $TagsToBeDeleted) {

                    $jsonPayload = $payload | ConvertTo-Json -Depth 5

                    if ($WhatIf) {
                        # This is to skip the subsequent CALL request during a tag modification when Whatif is used.
                        $SkipSubsequentRequestWithWhatIf = $True
                    }
                    
                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $jsonPayload -WhatIfBoolean $WhatIf  
                    
                    $payload = $payload | Select-Object -Property * -ExcludeProperty "delete_tags"

                                    
                }

                $jsonPayload = $payload | ConvertTo-Json -Depth 5

                if ($TagsToBeCreated -and -not $SkipSubsequentRequestWithWhatIf) {

                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $jsonPayload -WhatIfBoolean $WhatIf        
                                                
                    if (-not $WhatIf) {

                        foreach ($object in $Group.Group) {
                            $object.Status = "Complete"
                            $object.Details = [PSCustomObject]@{TagsAdded = $TagsToBeCreated.count; TagsDeleted = $TagsToBeDeleted.count; TagsUnmodified = $object.TagsUnmodified.count; Error = $Null }
                            [void] $AddTagsDevicesStatus.add($object)

                        }
                    }
                }
                else {

                    "[{0}] No action required, the same tag configuration already exists." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    if (-not $WhatIf) {

                        foreach ($object in $Group.Group) {
                            $object.Status = "Warning"
                            $object.Details = [PSCustomObject]@{TagsAdded = $TagsToBeCreated.count; TagsDeleted = $TagsToBeDeleted.count; TagsUnmodified = $object.TagsUnmodified.count; Error = "No action required, the same tag configuration already exists!" }
                            [void] $AddTagsDevicesStatus.add($object)

                        }
                    }
                    else {

                        foreach ($object in $Group.Group) {
                            Write-Warning "Device '$($object.SerialNumber)' has no action required, the tag configuration already exists."
                        }
                    }
                   
                }

            }
            catch {

                if (-not $WhatIf) {

                    foreach ($object in $Group.Group) {
                        $object.Status = "Failed"
                        $Object.TagsAdded = $Null
                        $object.Details = [PSCustomObject]@{TagsAdded = 0; TagsDeleted = 0; TagsUnmodified = 0; Error = "Device tagging error!" }
                        $object.Exception = $_.Exception.message 

                        [void] $AddTagsDevicesStatus.add($object)

                    }
                }
            }
        }
    
        # Getting objects where status is failed (condition when device is not found or tags are not supported )
        $ObjectStatusListOfDevicesNotFound = $ObjectStatusList | Where-Object { $_.Status -eq "Failed" } 


        "[{0}] List of objects with failed status: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListOfDevicesNotFound | Out-String) | Write-Verbose

        foreach ($Object in $ObjectStatusListOfDevicesNotFound) {

            if (-not $WhatIf) {
                $Object.TagsAdded = $Null
                [void] $AddTagsDevicesStatus.add($object)

            }
                
        }


        if (-not $WhatIf) {

            if ($AddTagsDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the tagging attempt!"
          
            }

            Return $AddTagsDevicesStatus
        }
    }
}


Function Remove-HPEGLDeviceTag {
    <#
.SYNOPSIS
Delete tag(s) from a device.

.DESCRIPTION
This Cmdlet deletes one or more tags from a specified device available in the workspace.

.PARAMETER SerialNumber
The serial number of the device from which tags must be deleted. This value can be retrieved using 'Get-HPEGLDevice'.

.PARAMETER Tags
Tags to be removed from the device. Tags must meet the following string format: <Name1>, <Name2>. For example, "Country" or "European location, timezone" or "Country, State, Grafana".

.PARAMETER WhatIf
Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

.EXAMPLE
Remove-HPEGLDeviceTag -SerialNumber CWERX2380BLC -Tags "European location"

Removes the tag 'European location' from the device with serial number 'CWERX2380BLC'. 

.EXAMPLE
Remove-HPEGLDeviceTag -SerialNumber CWERX2380BLC -Tags "Country, App"

Removes the tags 'Country' and 'App' from the device with serial number 'CWERX2380BLC'.

.EXAMPLE
'CNX2380BLC', 'MXQ73200W1', 'EZ12312312' | Remove-HPEGLDeviceTag -Tags "Department, Apps"

Removes the tags 'Department' and 'Apps' from the list of devices with the specified serial numbers defined in the pipeline.

.EXAMPLE
Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString DL360 | Remove-HPEGLDeviceTag -Tags "Country, State"

Removes the tags 'Country' and 'State' from all DL360 server devices found in the workspace.

.EXAMPLE
Import-Csv Tests/Network_Devices.csv | Remove-HPEGLDeviceTag -Tags "Country, City, State"

Removes three tags from all devices listed in a CSV file containing at least a SerialNumber column.

.EXAMPLE
Get-HPEGLDevice -FilterByDeviceType SWITCH | Remove-HPEGLDeviceTag -All

Removes all tags from all switch devices found in the workspace.

.EXAMPLE
Import-Csv .\Compute_Devices_Tags.csv -Delimiter ";"  | Remove-HPEGLDeviceTag 

Removes tags from all devices listed in a `Compute_Devices_Tags.csv` file containing at least two columns, SerialNumber and Tags.

The content of the CSV file must use the following format:
    SerialNumber; Tags
    7LKY2323233LM; Country, State, App
    CZ123QWE456; State, Role
    CZ122QWE533; City

.INPUTS
System.Collections.ArrayList
    List of devices(s) from 'Get-HPEGLDevice'.
System.String, System.String[]
    A single string object or a list of string objects representing the device's serial numbers.

.OUTPUTS
System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
    * SerialNumber - The serial number of the device from which tags were attempted to be removed.
    * PartNumber - The part number of the device.
    * TagsDeleted - List of tags that have been deleted.
    * TagsNotFound - List of tags that were not found on the device.
    * Status - The status of the untagging attempt (Failed for HTTP error return; Warning if tagging is incomplete; Complete if tagging is successful).
    * Details - More information about the status which includes a PSCustomObject with:
          - TagsDeleted - The number of tags deleted.
          - TagsNotFound - The number of tags that could not be found on the device.
          - Error - More information on a warning or failed status error.
    * Exception - Information about any exceptions generated during the operation.
#>



    [CmdletBinding(DefaultParameterSetName = 'SerialNumberAndTags')]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, ParameterSetName = "SerialNumberAndTags")]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, ParameterSetName = "SerialNumberAndAll")]
        [Alias ('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "SerialNumberAndTags")]
        [String]$Tags,

        [Parameter (ParameterSetName = "SerialNumberAndAll")]
        [Switch]$All,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesATagsUri + "?only_validate=false"
        
        $RemoveTagsDevicesStatus = [System.Collections.ArrayList]::new()
        
        $DevicesWithTagsToRemoveList = [System.Collections.ArrayList]::new()
        $ObjectStatusList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose               
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
          
            SerialNumber = $SerialNumber
            PartNumber   = $Null
            DeviceType   = $Null
            TagsDeleted  = $Tags
            TagsNotFound = $Null
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }

        # Add tracking object to the list of object status list
        [void]$ObjectStatusList.Add($objStatus)

    }

    end {


        try {
            $Devices = Get-HPEGLdevice 
        
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        "[{0}] List of devices where to remove tags: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ObjectStatusList.serialnumber | Write-Verbose

        foreach ($DeviceToRemoveTags in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $DeviceToRemoveTags.SerialNumber

            if ( -not $Device) {
                # Must return a message if device not found
                $DeviceToRemoveTags.Status = "Failed"
                $DeviceToRemoveTags.TagsDeleted = $Null
                $DeviceToRemoveTags.Details = [PSCustomObject]@{TagsDeleted = 0; TagsNotFound = 0; Error = "Device cannot be found in the HPE GreenLake workspace!" }

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $DeviceToRemoveTags.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {

                $DeviceToRemoveTags.PartNumber = $Device.Part_Number
                $DeviceToRemoveTags.DeviceType = $Device.Device_Type
                    
                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                        
                }      
                "[{0}] `$DeviceList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($DeviceList | out-String) | write-verbose
                    
                # Building the list of devices object where to remove tags
                [void]$DevicesWithTagsToRemoveList.Add($DeviceList)
                    
                # Capturing Tags that already exist
                $ExistingTags = $device.tags

                if ($ExistingTags) {
                    "[{0}] {1}: Existing tags: `n{2}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber, ($ExistingTags | Out-String) | write-verbose
                }
                else {
                    "[{0}] {1}: No existing tag!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SerialNumber | write-verbose
        
                }
    
                if ($ExistingTags) {
    
                    # Payload objects
                    $TagsToBeDeleted = [System.Collections.ArrayList]::new()
                    $TagsNotFoundList = [System.Collections.ArrayList]::new()
    
                    if ($All) {
    
                        foreach ($_Tag in $ExistingTags) {
            
                            [void]$TagsToBeDeleted.Add($_Tag)
    
                            $TagsNotfoundNumber = 0
            
                        }         
    
    
                    }                             
                    else {

                        $splittedtags = $DeviceToRemoveTags.TagsDeleted.split(",")

                        $TagsList = [System.Collections.ArrayList]::new()

                        foreach ($tag in $splittedtags) {

                            # Check tag format, if format is not <tagname>, return error
                            if ($tag -notmatch '^[\p{L}\p{Nd}_ .:+\-@]+$') {

                                $splittedtagName = $tag.TrimEnd().TrimStart()

                                $DeviceToRemoveTags.Status = "Failed"
                                $DeviceToRemoveTags.TagsDeleted = $Null
                                $DeviceToRemoveTags.Details = [PSCustomObject]@{TagsDeleted = 0; TagsNotFound = 0; Error = "Tag format '$splittedtagName' not supported! Expected format is <tagname>, <tagname>!" }

                                if ($WhatIf) {
                                    $ErrorMessage = "Device '{0}' tag '{1}' format not supported! Expected format is <tagname>, <tagname>!" -f $DeviceToRemoveTags.SerialNumber, $splittedtagName
                                    Write-warning $ErrorMessage
                                    break
                                }
                            }
                            else {
                            
                                # Remove space at the begining and at the end of the string if any
                                $tagname = $tag.TrimEnd().TrimStart()
                                
                                $TagsList += $tagname

                            }
                                
                        } 

                        if ($TagsList) {                                
                                
                            "[{0}] Tag list to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($TagsList | Out-String) | write-verbose
                                
                            foreach ($_Tag in $TagsList) {     
                                    
                                $_TagItem = $ExistingTags | Where-Object name -eq $_Tag
                                    
                                # Find tags that need to be deleted and that do exist
                                If ($_TagItem) {
                                        
                                    "[{0}] Tag '{1}' is present" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag | write-verbose
                                    [void]$TagsToBeDeleted.Add($_TagItem)
                                }
                                # Find tags that need to be deleted but that do not exist
                                else {
                
                                    "[{0}] Tag '{1}' cannot be found" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_Tag | write-verbose
                                    [void]$TagsNotFoundList.Add($_Tag)
                
                                }
                            }
                
                            $TagsNotfoundNumber = $TagsNotFoundList.count
                                
                            # Add list of tags not found to the tracking object
                            if ($TagsNotFoundList  ) {
                                $DeviceToRemoveTags.TagsNotFound = $TagsNotFoundList    
                                    
                            }
                            else {
                                $objStatus.TagsNotFound = $Null
                            }
                        }
                            
                    }
                        
                    # Add list of tags to be deleted to the tracking object
                    if ( $TagsToBeDeleted) {
                        $DeviceToRemoveTags.TagsDeleted = $TagsToBeDeleted    
                        "[{0}] Tag list to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($TagsToBeDeleted | Out-String) | write-verbose
                            
                    }
                    else {
                        $DeviceToRemoveTags.TagsDeleted = $Null                    
                        "[{0}] No tag to delete!" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-verbose

                    }
                }
            }
        }


        "[{0}] List of objects in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList | Out-String) | Write-Verbose

        # Removing objects where status is failed (condition when device is not found or tags not supported)
        $ObjectStatusListForFoundDevices = $ObjectStatusList | Where-Object { $_.Status -ne "Failed" }
        
        "[{0}] List of objects where status is not failed in `$ObjectStatusList: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListforFoundDevices | Out-String) | Write-Verbose
        
        "[{0}] Grouping objects based on identical TagsDeleted property values" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
        
        # Create a unique key for each object based on TagsDeleted
        $ObjectStatusListForFoundDevices | ForEach-Object {
            $uniqueKey = ($_.TagsDeleted | Sort-Object name, value | ForEach-Object { "$($_.name)=$($_.value)" }) -join ";"
            Add-Member -InputObject $_ -MemberType NoteProperty -Name UniqueKey -Value $uniqueKey
        }

        # Group objects based on the unique key
        $groupedObjects = $ObjectStatusListForFoundDevices | Group-Object -Property UniqueKey

        # Remove the UniqueKey property from each object in $groupedObjects
        $groupedObjects | ForEach-Object {
            $_.Group | ForEach-Object {
                $_ | ForEach-Object { $_.PSObject.Properties.Remove('UniqueKey') }

            }
        }
        
        "[{0}] List of object groups: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($groupedObjects | Out-String) | Write-Verbose

        
        foreach ($Group in $groupedObjects) {
            
            "[{0}] Group being processed: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Group | Out-String) | Write-Verbose

            $ListOfDevicesWithMatchingTagsDeleteded = $DevicesWithTagsToRemoveList | Where-Object serial_number -in $Group.group.SerialNumber 

            if ($Group.Count -eq 1 ) {
                $ListOfDevicesWithMatchingTagsDeleteded = @($ListOfDevicesWithMatchingTagsDeleteded)
            }

            $TagsToBeDeleted = $Group.group[0].TagsDeleted 

            # Build payload
            $payload = [PSCustomObject]@{
                devices     = $ListOfDevicesWithMatchingTagsDeleteded 
                delete_tags = $TagsToBeDeleted
                create_tags = @()
                
            }                         
                
                
            try {

                $jsonPayload = $payload | ConvertTo-Json -Depth 5

                if ($TagsToBeDeleted) {
                    
                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $jsonPayload -WhatIfBoolean $WhatIf     

                    if (-not $WhatIf) {
    
                        # Find tags that need to be deleted but that do not exist
                        $TagsNotfoundNumber = $TagsList.count - $TagsToBeDeleted.count
    
                        foreach ($object in $Group.Group) {
                            $object.Status = "Complete"
                            $object.Details = [PSCustomObject]@{TagsDeleted = $TagsToBeDeleted.count; TagsNotFound = $object.TagsNotFound.count; Error = $Null }
                            [void] $RemoveTagsDevicesStatus.add($object)
    
    
                        }
                    }
                }
                else {

                    "[{0}] No deletion is required, as there are no such tags to delete." -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                    if (-not $WhatIf) {

                        foreach ($object in $Group.Group) {
                            $object.Status = "Warning"
                            $object.Details = [PSCustomObject]@{TagsDeleted = $TagsToBeDeleted.count; TagsNotFound = $object.TagsNotFound.count; Error = "No action required, tags to remove cannot be found!" }
                            [void] $RemoveTagsDevicesStatus.add($object)

                        }
                    }
                    else {

                        foreach ($object in $Group.Group) {
                            Write-Warning "Device '$($object.SerialNumber)' has no action required, tags to remove cannot be found!"

                        }
                    }
                }
            }
            catch {

                if (-not $WhatIf) {

                    foreach ($object in $Group.Group) {
                        $object.Status = "Failed"
                        $object.Details = [PSCustomObject]@{TagsDeleted = 0; TagsNotFound = 0; Error = "Device untagging error!" }
                        $object.Exception = $_.Exception.message 
                        [void] $RemoveTagsDevicesStatus.add($object)

                    }
                }
            }
        }   
        
        # Getting objects where status is failed (condition when device is not found and tags are not supported)
        $ObjectStatusListOfDevicesNotFound = $ObjectStatusList | Where-Object { $_.Status -eq "Failed" } 


        "[{0}] List of objects with devices not found: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusListOfDevicesNotFound | Out-String) | Write-Verbose

        foreach ($Object in $ObjectStatusListOfDevicesNotFound) {

            if (-not $WhatIf) {
                [void] $RemoveTagsDevicesStatus.add($object)

            }
                
        }

        if (-not $WhatIf) {

            if ($RemoveTagsDevicesStatus | Where-Object { $_.Status -eq "Failed" }) {

                write-error "One or more devices failed the untagging attempt!"
        
            }

            Return $RemoveTagsDevicesStatus
        }
    }
}


Function Get-HPEGLLocation {
    <#
    .SYNOPSIS
    Retrieve device locations.

    .DESCRIPTION
    This Cmdlet returns a collection of physical locations and service shipping addresses for all devices.

    .PARAMETER Name 
    (Optional) Specifies the name of a location to display its details.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLLocation

    Returns all physical locations.

    .EXAMPLE
    Get-HPEGLLocation -Name "Geneva"

    Returns the Geneva location information.

    #>

    [CmdletBinding()]
    Param( 
        [String]$Name,            
 
        [Switch]$WhatIf

    ) 
    
    Begin {
    
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Uri = $DevicesLocationUri
  
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
        
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       

        if ($Null -ne $Collection.data) {
              
            $CollectionList = $Collection.data 

            # $ListOfDetailedLocations = [System.Collections.ArrayList]::new()
            $ListOfDetailedLocations = @()

            foreach ($Location in $CollectionList) {

                "[{0}] Selected collection data '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Location.name | Write-Verbose

                $Uri = $DevicesLocationUri + "/" + $Location.id

                "[{0}] URI for the '{1}' location: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Uri | Write-Verbose

                try {
                    [array]$_Resp = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 

                    # [void]$ListOfDetailedLocations.Add($_Resp)
                    $ListOfDetailedLocations += $_Resp
            
                }
                catch {
        
                    $PSCmdlet.ThrowTerminatingError($_)
            
                }
            }
                       
            if ($Name) {
                
                $ListOfDetailedLocations = $ListOfDetailedLocations | Where-Object { $_.name -eq $Name } 
                
            }
                
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $ListOfDetailedLocations -ObjectName "Location" 

            $ReturnData = $ReturnData | Sort-Object name, country

            return $ReturnData
  
        }
        else {

            return 
            
        }
    }
}


Function New-HPEGLLocation {
    <#
    .SYNOPSIS
    Creates a new physical location and service shipping address for devices.

    .DESCRIPTION
    This Cmdlet creates a new physical location with its street address, and optionally, a separate shipping/receiving address if it differs from the street address. It also includes contact details, with the primary contact being mandatory and optional contacts for shipping/receiving, security, and operations.

    Later, this location can be assigned to devices using `Set-HPEGLDeviceLocation`.

    The street address represents the physical location of devices assigned to it and will be used as the default shipping and receiving address. A different shipping and receiving address can be set if needed. If specified, this alternate address will be used when support cases are generated for devices assigned to the location.

    Note: A location can be assigned to devices for automated HPE support case creation and services using `Set-HPEGLDeviceLocation` or removed with `Remove-HPEGLDeviceLocation`.

    .PARAMETER Name 
    Specifies the name of the physical location.

    .PARAMETER Description 
    (Optional) Provides a description of the location.

    .PARAMETER Country 
    Specifies the country of the street address of the location.

    .PARAMETER Street 
    Specifies the postal street address of the location.

    .PARAMETER Street2 
    (Optional) Specifies the second line of the postal street address of the location.

    .PARAMETER City 
    Specifies the city of the street address of the location.

    .PARAMETER State 
    Specifies the state of the street address of the location.

    .PARAMETER PostalCode 
    Specifies the postal code of the street address of the location.

    .PARAMETER ShippingReceivingCountry
    (Optional) Specifies the country for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingStreet
    (Optional) Specifies the street for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingStreet2
    (Optional) Specifies the second line of the street for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingCity
    (Optional) Specifies the city for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingState
    (Optional) Specifies the state for the shipping and receiving address if it differs from the street address.

    .PARAMETER ShippingReceivingPostalCode
    (Optional) Specifies the postal code for the shipping and receiving address if it differs from the street address.

    .PARAMETER PrimaryContactEmail
    (Optional) Sets the primary contact email address for the location.

    .PARAMETER PrimaryContactPhone
    (Optional) Sets the primary contact phone number for the location.

    .PARAMETER ShippingReceivingContactEmail
    (Optional) Sets the shipping and receiving contact email address for the location.

    .PARAMETER ShippingReceivingContactPhone
    (Optional) Sets the shipping and receiving contact phone number for the location.

    .PARAMETER SecurityContactEmail
    (Optional) Sets the security contact email address for the location.

    .PARAMETER SecurityContactPhone
    (Optional) Sets the security contact phone number for the location.

    .PARAMETER OperationsContactEmail
    (Optional) Sets the operations contact email address for the location.

    .PARAMETER OperationsContactPhone
    (Optional) Sets the operations contact phone number for the location.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE  
    New-HPEGLLocation -Name "Boston" -Description "My Boston location" `
    -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" `
    -City "Boston" -State "MA" -PostalCode "02210" `
    -PrimaryContactEmail "Edmond@email.com" -PrimaryContactPhone "+1234567890" `
    -ShippingReceivingContactEmail "Lisa@email.com" -ShippingReceivingContactPhone "+1234567890"

    Creates a new location with shipping and receiving contact information the same as the primary contact, and with the service shipping address set to the same as the location address.

    .EXAMPLE   
    New-HPEGLLocation -Name "Boston" -Description "My Boston location" `
    -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" -City "Boston" -State "MA" -PostalCode "02210" `
    -PrimaryContactEmail "Edmond@email.com" -PrimaryContactPhone "+1234567890" `
    -ShippingReceivingContactEmail "Lisa@email.com" -ShippingReceivingContactPhone "+1234567890" `
    -ShippingReceivingCountry "France" -ShippingReceivingStreet "5th Avenue" -ShippingReceivingCity "Mougins" -ShippingReceivingState "NA" -ShippingReceivingPostalCode "06250"

    Creates a new location with a different service shipping and receiving address, with a primary contact information and with a service shipping address set with a different address than the location address.

    .EXAMPLE
    New-HPEGLLocation -Name "Boston" -Description "My Boston location" `
    -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" -City "Boston" -State "MA" -PostalCode "02210" `
    -PrimaryContactEmail "Edmond@email.com" -PrimaryContactPhone "+1234567890" `
    -ShippingReceivingContactEmail "Lisa@email.com" -ShippingReceivingContactPhone "+1234567890" `
    -ShippingReceivingCountry "France" -ShippingReceivingStreet "5th Avenue" -ShippingReceivingCity "Mougins" -ShippingReceivingState "NA" -ShippingReceivingPostalCode "06250" `
    -SecurityContactEmail Justine@ik.mail -OperationsContactEmail Walter@ik.mail

    Creates a new location with a different service shipping and receiving address, with primary, security, and operations contact information and with a service shipping address set with a different address than the location address.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList    
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the location object attempted to be created.
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.

    #>    

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [String]$Name,

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$Description,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$Street,

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$Street2,        

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$City,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$State,

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$PostalCode,
        
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingCountry, 

        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingStreet, 
        
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingStreet2, 
        
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingCity, 
        
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingState,    

        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingPostalCode,    

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$PrimaryContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$PrimaryContactPhone,  

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$ShippingReceivingContactPhone,  

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$SecurityContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$SecurityContactPhone,      
        
        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$OperationsContactEmail,   

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "ShippingReceiving")]
        [ValidateNotNullOrEmpty()]
        [String]$OperationsContactPhone,    

        [Switch]$WhatIf
    ) 

    Begin {

    
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesLocationUri  
        $NewLocationStatus = [System.Collections.ArrayList]::new()

               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }

        # Check if location already exists
        try {
            $Locationfound = Get-HPEGLLocation -Name $Name
                
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }


        if ( $Locationfound) {
            "[{0}] '{1}' Location name already created, use another name!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

            Throw "Error! '$Name' location already exists in the workspace!"
            
        }
        else {

            # Get contact names from emails 
            $PrimaryContactInfo = Get-HPEGLUser -Email $PrimaryContactEmail

            if ( $PrimaryContactInfo) {
                $PrimaryContactName = $PrimaryContactInfo.contact.first_name + " " + $PrimaryContactInfo.contact.last_name
            }
            else {
                Throw "$PrimaryContactEmail contact email cannot be found in the HPE GreenLake workspace!"
            }

            if ($ShippingReceivingContactEmail) {

                $ShippingReceivingContactInfo = Get-HPEGLUser -Email $ShippingReceivingContactEmail

                if ( $ShippingReceivingContactInfo) {
                    $ShippingReceivingContactName = $ShippingReceivingContactInfo.contact.first_name + " " + $ShippingReceivingContactInfo.contact.last_name

                }
                else {
                    Throw "$ShippingReceivingContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                }
            }
            
            if ($SecurityContactEmail) {

                $SecurityContactInfo = Get-HPEGLUser -Email $SecurityContactEmail

                if ( $SecurityContactInfo) {
                    $SecurityContactName = $SecurityContactInfo.contact.first_name + " " + $SecurityContactInfo.contact.last_name

                }
                else {
                    Throw "$SecurityContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                }
            }
            
            if ($OperationsContactEmail) {

                $OperationsContactInfo = Get-HPEGLUser -Email $OperationsContactEmail

                if ( $OperationsContactInfo) {
                    $OperationsContactName = $OperationsContactInfo.contact.first_name + " " + $OperationsContactInfo.contact.last_name

                }
                else {
                    Throw "$OperationsContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                }
            }


            # Defining location street address or location street address with shipping and receiving address

            
            $LocationAddressList = [System.Collections.ArrayList]::new()

            $StreetAddress = [PSCustomObject]@{
                country         = $Country
                street_address  = $Street
                street_address2 = $Street2
                city            = $City
                state           = $State
                postal_code     = $PostalCode
                type            = "street"

            }

            $LocationAddressList += $StreetAddress 

            if ($ShippingReceivingCountry) {

                $ShippingReceivingAddress = [PSCustomObject]@{
                    country         = $ShippingReceivingCountry
                    street_address  = $ShippingReceivingStreet
                    street_address2 = $ShippingReceivingStreet2
                    city            = $ShippingReceivingCity
                    state           = $ShippingReceivingState
                    postal_code     = $ShippingReceivingPostalCode
                    type            = "shipping_receiving"
                }
                    
                $LocationAddressList += $ShippingReceivingAddress

            }
           
           
            # Defining contacts

            $ContactsList = [System.Collections.ArrayList]::new()


            $PrimaryContact = [PSCustomObject]@{ 
                type         = "primary"
                name         = $PrimaryContactName
                phone_number = $PrimaryContactPhone
                email        = $PrimaryContactEmail
            }              
            
            $ContactsList += $PrimaryContact 


            if ($ShippingReceivingContactEmail) {
    
                $ShippingReceivingContact = [PSCustomObject]@{ 
                    type         = "shipping_receiving"
                    name         = $ShippingReceivingContactName
                    phone_number = $ShippingReceivingContactPhone
                    email        = $ShippingReceivingContactEmail
                }

                $ContactsList += $ShippingReceivingContact

            }
            
            if ($SecurityContactEmail) {

                $SecurityContact = [PSCustomObject]@{ 
                    type         = "security"
                    name         = $SecurityContactName
                    phone_number = $SecurityContactPhone
                    email        = $SecurityContactEmail
                }

                $ContactsList += $SecurityContact
            }
            
            if ($OperationsContactEmail) {

                $OperationsContact = [PSCustomObject]@{ 
                    type         = "operations"
                    name         = $OperationsContactName
                    phone_number = $OperationsContactPhone
                    email        = $OperationsContactEmail
                }

                $ContactsList += $OperationsContact
            }

            # Building payload

            $Payload = [PSCustomObject]@{
                name        = $Name
                description = $Description
                type        = "building"
                addresses   = $LocationAddressList
                contacts    = $ContactsList

            } | ConvertTo-Json -Depth 5
   
                   
            # Create Location
            try {

                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -WhatIfBoolean $WhatIf 
                
                if (-not $WhatIf) {

                    "[{0}] Location '{1}' successfully created" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Location successfully created"
        
                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Location cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }

            }

        }
        

        [void] $NewLocationStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($NewLocationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more location failed the creation attempt!"
          
            }

            Return $NewLocationStatus
        }


    }
}


Function Set-HPEGLLocation {
    <#
    .SYNOPSIS
    Modify an existing physical location.

    .DESCRIPTION
    This Cmdlet modifies physical location information such as addresses (street and shipping/receiving), contacts (primary, shipping/receiving, security, and operations), and other details. 
    
    If you omit any parameter, the cmdlet retains the current settings for those fields and only updates the provided parameters.

    The street address represents the physical location of the devices assigned to the location. It will be used as the default shipping and receiving address for these devices. A different shipping and receiving address can be set if needed. If specified, this alternate address will be used when support cases are generated for devices assigned to the location.

    Note: A location can be assigned to devices for automated HPE support case creation and services using `Set-HPEGLDeviceLocation` or removed with `Remove-HPEGLDeviceLocation`.
    
    .PARAMETER Name 
    Specifies the name of the physical location.

    .PARAMETER NewName 
    (Optional) Sets a new name for the location.

    .PARAMETER Description 
    (Optional) Sets a description of the location.

    .PARAMETER Country 
    (Optional) Sets the country of the street address of the location.

    .PARAMETER Street 
    (Optional) Sets the street address of the street address of the location.

    .PARAMETER Street2 
    (Optional) Sets the secondary street address of the street address of the location.

    .PARAMETER City 
    (Optional) Sets the city of the street address of the location.
        
    .PARAMETER State 
    (Optional) Sets the state of the street address of the location.

    .PARAMETER PostalCode 
    (Optional) Sets the postal code of the street address of the location.

    .PARAMETER ShippingReceivingCountry
    (Optional) Sets the country for the shipping and receiving address if it differs from the street address.        

    .PARAMETER ShippingReceivingStreet
    (Optional) Sets the street for the shipping and receiving address if it differs from the street address.     

    .PARAMETER ShippingReceivingStreet2
    (Optional) Sets the secondary street for the shipping and receiving address if it differs from the street address.  

    .PARAMETER ShippingReceivingCity
    (Optional) Sets the city for the shipping and receiving address if it differs from the street address.  

    .PARAMETER ShippingReceivingState
    (Optional) Sets the state for the shipping and receiving address if it differs from the street address.  

    .PARAMETER ShippingReceivingPostalCode
    (Optional) Sets the postal code for the shipping and receiving address if it differs from the street address. 

    .PARAMETER RemoveShippingReceivingAddress
    (Optional) Deletes the shipping and receiving address of the location.

    .PARAMETER PrimaryContactEmail
    (Optional) Sets the primary contact email address of the location.    

    .PARAMETER PrimaryContactPhone
    (Optional) Sets the primary contact phone number of the location.

    .PARAMETER ShippingReceivingContactEmail
    (Optional) Sets the shipping and receiving contact email address of the location.

    .PARAMETER ShippingReceivingContactPhone
    (Optional) Sets the shipping and receiving contact phone number of the location.

    .PARAMETER RemoveShippingReceivingContact
    (Optional) Deletes the shipping and receiving contact of the location.

    .PARAMETER SecurityContactEmail
    (Optional) Sets the security contact email address of the location.

    .PARAMETER SecurityContactPhone
    (Optional) Sets the security contact phone number of the location.

    .PARAMETER RemoveSecurityContact
    (Optional) Deletes the security contact of the location.

    .PARAMETER OperationsContactEmail
    (Optional) Sets the operations contact email address of the location.

    .PARAMETER OperationsContactPhone
    (Optional) Sets the operations contact phone number of the location.

    .PARAMETER RemoveOperationsContact
    (Optional) Deletes the operations contact of the location.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
        
   .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -NewName "HPE Mougins" -Description "Location in Central Europe"
    Renames the "Mougins" location to "HPE Mougins" and changes its description.

    .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -Description ""

    Removes the description set for the "Mougins" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Boston" -Country 'United States' -Street "321 Summer Street" -Street2 "5th floor" -City "Boston" -State "MA" -PostalCode "02210"

    Modifies the street address of the "Boston" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Boston" -Street2 ""

    Removes the secondary street address from the "Boston" location's street address.

    .EXAMPLE
    Set-HPEGLLocation -Name "Houston" -PrimaryContactEmail TheBoss@email.com -PrimaryContactPhone "+123456789"

    Modifies the "Houston" location with a primary contact email and phone number.

    .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -ShippingReceivingCountry "France" -ShippingReceivingStreet "790 Avenue du Docteur Donat" -ShippingReceivingStreet2 "Marco Polo - Batiment B" -ShippingReceivingCity "Mougins" -ShippingReceivingPostalCode 06254

    Adds or modifies the shipping and receiving address for the "Mougins" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Boston" -RemoveShippingReceivingAddress

    Removes the existing shipping and receiving address from the "Boston" location.

    .EXAMPLE
    Set-HPEGLLocation -Name "Mougins" -ShippingReceivingContactEmail TheTech@email.com -ShippingReceivingContactPhone "+123456789"

    Modifies or adds the shipping and receiving contact information for the "Mougins" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -RemoveShippingReceivingContact

    Removes the existing shipping and receiving contact information from the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -SecurityContactEmail Thesecurity@email.com -SecurityContactPhone "+3360000001"

    Modifies or adds the security contact information for the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -RemoveSecurityContact

    Removes the existing security contact from the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -OperationsContactEmail TheOperations@email.com -OperationsContactPhone "+1123456789"

    Modifies or adds the operations contact information for the "Barcelona" location.

    .EXAMPLE
    Set-HPEGLLocation -Name Barcelona -RemoveOperationsContact

    Removes the existing operations contact from the "Barcelona" location.

    .EXAMPLE
    Get-HPEGLLocation | Set-HPEGLLocation -SecurityContactEmail security@domain.com -SecurityContactPhone +123456789123

    Modifies or adds security contact information for all locations found in the currently connected HPE GreenLake workspace.

    .INPUTS
    System.Collections.ArrayList
        List of location(s) from 'Get-HPEGLLocation'.

    .OUTPUTS
    System.Collections.ArrayList    
    A custom status object or array of objects containing the following PsCustomObject keys:  
    * Name - name of the location object attempted to be modified 
    * Status - status of the modification attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed) 
    * Details - more information about the status 
    * Exception - information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Details')]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Parameter (ParameterSetName = "Details")]
        [String]$NewName,

        [Parameter (ParameterSetName = "Details")]
        [String]$Description,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,
        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$Street,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$Street2,        

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$City,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$State,

        [Parameter (ParameterSetName = "PrimaryAddress")]
        [String]$PostalCode,
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingCountry, 

        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingStreet, 
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingStreet2, 
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingCity, 
        
        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingState,    

        [Parameter (ParameterSetName = "ShippingReceivingAddress")]
        [String]$ShippingReceivingPostalCode,    

        [Parameter (ParameterSetName = "RemoveShippingReceivingAddress")]
        [Switch]$RemoveShippingReceivingAddress,    

        [Parameter (ParameterSetName = "PrimaryContact")]
        [String]$PrimaryContactEmail,   

        [Parameter (ParameterSetName = "PrimaryContact")]
        [String]$PrimaryContactPhone,  

        [Parameter (ParameterSetName = "ShippingReceivingContact")]
        [String]$ShippingReceivingContactEmail,   

        [Parameter (ParameterSetName = "ShippingReceivingContact")]
        [String]$ShippingReceivingContactPhone, 
        
        [Parameter (ParameterSetName = "RemoveShippingReceivingContact")]
        [Switch]$RemoveShippingReceivingContact,    

        [Parameter (ParameterSetName = "SecurityContact")]
        [String]$SecurityContactEmail,   

        [Parameter (ParameterSetName = "SecurityContact")]
        [String]$SecurityContactPhone,  
        
        [Parameter (ParameterSetName = "RemoveSecurityContact")]
        [Switch]$RemoveSecurityContact,    
        
        [Parameter (ParameterSetName = "OperationsContact")]
        [String]$OperationsContactEmail,   

        [Parameter (ParameterSetName = "OperationsContact")]
        [String]$OperationsContactPhone,  
        
        [Parameter (ParameterSetName = "RemoveOperationsContact")]
        [Switch]$RemoveOperationsContact,  

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $ObjectStatusList = [System.Collections.ArrayList]::new()

               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }
        

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            
            $Locations = Get-HPEGLLocation 
            $Users = Get-HPEGLUser 

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        foreach ($Object in $ObjectStatusList) {
            
            $Locationfound = $Locations | Where-Object name -eq $Object.Name
            $Uri = $DevicesLocationUri + "/" + $Locationfound.id

            if (-not $Locationfound) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Location name cannot be found in the HPE GreenLake workspace!"

                if ($WhatIf) {
                    $ErrorMessage = "Location '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.Name
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {
                                
                $LocationAddressList = [System.Collections.ArrayList]::new()
                $ContactsList = [System.Collections.ArrayList]::new()
                
                #Region Validate emails
                if ($PrimaryContactEmail) {

                    $PrimaryContactInfo = $Users | Where-Object email -eq $PrimaryContactEmail
                    
                    # Get contact names from emails 
                    if ( $PrimaryContactInfo) {
                        $PrimaryContactName = $PrimaryContactInfo.contact.first_name + " " + $PrimaryContactInfo.contact.last_name
                    }
                    else {
                        Throw "$PrimaryContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }          

                if ($ShippingReceivingContactEmail) {
                   
                    $ShippingReceivingContactInfo = $Users | Where-Object email -eq $ShippingReceivingContactEmail

                    if ( $ShippingReceivingContactInfo) {
                        $ShippingReceivingContactName = $ShippingReceivingContactInfo.contact.first_name + " " + $ShippingReceivingContactInfo.contact.last_name

                    }
                    else {
                        Throw "$ShippingReceivingContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }
                
                if ($SecurityContactEmail) {
                  
                    $SecurityContactInfo = $Users | Where-Object email -eq $SecurityContactEmail

                    if ( $SecurityContactInfo) {
                        $SecurityContactName = $SecurityContactInfo.contact.first_name + " " + $SecurityContactInfo.contact.last_name

                    }
                    else {
                        Throw "$SecurityContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }
                
                if ($OperationsContactEmail) {
                   
                    $OperationsContactInfo = $Users | Where-Object email -eq $OperationsContactEmail

                    if ( $OperationsContactInfo) {
                        $OperationsContactName = $OperationsContactInfo.contact.first_name + " " + $OperationsContactInfo.contact.last_name

                    }
                    else {
                        Throw "$OperationsContactEmail contact email cannot be found in the HPE GreenLake workspace!"
                    }
                }


                #EndRegion

                #Region Modifying details (Name or Description)

                if ($NewName) {

                    # newname cannot be used when more than one location is found in $ObjectStatusList
                    if ($ObjectStatusList.Count -gt 1) {
                        Throw "NewName cannot be used when more than one location is found in the pipeline!"
                    }
                    else {
                        $Name = $NewName
                    }

                }
                else {
                    $Name = $Locationfound.name
                }

                if (-not $PSBoundParameters.ContainsKey('Description')) {
                
                    if ($Locationfound.description) {
                                
                        $Description = $Locationfound.description
                    }
                    else {
                        $Description = $Null
                    }
                }

                if ($PSBoundParameters.ContainsKey('NewName') -or $PSBoundParameters.ContainsKey('Description')) {

                    # Building payload
            
                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
            
                    } | ConvertTo-Json -Depth 5
                }

                #EndRegion
            
                #Region Modifying street address
                if (-not $PSBoundParameters.ContainsKey('Country')) {
                
                    if (($Locationfound.addresses | Where-Object type -eq Street ).country) {
                                
                        $Country = ($Locationfound.addresses | Where-Object type -eq Street ).country
                    }
                    else {
                        $Country = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('Street')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).street_address) {
                                
                        $Street = ($Locationfound.addresses | Where-Object type -eq Street ).street_address
                    }
                    else {
                        $Street = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('Street2')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).street_address2) {
                                
                        $Street2 = ($Locationfound.addresses | Where-Object type -eq Street ).street_address2
                    }
                    else {
                        $Street2 = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('City')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).city) {
                                
                        $City = ($Locationfound.addresses | Where-Object type -eq Street ).city
                    }
                    else {
                        $City = $Null
                    }
                }
                # State is mandatory !
                if (-not $State) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).state) {
                                
                        $State = ($Locationfound.addresses | Where-Object type -eq Street ).state
                    }

                }
                if (-not $PSBoundParameters.ContainsKey('PostalCode')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq Street ).postal_code) {
                                
                        $PostalCode = ($Locationfound.addresses | Where-Object type -eq Street ).postal_code
                    }
                    else {
                        $PostalCode = $Null
                    }
                }

                if ($PSBoundParameters.ContainsKey('Country') -or $PSBoundParameters.ContainsKey('Street') -or $PSBoundParameters.ContainsKey('Street2') -or $PSBoundParameters.ContainsKey('City') -or $PSBoundParameters.ContainsKey('State') -or $PSBoundParameters.ContainsKey('PostalCode')) {
                
                    $PrimaryAddressId = ($Locationfound.addresses | Where-Object type -eq Street).id

                    $StreetAddress = [PSCustomObject]@{
                        country         = $Country
                        street_address  = $Street
                        street_address2 = $Street2
                        city            = $City
                        state           = $State
                        postal_code     = $PostalCode
                        type            = "street"
                        id              = $PrimaryAddressId
                    }

                    $LocationAddressList += $StreetAddress 
                }
                #Endregion

                #Region Modifying shipping/receiving address

                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingCountry')) {
                
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).country) {
                                
                        $ShippingReceivingCountry = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).country
                    }
                    else {
                        $ShippingReceivingCountry = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingStreet')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address) {
                                
                        $ShippingReceivingStreet = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address
                    }
                    else {
                        $ShippingReceivingStreet = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingStreet2')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address2) {
                                
                        $ShippingReceivingStreet2 = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).street_address2
                    }
                    else {
                        $ShippingReceivingStreet2 = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingCity')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).city) {
                                
                        $ShippingReceivingCity = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).city
                    }
                    else {
                        $ShippingReceivingCity = $Null
                    }
                }
                # Mandatory
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingState')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).state) {
                                
                        $ShippingReceivingState = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).state
                    }
                    else {
                        $ShippingReceivingState = "N/A"
                    }
                    
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingPostalCode')) {
            
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving ).postal_code) {
                                
                        $ShippingReceivingPostalCode = ($Locationfound.addresses | Where-Object type -eq shipping_receiving ).postal_code
                    }
                    else {
                        $ShippingReceivingPostalCode = $Null
                    }
                }


                if ($PSBoundParameters.ContainsKey('ShippingReceivingCountry') -or $PSBoundParameters.ContainsKey('ShippingReceivingStreet') -or $PSBoundParameters.ContainsKey('ShippingReceivingStreet2') `
                        -or $PSBoundParameters.ContainsKey('ShippingReceivingCity') -or $PSBoundParameters.ContainsKey('ShippingReceivingState') -or $PSBoundParameters.ContainsKey('ShippingReceivingPostalCode')) {

                    # if already exists
                    if (($Locationfound.addresses | Where-Object type -eq shipping_receiving).id) {

                        $ShippingAddressId = ($Locationfound.addresses | Where-Object type -eq shipping_receiving).id
                        
                        $ShippingReceivingAddress = [PSCustomObject]@{
                            country         = $ShippingReceivingCountry
                            street_address  = $ShippingReceivingStreet
                            street_address2 = $ShippingReceivingStreet2
                            city            = $ShippingReceivingCity
                            state           = $ShippingReceivingState
                            postal_code     = $ShippingReceivingPostalCode
                            type            = "shipping_receiving"
                            id              = $ShippingAddressId 
                        }
                    }
                    else {
                        $ShippingReceivingAddress = [PSCustomObject]@{
                            country         = $ShippingReceivingCountry
                            street_address  = $ShippingReceivingStreet
                            street_address2 = $ShippingReceivingStreet2
                            city            = $ShippingReceivingCity
                            state           = $ShippingReceivingState
                            postal_code     = $ShippingReceivingPostalCode
                            type            = "shipping_receiving"
                        }

                    }
                        
                    $LocationAddressList += $ShippingReceivingAddress
                }

                #Endregion
                
                #Region Removing Shipping/receiving contact
                if ($RemoveShippingReceivingAddress) {
        
                    $ShippingAddressId = ($Locationfound.addresses | Where-Object type -eq shipping_receiving).id
        
                    if (! $ShippingAddressId) {
    
                        "[{0}] There is no Shipping and Receiving address for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                        $Object.Status = "Failed"
                        $Object.Details = "There is no Shipping and Receiving address in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($Object)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no Shipping and Receiving address in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }

                    }
                    else {

                        $StreetAddressId = ($Locationfound.addresses | Where-Object type -eq street).id

                        $Country = ($Locationfound.addresses | Where-Object type -eq Street ).country
                    
                        $Street = ($Locationfound.addresses | Where-Object type -eq Street ).street_address
        
                        $Street2 = ($Locationfound.addresses | Where-Object type -eq Street ).street_address2
        
                        $City = ($Locationfound.addresses | Where-Object type -eq Street ).city
        
                        $State = ($Locationfound.addresses | Where-Object type -eq Street ).state
        
                        $PostalCode = ($Locationfound.addresses | Where-Object type -eq Street ).postal_code
        
                        $StreetAddress = [PSCustomObject]@{
                            country         = $Country
                            street_address  = $Street
                            street_address2 = $Street2
                            city            = $City
                            state           = $State
                            postal_code     = $PostalCode
                            type            = "street"
                            id              = $StreetAddressId 
        
                        }

                        $LocationAddressList += $StreetAddress      
                        
                        $ShippingAddressInfo = [PSCustomObject]@{ 
                            type = "shipping_receiving"
                            id   = $ShippingAddressId
                        }         
                        
                        $LocationAddressList += $ShippingAddressInfo      

                    }
                }
                #Endregion

                #Region Modifying primary contact

                if (-not $PSBoundParameters.ContainsKey('PrimaryContactName')) {
                
                    if (($Locationfound.contacts | Where-Object type -eq primary).name) {
                                
                        $PrimaryContactName = ($Locationfound.contacts | Where-Object type -eq primary).name
                    }
                    else {
                        $PrimaryContactName = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('PrimaryContactPhone')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq primary).phone_number) {
                                
                        $PrimaryContactPhone = ($Locationfound.contacts | Where-Object type -eq primary).phone_number
                    }
                    else {
                        $PrimaryContactPhone = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('PrimaryContactEmail')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq primary).email) {
                                
                        $PrimaryContactEmail = ($Locationfound.contacts | Where-Object type -eq primary).email
                    }
                    else {
                        $PrimaryContactEmail = $Null
                    }
                }

                if ($PSBoundParameters.ContainsKey('PrimaryContactEmail') -or $PSBoundParameters.ContainsKey('PrimaryContactPhone')) {
            
                    $PrimaryContactId = ($Locationfound.contacts | Where-Object type -eq primary).id
                
                    $ContactInfo = [PSCustomObject]@{ 
                        type = "primary"
                        id   = $PrimaryContactId
                    }         
                    
                    $ContactsList += $ContactInfo             
                    
                    $PrimaryContact = [PSCustomObject]@{ 
                        type         = "primary"
                        name         = $PrimaryContactName
                        phone_number = $PrimaryContactPhone
                        email        = $PrimaryContactEmail
                        location_id  = $Locationfound.id
                    }              
                
                    $ContactsList += $PrimaryContact 

                }

                #EndRegion

                #Region Modifying shipping/receiving contact

                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingContactPhone')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq shipping_receiving).phone_number) {
                                
                        $ShippingReceivingContactPhone = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).phone_number
                    }
                    else {
                        $ShippingReceivingContactPhone = $Null
                    }
                }
                if (-not $PSBoundParameters.ContainsKey('ShippingReceivingContactEmail')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq shipping_receiving).email) {
                                
                        $ShippingReceivingContactEmail = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).email
                    }
                    else {
                        $ShippingReceivingContactEmail = $Null
                    }
                }

                if ( $PSBoundParameters.ContainsKey('ShippingReceivingContactEmail') -or $PSBoundParameters.ContainsKey('ShippingReceivingContactPhone')) {
                    
                    # If contact not existing
                    if (! ($Locationfound.contacts | Where-Object type -eq shipping_receiving)) {

                        $ShippingReceivingContact = [PSCustomObject]@{ 
                            type         = "shipping_receiving"
                            name         = $ShippingReceivingContactName
                            phone_number = $ShippingReceivingContactPhone
                            email        = $ShippingReceivingContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $ShippingReceivingContact

                    }
                    # If contact already created
                    else {

                        $ShippingReceivingContactId = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).id
        
                        $ContactInfo = [PSCustomObject]@{ 
                            type = "shipping_receiving"
                            id   = $ShippingReceivingContactId
                        }         
                        
                        $ContactsList += $ContactInfo  

                        $ShippingReceivingContact = [PSCustomObject]@{ 
                            type         = "shipping_receiving"
                            name         = $ShippingReceivingContactName
                            phone_number = $ShippingReceivingContactPhone
                            email        = $ShippingReceivingContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $ShippingReceivingContact
                    }
                }

                #EndRegion

                #Region Remove Shipping/Receiving Contact
                if ($RemoveShippingReceivingContact) {
                    
                    $ShippingReceivingContactId = ($Locationfound.contacts | Where-Object type -eq shipping_receiving).id

                    if ( ! $ShippingReceivingContactId) {
                        
                        "[{0}] There is no Shipping and Receiving contact for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        
                        $Object.Status = "Failed"
                        $Object.Details = "There is no Shipping and Receiving contact in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($objStatus)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no Shipping and Receiving contact in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }
                 

                    }
                    else {
        
                        $ContactInfo = [PSCustomObject]@{ 
                            type = "shipping_receiving"
                            id   = $ShippingReceivingContactId
                        }         
                    
                        $ContactsList += $ContactInfo  
                    }
                }
                #Endregion

                #Region Modifying security contact

                if (-not $PSBoundParameters.ContainsKey('SecurityContactPhone')) {
        
                    if (($Locationfound.contacts | Where-Object type -eq security).phone_number) {
                                
                        $SecurityContactPhone = ($Locationfound.contacts | Where-Object type -eq security).phone_number
        
                    }
                    else {
                        $SecurityContactPhone = $Null
                    }
        
                }
                if (-not $PSBoundParameters.ContainsKey('SecurityContactEmail')) {
        
                    if (($Locationfound.contacts | Where-Object type -eq security).email) {
                                
                        $SecurityContactEmail = ($Locationfound.contacts | Where-Object type -eq security).email
        
                    }
                    else {
                        $SecurityContactEmail = $Null
                    }
        
                }

                if ( $PSBoundParameters.ContainsKey('SecurityContactEmail') -or $PSBoundParameters.ContainsKey('SecurityContactPhone')) {

                    # If contact not existing

                    if (! ($Locationfound.contacts | Where-Object type -eq security)) {

                        $SecurityContact = [PSCustomObject]@{ 
                            type         = "security"
                            name         = $SecurityContactName
                            phone_number = $SecurityContactPhone
                            email        = $SecurityContactEmail
                            location_id  = $Locationfound.id

                        }

                        $ContactsList += $SecurityContact

                    }
                    # If contact already created
                    else {

                        $SecurityContactId = ($Locationfound.contacts | Where-Object type -eq security).id

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "security"
                            id   = $SecurityContactId
                        }         
                    
                        $ContactsList += $ContactInfo  

                        $SecurityContact = [PSCustomObject]@{ 
                            type         = "security"
                            name         = $SecurityContactName
                            phone_number = $SecurityContactPhone
                            email        = $SecurityContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $SecurityContact
                    }
                }
                #Endregion

                #Region Remove Security Contact
                if ($RemoveSecurityContact) {
                    
                    $SecurityContactId = ($Locationfound.contacts | Where-Object type -eq security).id

                    if ( ! $SecurityContactId) {
                        
                        "[{0}] There is no security contact for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                        $Object.Status = "Failed"
                        $Object.Details = "There is no security contact in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($Object)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no security contact in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }

                    }
                    else {

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "security"
                            id   = $SecurityContactId
                        }         
                
                        $ContactsList += $ContactInfo  
                    }
                }
                #Endregion

                #Region Modifying operations contact

                if (-not $PSBoundParameters.ContainsKey('OperationsContactPhone')) {
            
                    if (($Locationfound.contacts | Where-Object type -eq operations).phone_number) {
                                
                        $OperationsContactPhone = ($Locationfound.contacts | Where-Object type -eq operations).phone_number
        
                    }
                    else {
                        $OperationsContactPhone = $Null
                    }
        
                }  
                if (-not $PSBoundParameters.ContainsKey('OperationsContactEmail')) {
        
                    if (($Locationfound.contacts | Where-Object type -eq operations).email) {
                                
                        $OperationsContactEmail = ($Locationfound.contacts | Where-Object type -eq operations).email
        
                    }
                    else {
                        $OperationsContactEmail = $Null
                    }
        
                }  

                if ($PSBoundParameters.ContainsKey('OperationsContactEmail') -or $PSBoundParameters.ContainsKey('OperationsContactPhone')) {

                    # If contact not existing

                    if (! ($Locationfound.contacts | Where-Object type -eq operations)) {

                        $OperationsContact = [PSCustomObject]@{ 
                            type         = "operations"
                            name         = $OperationsContactName
                            phone_number = $OperationsContactPhone
                            email        = $OperationsContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $OperationsContact

                    }                  
                    # If contact already created
                    else {

                        $OperationsContactId = ($Locationfound.contacts | Where-Object type -eq operations).id

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "operations"
                            id   = $OperationsContactId
                        }         
                
                        $ContactsList += $ContactInfo  

                        $OperationsContact = [PSCustomObject]@{ 
                            type         = "operations"
                            name         = $OperationsContactName
                            phone_number = $OperationsContactPhone
                            email        = $OperationsContactEmail
                            location_id  = $Locationfound.id
                        }

                        $ContactsList += $OperationsContact
                    }
                }
                #Endregion

                #Region Remove Operations Contact
                if ($RemoveOperationsContact) {

                    $OperationsContactId = ($Locationfound.contacts | Where-Object type -eq operations).id

                    if ( ! $OperationsContactId) {
                        
                        "[{0}] There is no operations contact for the '{1}' location!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        
                        $Object.Status = "Failed"
                        $Object.Details = "There is no operations contact in this location to be removed!"
                        # [void] $UpdateLocationStatus.add($Object)
                        continue

                        if ($Whatif) {
                            $ErrorMessage = "There is no operations contact in location '{0}' to be removed!" -f $Object.Name
                            Write-warning $ErrorMessage
                            continue
                        }
                       
                    }
                    else {

                        $ContactInfo = [PSCustomObject]@{ 
                            type = "operations"
                            id   = $OperationsContactId
                        }         
            
                        $ContactsList += $ContactInfo  
                    }
                }
                #Endregion


                # Building payload

                if ( $LocationAddressList) {
                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
                        addresses   = $LocationAddressList
        
                    } | ConvertTo-Json -Depth 5
                }

                if ( $ContactsList) {

                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
                        contacts    = $ContactsList

                    } | ConvertTo-Json -Depth 5
                }
                
                
                if ( $LocationAddressList -and $ContactsList) {
                    $Payload = [PSCustomObject]@{
                        name        = $Name
                        description = $Description
                        type        = "building"
                        addresses   = $LocationAddressList
                        contacts    = $ContactsList

        
                    } | ConvertTo-Json -Depth 5
                }


                    
                # Modify Location
                try {

                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'PUT' -body $Payload -WhatIfBoolean $WhatIf 
                    
                    if (-not $WhatIf) {

                        "[{0}] Location '{1}' successfully updated" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        $Object.Status = "Complete"
                        $Object.Details = "Location successfully modified"
            
                    }

                }
                catch {

                    if (-not $WhatIf) {
                        $Object.Status = "Failed"
                        $Object.Details = "Location cannot be modified!"
                        $Object.Exception = $_.Exception.message 
                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more location failed the modification attempt!"
          
            }

            Return $ObjectStatusList
        }


    }
}


Function Remove-HPEGLLocation {
    <#
    .SYNOPSIS
    Delete a physical location and service shipping address.

    .DESCRIPTION
    This Cmdlet can be used to delete a physical location and its addresses and contacts.

    The cmdlet issues a message at runtime to warn the user of the irreversible impact of this action and asks for a confirmation for the removal of the location.
        
    Any assigned devices will be released. Any associated addresses will no longer be accessible for automated support case creation. All associated contacts will no longer be assigned to any devices assigned to this location.

    .PARAMETER Name 
    Specifies the name of the physical location to be deleted.

    .PARAMETER Force
    Switch parameter that performs the deletion without prompting for confirmation.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLLocation -Name "Boston"

    Deletes the Boston physical location and any associated service shipping addresses and contacts after the user has confirmed the removal. Any devices assigned to the Boston location are released.

    .EXAMPLE
    Get-HPEGLLocation -Name "Mougins" | Remove-HPEGLLocation -Force

    Deletes the Mougins physical location and any associated service shipping addresses and contacts without prompting for confirmation.

    .EXAMPLE
    Get-HPEGLLocation | Remove-HPEGLLocation

    Deletes all physical locations and any associated service shipping addresses and contacts with prompting for confirmation.

    .INPUTS
    System.Collections.ArrayList
        List of location(s) from 'Get-HPEGLLocation'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the location's names.

    .OUTPUTS
    System.Collections.ArrayList    
    A custom status object or array of objects containing the following PsCustomObject keys:  
    * Name - name of the location object attempted to be deleted 
    * Status - status of the deletion attempt (Failed for HTTP error return; Complete if the deletion is successful; Warning if no action is needed) 
    * Details - more information about the status 
    * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [String]$Name, 

        [Switch]$Force,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $RemoveLocationStatus = [System.Collections.ArrayList]::new()
               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        if ($Force) {
            $decision = 0
        }
        else {
            $title = "Any assigned devices will be released. Any associated addresses will no longer be accessible for automated support case creation. All associated contacts will no longer be assigned to any devices assigned to this location." 
            $question = 'Are you sure you want to proceed?'
            $choices = '&Yes', '&No'
            $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
        }
           
        if ($decision -eq 0) {

            # Build object for the output
            $objStatus = [pscustomobject]@{
                Name      = $Name
                Status    = $Null
                Details   = $Null
                Exception = $Null
                          
            }

            # Check if location exists
            try {
                $Locationfound = Get-HPEGLLocation -Name $Name

                $Uri = $DevicesLocationUri + "/" + $Locationfound.id
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)                
            }


            if ( -not $Locationfound) {
    
                # Must return a message if resource not found
                
                if ($WhatIf) {
                    $ErrorMessage = "Location '{0}' cannot be found in the HPE GreenLake workspace!" -f $Name
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Location cannot be found in the HPE GreenLake workspace!"
                }

            
            }
            else {           
                   
                # Delete Location
                try {

                    $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $Payload -WhatIfBoolean $WhatIf 
                
                    if (-not $WhatIf) {

                        "[{0}] Location '{1}' successfully deleted" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Location successfully deleted"
        
                    }

                }
                catch {

                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Location cannot be deleted!"
                        $objStatus.Exception = $_.Exception.message 
                    }

                }

            }
        

            [void] $RemoveLocationStatus.add($objStatus)

        }

        else {
                
            'Operation cancelled by user!' | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Operation cancelled by the user!"
                Write-warning $ErrorMessage
                return
            }
            else {    
                $objStatus.Status = "Failed"
                $objStatus.Details = "Operation cancelled by the user!"
            }
        }
    }

    end {

        if (-not $WhatIf) {

            if ($RemoveLocationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more location failed the deletion attempt!"
          
            }

            Return $RemoveLocationStatus
        }


    }
}


Function Set-HPEGLDeviceLocation {
    <#
    .SYNOPSIS
    Assign device(s) to a physical location.

    .DESCRIPTION
    This Cmdlet assigns device(s) to an HPE GreenLake physical location. This action enables automated HPE support case creation and services.    

    For HPE OneView servers, use 'Set-HPECOMOneViewServerLocation'.

    .PARAMETER DeviceSerialNumber 
    Serial number of the device to be assigned to the location. This value can be retrieved from 'Get-HPEGLDevice'.

    .PARAMETER LocationName 
    Name of the available physical location to assign. This value can be retrieved from 'Get-HPEGLLocation'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLDeviceLocation -LocationName London -DeviceSerialNumber CW12312332
        
    Assigns the device with the serial number 'CW12312332' to the 'London' location.

    .EXAMPLE
    Get-HPEGLDevice -SerialNumber CW12312332 | Set-HPEGLDeviceLocation -LocationName 'Houston' 
       
    Assigns the device with the serial number 'CW12312332' to the 'Houston' location.

    .EXAMPLE
    'CW12312332', 'CW12312333', 'CW12312334' | Set-HPEGLDeviceLocation -LocationName "London"

    Assigns the devices with the provided list of serial numbers to the 'London' location using pipeline input.

    .EXAMPLE
    Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString "Gen11" | Set-HPEGLDeviceLocation -LocationName London 

    Assigns all 'Gen11' server devices to the 'London' location.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device being assigned to a physical location.
        * Location - Name of the location where the device is being assigned.
        * Status - Status of the assignment attempt (Failed for HTTP error return; Complete if assignment is successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory)]
        [String]$LocationName,

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('serial_number')]
        [String]$DeviceSerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

        try {
            
            $Locationfound = Get-HPEGLLocation -Name $LocationName

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }

        if ( -not $Locationfound) {
                    
            $ErrorMessage = "Location '{0}' cannot be found in the HPE GreenLake workspace!" -f $LocationName
            throw $ErrorMessage
        }

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Location     = $LocationName                       
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }
    

        [void]$ObjectStatusList.Add($objStatus)


    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ($device.location_name) {

                # Must return a message if device is already assigned to location and removed from the list of devices to be set
                $Object.Status = "Warning"
                $Object.Details = "Device is already assigned to the '$($device.location_name)' location!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is already assigned to the '{1}' location!" -f $Object.SerialNumber, $device.location_name
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {         

                # Build DeviceList object
                
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                    location_id   = $Locationfound.id
                }

                
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{
                devices = $DevicesList

            } | ConvertTo-Json -Depth 5

                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully assigned to device"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be assigned to device!"

                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more device locations failed to assign successfully!"

          
            }

            Return $ObjectStatusList
        }


    }
}


Function Remove-HPEGLDeviceLocation {
    <#
    .SYNOPSIS
    Remove device(s) from a physical location. 

    .DESCRIPTION
    This Cmdlet unassigns device(s) from an HPE GreenLake physical location.  

    For HPE OneView servers, use 'Remove-HPECOMOneViewServerLocation'.
        
    .PARAMETER DeviceSerialNumber 
    Serial number of the device to be unassigned from a physical location. 

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLDeviceLocation -DeviceSerialNumber CZ12312311
    
    Unassign the device with the serial number 'CZ12312311' from its physical location.

    .EXAMPLE
    Get-HPEGLDevice -SerialNumber CZ12312311 | Remove-HPEGLDeviceLocation -w

    Unassign the device with the serial number 'CZ12312311' from its physical location.

    .EXAMPLE
    'CW12312332', 'CW12312333' | Remove-HPEGLDeviceLocation 

    Unassign the devices with the serial numbers listed as a pipeline input from their physical location.

    .EXAMPLE
    Get-HPEGLDevice -FilterByDeviceType SERVER -SearchString "Gen11" | Remove-HPEGLDeviceLocation

    Unassign all 'Gen11' server devices from their physical location.

    .INPUTS
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device to be unassigned from a physical location. 
        * Status - Status of the unassignment attempt (Failed for http error return; Complete if unassignment is successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('serial_number')]
        [String]$DeviceSerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()


    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $DeviceSerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }
    
        [void]$ObjectStatusList.Add($objStatus)


    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to remove the location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif (-not $device.location_name) {

                # Must return a message if device is not assigned to a location
                $Object.Status = "Warning"
                $Object.Details = "Device is not assigned to a location!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is not assigned to a location!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {         

                # Build DeviceList object
                
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                    location_id   = ""
                }

                
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{
                devices = $DevicesList

            } | ConvertTo-Json -Depth 5

                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Location successfully unassigned from device"

                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Location cannot be unassigned from device!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more server locations failed to unassign successfully!"
                
          
            }

            Return $ObjectStatusList
        }


    }
}

#EndRegion


#Region --- SERVICE ---


Function Get-HPEGLService {
    <#
    .SYNOPSIS
    Retrieve the list of services and instances.

    .DESCRIPTION
    This Cmdlet returns a collection of services that are available for provisioning or that are already provisioned.    

    .PARAMETER Name 
    An optional parameter to display a service by name.

    .PARAMETER Region 
    An optional parameter to display a service instance in a region. You can use 'Get-HPEGLRegion' to see all available regions.

    .PARAMETER ShowProvisioned 
    An optional parameter to display the list of provisioned services.

    .PARAMETER ShowUnprovisioned 
    An optional parameter to display the list of available services that can be provisioned.

    .PARAMETER ShowAssignedDevices 
    An optional parameter to display the list of devices assigned to a particular service instance.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLService

    Returns all services, both those available for provisioning and those already provisioned.

    .EXAMPLE
    Get-HPEGLService -Name 'Compute Ops Management'

    Returns all Compute Ops Management service instances.

    .EXAMPLE
    Get-HPEGLService -Name 'Compute Ops Management' -ShowProvisioned

    Returns all Compute Ops Management service instances that are provisioned. 

    .EXAMPLE
    Get-HPEGLService -Name 'Compute Ops Management' -Region EU

    Returns all Compute Ops Management service instances that are provisioned in Europe. 

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned 

    Returns all services available for provisioning in different regions.

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned -Region 'eu-central'

    Returns all services available for provisioning in the Central Europe region.
    

#>

    [CmdletBinding(DefaultParameterSetName = 'Provisioned')]
    Param( 
        [Parameter (ParameterSetName = 'Provisioned')]
        [Parameter (ParameterSetName = 'Available')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedDevices')]
        # [ValidateSet( 'Compute Ops Management', 'Data Services', 'Aruba Central', 'HPE GreenLake' )]
        [String]$Name,            
 
        [Parameter (ParameterSetName = 'Provisioned')]
        [Parameter (ParameterSetName = 'Available')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedDevices')]
        [String]$Region,
    
        [Parameter (ParameterSetName = 'Provisioned')]
        [Switch]$ShowProvisioned,

        [Parameter (ParameterSetName = 'Available')]
        [Switch]$ShowUnprovisioned,

        [Parameter (ParameterSetName = 'AssignedDevices')]
        [Switch]$ShowAssignedDevices,

        [Switch]$WhatIf

    ) 
    
    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        $Uri = $ApplicationsProvisionsUri
  

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
        
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       
        
        if ($ShowAssignedDevices) {

            try {
                $AppRegionfound = Get-HPEGLService -Name $Name -Region $Region
            }
            catch {
       
                $PSCmdlet.ThrowTerminatingError($_)
           
            }
          
            if ($AppRegionfound) {

                $ServiceInstanceId = $AppRegionfound.application_instance_id

                try {
                    [array]$Collection = Get-HPEGLdevice | Where-Object application_instance_id -eq $ServiceInstanceId
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Device"
                    $ReturnData = $ReturnData | Sort-Object serial_number, ccs_region
                    return $ReturnData 
                }
                catch {
           
                    $PSCmdlet.ThrowTerminatingError($_)
               
                }

            }
        }

        if ($Null -ne $Collection.applications) {
              
            $CollectionList = $Collection.applications 
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Service"         
                         
            if ($Name -and -not $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.application_name -eq $name } | Sort-Object ccs_region

            }
            elseif ($Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.application_name -eq $name -and $_.ccs_region -eq $Region } | Sort-Object application_name

            }
            elseif (-not $Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.ccs_region -eq $Region } | Sort-Object application_name
                
            }
            else {
                $ReturnData = $ReturnData | Sort-Object application_name, ccs_region

            }     
      
            return $ReturnData 
  
        }
        elseif ($Null -ne $Collection.provisions) {

            $CollectionList = $Collection.provisions 
            
            if ($ShowProvisioned) {
                
                $CollectionList = $CollectionList | Where-Object { $_.provision_status -eq "PROVISIONED" }
                        
            }


            if ($ShowUnprovisioned) {

                $CollectionList = $CollectionList | Where-Object { $_.provision_status -ne "PROVISIONED" }
                
            }
            
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Service"   


            if ($Name -and -not $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.name -eq $name } | Sort-Object region

            }
            elseif ($Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.name -eq $name -and $_.region -eq $Region } | Sort-Object name
                
            }
            elseif (-not $Name -and $Region) {
                $ReturnData = $ReturnData | Where-Object { $_.region -eq $Region } | Sort-Object name
                
            }
            else {
                $ReturnData = $ReturnData | Sort-Object name, region
                
            }     
            
            

            return $ReturnData 
            


        }
        else {

            return 
            
        }
    }
}


Function Get-HPEGLServiceResourceRestrictionPolicyFilter {
    <#
    .SYNOPSIS
    Retrieve resource restriction policy filters.

    .DESCRIPTION
    This Cmdlet returns the resource restriction policy filters that are available in a service instance.    

    .PARAMETER ServiceName 
    Parameter to display resource restriction policy filter for a service name (can be retrieved using 'Get-HPEGLService').

    .PARAMETER ServiceRegion 
    Name of the region of the service (can be retrieved using Get-HPEGLService).

    .PARAMETER FilterName
    Name of a filter to display.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName 'Compute Ops Management' -ServiceRegion "eu-central"
  
    Returns all resource restriction policy filters for the Compute Ops Management service in the Central European region.

    .EXAMPLE
    Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName 'Compute Ops Management' -ServiceRegion "us-west" -FilterName RRP_ESXi_Houston
  
    Returns the 'RRP_ESXi_Houston' resource restriction policy filter for the 'Compute Ops Management' service in the US western region.
    
   #>
    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)]
        [String]$ServiceName,   
        
        [Parameter (Mandatory)]
        [String]$ServiceRegion,

        [String]$FilterName,

        [Switch]$WhatIf

    ) 
    
    Begin {
  
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        try {

            $_Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName -Region $ServiceRegion
                     
        }
        catch {
   
            $PSCmdlet.ThrowTerminatingError($_)
       
        }
       
        
        if ($_Service) {

                  
            $ServiceID = $_Service.application_id

            $Uri = $ApplicationsScopeAssignmentsUri + "?application_id=" + $ServiceID + "&include_predefined_filters_and_scope_resource_instances=true"

            try {
                [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
              
            }
            catch {

                $PSCmdlet.ThrowTerminatingError($_)
   
            }
        }
       

        if ($Null -ne $Collection) {
           
            $Collection = $Collection | Where-Object region -eq $ServiceRegion

            # $Collection | Out-String | Write-Verbose

            $FilterList = @()
            
            if ($Collection.slug -eq "HPECC") {
               
                $ServiceInstanceId = $_Service.application_instance_id
                $ServiceCustomerId = $_Service.application_customer_id
                $Slug = $Collection.scope_resources.slug

                $Uri = $ApplicationInstancesUri + "/" + $ServiceInstanceId + "/scope_resource_instances?limit=200&offset=0&application_cid=" + $ServiceCustomerId + "&scope_resource=$slug"
            
                try {
                    [array]$FilterCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf 
              
                }
                catch {

                    $PSCmdlet.ThrowTerminatingError($_)
   
                }

                # $FilterCollection | Out-String | Write-Verbose

                foreach ($Filter in $FilterCollection.scope_resource_instances) {
                    
                    "[{0}] Filter '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $filter.name | Write-Verbose

                    $ReturnData = $FilterCollection | Select-Object  `
                    @{N = "filter_name"; E = { $Filter.name } }, `
                    @{N = "application_name"; E = { $ServiceName } }, `
                    @{N = "region"; E = { $Collection.region } }, `
                    @{N = "slug"; E = { $Filter.slug } }, `
                    @{N = "scope_type_name"; E = { $_.scope_resource_instances.name } }, `
                        # @{N = "description"; E = { $_.scope_resource_instances.description } }, `
                    @{N = "application_customer_id"; E = { $_.application_customer_id } }, `
                    @{N = "application_instance_id"; E = { $_.application_instance_id } }, `
                    @{N = "application_id"; E = { $_.application_id } }

                    $FilterList += $ReturnData | Sort-Object -Property filter_name
                }

            } 

            elseif ($Collection.scope_resources) {
               
                foreach ($Filter in $Collection.scope_resources) {
                    
                    "[{0}] Filter '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $filter.name | Write-Verbose

                    $ReturnData = $Collection | Select-Object  `
                    @{N = "filter_name"; E = { $Filter.name } }, `
                    @{N = "application_name"; E = { $ServiceName } }, `
                    @{N = "region"; E = { $_.region } }, `
                    @{N = "slug"; E = { $Filter.slug } }, `
                    @{N = "scope_type_name"; E = { $_.scope_resources.name } }, `
                        # @{N = "description"; E = { $_.scope_resources.description } }, `
                    @{N = "application_customer_id"; E = { $_.application_customer_id } }, `
                    @{N = "application_instance_id"; E = { $_.application_instance_id } }, `
                    @{N = "application_id"; E = { $_.application_id } }

                    $FilterList += $ReturnData | Sort-Object -Property filter_name
                }
            }
            elseif ($Collection.predefined_filters) {      
                    
                foreach ($Filter in $Collection.predefined_filters) {
                        
                    "[{0}] Predefined filter '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Filter.name | Write-Verbose

                    $ReturnData = $Collection | Select-Object  `
                    @{N = "filter_name"; E = { $Filter.name } }, `
                    @{N = "application_name"; E = { $ServiceName } }, `
                    @{N = "region"; E = { $_.region } }, `
                    @{N = "slug"; E = { $Filter.slug } }, `
                    @{N = "scope_type_name"; E = { $Filter.name } }, `
                        # @{N = "description"; E = { $Filter.description } }, `
                    @{N = "application_customer_id"; E = { $_.application_customer_id } }, `
                    @{N = "application_instance_id"; E = { $_.application_instance_id } }, `
                    @{N = "application_id"; E = { $_.application_id } }

                    $FilterList += $ReturnData | Sort-Object -Property filter_name
                }
            } 
      

            if ($FilterName) {
                $FilterList = $FilterList | Where-Object filter_name -eq $FilterName

            } 

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $FilterList -ObjectName "Service.Resource.Restriction.Policy.Filter"         
            $ReturnData = $ReturnData | sort-object filter_name, application_name, region

            return $ReturnData

        }     
       
        else {

            return 
            
        }
    }
}


Function Add-HPEGLService {
    <#
    .SYNOPSIS
    Deploy a service in a specified region.

    .DESCRIPTION
    This Cmdlet can be used to deploy a service in a new region within HPE GreenLake. By deploying a service, you enable its functionalities and resources in the selected region.

    .PARAMETER Name 
    The name of the available service to deploy. This value can be retrieved from 'Get-HPEGLService -ShowUnprovisioned'.

    .PARAMETER Region 
    The name of the region where the service will be deployed. This value can be retrieved from 'Get-HPEGLService -ShowUnprovisioned'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLService -Name "Aruba Central" -Region "eu-central"

    Deploys the service "Aruba Central" in the "eu-central" region.

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned -Name "Compute Ops Management" -Region "us-west" | Add-HPEGLService

    Retrieves the "Compute Ops Management" service available in the "us-west" region and deploys it.

    .EXAMPLE
    Get-HPEGLService -ShowUnprovisioned -Name "Compute Ops Management" | Add-HPEGLService

    Retrieves all unprovisioned instances of the "Compute Ops Management" service across all regions and deploys them in their respective regions.

    .INPUTS
    System.Collections.ArrayList
        A list of services obtained from 'Get-HPEGLService -ShowUnprovisioned'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Service - The name of the service attempted to be deployed.
        * Region - The name of the region where the service was deployed.
        * Status - The status of the deployment attempt (Failed for HTTP error return; Complete if deployment is successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.

    #>



    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias('applicationname')]
        [String]$Name,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias('ccs_region')]
        [String]$Region,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $ApplicationProvisioningUri  
        $AddServiceStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Service   = $Name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
                                  
        }      


        try {

            $Appfound = Get-HPEGLService -Name $Name -Region $Region -ShowUnprovisioned

        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
    
        }
        
        if (-not $Appfound) {
            # Must return a message if Service is already provisioned 
            "[{0}] Service '{1}' is not available in '{2}' region for provisioning!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Region | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}' is not available in '{1}' region for provisioning!" -f $Name, $Region
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Service is not available in this region for provisioning!"
            }
        }
        else {
       
            $ServiceID = $Appfound.application_id


            # Build payload
            $payload = ConvertTo-Json @{
                region         = $Region
                application_id = $ServiceID 
                action         = "PROVISION"
                
            }
      

            # Deploy the service in a region. 
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | Out-Null

                if (-not $WhatIf) {

                    "[{0}] Service '{1}' successfully deployed in '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Service successfully deployed in $Region region"
                        
                    do {
                        $provision_status = (Get-HPEGLService -Name $name -Region $Region ).provision_status
                        Start-Sleep 2
                    } until ($provision_status -eq "PROVISIONED")
                       
                    if ($Name -eq "Compute Ops Management") {
                            
                        # Add region to the global variable for the argument completer for the Region parameter of *HPECOM* cmdlets
                        [void]$Global:HPECOMAPICredentialRegions.add($region)
                            
                        #Region- Generate new COM API client credential using template $APIClientCredentialTemplateName in $region
                  
                        "[{0}] ------- Create '{1}' temporary COM API client credential for '{2}' region" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                        # Save access token into $HPEGreenLakesession.comApiAccessToken
                        # It will save client_id / client_secret into $HPEGreenLakesession.apiCredentials.COM-<region>-PowerShell_Library_Temporary_Credential
                            
                        $COMAPICreationTask = New-HPEGLAPIcredential -ServiceName $Name -Region $Region -TemplateName $APIClientCredentialTemplateName -ErrorAction SilentlyContinue #| out-Null
                                                                                
                        if ($COMAPICreationTask.status -eq "Failed") {
                            "API Credential '{0}' cannot be created ! '{1}'" -f ($COMAPICreationTask.Name.substring(0, ($COMAPICreationTask.Name.length - ($APIClientCredentialTemplateName.Length + 1))))  , $COMAPICreationTask.Exception | Write-Error
                        }
                        else {
                            
                            "[{0}] ------- Create session with to capture access token " -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            # Create session with the API and capture new access tokens
                            $TemportaryCredential = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.region -match $Region }

                            "[{0}] Credential found: `n{1} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $TemportaryCredential | Write-Verbose
            

                            $SecureClientSecret = $TemportaryCredential.secure_client_secret | ConvertTo-SecureString
                            $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
                            $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr) 

                            $Payload = @{
                                'client_id'     = $TemportaryCredential.client_id
                                'client_secret' = $ClientSecret
                                'grant_type'    = 'client_credentials'
                            }
            
                            "[{0}] About to execute POST request to: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $HPEGLtokenEndpoint | Write-Verbose
                            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($payload | convertto-json) | Write-Verbose
    
                            try {
    
                                $response = Invoke-RestMethod -Method Post -Uri $HPEGLtokenEndpoint -Body $Payload -ContentType 'application/x-www-form-urlencoded' 
            
                                "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                                "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
    
                                $comApiAccessToken = [PSCustomObject]@{
                                    name         = $TemportaryCredential.name
                                    access_token = $response.access_token 
                                    expires_in   = $response.expires_in
                                    creation_time = (Get-Date)
                                }
                            
                                [void]$global:HPEGreenLakeSession.comApiAccessToken.add($comApiAccessToken)
                                "[{0}] COM API access token has been set in `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            }
                            catch {
    
                                "[{0}] Create API session payload content: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Payload | Out-String) | Write-Verbose
    
                                if ($_.ErrorDetails.Message) {
                                    Write-Warning $_.ErrorDetails
                                }
    
                                $PSCmdlet.ThrowTerminatingError($_).Exception.Message
    
                            }
                        }
                        #endregion
                    }  
                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service cannot be deployed!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }           

        }
       
        

        [void] $AddServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($AddServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more services failed the deployment attempt!"
          
            }

            Return $AddServiceStatus
        }


    }
}


Function Remove-HPEGLService {
    <#
    .SYNOPSIS
    Remove a service from a specified region.

    .DESCRIPTION
    This Cmdlet can be used to remove a service from a region. This action is irreversible and cannot be canceled or undone once the process has begun. All users will lose access, and it will permanently delete all device and user data.

    The cmdlet issues a message at runtime to warn the user of the irreversible impact of this action and asks for a confirmation for the removal of the service.
        
    .PARAMETER Name 
    The name of the available service to remove. This value can be retrieved from 'Get-HPEGLService -ShowProvisioned'.
        
    .PARAMETER Region 
    The name of the region where the service is removed. This value can be retrieved from 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLService -Name "Aruba Central" -Region "eu-central"

    Removes the "Aruba Central" service from the "eu-central" region after the user has confirmed the removal.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned -Name "Compute Ops Management" -Region "us-west" | Remove-HPEGLService

    Retrieves the provisioned "Compute Ops Management" service in the "us-west" region and removes it. A warning message appears and asks the user to confirm the action.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned -Name "Compute Ops Management" | Remove-HPEGLService

    Retrieves all provisioned instances of the "Compute Ops Management" service across all regions and removes them, pending user confirmation.

    .INPUTS
    System.Collections.ArrayList
        A list of services obtained from 'Get-HPEGLService -ShowProvisioned'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following keys:
        * Service - The name of the service attempted to be removed.
        * Region - The name of the region where the service was removed.
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if removal is successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.


    #>


    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [Alias('applicationname')]
        [String]$Name,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [Alias('ccs_region')]
        [String]$Region,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveServiceStatus = [System.Collections.ArrayList]::new()


    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $AppRegionfound = Get-HPEGLService -Name $name -Region $Region
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
    
        }
       
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Service   = $name
            Region    = $Region                            
            Status    = $Null
            Details   = $Null
            Exception = $Null
                                      
        }  
       
       
        if (-not $AppRegionfound) {
            # Must return a message if Serviceis not found in the region
            "[{0}] Service '{1}' not available in '{2}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}' cannot be found in the HPE GreenLake workspace!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Service not available in $Region region!"
            }



        }
        elseif (-not $AppRegionfound.provision_status) {
            # Must return a message if Service is not provisioned 
            "[{0}] Service '{1}' is not provisioned!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service '{0}' is not provisioned in any region!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Service is not provisioned in any region!"
            }

        }
        else {       
           
            $title = "All users will lose access and this will permanently delete all device and user data. Confirm that you would like to remove '{0}' from '{1}'." -f $name, $Region
            $question = 'This action is irreversible and cannot be canceled or undone once the process has begun. Are you sure you want to proceed?'
            $choices = '&Yes', '&No'

            $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)

            if ($decision -eq 0) {

                $ServiceID = $AppRegionfound.application_customer_id

                $Uri = $ApplicationProvisioningUri + "/" + $ServiceID
    
                # Build payload
                $payload = ConvertTo-Json @{
                    action = "UNPROVISION"
                    
                }
          
    
                # Deploy the Service in a region. 
                try {
                    Invoke-HPEGLWebRequest -Uri $Uri -method 'PATCH' -body $payload -WhatIfBoolean $WhatIf | Out-Null

                    if (-not $WhatIf) {
    
                        "{0}: Service successfully removed from '{1}' region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose

                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Service successfully removed from $Region region"

                        if ($name -eq "Compute Ops Management") {
                            
                            # Remove region from the global variable for the argument completer for the Region parameter of *HPECOM* cmdlets
                            [void]$Global:HPECOMAPICredentialRegions.remove($region)
                            
                            #Region- Remove COM API client credential for $region
                            "[{0}] ------------------------------------- Remove COM API client credential -------------------------------------" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
                            $COMinstanceAPIcredential = Get-HPEGLAPICredential | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.name -match $Region }
            
                            if ($COMinstanceAPIcredential) {
                                $COMinstanceAPIcredential | Remove-HPEGLAPICredential | Out-Null
                            }
                            "[{0}] ------- Delete '{1}' temporary API client credentials for region '{2}' in `$HPEGreenLakeSession.apiCredentials" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name, $Region | Write-Verbose
                            # Remove access token from $HPEGreenLakesession.comApiAccessToken
                            # It will remove client_id / client_secret from $HPEGreenLakesession.apiCredentials
                                                     
                            $comApiCredential = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.region -match $Region }                          
                            "[{0}] COM API Credential found for '{1}' in `$HPEGreenLakeSession.apiCredentials: `n{2} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Region, $comApiCredential | Write-Verbose
                            [void]$global:HPEGreenLakeSession.apiCredentials.remove($comApiCredential)
                            "[{0}] COM API credential has been removed from `$HPEGreenLakeSession.apiCredentials` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                            $comApiAccessToken = $HPEGreenLakeSession.comApiAccessToken | Where-Object { $_.name -match $APIClientCredentialTemplateName -and $_.name -match "COM" -and $_.name -match $Region }
                            "[{0}] COM Access Token found: `n{1} " -f $MyInvocation.InvocationName.ToString().ToUpper(), $comApiAccessToken | Write-Verbose
                            [void]$global:HPEGreenLakeSession.comApiAccessToken.remove($comApiAccessToken)
                            "[{0}] COM API access token has been removed from `$HPEGreenLakeSession.comApiAccessToken` global variable!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        }
                        #endregion
                    }  
                }
                catch {

                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Service cannot be removed!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }                          
          
            }
            else {
                'Operation cancelled by user!' | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Operation cancelled by the user!"
                    Write-warning $ErrorMessage
                    return
                }
                else {    
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Operation cancelled by the user!"
                }
            }
       
        }

        [void] $RemoveServiceStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveServiceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more services has failed!"

          
            }

            Return $RemoveServiceStatus
            
        }


    }
}


Function Add-HPEGLDeviceToService {
    <#
    .SYNOPSIS
    Assign device(s) to an HPE GreenLake service instance.

    .DESCRIPTION
    This Cmdlet assigns device(s) to an HPE GreenLake service instance.

    .PARAMETER SerialNumber 
    Specifies the serial number of the device to assign to a service instance. This value can be retrieved using 'Get-HPEGLDevice -ShowRequireAssignment'.

    .PARAMETER Name 
    Specifies the name of the available service to which the device will be assigned. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER Region 
    Specifies the region of the service instance. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option helps in understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceToService -SerialNumber "1234567890" -Name "Compute Ops Management" -Region "US-West"

    Assigns the device with the serial number '1234567890' to the "Compute Ops Management" service in the western US region.

    .EXAMPLE
    'MXQ72407P3', 'MXQ73200W1' | Add-HPEGLDeviceToService -Name "Aruba Central" -Region "eu-central"

    Assigns devices with serial numbers 'MXQ72407P3' and 'MXQ73200W1' to the "Aruba Central" service in the "eu-central" region.

    .EXAMPLE
    Get-HPEGLDevice -ShowRequireAssignment | Add-HPEGLDeviceToService -Name "Compute Ops Management" -Region "US-West"

    Assigns all devices that require service assignment to the "Compute Ops Management" service in the western US region.

    .EXAMPLE
    Add-Content -Path Tests\SerialNumbers.csv -Value '"Serialnumber"'
    $Serialnumbers = @('7CE244P9LM' , 'MXQ73200W1')
    $Serialnumbers | foreach { Add-Content -Path Tests\SerialNumbers.csv -Value $_ }

    Import-Csv Tests\SerialNumbers.csv | Add-HPEGLDeviceToService -Name "Compute Ops Management" -Region "US-West"

    Assigns the devices listed in a CSV file to a service instance.

    .INPUTS
    System.Collections.ArrayList
        A list of devices from 'Get-HPEGLDevice -ShowRequireAssignment'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers.

    .OUTPUTS
    System.Collections.ArrayList
        Returns a custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device assigned to a service instance. 
        * Status - Status of the assignment attempt (Failed for HTTP error return; Complete if assignment is successful; Warning if no action is needed).
        * Details - More information about the status. 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory)]
        [String]$Name,

        [Parameter (Mandatory)]
        [String]$Region,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $Uri = $DevicesApplicationInstanceUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

        try {
            
            $Servicefound = Get-HPEGLService -Name $Name -Region $Region -ShowProvisioned

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }

        if ( -not $Servicefound) {
                    
            $ErrorMessage = "Service '{0}' is not provisioned in the '{1}' region!" -f $Name, $Region
            throw $ErrorMessage
        }


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                  
        }
    

        [void]$ObjectStatusList.Add($objStatus)


    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( $device.application_id) {

                # Must return a message if device is already assigned to location and removed from the list of devices to be set
                $Object.Status = "Warning"
                $Object.Details = "Device already assigned to a service instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is already assigned to a service instance!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       
            
                # Build DeviceList object
                if ($device | Where-Object device_model -match "Gen11" ) {

                    $DeviceList = [PSCustomObject]@{
                        serial_number = $Device.serial_number
                        part_number   = $Device.part_number 
                        mac_address   = $Device.mac_address
                        device_type   = $Device.device_type
                    }
                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        serial_number = $Device.serial_number
                        part_number   = $Device.part_number 
                        device_type   = $Device.device_type
                    }
                }
            
               
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{ assign_list = @(
                    @{  devices                 = $DevicesList
                        application_id          = $Servicefound.application_id
                        application_instance_id = $Servicefound.application_instance_id
                    })
            } | ConvertTo-Json -Depth 5
                
                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Device successfully assigned to the service instance!"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Device cannot be assigned to the service instance!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the service assignment attempt!"
               
          
            }

            Return $ObjectStatusList
        }


    }
}


Function Remove-HPEGLDeviceFromService {
    <#
    .SYNOPSIS
    Unassign device(s) from a service instance. 

    .DESCRIPTION
    This Cmdlet unassigns device(s) from an HPE GreenLake service instance.    
        
    .PARAMETER SerialNumber 
    Serial number of the device to be unassigned from a service instance. 
    This value can be retrieved from 'Get-HPEGLDevice'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLDeviceFromService -SerialNumber MXQ73200W1

    Unassigns the specified device from its service instance.

    .EXAMPLE
    Get-HPEGLDevice -Location "Mougins"  | Remove-HPEGLDeviceFromService 

    Unassigns all devices in the 'Mougins' location from their respective service instances.

    .EXAMPLE
    'MXQ72407P3', 'MXQ73200W1'  | Remove-HPEGLDeviceFromService

    Unassigns devices with serial numbers 'MXQ72407P3' and 'MXQ73200W1' from their respective service instances.

    .INPUTS
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device to be unassigned from a service instance. 
        * Status - Status of the unassignment attempt (Failed for http error return; Complete if unassignment is successful) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

   
   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('serial_number')]
        [String]$SerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $DevicesApplicationInstanceUri  
        # $UnassignmentDevicesStatus = [System.Collections.ArrayList]::new()
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                      
        }
   

        [void] $ObjectStatusList.add($objStatus)
        
    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $device.application_id) {

                # Must return a message if device is already assigned to location and removed from the list of devices to be set
                $Object.Status = "Warning"
                $Object.Details = "Device not assigned to a service instance!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' not assigned to a service instance!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       
            
                # Build DeviceList object
                if ($device | Where-Object device_model -match "Gen11" ) {

                    # $mac = $device | ForEach-Object mac_address

                    $DeviceList = [PSCustomObject]@{
                        serial_number = $Device.serial_number
                        part_number   = $Device.part_number 
                        mac_address   = $Device.mac_address
                        device_type   = $Device.device_type
                    }
                }
                else {

                    $DeviceList = [PSCustomObject]@{
                        serial_number = $Device.serial_number
                        part_number   = $Device.part_number 
                        device_type   = $Device.device_type
                    }
                }
            
               
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Build payload
            $payload = [PSCustomObject]@{
                devices = $DevicesList
            } | ConvertTo-Json -Depth 5
   
                
                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Complete"
                            $Object.Details = "Device successfully unassigned from the service instance!"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                              
                            $Object.Status = "Failed"
                            $Object.Details = "Device cannot be unassigned from the service instance!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more devices from the service assignment has failed!"
          
            }

            Return $ObjectStatusList
        }


    }
}


Function Get-HPEGLAPIcredential {
    <#
    .SYNOPSIS
    Retrieve API credentials for an HPE GreenLake service instance.

    .DESCRIPTION
    This Cmdlet returns a collection of API credential resources for an HPE GreenLake (GLP) service instance.

    .PARAMETER Name
    Specifies the name of the API client credential to retrieve.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. 
    This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLAPICredential

    Returns the API credentials for all service instances.

    .EXAMPLE
    Get-HPEGLAPICredential -Name "Grafana-COM-AP_NorthEast"

    Returns the API credential for the service instance named "Grafana-COM-AP_NorthEast".
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [String]$Name,  

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $Uri = $ApplicationsAPICredentialsUri
        
        $Services = Get-HPEGLService -ShowProvisioned

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        $ReturnData = @()

        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf

        }  
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        if ($Null -ne $Collection ) {

            If ($Name) {

                $CollectionList = $Collection | Where-Object credential_name -eq $Name
            }
            else {

                $CollectionList = $Collection 
            }

            foreach ($item in $CollectionList) {
                
                if ($item.application_instance_id -eq "00000000-0000-0000-0000-000000000000" ) {
                    
                    $ServiceName = "HPE GreenLake"
                    $ServiceRegion = "N/A"
                    $ConnectivityEndPoint = "https://global.api.greenlake.hpe.com"
                    
                }
                else {
               
                    $Service = $Services | Where-Object application_instance_id -eq $item.application_instance_id
                    $ServiceName = $Service | ForEach-Object name
                    $ServiceRegion = $Service | ForEach-Object region

                    if ($Service.name -eq "Data Services") {
                        $ConnectivityEndPoint = "https://sso.common.cloud.hpe.com/as/token.oauth2"
    
                    }
                    else {
                        
                        $ConnectivityEndPoint = $item.app_nbapi_endpoint
                    }

                }

                $ReturnData += $item | Select-Object  `
                @{N = "name"; E = { $item.credential_name } }, `
                @{N = "application_name"; E = { $ServiceName } }, `
                @{N = "region"; E = { $ServiceRegion } }, `
                @{N = "application_instance_id"; E = { $item.application_instance_id } }, `
                @{N = "client_id"; E = { $item.client_id } }, `
                @{N = "connectivity_endpoint"; E = { $ConnectivityEndPoint } }

            }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $ReturnData -ObjectName "Service.API.Credential"         

            $ReturnData = $ReturnData | Sort-Object { $_.name }
            
            return $ReturnData 
    
        }
        else {
            return
        }
    }
}


Function New-HPEGLAPIcredential {
    <#
    .SYNOPSIS
    Creates API client credentials for a service instance.

    .DESCRIPTION
    This Cmdlet generates API client credentials for HPE GreenLake or an HPE GreenLake service instance.

    API client credentials are used to generate access tokens required for accessing workspace data. You can maintain a maximum of 5 credentials.

    The prerequisite for generating an API access token is that the service instance must be provisioned/added to the user's workspace. 
    The user must have the necessary role to perform the intended operation in the service instance.

    .PARAMETER TemplateName
    Template name of the API client credential to create. This parameter automatically generates the name of the API client credential based on the template name, service name, and region.
    Format: <ServiceName>-<ServiceRegion>-<TemplateName>
    <ServiceName> can be either `COM`, `DS`, or the service name without spaces.
    Examples: "DS-US_West-Grafana", "COM-EU_Central-Ansible", "Aruba_Central-AP_Central-Terraform"

    For HPE GreenLake API client credentials:
    Format: GLP-<TemplateName>
    Examples: "GLP-Grafana", "GLP-Ansible"

    .PARAMETER ServiceName
    Name of the provisioned service accessible using the API credentials. Retrieve this value from `Get-HPEGLService -ShowProvisioned`.

    .PARAMETER Region
    Region of the service accessible using the API credentials. Retrieve this value from `Get-HPEGLService -ShowProvisioned`.

    .PARAMETER HPEGreenLake
    Switch parameter to generate API client credentials for the HPE GreenLake service.

    .PARAMETER Location
    Directory to export the API credentials to. The exported credentials include all necessary details for executing subsequent API requests.
    Exported filename format: "<Auto-generated API Credential name>_API_Credential.json".
    This parameter is optional. Note that generated API credentials are always stored during a session in `${Global:HPEGreenLakeSession.apiCredentials}`.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. Useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    New-HPEGLAPIcredential -ServiceName "Compute Ops Management" -Region "eu-central" -TemplateName POSH_Lib

    Generates a new 'COM-eu-central-POSH_Lib' API client credential for the 'Compute Ops Management' service instance in the Central Europe region.
    Adds an object containing the client_id, secure_client_secret, and connectivity_endpoint to the `${Global:HPEGreenLakeSession.apiCredentials}` variable, accessible as long as the PowerShell console is active and 'Disconnect-HPEGL' has not been executed.

    .EXAMPLE
    Get-HPEGLService -Name 'Data Services' -Region "EU-Central" | New-HPEGLAPIcredential -TemplateName Grafana -Location .

    Generates the 'DS-EU_Central-Grafana' API client credential for the 'Data Services' service instance in the Central Europe region.
    Exports the API credentials, including the client ID and secret, to a JSON file named 'DS-EU_Central-Grafana_API_Credentials.json' in the local folder.
    
    To read the encrypted API credential file contents later:
        $SecureClientSecret = (Get-Content .\DS-EU_Central-Grafana_API_Credentials.json | ConvertFrom-Json).secure_client_secret | ConvertTo-SecureString
        $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)
        $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)

    Note: Decryption is only supported on the same machine where the cmdlet was executed.

    .EXAMPLE
    Get-HPEGLService -ShowProvisioned -Name 'Compute Ops Management' | New-HPEGLAPIcredential -TemplateName Grafana -Location c:\MyCredentials

    Generates API client credentials for all provisioned instances of 'Compute Ops Management'. Credential names are auto-generated from the TemplateName property, such as "COM-AP_NorthEast-Grafana" for 'Compute Ops Management AP NorthEast', and "COM-EU_Central-Grafana" for 'Compute Ops Management EU Central'.
    API credentials for each instance are exported to the c:\MyCredentials folder. Exported filenames format: 'COM-<Region_Name>-Grafana_API_Credentials.json'.

    .EXAMPLE
    # Step 1: Fetch the service details for 'Data Services' in the 'eu-west' region that is provisioned and pass that in the pipeline to create a new API client credential.
    $response = Get-HPEGLService -Name 'Data Services' -Region "eu-west" -ShowProvisioned | New-HPEGLAPIcredential -TemplateName Grafana 

    # Step 2: Extract the API credentials generated by 'New-HPEGLAPIcredential' in $HPEGreenLakeSession matching the response name and current workspace ID.
    $Grafana_DS_EU_Central_Credentials = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -eq $response.Name -and $_.workspace_id -eq $HPEGreenLakeSession.workspaceId }

    # Step 3: Convert the secure client secret from encrypted format to a SecureString object.
    $SecureClientSecret = $Grafana_DS_EU_Central_Credentials.secure_client_secret | ConvertTo-SecureString

    # Step 4: Marshal the SecureString to a BSTR (binary string).
    $Bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureClientSecret)

    # Step 5: Convert the BSTR to a plain text string.
    $ClientSecret = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($bstr)

    # Step 6: Use the stored API credentials to connect to HPE Data Services (formerly known as Data Storage Cloud Services).
    Connect-DSCC -Client_Id $Grafana_DS_EU_Central_Credentials.client_id -Client_Secret $ClientSecret -GreenlakeType EU -AutoRenew -WhatIfToken

    # Explanation:
    # This script demonstrates how to pass the stored API credentials from the `$HPEGreenLakeSession` global variable to `Connect-DSCC`, which initiates a connection to HPE Data Services. 
    # The `$HPEGreenLakeSession` global variable remains accessible as long as the PowerShell console is active and 'Disconnect-HPEGL' has not been run.

    .INPUTS
    System.Collections.ArrayList
        List of service instance(s) from `Get-HPEGLService -ShowProvisioned`.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects with the following keys:
            * Name - name of the attempted API credential
            * Filename - name of the exported file
            * Location - path of the exported file
            * Encrypted - encryption status Boolean
            * Status - creation status (Failed for HTTP errors; Complete if successful; Warning if no action needed)
            * Details - additional status information
            * Exception - information about any exceptions during the operation

    HPEGreenLakeSession.apiCredentials
        When successful, an object is added to `${Global:HPEGreenLakeSession.apiCredentials}` with the following properties:
            ==================================================================================================
            | Name                      | Type               | Value                                         |
            |------------------------------------------------------------------------------------------------
            | name                      | String             | Name of the generated API client credential   |
            -------------------------------------------------------------------------------------------------
            | workspace_name            | String             | Name of the workspace                         |
            -------------------------------------------------------------------------------------------------
            | workspace_id              | String             | ID of the workspace                           |
            -------------------------------------------------------------------------------------------------
            | application_name          | String             | Name of the provisioned service               |
            -------------------------------------------------------------------------------------------------
            | region                    | String             | Name of the service region                    |
            -------------------------------------------------------------------------------------------------
            | application_instance_id   | String             | ID of the provisioned service instance        |
            -------------------------------------------------------------------------------------------------
            | secure_client_secret      | Secure String      | API Client Secret in a secure string format   |
            -------------------------------------------------------------------------------------------------
            | client_id                 | String             | API Client ID                                 |
            -------------------------------------------------------------------------------------------------
            | connectivity_endpoint     | String             | API connectivity endpoint                     |
            ==================================================================================================
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "Default")]
        [Parameter (Mandatory, ParameterSetName = "GLP")]
        [String]$TemplateName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [Alias('name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ParameterSetName = "GLP")]
        [Switch]$HPEGreenLake,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [Alias('ccs_region')]
        [String]$Region,

        [Parameter (ParameterSetName = "Default")]
        [Parameter (ParameterSetName = "GLP")]
        [Alias ("x", "export", 'exportFile')]
        [ValidateScript({ Test-Path $_ })]
        [String]$Location,


        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $ApplicationsAPICredentialsUri  
        $NewAPICredentialStatus = [System.Collections.ArrayList]::new()
        
        try {
            
            "[{0}] ------ About to run: Get-HPEGLService -ShowProvisioned" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            $Services = Get-HPEGLService -ShowProvisioned 
    
            "[{0}] ------ About to run: Get-HPEGLAPICredential" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
            $Credentials = Get-HPEGLAPICredential
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        [int]$Numberofcredentials = $Credentials.count
               
    }

    Process {         

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Null
            Filename  = $Null
            Location  = $Null     
            Encrypted = $Null                       
            Status    = $Null
            Details   = $Null
            Exception = $Null
                      
        }

        if ($HPEGreenLake) {

            $ServiceName = "GLP"
            $ServiceInstanceId = "00000000-0000-0000-0000-000000000000"

            $CredentialName = $ServiceName + "-" + $TemplateName
    
            "[{0}] Credential name that will be generated: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose
            $objStatus.Name = $CredentialName 

            $Region = "N/A"
        }
        else {

            # "------ About to run: Get-HPEGLService -ShowProvisioned -Name '{0}' -Region '{1}'" -f $ServiceName, $Region | Write-Verbose
            # $service = Get-HPEGLService -ShowProvisioned -Name $ServiceName -Region $Region
            
            $service = $services | Where-Object { $_.name -eq $ServiceName -and $_.region -eq $Region }
            $ServiceInstanceId = $service.application_instance_id

            if (-not $service) {
                # Must return a message if resource not found
                "[{0}] Service '{1}' not found or not provisioned! API credential cannot be created!" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServiceName + " - " + $Region) | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Service '{0}' cannot be found or is not provisioned in '{1}' region!" -f $ServiceName, $Region
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service cannot be found in the HPE GreenLake workspace!"
                }
              
            }
            else {
            
                if ($ServiceName -eq "Compute Ops Management") {
                    $ServiceName = "COM"
                }  
                elseif ($ServiceName -eq "Data Services") {
                    $ServiceName = "DS"
                }
                else {
                    $ServiceName = $ServiceName.replace(" ", "_")
                }
           
                $CredentialName = $ServiceName + "-" + $service.region + "-" + $TemplateName
                "[{0}] Credential name that wil be generated: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose
    
                $objStatus.Name = $CredentialName 

            } 
        }      

        # Check if credential already exists or if more than 5 credentials

        # "------ About to run: Get-HPEGLAPICredential -Name '{0}'" -f $CredentialName | Write-Verbose
        # $Credentials = Get-HPEGLAPICredential
        $Credentialfound = $Credentials | Where-Object name -eq $CredentialName
            
        if ( $Credentialfound) {

            "[{0}] API credential name '{1}' already created, use another name!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose

            # Must return a message if resource not found

            if ($WhatIf) {
                $ErrorMessage = "API credential '{0}' already created!" -f $CredentialName
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "API credential name already created!"
            }
            
        }
        elseif ($Numberofcredentials -ge 5) {
            "[{0}] API credential '{1}' cannot be created because you have reached the maximum of 5 credentials" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "API credential '{0}' cannot be created because you have reached the maximum of 5 credentials" -f $CredentialName
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "API credential cannot be created!"
                $objStatus.Exception = "You have reached the maximum of 5 credentials!"
            }


        }
        else {

            $Payload = [PSCustomObject]@{
                credential_name         = $CredentialName
                application_instance_id = $ServiceInstanceId 
            } | ConvertTo-Json -Depth 5
   
            # Create API Credential  
            try {

                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -WhatIfBoolean $WhatIf
                
                Start-Sleep 1
                
                if (-not $WhatIf) {

                    if ($Region -eq "N/A") {
                        "[{0}] API credential '{1}' successfully created for '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName, $ServiceName | Write-Verbose

                    }
                    else {
                        "[{0}] API credential '{1}' successfully created for '{2}' in '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CredentialName, $ServiceName, $Region | Write-Verbose
                    }
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "API Credential successfully created"
                    $Numberofcredentials += 1
                    "[{0}] Number of credentials: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Numberofcredentials | Write-Verbose
            
                    # Save Service token 
                    # $Clientsecret = $Response.client_secret

                    $secClientSecret = ConvertTo-SecureString -String $Response.client_secret -AsPlainText -Force | ConvertFrom-SecureString  

                    $ClientID = $Response.client_id
    
                    # $ConnectivityEndpoint = (Get-HPEGLAPICredential -Name $CredentialName).connectivity_endpoint
                
                
                    $ServiceAPICredential = [PSCustomObject]@{
                        name                    = $CredentialName 
                        workspace_name          = $HPEGreenLakeSession.workspace
                        workspace_id            = $HPEGreenLakeSession.workspaceId
                        application_name        = $ServiceName
                        region                  = $Region
                        application_instance_id = $ServiceInstanceId
                        secure_client_secret    = $secClientSecret 
                        client_id               = $ClientID
                        connectivity_endpoint   = $Null
                        # connectivity_endpoint   = $ConnectivityEndpoint
                    }
    
                    "[{0}] API credential to add to `$HPEGreenLakeSession.apiCredentials global variable: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ServiceAPICredential | ConvertTo-Json -d 10) | Write-Verbose                   
                                   
                    [void]$global:HPEGreenLakeSession.apiCredentials.Add($ServiceAPICredential)
                    "[{0}] `$HPEGreenLakeSession.apiCredentials global variable set with new content" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose   
                    
                    # If the template name equal the template name set for the library temporary API credential, then set the region in $HPECOMAPICredentialRegions global variable 
                    # This variable is used for the argument completer for the Region parameter of *HPECOM* cmdlets

                    if ($TemplateName -eq $APIClientCredentialTemplateName -and $ServiceAPICredential.application_name -ne "GLP") {

                        [void]$Global:HPECOMAPICredentialRegions.Add($ServiceAPICredential.region)                   

                    }
                
                    if ($Location) {
                    
                        if ([System.IO.Path]::IsPathRooted($Location)) {

                            $objStatus.Location = $Location

                        }
                        else {
                            $objStatus.Location = (Resolve-Path $Location).Path

                        }

                        $_filename = "{0}_API_Credentials.json" -f $CredentialName

                        $objStatus.Filename = $_filename
    
                        $ServiceAPICredentialJson = $ServiceAPICredential | convertto-json -depth 99                 
                        
                        $ServiceAPICredentialJson | Out-File ($Location + '\' + $_filename)
                        "[{0}] API Client credential file '{1}' successfully created in '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $_filename, ((get-Item ($Location + '\' + $_filename)).DirectoryName) | Write-Verbose
                        $objStatus.Encrypted = $False
    
                        
                    }
        
                }
                

            }
            catch {

                # if ($Response -match "Error status Code: 400") {
                #     "{0} API credential cannot be created because you have reached the maximum of 5 credentials" -f $CredentialName | Write-Verbose
    
                # }

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "API Credential cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                }

            }

        }

        [void] $NewAPICredentialStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            "[{0}] Adding connectivity endpoints when absent to each generated credentials" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

            try {
                $Credentials = Get-HPEGLAPICredential 
           
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }

            # Collect credentials that need modification
            $credentialsToUpdate = @()

            foreach ($credential in $HPEGreenLakeSession.apiCredentials) {
                if ($Null -eq $credential.connectivity_endpoint) {
                    $credentialsToUpdate += $credential
                }   
            }
    
            foreach ($credential in $credentialsToUpdate) {              
                
                $ConnectivityEndpoint = ($Credentials | Where-Object name -eq $credential.name ).connectivity_endpoint
    
                "[{0}] Removing credential `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($credential | Out-String) | Write-Verbose                
                [void]$global:HPEGreenLakeSession.apiCredentials.Remove($credential)
                    
                $credential.connectivity_endpoint = $ConnectivityEndpoint
                # "Adding connectivity endpoint '{0}' to credential '{1}'" -f $ConnectivityEndpoint, $credential.name | Write-Verbose
                "[{0}] Adding credential `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($credential | Out-String) | Write-Verbose                
                    
                "[{0}] Saving to `$HPEGreenLakeSession.apiCredentials" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-Verbose
                [void]$global:HPEGreenLakeSession.apiCredentials.Add($credential)
                
            }

            if ($NewAPICredentialStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more API Credentials failed the creation attempt!"
          
            }

            Return $NewAPICredentialStatus
        }


    }
}


Function Remove-HPEGLAPICredential {
    <#
    .SYNOPSIS
    Deletes API credential of a service instance. 

    .DESCRIPTION
    This Cmdlet deletes API client credential for an HPE GreenLake service instance.
        
    .PARAMETER Name 
    Name (Case sensitve) of the API client credential to delete.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLAPICredential -Name "Grafana-COM-AP_NorthEast"

    Delete the API credential "Grafana-COM-AP_NorthEast".

    .EXAMPLE
    Get-HPEGLAPICredential | Where-Object name -match Grafana | Remove-HPEGLAPIcredential

    Delete all API credentials whose name matches with Grafana (such as Grafana-COM-AP_NorthEast, Grafana-COM-EU_Central, Grafana-COM-US_West).

    .EXAMPLE
    Get-HPEGLAPICredential | Remove-HPEGLAPICredential

    Delete all API credentials.

    .INPUTS
    System.Collections.ArrayList
        List of API Credential(s) from 'Get-HPEGLAPICredential'.    
    
    .OUTPUTS
    System.Collections.ArrayList    
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - name of the API credential object attempted to be deleted 
        * Status - status of the creation attempt (Failed for http error return; Complete if the deletion is successful) 
        * Details - more information about the status 
        * Exception: Information about any exceptions generated during the operation.

   #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [Alias ('credential_name')]
        [String]$Name,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $RemoveAPICredentialStatus = [System.Collections.ArrayList]::new()
        
        try {
            "------ About to run: Get-HPEGLAPICredential" | Write-Verbose
            $APIcredentials = Get-HPEGLAPICredential
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # "------ About to run: Get-HPEGLAPICredential -name '{0}'" -f $Name | Write-Verbose
        # $APIcredential = Get-HPEGLAPICredential -Name $Name

        $APIcredential = $APIcredentials | Where-Object name -eq $Name
   
        # Build object for the output
        $objStatus = [pscustomobject]@{
            Name      = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                          
        }

        if (-not $APIcredential) {
            # Must return a message if API credential not found
            "[{0}] API credential '{1}' not found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $name | Write-Verbose

            # Must return a message if resource not found

            if ($WhatIf) {
                $ErrorMessage = "API credential '{0}' cannot be found in the HPE GreenLake workspace!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "API credential cannot be found!"
            }

               
        }
        else {

            # Delete API Credential  
            
            $Uri = $ApplicationsAPICredentialsUri + "/$Name" 
            
            try {
                
                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -WhatIfBoolean $WhatIf | Out-Null
                
                if (-not $WhatIf) {
                    
                    "[{0}] API credential '{1}' successfully deleted!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose
                    $objStatus.Status = "Complete"
                    $objStatus.Details = "API Credential successfully deleted"
                    
                    # Remove credential from $HPEGreenLakeSession.apiCredentials global variable
                    $APICredentialtoRemove = $HPEGreenLakeSession.apiCredentials | Where-Object { $_.name -eq $Name -and $_.workspace_id -eq $HPEGreenLakeSession.workspaceId } 

                    if ($APICredentialtoRemove) {
                 
                        "[{0}] API credential to remove from `$HPEGreenLakeSession.apiCredentials global variable: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($APICredentialtoRemove | ConvertTo-Json -d 10) | Write-Verbose                   
            
                        [void]$global:HPEGreenLakeSession.apiCredentials.Remove($APICredentialtoRemove)
        
                    }

                    Start-Sleep 1

                }
            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "API Credential cannot be deleted!"
                    $objStatus.Exception = $_.Exception.message 
                }

            }
        }  
        [void] $RemoveAPICredentialStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($RemoveAPICredentialStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more API Credentials failed the deletion attempt!"
          
            }

            Return $RemoveAPICredentialStatus
        }


    }
}

#EndRegion


#Region --- SUBSCRIPTION - LICENSE ---


Function Get-HPEGLDeviceSubscription {
    <#
    .SYNOPSIS
    Retrieve device subscriptions from HPE GreenLake.

    .DESCRIPTION
    This Cmdlet returns a collection of device subscriptions or a filtered collection based on optional parameters.
    Subscriptions are necessary for assigning them to devices using the 'Set-HPEGLDeviceSubscription' Cmdlet.

    .PARAMETER Key
    Specifies the subscription key to display.

    .PARAMETER ShowWithAvailableQuantity 
    Optional parameter that displays only the subscriptions with available quantity.

    .PARAMETER ShowExpired 
    Optional parameter that displays only the subscriptions that are expired.
    
    .PARAMETER ShowValid 
    Optional parameter that displays only the subscriptions that are not expired.

    .PARAMETER FilterByDeviceType 
    Optional parameter used to select subscription by device type, such as 'ACCESS POINT', 'GATEWAY', 'SERVER', 'STORAGE', 'SWITCH'.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLDeviceSubscription

    Returns all device subscriptions.

    .EXAMPLE
    Get-HPEGLDeviceSubscription -ShowValid
        
    Returns all device subscriptions that are not expired.

    .EXAMPLE
    Get-HPEGLDeviceSubscription -ShowValid -ShowWithAvailableQuantity
        
    Returns all device subscriptions that are not expired and have available quantity.

    .EXAMPLE
    Get-HPEGLDeviceSubscription -ShowWithAvailableQuantity -ShowValid -FilterByDeviceType SWITCH

    Returns all 'Switch' subscriptions that are not expired and have available quantity.

    #>    
   
    [CmdletBinding(DefaultParameterSetName = 'NotExpired')]
    Param( 

        [String]$Key,

        [Parameter (ParameterSetName = 'Expired')]
        [Parameter (ParameterSetName = 'NotExpired')]
        [Switch]$ShowWithAvailableQuantity,

        [Parameter (ParameterSetName = 'Expired')]
        [Switch]$ShowExpired,

        [Parameter (ParameterSetName = 'NotExpired')]
        [Switch]$ShowValid,

        [Parameter (ParameterSetName = 'Expired')]
        [Parameter (ParameterSetName = 'NotExpired')]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('ACCESS POINT', 'GATEWAY', 'SERVER', 'STORAGE', 'SWITCH')]
        [String]$FilterByDeviceType,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $LicenseDevicesProductTypeDeviceUri
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Post -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
                
        if ($Null -ne $Collection.subscriptions) {

            $CollectionList = $Collection.subscriptions 
            
            if ($ShowWithAvailableQuantity -and $ShowValid) {
                # "Available and notexpired" -f $Null
                $CollectionList = $CollectionList | Where-Object { $_.available_quantity -ge 1 -and $_.license_state_type -ne "Ended" }
            }
            elseif ($ShowWithAvailableQuantity -and $ShowExpired) {    
                # "Available and expired" -f $Null
                $CollectionList = $CollectionList | Where-Object { $_.available_quantity -ge 1 -and $_.license_state_type -eq "Ended" }
            }
            elseif ($ShowWithAvailableQuantity -and -not $ShowExpired -and -not $ShowValid) {    
                # "Available" -f $Null
                $CollectionList = $CollectionList | Where-Object available_quantity -ge 1
            }       
            elseif ($ShowExpired -and -not $ShowWithAvailableQuantity -and -not $ShowValid) {    
                # "Expired" -f $Null
                $CollectionList = $CollectionList | Where-Object license_state_type -eq "Ended"   
            }  
            elseif ($ShowValid -and -not $ShowWithAvailableQuantity -and -not $ShowExpired) {    
                # "Not Expired" -f $Null
                $CollectionList = $CollectionList | Where-Object license_state_type -ne "Ended"
            }

            if ($FilterByDeviceType) {

                if ($FilterByDeviceType -eq "ACCESS POINT") {
                    $_DeviceType = "AP"
                }
                    
                if ($FilterByDeviceType -eq "GATEWAY") {
                    $_DeviceType = "GATEWAY"
                }
        
                if ($FilterByDeviceType -eq "SERVER") {
                    $_DeviceType = "COMPUTE"
                }
        
                if ($FilterByDeviceType -eq "STORAGE") {
                    $_DeviceType = "STORAGE"
                }
        
                if ($FilterByDeviceType -eq "SWITCH") {
                    $_DeviceType = "SWITCH"
                }

                $CollectionList = $CollectionList | Where-Object supported_device_types -match $_DeviceType
            }    

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "License.Device"    

            $ReturnData = $ReturnData | Sort-Object { $_.subscription_key }

            if ($Key) {
                $ReturnData = $ReturnData | Where-Object subscription_key -eq $Key
            }
    
            return $ReturnData 
        }
        else {

            return 
            
        }
    }
}


Function Add-HPEGLDeviceSubscription {
    <#
    .SYNOPSIS
    Add a device subscription to HPE GreenLake.

    .DESCRIPTION
    This Cmdlet adds a device subscription to the HPE GreenLake workspace. 
    Subscriptions are required to assign them to devices using 'Set-HPEGLDeviceSubscription'. 

    .PARAMETER SubscriptionKey 
    The subscription key to add to the GreenLake workspace.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLDeviceSubscription -SubscriptionKey 'Kxxxxxxxxxx'

    Adds the device subscription key 'Kxxxxxxxxxx'.
        
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SubscriptionKey - The subscription key attempted to be added 
        * Status - The status of the addition attempt (Failed for HTTP error return; Complete if addition is successful) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'Default')]
        [String]$SubscriptionKey,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AddLicenseDevicesUri
        $AddDevicesSubscriptionStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $SubscriptionKeyFound = Get-HPEGLDeviceSubscription | Where-Object  subscription_key -eq $SubscriptionKey
      
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
        
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SubscriptionKey = $SubscriptionKey
            Status          = $Null
            Details         = $Null
            Exception       = $Null
          
        }

        if ($SubscriptionKeyFound) {
            # Must return a message if subscription already present
            "[{0}] Subscription '{1}' is already present in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SubscriptionKey | Write-Verbose
        
            if ($WhatIf) {
                $ErrorMessage = "Subscription '{0}' is already present in the HPE GreenLake workspace!" -f $SubscriptionKey
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Subscription is already present in the HPE GreenLake workspace!"
            }
        }
        else {
           

            # Build payload
            $payload = [PSCustomObject]@{
                key = $SubscriptionKey 
            } | ConvertTo-Json -Depth 5

            

            # Add device subscription
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Device subscription successfully added to the HPE GreenLake platform"
                    
                }
                
            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Device subscription was not added to the HPE GreenLake platform"
                    $objStatus.Exception = $_.Exception.message 
                }
            
            }   
        } 

        [void] $AddDevicesSubscriptionStatus.add($objStatus)

  
    }
    end {

        if (-not $WhatIf) {

            if ($AddDevicesSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more device subscriptions could not be added!"
          
            }

            Return $AddDevicesSubscriptionStatus
        }


    }
      
}


<# NOT SUPPORTED
Function Remove-HPEGLSubscription {
    <#
    .SYNOPSIS
    Delete a subscription from the HPE GreenLake Workspace.

    .DESCRIPTION
    This Cmdlet removes a subscription from the HPE GreenLake workspace. 

    .PARAMETER SubscriptionKey 
    The subscription key to remove from the GreenLake workspace.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLServiceSubscription -SubscriptionKey 'Kxxxxxxxxxx'

    Removes the service subscription key 'Kxxxxxxxxxx'.
        
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SubscriptionKey - The subscription key attempted to be added 
        * Status - The status of the addition attempt (Failed for HTTP error return; Complete if addition is successful) 
        * Details - More information about the status 
        * Exception - Information about any exceptions generated during the operation.
    


    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'Default')]
        [String]$SubscriptionKey,
        
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $AddDevicesSubscriptionStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $SubscriptionKeyFound = Get-HPEGLDeviceSubscription | Where-Object  subscription_key -eq $SubscriptionKey
      
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)
        
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SubscriptionKey = $SubscriptionKey
            Status          = $Null
            Details         = $Null
            Exception       = $Null
          
        }


        if (-not $SubscriptionKeyFound) {
            # Must return a message if subscription already present
            "[{0}] Subscription '{1}' is not present in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $SubscriptionKey | Write-Verbose
        
            if ($WhatIf) {
                $ErrorMessage = "Subscription '{0}' is not present in the HPE GreenLake workspace!" -f $SubscriptionKey
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "Subscription is not present in the HPE GreenLake workspace!"
            }
        }
        else {
           
            $ResourceId = $SubscriptionKeyFound.resource_id

            $Uri = $AddLicenseDevicesUri + "/" + $ResourceId

            # Add device subscription
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -WhatIfBoolean $WhatIf | out-Null

                if (-not $WhatIf) {

                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Device subscription successfully removed from HPE GreenLake platform"
                    
                }
                
            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Device subscription was not removed from the HPE GreenLake platform"
                    $objStatus.Exception = $_.Exception.message 
                }
            
            }   
        } 

        [void] $AddDevicesSubscriptionStatus.add($objStatus)

  
    }
    end {

        if (-not $WhatIf) {

            if ($AddDevicesSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more device subscriptions could not be removed!"
          
            }

            Return $AddDevicesSubscriptionStatus
        }


    }
      
}

#>


Function Get-HPEGLServiceSubscription {
    <#
    .SYNOPSIS
    Retrieve service subscriptions from HPE GreenLake.

    .DESCRIPTION
    This Cmdlet returns a collection of service subscriptions or a filtered collection based on optional parameters. 

    .PARAMETER ShowWithAvailableQuantity 
    Optional parameter that displays only the subscriptions with available quantity.

    .PARAMETER ShowExpired 
    Optional parameter that displays only the subscriptions that are expired.
    
    .PARAMETER ShowValid 
    Optional parameter that displays only the subscriptions that are not expired.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLServiceSubscription

    Returns all service subscriptions.

    .EXAMPLE
    Get-HPEGLServiceSubscription -ShowValid
        
    Returns all service subscriptions that are not expired.

    .EXAMPLE
    Get-HPEGLServiceSubscription -ShowValid -ShowWithAvailableQuantity
        
    Returns all service subscriptions that are not expired and have available quantity.

    #>


    [CmdletBinding(DefaultParameterSetName = 'NotExpired')]
    Param( 
       
        [Parameter (ParameterSetName = 'Expired')]
        [Parameter (ParameterSetName = 'NotExpired')]
        [Switch]$ShowWithAvailableQuantity,

        [Parameter (ParameterSetName = 'Expired')]
        [Switch]$ShowExpired,

        [Parameter (ParameterSetName = 'NotExpired')]
        [Switch]$ShowValid,
   
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $ServiceSubscriptionsListUri + "?product_type=SERVICE"
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
   
   
        
        if ($Null -ne $Collection.subscriptions) {

            $CollectionList = $Collection.subscriptions 

            
            if ($ShowWithAvailableQuantity -and $ShowValid) { 
                # "Available and notexpired" -f $Null
                $CollectionList = $CollectionList | Where-Object { $_.available_quantity -ge 1 -and $_.license_state_type -ne "Ended" }
            
            }
            elseif ($ShowWithAvailableQuantity -and $ShowExpired) {    
                # "Available and expired" -f $Null
                $CollectionList = $CollectionList | Where-Object { $_.available_quantity -ge 1 -and $_.license_state_type -eq "Ended" }
            }
            elseif ($ShowWithAvailableQuantity -and -not $ShowExpired -and -not $ShowValid) {    
                # "Available" -f $Null
                $CollectionList = $CollectionList | Where-Object available_quantity -ge 1
            }       
            elseif ($ShowExpired -and -not $ShowWithAvailableQuantity -and -not $ShowValid) {    
                # "Expired" -f $Null
                $CollectionList = $CollectionList | Where-Object license_state_type -eq "Ended"   
            }  
            elseif ($ShowValid -and -not $ShowWithAvailableQuantity -and -not $ShowExpired) {    
                # "Not Expired" -f $Null
                $CollectionList = $CollectionList | Where-Object license_state_type -ne "Ended"
            }
  

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "License.Service"    

            $ReturnData = $ReturnData | Sort-Object { $_.subscription_key }
    
            return $ReturnData 
        }
        else {

            return 
            
        }  
    }
}


Function Get-HPEGLDeviceAutoSubscription {
    <#
    .SYNOPSIS
    Retrieve the auto-subscription status of device(s) in the HPE GrenLake workspace.

    .DESCRIPTION
    This Cmdlet returns the device types enabled for automatic subscription assignment.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLDeviceAutoSubscription

    Returns all auto-subscribed device types.
    
   #>

    [CmdletBinding()]
    Param( 
        [Switch]$WhatIf   
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoLicenseDevicesUri
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
  
        
        if ($Null -ne $Collection.autolicenses) {

            $CollectionList = $Collection.autolicenses | Where-Object { $_.enabled -eq $True }

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "License.Auto"    

            $ReturnData = $ReturnData | Sort-Object { $_.device_type }
    
            return $ReturnData 
        }
        else {

            return 
            
        }  
    }
}


function Set-HPEGLDeviceAutoSubscription {
    <#
    .SYNOPSIS
    Configure automatic subscription assignment for each supported device type.

    .DESCRIPTION
    This Cmdlet enables the automatic assignment of subscriptions to devices. When a subscription assigned to a device expires or is canceled, HPE GreenLake checks for available subscription tokens in your workspace and assigns the longest available subscription token to the device.

    .PARAMETER AccessPointSubscriptionTier 
    Defines the automatic subscription for "Access Points". The subscription level can be selected from a predefined list.

    .PARAMETER GatewaySubscriptionTier 
    Defines the automatic subscription for "Gateways". The subscription level can be selected from a predefined list.

    .PARAMETER ComputeSubscriptionTier 
    Defines the automatic subscription for "Computes". The subscription level can be selected from a predefined list.

    .PARAMETER SwitchSubscriptionTier 
    Defines the automatic subscription for "Switches". The subscription level can be selected from a predefined list.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLDeviceAutoSubscription -ComputeSubscriptionTier ENHANCED

    Configures auto-subscription for your Compute devices using the Enhanced subscription tier.

    .EXAMPLE
    Set-HPEGLDeviceAutoSubscription -SwitchSubscriptionTier ADVANCED

    Configures auto-subscription for your Switch devices using the Advanced subscription tier.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or an array of objects containing the following PsCustomObject keys:  
        * DeviceType - The type of device configured for auto-subscription.
        * Status - The status of the auto-subscription assignment attempt (Failed for HTTP error return; Complete if successful).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "AP")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION', 'ADVANCED')]
        [String]$AccessPointSubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Gateway")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION', 'ADVANCED')]
        [String]$GatewaySubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Compute")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('STANDARD', 'ENHANCED')]
        [String]$ComputeSubscriptionTier,

        [Parameter (Mandatory, ParameterSetName = "Switch")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('FOUNDATION', 'ADVANCED')]
        [String]$SwitchSubscriptionTier,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoLicenseDevicesUri  
        $AutoSubscriptionStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        if ($AccessPointSubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_AP"
            $DeviceType = "AP"
        }
        elseif ($AccessPointSubscriptionTier -eq 'ADVANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ADVANCED_AP"
            $DeviceType = "AP"
        }


        if ($GatewaySubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_GW"
            $DeviceType = "GATEWAY"

        }
        elseif ($GatewaySubscriptionTier -eq 'ADVANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ADVANCED_GW"
            $DeviceType = "GATEWAY"

        }


        if ($ComputeSubscriptionTier -eq 'STANDARD' ) {
            $AutoLicenseSubscriptionTierGroup = "STANDARD_COMPUTE"
            $DeviceType = "COMPUTE"

        }
        elseif ($ComputeSubscriptionTier -eq 'ENHANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ENHANCED_COMPUTE"
            $DeviceType = "COMPUTE"

        }


        if ($SwitchSubscriptionTier -eq 'FOUNDATION' ) {
            $AutoLicenseSubscriptionTierGroup = "FOUNDATION_SWITCH"
            $DeviceType = "SWITCH"

        }
        elseif ($SwitchSubscriptionTier -eq 'ADVANCED' ) {
            $AutoLicenseSubscriptionTierGroup = "ADVANCED_SWITCH"
            $DeviceType = "SWITCH"

        }



        # Build object for the output
        $objStatus = [pscustomobject]@{
 
            DeviceType = $DeviceType
            Status     = $Null
            Details    = $Null
            Exception  = $Null
                 
        }


        # Build payload
        $payload = ConvertTo-Json @(
            @{
                device_type                          = $DeviceType
                enabled                              = $True 
                auto_license_subscription_tier_group = $AutoLicenseSubscriptionTierGroup
                    
            }
        ) 
  

        # Assign Device to Service 
    
        try {
            Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | Out-Null
               
            if (-not $WhatIf) {

                $objStatus.Status = "Complete"
                $objStatus.Details = "Automatic assignment of subscriptions to $DeviceType successfully set!"
                

            }
        }
        catch {
            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Automatic assignment of subscriptions to $DeviceType cannot be set!"
                $objStatus.Exception = $_.Exception.message 
            }
        }
        

        [void] $AutoSubscriptionStatus.add($objStatus)
    }

    end {

        if (-not $WhatIf) {

            if ($AutoSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
 
                write-error "$DeviceType automatic assignment of subscription configuration failure!"
         
            }

            Return $AutoSubscriptionStatus
        }


    }
}


function Remove-HPEGLDeviceAutoSubscription {
    <#
    .SYNOPSIS
    Remove automatic subscription assignment for specified device types.

    .DESCRIPTION
    This Cmdlet disables the automatic assignment of subscriptions to specified device types. It allows you to remove auto-subscription settings for Access Points, Gateways, Computes, and Switches.

    .PARAMETER AccessPoint 
    Removes the automatic subscription assignment for "Access Points".

    .PARAMETER Gateway 
    Removes the automatic subscription assignment for "Gateways".

    .PARAMETER Compute 
    Removes the automatic subscription assignment for "Computes".

    .PARAMETER Switch 
    Removes the automatic subscription assignment for "Switches".

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLDeviceAutoSubscription -Compute

    Removes the auto-subscription for Compute devices.

    .EXAMPLE
    Remove-HPEGLDeviceAutoSubscription -Switch

    Removes the auto-subscription for Switch devices.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.
    
    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or an array of objects containing the following PsCustomObject keys:  
        * DeviceType - The type of device removed from auto-subscription.
        * Status - The status of the auto-subscription unassignment attempt (Failed for HTTP error return; Complete if successful).
        * Details - Additional information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = "AP")]
        [Switch]$AccessPoint,

        [Parameter (Mandatory, ParameterSetName = "Gateway")]
        [Switch]$Gateway,

        [Parameter (Mandatory, ParameterSetName = "Compute")]
        [Switch]$Compute,

        [Parameter (Mandatory, ParameterSetName = "Switch")]
        [Switch]$Switch,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AutoLicenseDevicesUri  
        $AutoSubscriptionStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        if ($AccessPoint ) {
            $DeviceType = "AP"
        }

        if ($Gateway) {
            $DeviceType = "GATEWAY"

        }

        if ($Compute ) {
            $DeviceType = "COMPUTE"

        }

        if ($Switch) {
            $DeviceType = "SWITCH"

        }


        # Build object for the output
        $objStatus = [pscustomobject]@{

            DeviceType = $DeviceType
            Status     = $Null
            Details    = $Null
            Exception  = $Null
             
        }


        try {
            
            $AutoLicenseSubscriptionTierGroup = (Get-HPEGLDeviceAutoSubscription | Where-Object { $_.device_type -eq $DeviceType }).auto_license_subscription_tier_group
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if ($AutoLicenseSubscriptionTierGroup) {

            # Build payload
            $payload = ConvertTo-Json @(
                @{
                    device_type                          = $DeviceType
                    enabled                              = $False 
                    auto_license_subscription_tier_group = $AutoLicenseSubscriptionTierGroup
                    
                }
            ) 
  

            # Assign Device to Service 
    
            try {
                Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | Out-Null
               
                if (-not $WhatIf) {

                    $objStatus.Status = "Complete"
                    $objStatus.Details = "Automatic assignment of subscriptions to $DeviceType successfully set!"
                
                }
            }
            catch {
                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Automatic assignment of subscriptions to $DeviceType cannot be set!"
                    $objStatus.Exception = $_.Exception.message 
                }
            }
        }

        else {

            if ($WhatIf) {
                $ErrorMessage = "Automatic subscription cannot be found for $DeviceType!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Automatic subscription cannot be found!"
            }
           
        }

        [void] $AutoSubscriptionStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($AutoSubscriptionStatus | Where-Object { $_.Status -eq "Failed" }) {
 
                write-error "$DeviceType automatic assignment of subscription configuration failure!"
         
            }

            Return $AutoSubscriptionStatus
        }


    }
}


Function Set-HPEGLDeviceSubscription {
    <#
        .SYNOPSIS
        Apply a subscription key to device(s). 

        .DESCRIPTION
        This Cmdlet applies a license subscription key to device(s).     
            
        .PARAMETER SerialNumber 
        Specifies the serial number of the device to which a subscription key will be applied. This value can be retrieved using 'Get-HPEGLDevice'.

        .PARAMETER SubscriptionKey 
        Specifies the subscription key of a valid and non-expired license. This value can be retrieved using 'Get-HPEGLDeviceSubscription -ShowWithAvailableQuantity -ShowValid'.

        .PARAMETER WhatIf
        Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

        .EXAMPLE
        Set-HPEGLDeviceSubscription -SerialNumber CNX2380BLC -SubscriptionKey ABCDEFG1234

        Applies a the subscription key 'ABCDEFG1234' to the device with the serial number CNX2380BLC.

        .EXAMPLE
        Get-HPEGLDeviceSubscription -ShowWithAvailableQuantity -ShowValid -FilterByDeviceType SERVER  | Select-Object -First 1 | Set-HPEGLDeviceSubscription -SerialNumber CNX2380BLC 

        Applies a subscription key to the device with the license provided in the pipeline.

        .EXAMPLE
        $SubscriptionKey = (Get-HPEGLDeviceSubscription -ShowWithAvailableQuantity -ShowValid -FilterByDeviceType SERVER | Select-Object -First 1).subscription_key
        'CNX2380BLC', 'MXQ73200W1' | Set-HPEGLDeviceSubscription -SubscriptionKey $SubscriptionKey

        Applies a server subscription key to devices with serial numbers 'CNX2380BLC' and 'MXQ73200W1'.

        .EXAMPLE
        Import-Csv Tests/Network_Devices.csv | Set-HPEGLDeviceSubscription -SubscriptionKey $SubscriptionKey

        Applies a subscription key to devices listed in a CSV file containing at least a SerialNumber column.

        .INPUTS
        System.Collections.ArrayList
            List of device(s) retrieved using the 'Get-HPEGLDevice' cmdlet.
        System.String, System.String[]
            A single string object or a list of string objects representing device serial numbers.
        System.String
            A subscription key obtained from the 'Get-HPEGLDeviceSubscription' cmdlet.

        .OUTPUTS
        System.Collections.ArrayList
            A custom status object or array of objects containing the following PsCustomObject keys:
                * SerialNumber - Serial number of the device assigned to a subscription key.
                * Status - Status of the assignment attempt (Failed for HTTP error return; Complete if assignment is successful; Warning if no action is needed).
                * Details - More information about the status.
                * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias('serial_number')]
        [String]$SerialNumber,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName)]
        [ValidateNotNullOrEmpty()]
        [Alias('subscription_key')]
        [String]$SubscriptionKey,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $LicenseDevicesUri  

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

        try {
            
            $subscriptionKeyFound = Get-HPEGLDeviceSubscription -Key $SubscriptionKey -ShowWithAvailableQuantity -ShowValid

            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }

        if ( -not $subscriptionKeyFound) {

            $ErrorMessage = "'{0}' is not a valid subscription or without available quantity or it cannot be found in the HPE GreenLake workspace!" -f $SubscriptionKey
            throw $ErrorMessage

        }


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
            
        }
        

        [void] $ObjectStatusList.add($objStatus)
    }

    end {
        
        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( $device.subscription_key ) {

                # Must return a message if device is already licensed to a subscription key
                $Object.Status = "Warning"
                $Object.Details = "Device already licensed with a subscription key!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is already licensed with a subscription key!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            elseif (-not $device.application_name) {
        
                # Must return a message if the device is not assigned to a service
                $Object.Status = "Failed"
                $Object.Details = "Device not assigned to a service! Use first Add-HPEGLDeviceToService!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is not assigned to a service! Use first 'Add-HPEGLDeviceToService'!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }
          
            }
            else {       
            
                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number    = $Device.serial_number
                    part_number      = $Device.part_number 
                    device_type      = $Device.device_type
                    subscription_key = $SubscriptionKey
                }
              
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            # Check to see if there is enough license available fro the number of devices
            if ( $subscriptionKeyFound.available_quantity -lt $DevicesList.Count ) {
                $ErrorMessage = "There are not enough licenses available in $subscriptionKey for the number of devices to be assigned!"
                throw $ErrorMessage
            }
            else {
                
                # Build payload
                $payload = ConvertTo-Json $DevicesList
                    
                                    
                # Assign Devices to location  
                try {

                    Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null
                    
                    if (-not $WhatIf) {
                        
                        foreach ($Object in $ObjectStatusList) {

                            $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                            If ($DeviceSet) {
                                
                                $Object.Status = "Complete"
                                $Object.Details = "Device successfully attached to subscription key!"

                            }
                        }

                    }
                }
                catch {
                    
                    if (-not $WhatIf) {

                        foreach ($Object in $ObjectStatusList) {

                            $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                            If ($DeviceSet) {
                                
                                $Object.Status = "Failed"
                                $Object.Details = "Device cannot be attached to subscription key!"
                                $Object.Exception = $_.Exception.message 

                            }
                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more devices failed the assignment attempt!"
          
            }

            Return $ObjectStatusList
        }
    }
}


Function Remove-HPEGLDeviceSubscription {
    <#
    .SYNOPSIS
    Detach a subscription key from device(s). 

    .DESCRIPTION
    This Cmdlet detaches a license subscription key from device(s).     

    .PARAMETER SerialNumber 
    Serial number of the device to which a subscription key must be detached. This value can be retrieved from 'Get-HPEGLDevice'.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
   
    .EXAMPLE
    Remove-HPEGLDeviceSubscription -SerialNumber CNX2380BLC 

    Detach a subscription key from a device using its serial number.

    .EXAMPLE
    'CNX2380BLC', 'MXQ73200W1' | Remove-HPEGLDeviceSubscription

    Detach subscription keys from devices with serial numbers 'CNX2380BLC' and 'MXQ73200W1'.

    .EXAMPLE
    Import-Csv Tests/Network_Devices.csv  |  Remove-HPEGLDeviceSubscription 

    Detach subscription keys from devices listed in a csv file containing at least a SerialNumber column.

    .EXAMPLE
    Get-HPEGLdevice | Remove-HPEGLDeviceSubscription 

    Detach subscription keys from all devices found in the workspace.

    .INPUTS
    System.Collections.ArrayList
        List of devices(s) from 'Get-HPEGLDevice'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the device's serial numbers. 

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * SerialNumber - Serial number of the device detached from a subscription key. 
        * Status - Status of the detachment attempt (Failed for http error return; Complete if assignment is successful) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>

    [CmdletBinding()]
    Param( 
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline)]
        [Alias('serial_number')]
        [String]$SerialNumber,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $LicenseDevicesUri  
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $DevicesList = [System.Collections.ArrayList]::new()

    }

    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

      
        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            SerialNumber = $SerialNumber
            Status       = $Null
            Details      = $Null
            Exception    = $Null
                      
        }
    

        [void] $ObjectStatusList.add($objStatus)

    }

    end {

        try {
            
            $devices = Get-HPEGLdevice 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)                
        }
        
        
        "[{0}] List of devices where to set a location: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.serialnumber | out-string) | Write-Verbose

        foreach ($Object in $ObjectStatusList) {

            $Device = $Devices | Where-Object serial_number -eq $Object.SerialNumber

            if ( -not $Device) {

                # Must return a message if device not found
                $Object.Status = "Failed"
                $Object.Details = "Device cannot be found in the HPE GreenLake workspace!" 

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            } 
            elseif ( -not $device.subscription_key ) {

                # Must return a message if device is not licensed with a subscription key
                $Object.Status = "Warning"
                $Object.Details = "Device is not licensed with a subscription key!"

                if ($WhatIf) {
                    $ErrorMessage = "Device '{0}' is not licensed with a subscription key!" -f $Object.SerialNumber
                    Write-warning $ErrorMessage
                    continue
                }

            }
            else {       
            
                # Build DeviceList object
                $DeviceList = [PSCustomObject]@{
                    serial_number = $Device.serial_number
                    part_number   = $Device.part_number 
                    device_type   = $Device.device_type
                }
              
                # Building the list of devices object where to add tags
                [void]$DevicesList.Add($DeviceList)
                    
            }
        }

        if ($DevicesList) {

            
            # Build payload
            $payload = ConvertTo-Json $DevicesList
                
                                
            # Assign Devices to location  
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Complete"
                            $Object.Details = "Device successfully detached from subscription key!"

                        }
                    }

                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $DeviceSet = $DevicesList | Where-Object serial_number -eq $Object.SerialNumber

                        If ($DeviceSet) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Device cannot be detached from subscription key!"
                            $Object.Exception = $_.Exception.message 

                        }
                    }
                }
            }
        }
        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more devices from the subscription assignment has failed!"

          
            }

            Return $ObjectStatusList
        }


    }
}

#EndRegion


#Region --- USER - ROLES - PERMISSIONS ---


Function Get-HPEGLUser {
    <#
    .SYNOPSIS
    Retrieve user resource(s).

    .DESCRIPTION
    This Cmdlet returns a collection of user resources or user statistics. Roles and permissions can also be retrieved.

    .PARAMETER FirstName 
    Specifies the first name associated with resources (case-sensitive!).

    .PARAMETER LastName 
    Specifies the last name associated with resources (case-sensitive!).
  
    .PARAMETER Email 
    Specifies the email associated with resources.

    .PARAMETER ShowUnverified 
    Optional parameter that can be used to display unverified users.

    .PARAMETER ShowStats 
    Optional parameter that can be used to display user statistics.

    .PARAMETER ShowRoles 
    This option can be used to see the roles assigned to a user.

    .PARAMETER ShowPermissions 
    This option can be used to see the permissions assigned to a user.
    
    .PARAMETER ShowActivities
    This option can be used to see the activites of a user.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLUser -FirstName Eddy 

    Return the user resource with first name "Eddy".

    .EXAMPLE
    Get-HPEGLUser -ShowStats 

    Return user statistics.

    .EXAMPLE
    Get-HPEGLUser -ShowPermissions -FirstName Albert -LastName Einstein

    Return Albert Einstein permissions.

    .EXAMPLE
    Get-HPEGLUser -ShowRoles -FirstName Albert -LastName Einstein

    Return Albert Einstein roles.
    
   #>
    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (Mandatory, ParameterSetName = 'Roles')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions')]
        [Parameter (Mandatory, ParameterSetName = 'Activity')]
        [ValidateNotNullOrEmpty()]
        [String]$FirstName,  

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (Mandatory, ParameterSetName = 'Roles')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions')]
        [Parameter (Mandatory, ParameterSetName = 'Activity')]
        [ValidateNotNullOrEmpty()]
        [String]$LastName,  
        
        [Parameter (Mandatory, ParameterSetName = 'Email')]
        [Parameter (Mandatory, ParameterSetName = 'EmailRoles')]
        [Parameter (Mandatory, ParameterSetName = 'EmailPermissions')]
        [Parameter (Mandatory, ParameterSetName = 'EmailActivity')]
        [ValidateNotNullOrEmpty()]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,  

        [Parameter(Mandatory, ParameterSetName = 'Unverified')]
        [Switch]$ShowUnverified,
                
        [Parameter (Mandatory, ParameterSetName = 'Roles')]
        [Parameter (Mandatory, ParameterSetName = 'EmailRoles')]
        [Switch]$ShowRoles,
        
        [Parameter (Mandatory, ParameterSetName = 'EmailActivity')]
        [Parameter (Mandatory, ParameterSetName = 'Activity')]
        [Switch]$ShowActivities,

        [Parameter (Mandatory, ParameterSetName = 'Permissions')]
        [Parameter (Mandatory, ParameterSetName = 'EmailPermissions')]
        [Switch]$ShowPermissions,
        
        [Parameter(Mandatory, ParameterSetName = 'Stats')]
        [Switch]$ShowStats,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose


        $Uri = $UsersUri + "?limit=2000&include_unverified=true"

        $query = @()

        if ($FirstName) {
            $query += "first_name=$FirstName"
        }

        if ($LastName) {
            $query += "last_name=$LastName"
        }

        if ($ShowStats) {
            $Uri = $UsersStatsUri
        }
        
        if ($query) {
            foreach ($Item in $query) {
                if ($query.count -eq 1) {
                    $queries = $Item
                }
                else {
                    $queries += ($Item + "&")
                }

                $Uri = $Uri + "&" + $queries

            }
            
        }
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
       
        $ReturnData = @()

   
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if ($ShowStats) {

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "User.stat"         
            return $ReturnData 

        }
        else {

            if ($Null -ne $Collection.users) {
                
                $CollectionList = $Collection.users 

                # "[{0}] List of users: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ( $CollectionList | out-string ) | Write-Verbose

                if ($Email) {
                    $CollectionList = $CollectionList | Where-Object { $_.contact.email -eq $email }
                }

                if ($ShowUnverified) {
                    $CollectionList = $CollectionList | Where-Object { $_.user_status -eq "UNVERIFIED" }
                }

                if ($ShowRoles) {      
                    
                    $RolesList = @()                    

                    if (-not $Email) {
                         
                        $Emailfound = $CollectionList.contact.email
                        
                    }
                    else {
                        $Emailfound = $Email
                    }

                    "[{0}] Number of users: '{1}': retreiving role for: '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CollectionList.count, $Emailfound, ( $CollectionList | out-string ) | Write-Verbose

                    foreach ($Item in $Emailfound) {
                        
                        try {

                            $Rolesfound = Get-HPEGLUserRole -Email $Item 
                            $RolesList += $Rolesfound
                        
                    
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }
                
                    }
    
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $RolesList -ObjectName "User.Role"         
                    $ReturnData = $ReturnData | sort-object email, application_name, role, resource_restriction_policy
                    
                    return $ReturnData
                       
                    
                }
                elseif ($ShowPermissions) {

                    $PermissionsList = @()

                    if ($Email) {
                         
                        $CollectionList = $CollectionList | Where-Object { $_.contact.email -eq $Email }
                    }

                    "[{0}] Number of users: '{1}': retreiving permissions for: '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $CollectionList.count, $Email, ( $CollectionList | out-string ) | Write-Verbose

            
                    if ($CollectionList.count -ne "1") {
                        throw "You need to refine your query as several users have been found and this is not compatible with the Permissions parameter!"
                    }
                    else {

                        $UserRoles = $CollectionList.user_role
                                       
                        foreach ($UserRole in $UserRoles) {

                            $Rolename = $UserRole | ForEach-Object role_name
                            $AppName = $UserRole | ForEach-Object application_name
                        
                            "[{0}] Service: '{1}' - Role: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $AppName, $Rolename | Write-Verbose

                            try {
                                $ResourcePolicies = Get-HPEGLRole -ServiceName $AppName -ServiceRole $RoleName -ShowPermissions

                                $PermissionsList += $ResourcePolicies

                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }

                     
                       
                        }
                        
                        $PermissionsList = $PermissionsList | Sort-Object application, rolename, resource
                        return $PermissionsList

                    }


                }
                else {


                    # Add email to object
                    foreach ($user in $CollectionList) {
                        $user | Add-Member -MemberType NoteProperty -Name email -Value $user.contact.email
                        $user | Add-Member -MemberType NoteProperty -Name firstname -Value $user.contact.first_name
                        $user | Add-Member -MemberType NoteProperty -Name lastname -Value $user.contact.last_name
                    }
                   
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "User"         
                    $ReturnData = $ReturnData | Sort-Object firstName, lastname, email
           

                    if ($ShowActivities) {

                        $SearchString = $ReturnData.contact.Email
                        $ReturnData = Get-HPEGLAuditLog -SearchString $SearchString -Limit 100
                        return $ReturnData 

                    }
                    else {
                        return $ReturnData 
                        
                    }

                }
    
            }
            else {

                return 
                
            }
        }
        
    }
}


Function Send-HPEGLUserInvitation {
    <#
    .SYNOPSIS
    Send an invitation email to join the HPE GreenLake workspace.

    .DESCRIPTION
    This cmdlet is used by workspace administrators to invite team members to join the currently connected HPE GreenLake workspace. 
    An email notification is sent to the specified user's address, and the user is added to the team members with the designated role.

    .PARAMETER Email
    Specifies the email address of the user to be invited.

    .PARAMETER Role
    Specifies the HPE GreenLake role to assign to the user.
    The predefined roles are:
        * Workspace Administrator
        * Workspace Observer
        * Workspace Operator
        * Orders Administrator
        * Orders Observer
        * Orders Operator

    .PARAMETER SenderEmail
    (Optional) Specifies the email address of the sender of this invitation. When not defined, the user email address used with Connect-HPEGL to create a session with the worksapce is used.

    .PARAMETER Resend
    Indicates that a new invitation should be sent to an existing user.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Send-HPEGLUserInvitation -Email leonhard.euler@mathematician.edu -Role 'Orders Operator' -SenderEmail bernhard.riemann@mathematician.edu

    Leonhard Euler is added to the team members as an Orders Operator, and an email notification is sent to the specified email address.
    Bernhard Riemann is recorded as the administrator who added Leonhard Euler to the group.

    .EXAMPLE
    Send-HPEGLUserInvitation -Email leonhard.euler@mathematician.com -Resend

    A new invitation is re-sent to Leonhard Euler.

    .EXAMPLE
    'leonhard.euler@mathematician.com','bernhard.riemann@mathematician.edu' | Send-HPEGLUserInvitation -Role 'Account Administrator'

    Leonhard Euler and Bernhard Riemann are added to the team members as Account Administrators, and email notifications are sent to them.

    .EXAMPLE
    Import-Csv emails.csv | Send-HPEGLUserInvitation -Role 'Workspace Observer'

    Sends an invitation to the email addresses listed in a CSV file containing at least the Email and Role columns.

    The content of the CSV file must use the following format:
        Email, Role
        leonhard.euler@mathematician.com, Workspace Administrator
        bernhard.riemann@mathematician.edu, Workspace Observer

    .INPUTS
    System.String, System.String[]
        A single string object or an array of string objects that represent the user's email addresses.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - The email address of the user.
        * Status - The status of the join group/email notification attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, ParameterSetName = 'Default')]
        [Parameter (Mandatory, ValueFromPipeline, ParameterSetName = 'Resend')]
        [ValidateNotNullOrEmpty()]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,  

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [ValidateSet('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$Role,

        [Parameter (ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$SenderEmail,  

        [Parameter (ParameterSetName = 'Resend')]
        [Switch]$Resend,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        if ($Resend) {
            # Resend an invite
            $Uri = $ReInviteUserUri 
        }
        else {
            $Uri = $InviteUserUri
        }
        
        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $UsernamesList = [System.Collections.ArrayList]::new()


        try {
            $AppRole = Get-HPEGLRole -HPEGreenLake
            $Users = Get-HPEGLUser

            $RoleSlug = $AppRole | Where-Object name -eq $Role | ForEach-Object slug

        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        

    }

    Process {                   
       
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        # Build object for the output
        $objStatus = [pscustomobject]@{
            
            Email     = $Email
            Status    = $Null
            Details   = $Null
            Exception = $Null
            
        }
        
        $User = $Users | Where-Object email -eq $Email


        if ($Resend) {

            if (-not $User) {
                # Must return a message if account not found
                "[{0}] User '{1}' account does not exist!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "User '{0}' cannot be found in the HPE GreenLake workspace to resend an invitation!" -f $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "User account cannot be found in the HPE GreenLake workspace to resend an invitation!"
                    
                }

            }
            elseif ($User.user_status -eq "VERIFIED") {
                # Must return a message if account is already verified
                "[{0}] User '{1}' account is already verified!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "User '{0}' is already verified!" -f $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "User is already verified!"
                    
                }

            }
            else {
             
                # Create payload  
                $Payload = [PSCustomObject]@{
                    usernames = @($Email)
            
                } | ConvertTo-Json      

                # Resend invitation      
                
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Post -Uri $Uri -Body $Payload -whatifBoolean $WhatIf

                    if (-not $WhatIf) {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Invitation resent!"
                    }

                    if ($Collection.message) {
                        $Collection.message | Write-Verbose
                    }
                }
                catch {
            
                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Invitation resending failure!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }
           
            }
        }
        else {

            if ($User) {
                # Must return a message if account found
                "[{0}] User '{1}' account has already been invited!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "User '{0}' has already been invited to the HPE GreenLake workspace!" -f $Email
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "User account has already been invited!"
                }
            }
            else {

                try {
                    $AppRole = Get-HPEGLRole -HPEGreenLake
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
            
                $RoleSlug = $AppRole | ? name -eq $Role | % slug
 

                # Create payload  
                $Payload = [PSCustomObject]@{
                    user_names          = @($Email)
                    contact_information = if ($SenderEmail) { $SenderEmail } else { $HPEGreenLakeSession.username }
                    roles               = @(
                        @{ role = @{
                                application_id = "00000000-0000-0000-0000-000000000000"
                                slug           = $RoleSlug 
                            }
                            
                        })
                } | ConvertTo-Json -Depth 5
                    
        
                # Send invitation      
                
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Post -Uri $Uri -Body $Payload -whatifBoolean $WhatIf
        
                    if (-not $WhatIf) {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Invitation sent!"
                    }
        
                    if ($Collection.message) {
                        $Collection.message | Write-Verbose
                    }
                }
                catch {
                    
                    if (-not $WhatIf) {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Invitation sending failure!"
                        $objStatus.Exception = $_.Exception.message 
                    }
                }
            }
        }     



        [void] $ObjectStatusList.add($objStatus)
    }

    end {

        # API DOES NOT SUPPORT LIST OF EMAILS IN PAYLOAD RIGHT NOW !

        # try {
        #     $Users = Get-HPEGLUser
           
        # }
        # catch {
        #     $PSCmdlet.ThrowTerminatingError($_)
            
        # }


        # "[{0}] List of users to send an invitation: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.Email | out-string) | Write-Verbose

        # foreach ($Object in $ObjectStatusList) {

        #     $User = $Users | Where-Object email -eq $Object.Email

        #     if ($Resend) {
                
        #         if (-not $User) {
                    
        #             # Must return a message if not found
        #             $Object.Status = "Failed"
        #             $Object.Details =  "User account cannot be found in the HPE GreenLake workspace to resend an invitation!"
                    
        #             if ($WhatIf) {
        #                 $ErrorMessage = "User '{0}' cannot be found in the HPE GreenLake workspace to resend an invitation!" -f $Object.Email
        #                 Write-warning $ErrorMessage
        #                 continue
        #             }
                    
        #         } 

        #     }
        #     else {

        #         if ( $User) {
                    
        #             # Must return a message if account found
        #             $Object.Status = "Warning"
        #             $Object.Details = "User account has already been invited!"
                    
        #             if ($WhatIf) {
        #                 $ErrorMessage = "User '{0}' has already been invited to the HPE GreenLake workspace!" -f $Object.Email
        #                 Write-warning $ErrorMessage
        #                 continue
        #             }
                    
        #         } 
        #     }

        #     # Building the list of email object where to send the invitation
        #     [void]$UsernamesList.Add($Object.Email)

        # }


        # if ($UsernamesList) {

        #     # Build payload
        #     $payload = ConvertTo-Json $UsernamesList
            
        #     if ($Resend) {
                
        #         # Create payload  
        #         $Payload = [PSCustomObject]@{
        #             usernames = $UsernamesList
            
        #         } | ConvertTo-Json  
                
        #     }
        #     else {
                
        #         # Create payload  
        #         $Payload = [PSCustomObject]@{
        #             user_names          = $UsernamesList
        #             contact_information = if ($SenderEmail) { $SenderEmail } else { $HPEGreenLakeSession.username }
        #             roles               = @(
        #                 @{ role = @{
        #                         application_id = "00000000-0000-0000-0000-000000000000"
        #                         slug           = $RoleSlug 
        #                     }
                            
        #                 })
        #         } | ConvertTo-Json -Depth 5

        #     }
            
            
        #     # Send invitation      
        #     try {

        #         Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
        #         if (-not $WhatIf) {
                    
        #             foreach ($Object in $ObjectStatusList) {

        #                 $Username = $UsernamesList | Where-Object {$_ -eq $Object.email}

        #                 If ($Username) {

        #                     if ($Resend) {

        #                         $Object.Status = "Complete"
        #                         $Object.Details = "Invitation resent successfully!"

        #                     }
        #                     else {
        #                         $Object.Status = "Complete"
        #                         $Object.Details = "Invitation sent successfully!"
        #                     }
        #                 }
        #             }
        #         }
        #     }
        #     catch {
                
        #         if (-not $WhatIf) {

        #             foreach ($Object in $ObjectStatusList) {

        #                 $Username = $UsernamesList | Where-Object {$_ -eq $Object.email}
                        
        #                 If ($Username) {

        #                     if ($Resend) {

        #                         $Object.Status = "Failed"
        #                         $Object.Details =  "Invitation resending failure!"
        #                         $Object.Exception = $_.Exception.message 
                                

        #                     }
        #                     else {
                                  
        #                         $Object.Status = "Failed"
        #                         $Object.Details =  "Invitation sending failure!"
        #                         $Object.Exception = $_.Exception.message 
        #                     }
        #                 }
        #             }
        #         }
        #     }
        # }
                            

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to send an invitation!"
          
            }

            Return $ObjectStatusList
        }
    }
}


Function Remove-HPEGLUser {
    <#
    .SYNOPSIS
    Delete a user from the HPE GreenLake workspace.

    .DESCRIPTION
    This cmdlet can be used by account administrators to delete a user account from the currently connected HPE GreenLake workspace.

    .PARAMETER Email
    Specifies the email address of the user to delete.

    .PARAMETER WhatIf
    Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLUser -Email johanncarlfriedrich.gauss@mathematician.edu

    Deletes the user Johann Carl Friedrich Gauss.

    .EXAMPLE
    'leonhard.euler@mathematician.com','bernhard.riemann@mathematician.edu' | Remove-HPEGLUser

    Deletes Leonhard Euler and Bernhard Riemann from the currently connected HPE GreenLake workspace.

    .EXAMPLE
    Import-Csv emails.csv | Remove-HPEGLUser 

    Deletes the users whose email addresses are listed in a CSV file containing at least an Email column.

    The content of the CSV file must use the following format:
        Email
        leonhard.euler@mathematician.com
        bernhard.riemann@mathematician.edu

    .EXAMPLE
    Get-HPEGLUser | Remove-HPEGLUser 
    
    Deletes all users from the HPE GrenLake workspace.

    .INPUTS
    System.Collections.ArrayList
        List of user(s) from 'Get-HPEGLUser'.
    System.String, System.String[]
        A single string object or an array of string objects representing the user's email addresses.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - The email address of the user.
        * Status - The status of the removal attempt (Failed for HTTP error return; Complete if successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,  

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
       
        $Uri = $UsersUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $UsernamesList = [System.Collections.ArrayList]::new()
        
    }

    Process {   

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email     = $Email
            Status    = $Null
            Details   = $Null
            Exception = $Null
              
        }
        
        [void] $ObjectStatusList.add($objStatus)

    }
    end {
        
        try {

            $Users = Get-HPEGLUser
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        "[{0}] List of users to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.Email | out-string) | Write-Verbose
        

        foreach ($Object in $ObjectStatusList) {

            $User = $Users | Where-Object email -eq $Object.Email

            if ($Resend) {
                
                if (-not $User) {
                    
                    # Must return a message if not found
                    $Object.Status = "Failed"
                    $Object.Details = "User account cannot be found in the HPE GreenLake workspace!"
                    
                    if ($WhatIf) {
                        $ErrorMessage = "User '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.Email
                        Write-warning $ErrorMessage
                        continue
                    }
                    
                } 

            }

            # Building the list of email object where to send the invitation
            [void]$UsernamesList.Add($Object.Email)

        }


        if ($UsernamesList) {

            # Build payload
            $Payload = [PSCustomObject]@{
                usernames = $UsernamesList
                
            } | ConvertTo-Json     
                       
            
            # Send invitation      
            try {

                Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
                
                if (-not $WhatIf) {
                    
                    foreach ($Object in $ObjectStatusList) {

                        $Username = $UsernamesList | Where-Object { $_ -eq $Object.email }

                        If ($Username) {

                            $Object.Status = "Complete"
                            $Object.Details = "User account successfully removed!"
                        }
                    }
                }
            }
            catch {
                
                if (-not $WhatIf) {

                    foreach ($Object in $ObjectStatusList) {

                        $Username = $UsernamesList | Where-Object { $_ -eq $Object.email }
                        
                        If ($Username) {

                            $Object.Status = "Failed"
                            $Object.Details = "User account removal failure!"
                            $Object.Exception = $_.Exception.message 
                            
                        }
                    }
                }
            }
        }


        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more user accounts has failed!"

          
            }

            Return $ObjectStatusList
        }


    }
}


Function Get-HPEGLRole {
    <#
    .SYNOPSIS
    View service roles.

    .DESCRIPTION
    This Cmdlet returns the service roles. Roles are groups of permissions that grant access to users.

    .PARAMETER ServiceName 
    Name of the service retrieved using 'Get-HPEGLService'.   
    
    .PARAMETER ArubaCentral 
    Optional parameter to display the roles of the Aruba Central service.

    .PARAMETER ComputeOpsManagement 
    Optional parameter to display the roles of the Compute Ops Management service.

    .PARAMETER DataServices 
    Optional parameter to display a specific role of the Data Services service.

    .PARAMETER HPEGreenLake 
    Optional parameter to display the roles of the HPE GreenLake service.

    .PARAMETER ArubaCentralRole 
    Optional parameter to display a specific role of the Aruba Central service.
    The predefined roles are as follows:
        * Aruba Central Administrator  
        * Aruba Central Guest Operator
        * Aruba Central Operator
        * Aruba Central view edit role
        * Aruba Central View Only
        * Netlnsight Campus Admin
        * Netlnsight Campus Viewonly

    .PARAMETER ComputeOpsManagementRole 
    Optional parameter to display a specific role of the Compute Ops Management service.
    The predefined roles are as follows:
        * Administrator
        * Observer
        * Operator

    .PARAMETER DataServicesRole 
    Optional parameter to display a specific role of the Data Services service.
    The predefined roles are as follows:
        * Administrator
        * Backup and Recovery Administrator
        * Backup and Recovery Operator
        * Data Ops Manager Administrator
        * Data Ops Manager Operator
        * Disaster Recovery Admin
        * Read only

    .PARAMETER HPEGreenLakeRole 
    Optional parameter to display a specific role of the HPE GreenLake service.
    The predefined roles are as follows:
        * Workspace Administrator
        * Workspace Observer
        * Workspace Operator
        * Orders Administrator
        * Orders Observer
        * Orders Operator

    .PARAMETER ShowAssignedUsers 
    The AssignedUsers directive returns the users assigned to the role name.

    .PARAMETER ShowPermissions
    The ShowPermissions directive returns the permissions of a role name.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLRole 

    Return the service roles in an HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLRole -ArubaCentral 

    Return the roles for the Aruba Central service instances in your HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLRole -ServiceName "Data Services" 

    Return the roles for the Data Services service instances in your HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLRole -ServiceName "Data Services" -ServiceRole "Disaster Recovery Admin"
    
    Return the "Disaster Recovery Admin" role information for the Data Services service.

    .EXAMPLE
    Get-HPEGLRole -ComputeOpsManagementRole Administrator 

    Return the Administrator role information for the Compute Ops Management service.
           
    .EXAMPLE
    Get-HPEGLRole -ComputeOpsManagementRole Administrator -ShowAssignedUsers 

    Return the users assigned to the Administrator role of the Compute Ops Management service.

    .EXAMPLE
    Get-HPEGLRole -DataServicesRole 'Backup and Recovery Administrator' -ShowPermissions

    Return the list of permissions for the 'Backup and Recovery Administrator' role of the Data Services service.

    .EXAMPLE
    Get-HPEGLRole -ServiceName "Compute Ops Management" -ServiceRole Administrator -ShowPermissions

    Return the list of permissions for the Administrator role of the Compute Ops Management service.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ComputeOpsManagement')]
    Param(        
        [Parameter (Mandatory, ParameterSetName = 'ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ApplicationName')]
        [String]$ServiceName,
    
        [Parameter (ParameterSetName = 'ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ApplicationName')]
        [String]$ServiceRole,

        [Parameter (ParameterSetName = 'ArubaCentral')]
        [Switch]$ArubaCentral,

        [Parameter (ParameterSetName = 'ArubaCentralRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ArubaCentral')]
        [ValidateSet ('Aruba Central Administrator', 'Aruba Central Guest Operator', 'Aruba Central Operator', 'Aruba Central view edit role', 'Aruba Central View Only', 'Netlnsight Campus Admin', 'Netlnsight Campus Viewonly')]
        [String]$ArubaCentralRole,

        [Parameter (ParameterSetName = 'ComputeOpsManagement')]
        [Switch]$ComputeOpsManagement,

        [Parameter (ParameterSetName = 'ComputeOpsManagementRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ComputeOpsManagement')]
        [ValidateSet ('Administrator', 'Observer', 'Operator')]
        [String]$ComputeOpsManagementRole,

        [Parameter (ParameterSetName = 'DataServices')]
        [Switch]$DataServices,

        [Parameter (ParameterSetName = 'DataServicesRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-DataServicesCloudConsole')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-DataServicesCloudConsole')]
        [ValidateSet ('Administrator', 'Backup and Recovery Administrator', 'Backup and Recovery Operator', 'Data Ops Manager Administrator', 'Data Ops Manager Operator', 'Disaster Recovery Admin', 'Read only')]
        [String]$DataServicesRole,

        [Parameter (ParameterSetName = 'HPEGreenLake')]
        [Switch]$HPEGreenLake,

        [Parameter (ParameterSetName = 'HPEGreenLakeRole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-HPEGreenLake')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-HPEGreenLake')]
        [ValidateSet ('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$HPEGreenLakeRole,

        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-DataServicesCloudConsole')]
        [Parameter (Mandatory, ParameterSetName = 'AssignedUsers-HPEGreenLake')]
        [Switch]$ShowAssignedUsers,

        [Parameter (Mandatory, ParameterSetName = 'Permissions-ApplicationName')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-DataServicesCloudConsole')]
        [Parameter (Mandatory, ParameterSetName = 'Permissions-HPEGreenLake')]
        [Switch]$ShowPermissions,

        [Switch]$WhatIf


 
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        # $Uri = $UsersRolesUri + $HPEGreenLakeSession.workspaceId + "/roles"
        # $Uri = $UsersRolesUri 

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        if ($ShowPermissions) {
            
            if ($ServiceName) {

                try {
                    $Service = Get-HPEGLService -Name $ServiceName | sort-object application_id -Unique 
                
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
    
                if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                    "[{0}] Service'{1}' not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
                    Return
                }
                else {

                    $Uri = $UsersRolesUri 

                    $ReturnData = @()
                    $PermissionsList = @()

        
                    try {
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($Null -ne $Collection.roles) {

                        $CollectionList = $Collection.roles | Where-Object application_name -eq $ServiceName       
                    
                        if ($ServiceRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ServiceRole
                        }

                        "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose


                        # If role name not found, then return
                        if (-Not $CollectionList) {
                            Return
                        }

                        $Slug = $CollectionList.slug 
                        $ServiceID = $CollectionList.application_id

                        "[{0}] Permission + ServiceName -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceID, $ServiceRole | Write-Verbose

    
                        # GET /ui-doorway/ui/v2/um/customers/roles/ccs.observer?application_id=00000000-0000-0000-0000-000000000000
                        $Uri = $UsersRolesUri + "/" + $Slug + "?application_id=" + $ServiceID

                        try {
                            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        if ($Null -ne $Collection.resource_policies) {

                            foreach ($ResourcePolicy in $Collection.resource_policies) {

                                if ($ResourcePolicy.resource.Name) {
                                    $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.name } }, @{N = "Permissions"; E = { $_.permissions.name } }
                                }
                                else {
                                    $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.matcher } }, @{N = "Permissions"; E = { $_.permissions.slug } }
                                }
                                $PermissionsList += $ReturnData 
                            }

                            $PermissionsList = $PermissionsList | Sort-Object application, rolename, resource
                            return $PermissionsList
                           
                        }

    
                                    
                    }
                    else {
                        return   
                    }

                } 

            }
        
            else {

                $Uri = $UsersRolesUri 

                $ReturnData = @()
                $PermissionsList = @()
        
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                   
                if ($Null -ne $Collection.roles) {

                    if ($ComputeOpsManagementRole) {
                        $ServiceName = "Compute Ops Management"
                    }
                    elseif ($DataServicesRole) { 
                        $ServiceName = "Data Services" 
                    }
                    elseif ($ArubaCentralRole) { 
                        $ServiceName = "Aruba Central" 
                    }
                    elseif ($HPEGreenLakeRole) { 
                        $ServiceName = "HPE GreenLake platform"
                    }

                        
                    $CollectionList = $Collection.roles | Where-Object application_name -eq $ServiceName

                    "[{0}] Roles for the service: '{1}': '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, ($CollectionList | Out-String) | Write-Verbose

                    if ($ArubaCentralRole) {
                        
                        $CollectionList = $CollectionList | Where-Object name -eq $ArubaCentralRole
                        $ServiceRole = $ArubaCentralRole
                    }
                    if ($ComputeOpsManagementRole) {
                        
                        $CollectionList = $CollectionList | Where-Object name -eq $ComputeOpsManagementRole
                        $ServiceRole = $ComputeOpsManagementRole

                    } 
                        
                    if ($DataServicesRole) {
                        
                        $CollectionList = $CollectionList | Where-Object name -eq $DataServicesRole
                        $ServiceRole = $DataServicesRole

                    }
                    if ($HPEGreenLakeRole) {
    
                        $CollectionList = $CollectionList | Where-Object name -eq $HPEGreenLakeRole
                        $ServiceRole = $HPEGreenLakeRole

                    }
                            
                    "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose

                    
                    # If role name not found, then return
                    if (-Not $CollectionList) {
                        Return
                    }

                    $Slug = $CollectionList.slug 
                    $ServiceID = $CollectionList.application_id 

                    "[{0}] Permission + Predefined Role -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceID, $ServiceRole | Write-Verbose

    
                    # GET /ui-doorway/ui/v1/um/customers/roles/ccs.observer?application_id=00000000-0000-0000-0000-000000000000
                    $Uri = $UsersRolesUri + "/" + $Slug + "?application_id=" + $ServiceID

                    try {
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($Null -ne $Collection.resource_policies) {

                        foreach ($ResourcePolicy in $Collection.resource_policies) {

                            if ($ResourcePolicy.resource.Name) {
                                $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.name } }, @{N = "Permissions"; E = { $_.permissions.name } }
                            }
                            else {
                                $ReturnData = $ResourcePolicy | Select-Object  @{N = "Application"; E = { $ServiceName } }, @{N = "Rolename"; E = { $ServiceRole } }, @{N = "Resource"; E = { $_.resource.matcher } }, @{N = "Permissions"; E = { $_.permissions.slug } }
                            }
                            $PermissionsList += $ReturnData 
                        }

                        $PermissionsList = $PermissionsList | Sort-Object application, rolename, resource
                        return $PermissionsList
                           
                    }

    
                                    
                }
                else {
                    return   
                }
            }

        }
        else {

            $Uri = $UsersRolesUri 

            if ($ServiceName) {
            
                try {
                    $Service = Get-HPEGLService -Name $ServiceName 
                
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }
    
                if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                    "[{0}] Service '{1}' not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
                    Return
                }
                else {
                
                    $ReturnData = @()
        
                    try {
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($Null -ne $Collection.roles) {

                        $CollectionList = $Collection.roles | Where-Object application_name -eq $ServiceName   
                        
                                            
                        if ($ServiceRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ServiceRole
   
                            "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose

                        }
                                  
                        if ($ShowAssignedUsers) {

                            $ServiceID = $CollectionList.application_id
                            $Slug = $CollectionList.slug
    
                            $Uri = $AuthzRolesUri + $HPEGreenLakeSession.workspaceId + "/applications/" + $ServiceID + "/roles/" + $Slug + "/user_assignments"
    
                            try {
                                [array]$UserCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }

                            "[{0}] AssignedUsers to roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose


                            if ($Null -ne $UserCollection.users) {
            
                                $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserCollection.users -ObjectName "User.Role.Assigned.Users"    
                                $ReturnData = $UserCollection.users | Sort-Object { $_.email }

                                return $ReturnData 

                                        
                            }
                            else {
                                return   
                            }
                        }

            
                        $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Role"    

                        $ReturnData = $ReturnData | Sort-Object { $_.application_name, $_.name }

                        return $ReturnData 
                    }
                    else {

                        return
            
                    }
        
                }           
            }
            else {

                $ReturnData = @()
        
                try {
                    [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
        
   
                if ($Null -ne $Collection.roles) {

                    $CollectionList = $Collection.roles 

                    if ($ComputeOpsManagement) {
                        $ServiceName = "Compute Ops Management"
                    }
                    elseif ($DataServices) { 
                        $ServiceName = "Data Services" 
                    }
                    elseif ($ArubaCentral) { 
                        $ServiceName = "Aruba Central" 
                    }
                    elseif ($HPEGreenLake) { 
                        # $Service = "Common Cloud Service" 
                        $ServiceName = "HPE GreenLake platform"

                    }


                    if ($ComputeOpsManagementRole) {
                        $ServiceName = "Compute Ops Management"
                        $ServiceRole = $ComputeOpsManagementRole

                    }
                    elseif ($DataServicesRole) { 
                        $ServiceName = "Data Services" 
                        $ServiceRole = $DataServicesRole

                    }
                    elseif ($ArubaCentralRole) { 
                        $ServiceName = "Aruba Central" 
                        $ServiceRole = $ArubaCentralRole

                    }
                    elseif ($HPEGreenLakeRole) { 
                        $ServiceName = "HPE GreenLake platform"
                        $ServiceRole = $HPEGreenLakeRole

                    }


                    if ($ServiceName) {

                        $CollectionList = $CollectionList | Where-Object application_name -eq $ServiceName

                        if ($ArubaCentralRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ArubaCentralRole
                        }
                        if ($ComputeOpsManagementRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $ComputeOpsManagementRole
                        } 
                    
                        if ($DataServicesRole) {
                    
                            $CollectionList = $CollectionList | Where-Object name -eq $DataServicesRole
                        }
                        if ($HPEGreenLakeRole) {

                            $CollectionList = $CollectionList | Where-Object name -eq $HPEGreenLakeRole
                        }

                        "[{0}] Roles for the service: '{1}' filtered to '{2}': '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceRole, ($CollectionList | Out-String) | Write-Verbose

                        
                    }
                     
                    if ($ShowAssignedUsers) {

                        $ServiceID = $CollectionList.application_id
                        $Slug = $CollectionList.slug
    
                        $Uri = $AuthzRolesUri + $HPEGreenLakeSession.workspaceId + "/applications/" + $ServiceID + "/roles/" + $Slug + "/user_assignments"
    
                        try {
                            [array]$UserCollection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        "[{0}] AssignedUsers + Predefined Role -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $ServiceID, $ServiceRole | Write-Verbose


                        if ($Null -ne $UserCollection.users) {
            
                            $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserCollection.users -ObjectName "User.Role.Assigned.Users"    
                            $ReturnData = $UserCollection.users | Sort-Object { $_.email }

                            return $ReturnData 

                                        
                        }
                        else {
                            return   
                        }
                    }

            
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Role"    

                    $ReturnData = $ReturnData | Sort-Object { $_.application_name, $_.name }

                    return $ReturnData 
                }
                else {

                    return
            
                }
            }
        }
    }
}


Function Get-HPEGLUserRole {
    <#
    .SYNOPSIS
        View user roles in an HPE GreenLake workspace.

    .DESCRIPTION
        This Cmdlet lists the users' roles and permissions in an HPE GreenLake workspace. Roles are groups of permissions that grant access to users.

    .PARAMETER Email 
        The email address of the user for whom you want to obtain roles and permissions (can be retrieved using 'Get-HPEGLUser').

    .PARAMETER ServiceName 
        An optional parameter to display user roles and permissions for a specified service name (can be retrieved using 'Get-HPEGLService').
        
    .PARAMETER ShowPermissions 
        A switch to display the specific permissions assigned to a user.
    
    .PARAMETER WhatIf 
        Displays the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com 

        Returns the user's roles for all services for which the user has privileges.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ShowPermissions

        Returns the user's permissions for all services for which the user has privileges.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ServiceName 'Compute Ops Management' 

        Returns the user's roles for the Compute Ops Management service.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ServiceName 'Data Services' -ShowPermissions

        Returns the user's permissions for the Data Services service.

    .EXAMPLE
        Get-HPEGLUserRole -Email Isaac.Newton@revolution.com -ServiceName "Aruba Central"

        Returns the user's roles for the Aruba Central service.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Application')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'Application')]
        [Parameter (Mandatory, ParameterSetName = 'ApplicationInstance')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,
       
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "ApplicationInstance")]
        [ValidateNotNullOrEmpty()]
        [Alias('name')]
        [String]$ServiceName,

        [Parameter (ParameterSetName = 'Application')]
        [Parameter (ParameterSetName = 'ApplicationInstance')]
        [Switch]$ShowPermissions,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AuthzUsersRolesAssignmentsUri + $HPEGreenLakeSession.workspaceId + "/users/" + $Email.ToLower() + "/role_assignments"

    }

    Process {
       
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $User = Get-HPEGLUser -Email $Email
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        if (-not $user) {
            Return
        }

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
     
        
        if ($Null -ne $Collection.roles) {
            
            $PermissionsList = @()
            
            if ($ServiceName) {
                
                try {
                    
                    $App = Get-HPEGLService -Name $ServiceName | sort-object application_id -Unique 
                    
                    "[{0}] Service '{1}' found: `n{2}!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName, $App | Write-Verbose

                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                                    
                if (-not $App -and $ServiceName -ne "HPE GreenLake platform") {
                    "[{0}] Service '{1}' not found in the HPE GreenLake workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
                    Throw "Error! Service name not found!"
                }

                if ($ServiceName -eq "HPE GreenLake platform") {

                    $ServiceID = "00000000-0000-0000-0000-000000000000"

                }
                else {
                    $ServiceID = $App.application_id

                }

                $UserRoles = $Collection.roles | Where-Object application_id -eq $ServiceID

                
            }
            else {
                $userRoles = $Collection.roles

            } 
            

            foreach ($UserRole in $UserRoles) {

                $UserFirstName = $Collection | ForEach-Object user_first_name
                $UserLastName = $Collection | ForEach-Object user_last_name
                $UserType = $Collection | ForEach-Object user_type

                $RoleName = $UserRole | ForEach-Object role_name
                $AppName = $UserRole | ForEach-Object application_name

                $AppID = $UserRole | ForEach-Object application_id
             
                $Slug = $UserRole | ForEach-Object slug
                    
                
                if ($ShowPermissions) {

                    "[{0}] Permission -- Service Name: '{1}': Service ID: '{2}' - Role Name: '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $AppName, $AppID, $RoleName | Write-Verbose
                   
                    try {
              
                        $ResourcePolicies = Get-HPEGLRole -ServiceName $AppName -ServiceRole $RoleName -ShowPermissions
              
                        $PermissionsList += $ResourcePolicies 

                        "[{0}] Resource Policies: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ResourcePolicies | Out-String) | Write-Verbose
                                          
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                }
                else {

                    if ($UserRole.resource_restriction_policies) {
                            
                        "[{0}] Resource Restriction policies found!" -f $MyInvocation.InvocationName.ToString().ToUpper() | write-Verbose
                                                       
                        if ($UserRole.resource_restriction_policies.name -eq "Allscopes") {
                            $RRPName = "Full Access"

                        }
                        elseif (-not $UserRole.resource_restriction_policies.name ) {
                            $RRPName = "None"

                        }
                        else {
                            $RRPName = $UserRole.resource_restriction_policies.name 

                        }

                        $RRPDescription = $UserRole.resource_restriction_policies.description 
                        $ResourceRestrictionPolicyId = $UserRole.resource_restriction_policies.resource_restriction_policy_id
                          

                        $ReturnData = $UserRole | Select-Object `
                        @{N = "email"; E = { $Email } }, `
                        @{N = "user_first_name"; E = { $UserFirstName } }, `
                        @{N = "user_last_name"; E = { $UserLastName } }, `
                        @{N = "user_type"; E = { $UserType } }, `
                        @{N = "application_name"; E = { $AppName } }, `
                        @{N = "application_id"; E = { $AppID } }, `
                        @{N = "resource_restriction_policy_description"; E = { $RRPDescription } }, `
                        @{N = "resource_restriction_policy_id"; E = { $ResourceRestrictionPolicyId } }, `
                        @{N = "role"; E = { $Rolename } }, `
                        @{N = "resource_restriction_policy"; E = { $RRPName } }, `
                        @{N = "slug"; E = { $Slug } }

                        $PermissionsList += $ReturnData 
                            
                    }
                    else {

                        $RRPName = "None"
              
                        $ReturnData = $UserRole | Select-Object `
                        @{N = "email"; E = { $Email } }, `
                        @{N = "user_first_name"; E = { $UserFirstName } }, `
                        @{N = "user_last_name"; E = { $UserLastName } }, `
                        @{N = "user_type"; E = { $UserType } }, `
                        @{N = "application_name"; E = { $AppName } }, `
                        @{N = "application_id"; E = { $AppID } }, `
                        @{N = "resource_restriction_policy_description"; E = { $Null } }, `
                        @{N = "resource_restriction_policy_id"; E = { $Null } }, `
                        @{N = "role"; E = { $Rolename } }, `
                        @{N = "resource_restriction_policy"; E = { $RRPName } }, `
                        @{N = "slug"; E = { $Slug } }

                        $PermissionsList += $ReturnData 

                    }
                }
            }

            if (-not $ShowPermissions) {
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $PermissionsList -ObjectName "User.Role"         
                $ReturnData = $ReturnData | sort-object application_name, role

            }
            else {
                
                $ReturnData = $PermissionsList

            }
            

            return $ReturnData
           
        }

        else {
            return
        }
    }
}


Function Add-HPEGLUserRole {
    <#
    .SYNOPSIS
    Add user roles in an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet adds roles and permissions to a user in an HPE GreenLake workspace. Roles are groups of permissions that grant users access to the HPE GreenLake services.

    Roles are assigned to a service in all regions. If you need to further limit the scope of resources a user role can access, you can use the resource restriction policy feature using 'Set-HPEGLResourceRestrictionPolicy'.

    .PARAMETER Email 
    Email address of the user for whom you want to set roles and permissions (can be retrieved using 'Get-HPEGLUser').

    .PARAMETER ArubaCentralRole 
    Name of the Aruba Central role to add to the user's roles. 
    The predefined roles are as follows:
    - Aruba Central Administrator  
    - Aruba Central Guest Operator
    - Aruba Central Operator
    - Aruba Central View Edit Role
    - Aruba Central View Only
    - Netlnsight Campus Admin
    - Netlnsight Campus Viewonly

    .PARAMETER ComputeOpsManagementRole 
    Name of the Compute Ops Management role to add to the user's roles. 
    The predefined roles are as follows:
    - Administrator
    - Observer
    - Operator

    .PARAMETER DataServicesRole 
    Name of the Data Services role to add to the user's roles. 
    The predefined roles are as follows:
    - Administrator
    - Backup and Recovery Administrator
    - Backup and Recovery Operator
    - Data Ops Manager Administrator
    - Data Ops Manager Operator
    - Disaster Recovery Admin
    - Read Only

    .PARAMETER HPEGreenLakeRole 
    Name of the HPE GreenLake role to add to the user's roles. 
    The predefined roles are as follows:
    - Workspace Administrator
    - Workspace Observer
    - Workspace Operator
    - Orders Administrator
    - Orders Observer
    - Orders Operator

    .PARAMETER ServiceName 
    Name of the service to which the role name will be assigned (can be retrieved using 'Get-HPEGLRole').   
        
    .PARAMETER RoleName 
    Name of the role of a service to be assigned to the user (can be retrieved using 'Get-HPEGLRole').   

    .PARAMETER ResourceRestrictionPolicyName 
    Specifies the name of a resource restriction policy to further limit the scope of resources accessible by the user (can be retrieved using 'Get-HPEGLResourceRestrictionPolicy').

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Add-HPEGLUserRole -Email richardfeynman@quantummechanics.lab -ComputeOpsManagementRole Observer 

    Adds the Observer role to richardfeynman@quantummechanics.lab for the "Compute Ops Management" service.

    .EXAMPLE
    Add-HPEGLUserRole -Email richardfeynman@quantummechanics.lab -ServiceName "Data Services" -RoleName "Backup and Recovery Administrator"

    Adds the Backup and Recovery Administrator role to richardfeynman@quantummechanics.lab for the "Data Services" service.

    .EXAMPLE
    Get-HPEGLRole -ComputeOpsManagementRole Administrator | Add-HPEGLUserRole -Email richardfeynman@quantummechanics.lab

    Adds the Administrator role to richardfeynman@quantummechanics.lab for the "Compute Ops Management" service.

    .EXAMPLE
    Add-HPEGLUserRole -Email alexandreliapounov@math.edu -ComputeOpsManagementRole 'Administrator' -ResourceRestrictionPolicyName 'RRP_COM-Location-Texas'

    Adds the Administrator role to alexandreliapounov@math.edu for the "Compute Ops Management" service, limiting the scope of accessible resources to the Texas location using the resource restriction policy named 'RRP_COM-Location-Texas'.
      
    .INPUTS
    System.Collections.ArrayList
        List of roles from 'Get-HPEGLRole'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        - Email: Email of the user 
        - Role: Name of the role to add 
        - Service: Name of the service 
        - ResourceRestrictionPolicyName: Name of the resource restriction policy to assign
        - Status: Status of the role assignment attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed) 
        - Details: More information about the status 
        - Exception: Information about any exceptions generated during the operation.
    #>


    [CmdletBinding(DefaultParameterSetName = 'ComputeOpsManagement')]
    Param( 

        [Parameter (Mandatory, ParameterSetName = 'ArubaCentral')]
        [Parameter (Mandatory, ParameterSetName = 'HPEGreenLake')]
        [Parameter (Mandatory, ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (Mandatory, ParameterSetName = 'DataServices')]
        [Parameter (Mandatory, ParameterSetName = 'Other')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,
       
        [Parameter (Mandatory, ParameterSetName = 'ArubaCentral')]
        [ValidateSet ('Aruba Central Administrator', 'Aruba Central Guest Operator', 'Aruba Central Operator', 'Aruba Central view edit role', 'Aruba Central View Only', 'Netlnsight Campus Admin', 'Netlnsight Campus Viewonly')]
        [String]$ArubaCentralRole,

        [Parameter (Mandatory, ParameterSetName = 'HPEGreenLake')]
        [ValidateSet ('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$HPEGreenLakeRole,

        [Parameter (Mandatory, ParameterSetName = 'ComputeOpsManagement')]
        [ValidateSet ('Administrator', 'Observer', 'Operator')]
        [String]$ComputeOpsManagementRole,

        [Parameter (Mandatory, ParameterSetName = 'DataServices')]
        [ValidateSet ('Administrator', 'Backup and Recovery Administrator', 'Backup and Recovery Operator', 'Data Ops Manager Administrator', 'Data Ops Manager Operator', 'Disaster Recovery Admin', 'Read only')]
        [String]$DataServicesRole,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [Alias('application_name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [Alias('name')]
        [String]$RoleName,

        [Parameter (ParameterSetName = 'ArubaCentral')]
        [Parameter (ParameterSetName = 'HPEGreenLake')]
        [Parameter (ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (ParameterSetName = 'DataServices')]
        [Parameter (ParameterSetName = 'Other')]
        [String]$ResourceRestrictionPolicyName,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $AuthzUsersRolesUri + $Email.ToLower() + "/roles"

        $UserRoleAssignmentStatus = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Test if user present
        try {
            $User = (Get-HPEGLUser).contact | Where-Object email -eq $Email
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email                         = $Email
            Role                          = $Null
            Service                       = $Null
            ResourceRestrictionPolicyName = $Null
            Status                        = $Null
            Details                       = $Null
            Exception                     = $Null
                  
        }
        
        if (-not $User) {
            # Must return a message if user not found
            "[{0}] User '{1}' not found." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

            if ($Whatif) {
                $ErrorMessage = "User '{0}' cannot be found in HPE GreenLake!" -f $Email
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "User cannot be found in the HPE GreenLake workspace!"
                $objStatus.Service = $ServiceName
                    
            }

            
        }
        
        ############## If RoleName / ServiceName ##############
        elseif ($RoleName) {

            $objStatus.Role = $RoleName
            $objStatus.Service = $ServiceName

            try {
                $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique

                $ServiceID = $Service.application_id
                
            }
            catch {    
                $PSCmdlet.ThrowTerminatingError($_)

            }

            # If ServiceName not found except if GreenLake service
            if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                # Must return a message if Service is not provisioned in the region
                "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
    
                if ($Whatif) {
                    $ErrorMessage = "Service '{0}' is not provisioned in any region!" -f $ServiceName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service not provisioned in any region!"
                    $objStatus.Service = $ServiceName
                               
                }

    
            }

            # If ServiceName 
            else {

                # Role already assigned?                       
                try {

                    $AppRoles = Get-HPEGLRole -ServiceName $ServiceName 
                    $AppRole = $AppRoles | Where-Object name -eq $RoleName
                    $Slug = $AppRole.slug
                              
                    "[{0}] role '{1}' found for '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolename, $ServiceName | Write-Verbose
                    "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose

                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                # If service role found
                if ( $AppRole) {
                    
                    try {

                        $ExistingUserRoles = Get-HPEGLUserRole -Email $email

                        $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName

                        $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName

                        # Check if RRP name already assigned to the role
                        $RRPAlreadyAssigned = $Rolefound.resource_restriction_policy


                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }


                    # Role found without RRP parameter = ERROR
                    if ($Rolefound -and -not $ResourceRestrictionPolicyName) {

                        # Must return a message if Rolename is already assigned
                        "[{0}] Role name '{1}' is already assigned to this user!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName | Write-Verbose
    
                        if ($Whatif) {
                            $ErrorMessage = "Service role '{0}' is already assigned to this user!" -f $RoleName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Warning"
                            $objStatus.Details = "Service role name is already assigned to this user!"
                            
                        }                      

                    }

                    
                    # Role found with RRP parameter = MODIFICATION
                    elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                        $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                        try {
                            $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
        
                        }
                        catch {    
                            $PSCmdlet.ThrowTerminatingError($_)

                        }


                        # Check if RRP is available
                        try {
                            $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                        }
                        catch {
                            $PSCmdlet.ThrowTerminatingError($_)
                        }

                        if ($RRP) {
                   
                            $ResourceRestrictionPolicyIDToSet = $RRP.resource_restriction_policy_id

                            # If RRP name not already assigned to the role: Overwrite needed !
                            if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                                $RolesList = [System.Collections.ArrayList]::new()
                
                                foreach ($ExistingUserRole in $ExistingUserRoles) {
                 
                                    $Slug = $ExistingUserRole.slug
                                    $ServiceID = $ExistingUserRole.application_id
                 
                                    # If ExistingUserRole is not the one we want to modify with new RRP, we capture existing RRP
                                    if ($ExistingUserRole.resource_restriction_policy) {

                                        $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                                        # If ExistingUserRole is the one we want to modify with new RRP
                                        if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                        
                                            $ResourceRestrictionPolicyID = $ResourceRestrictionPolicyIDToSet
                      
                                        }
                        
                                        $Role = [PSCustomObject]@{
                                            role                          = @{  
                                                slug           = $Slug
                                                application_id = $ServiceID
                                            }
                                            resource_restriction_policies = @(
                                                $ResourceRestrictionPolicyID
                                            )
                                        }

                                    }
                                    else {                                
                  
                                        $Role = [PSCustomObject]@{
                                            role                          = @{  
                                                slug           = $Slug
                                                application_id = $ServiceID
                                            }
                                            resource_restriction_policies = @( )
                                        }
                                    }

                                    $RolesList += $Role

                                }
                

                                # Build payload
                                $Payload = [PSCustomObject]@{ overwrite = @( 
                                        $RolesList
                                    )
                                } | ConvertTo-Json -Depth 5
                

                                # Set user role with RRP      
                                try {
                                    Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                                    if (-not $WhatIf) {

                                        "[{0}] Role '{1}' with resource restriction policy '{2}' successfully set for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                                        $objStatus.Status = "Complete"
                                        $objStatus.Details = "Resource restriction policy successfully set!"
                                        $objStatus.Service = $ServiceName

                                    }

                                }
                                catch {
                                    if (-not $WhatIf) {
                                        $objStatus.Status = "Failed"
                                        $objStatus.Details = "Resource restriction policy cannot be set!"
                                        $objStatus.Exception = $_.Exception.message 
                                        $objStatus.Service = $ServiceName
                                    }
                                }

                            }
                            # If RRP name already assigned to the role
                            else {
                                # Must return a message if RRP name is already assigned to the role
                                "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                if ($Whatif) {
                                    $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                    Write-warning $ErrorMessage
                                    return
                                }
                                else {
                                    $objStatus.Status = "Warning"
                                    $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                    
                                }

                            }
                        }
                        else {
                            # Must return a message if RRP name is not found in the region
                            "[{0}] Resource restriction policy name '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                            if ($Whatif) {
                                $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                                Write-warning $ErrorMessage
                                return
                            }
                            else {
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                                
                            }
         
                        } 
                    }

                    # Role not found without RRP parameter = CREATION
                    # Role not found with RRP parameter = CREATION
                    elseif (-not $Rolefound) {    

                        $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                        if ($ServiceName -eq "HPE GreenLake platform") {
                            $ServiceID = "00000000-0000-0000-0000-000000000000"
                        }
                        else {
                            $ServiceID = $Service.application_id
                        }

                        # If not RRP
                        if (-Not $ResourceRestrictionPolicyName) {

                            # Build payload
                            $Payload = [PSCustomObject]@{ add = @( 
                                    @{ 
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = $Null
                                    
                                    }
    
                                )
                            } | ConvertTo-Json -Depth 5

                            # Set user roles without RRP       
                            try { 
                                Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                                
                                if (-not $WhatIf) {

                                    "[{0}] Role '{1}' successfully assigned to user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                                    $objStatus.Status = "Complete"
                                    $objStatus.Details = "Role successfully assigned!"
                                    $objStatus.Service = $ServiceName

                                }
                            }
                            catch {
                                if (-not $WhatIf) {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Role cannot be assigned to user!"
                                    $objStatus.Exception = $_.Exception.message 
                                    $objStatus.Service = $ServiceName
                                }
                            }

                        }
                        # If RRP
                        else {

                            $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                            # Check if RRP is available

                            try {
                                $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }
                            # If RRP name found
                            if ($RRP) {
                               
                                $ResourceRestrictionPolicyID = $RRP.resource_restriction_policy_id

                                # Check if RRP name already assigned to the role

                                try {
                                    $RRPAlreadyAssigned = ($ServiceNameUserRoles | Where-Object role -eq $RoleName).resource_restriction_policy
                                }
                                catch {
                                    $PSCmdlet.ThrowTerminatingError($_)
                                }


                                if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                                    # Build payload
                                    $Payload = [PSCustomObject]@{ add = @( 
                                            @{ 
                                                role                          = @{  
                                                    slug           = $Slug
                                                    application_id = $ServiceID
                                                }
                                                resource_restriction_policies = @(
                                                    $ResourceRestrictionPolicyID
                                                )
                                            }
        
                                        )
                                    } | ConvertTo-Json -Depth 5
                        
                                    # Set user roles with RRP    
                                    try { 
                                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                                    
                                        if (-not $WhatIf) {

                                            "[{0}] Role '{1}' successfully assigned to user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                                            $objStatus.Status = "Complete"
                                            $objStatus.Details = "Role successfully assigned!"
                                            $objStatus.Service = $ServiceName

                                        }
                                    }
                                    catch {
                                        if (-not $WhatIf) {
                                            $objStatus.Status = "Failed"
                                            $objStatus.Details = "Role cannot be assigned to user!"
                                            $objStatus.Exception = $_.Exception.message 
                                            $objStatus.Service = $ServiceName
                                        }
                                    }
                                }
                                else {
                                    # Must return a message if RRP name is already assigned to the role
                                    "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                    if ($Whatif) {
                                        $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                        Write-warning $ErrorMessage
                                        return
                                    }
                                    else {
                                        $objStatus.Status = "Warning"
                                        $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                        
                                    }

                
                                }
                            
                            }
                            # If not RRP name not found
                            else {
                                # Must return a message if RRP name is not found in the region
                                "[{0}] Resource restriction policy nam '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose
    
                                if ($Whatif) {
                                    $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                                    Write-warning $ErrorMessage
                                    return
                                }
                                else {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                                    
                                }

                              
                            }
                        }
                    }
                }
                # If role not found
                else {
                    # Must return a message if Rolename is not found
                    "[{0}] Role name '{1}' cannot be found for service '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ServiceName | Write-Verbose
    
                    if ($Whatif) {
                        $ErrorMessage = "Role '{0}' cannot be found for service '{1}'!" -f $RoleName, $ServiceName
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Role name cannot be found for this service!"
                        $objStatus.Service = $ServiceName
                        
                    }

                }            
            }
            
        }

        ############## If Predefined roles (i.e. -ComputeOpsManagementRole, etc.) ##############
        else {

            try {
                $ExistingUserRoles = Get-HPEGLUserRole -Email $email
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }


            # Role already assigned?
            if ($MyInvocation.BoundParameters["ArubaCentralRole"] ) {
            
                $ServiceName = "Aruba Central"
                $Rolename = $ArubaCentralRole
            
            }
            elseif ($MyInvocation.BoundParameters["HPEGreenLakeRole"] ) {
            
                $ServiceName = "HPE GreenLake platform"
                $Rolename = $HPEGreenLakeRole
            
            }
            elseif ($MyInvocation.BoundParameters["ComputeOpsManagementRole"] ) {

                $ServiceName = "Compute Ops Management"
                $Rolename = $ComputeOpsManagementRole
            
            }
            elseif ($MyInvocation.BoundParameters["DataServicesRole"] ) {
            
                $ServiceName = "Data Services"
                $Rolename = $DataServicesRole

            }

            $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName
            $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName

            $objStatus.Role = $Rolename
            $objStatus.Service = $ServiceName
        
            # Role found without RRP parameter = ERROR
            if ($Rolefound -and -not $ResourceRestrictionPolicyName) {
        
                # Must return a message if Rolename is already assigned
                "[{0}] Role name '{1}' is already assigned to this user!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName | Write-Verbose
        
                if ($Whatif) {
                    $ErrorMessage = "Service role '{0}' is already assigned to this user!" -f $RoleName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "Service role name is already assigned to this user!"
                    $objStatus.Service = $ServiceName
                    
                }


            }

            # Role found with RRP parameter = MODIFICATION
            elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                # Get slug
                try {
                    $Slug = (Get-HPEGLRole -ServiceName $ServiceName -ServiceRole $RoleName).slug
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose
                

                try {
                    $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique

                    $ServiceID = $Service.application_id

                    
                }
                catch {    
                    $PSCmdlet.ThrowTerminatingError($_)
    
                }

                if (-not $Service) {
                    # Must return a message if Service is not provisioned in the region
                    "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
        
                    if ($Whatif) {
                        $ErrorMessage = "Service '{0}' is not provisioned in a region!" -f $ServiceName
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Service not provisioned in a region!"
                        $objStatus.Service = $ServiceName
                        
                    }

        
                }
                else {

                    # Check if RRP is available

                    try {
                        $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }

                    if ($RRP) {
                               
                        $ResourceRestrictionPolicyIDToSet = $RRP.resource_restriction_policy_id

                        # Check if RRP name already assigned to the role
                        $RRPAlreadyAssigned = $Rolefound.resource_restriction_policy

                        # If RRP name not already assigned to the role: Overwrite needed !
                        if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                            $RolesList = [System.Collections.ArrayList]::new()
                            
                            foreach ($ExistingUserRole in $ExistingUserRoles) {
                             
                                $Slug = $ExistingUserRole.slug
                                $ServiceID = $ExistingUserRole.application_id
                             
                                # If ExistingUserRole is not the one we want to modify with new RRP, we capture existing RRP
                                if ($ExistingUserRole.resource_restriction_policy) {

                                    $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                                    # If ExistingUserRole is the one we want to modify with new RRP
                                    if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                                    
                                        $ResourceRestrictionPolicyID = $ResourceRestrictionPolicyIDToSet
                                  
                                    }
                                    
                                    $Role = [PSCustomObject]@{
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = @(
                                            $ResourceRestrictionPolicyID
                                        )
                                    }

                                }
                                else {                                
                              
                                    $Role = [PSCustomObject]@{
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = @( )
                                    }
                                }

                                $RolesList += $Role

                            }
                            

                            # Build payload
                            $Payload = [PSCustomObject]@{ overwrite = @( 
                                    $RolesList
                                )
                            } | ConvertTo-Json -Depth 5
                            

                            # Set user role with RRP      
                            try {
                                Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                                if (-not $WhatIf) {

                                    "[{0}] Role '{1}' with resource restriction policy '{2}' successfully set for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                                    $objStatus.Status = "Complete"
                                    $objStatus.Details = "Resource restriction policy successfully set!"
                                    $objStatus.Service = $ServiceName

                                }

                            }
                            catch {
                                if (-not $WhatIf) {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Resource restriction policy cannot be set!"
                                    $objStatus.Exception = $_.Exception.message 
                                    $objStatus.Service = $ServiceName
                                }
                            }

                        }
                        # If RRP name already assigned to the role
                        else {
                            # Must return a message if RRP name is already assigned to the role
                            "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                            if ($Whatif) {
                                $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                Write-warning $ErrorMessage
                                return
                            }
                            else {
                                $objStatus.Status = "Warning"
                                $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                
                            }

                        }
                    }
                    else {
                        # Must return a message if RRP name is not found in the region
                        "[{0}] Resource restriction policy name '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                        if ($Whatif) {
                            $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                            
                        }
                    }
                }
            }
            
            # Role not found without RRP parameter = CREATION
            # Role not found with RRP parameter = CREATION
            elseif (-not $Rolefound) {   

                $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                # Get slug
                try {
                    $Slug = (Get-HPEGLRole -ServiceName $ServiceName -ServiceRole $RoleName).slug
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose
                
                # If all apps except GreenLake service
                if (-not $MyInvocation.BoundParameters["HPEGreenLakeRole"]) {

                    try {
                        $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
                    
                    }
                    catch {    
                        $PSCmdlet.ThrowTerminatingError($_)
    
                    }

                    if (-not $Service) {
                        # Must return a message if Service is not provisioned in the region
                        "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose
        
                        if ($Whatif) {
                            $ErrorMessage = "Service '{0}' is not provisioned in a region!" -f $ServiceName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Service not provisioned in a region!"
                            $objStatus.Service = $ServiceName
                            
                        }       
        
                    }
                    else {

                        $ServiceID = $Service.application_id
                        
                        # If not RRP
                        if (-Not $ResourceRestrictionPolicyName) {

                            # Build payload
                            $Payload = [PSCustomObject]@{ add = @( 
                                    @{ 
                                        role                          = @{  
                                            slug           = $Slug
                                            application_id = $ServiceID
                                        }
                                        resource_restriction_policies = $Null
                                    
                                    }
    
                                )
                            } | ConvertTo-Json -Depth 5

                            # Set user roles without RRP       
                            try { 
                                Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                                
                                if (-not $WhatIf) {

                                    "[{0}] Role '{1}' successfully assigned to user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                                    $objStatus.Status = "Complete"
                                    $objStatus.Details = "Role successfully assigned!"
                                    $objStatus.Service = $ServiceName

                                }
                            }
                            catch {
                                if (-not $WhatIf) {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Role cannot be assigned to user!"
                                    $objStatus.Exception = $_.Exception.message 
                                    $objStatus.Service = $ServiceName
                                }
                            }

                        }
                        
                        # If RRP
                        else {

                            $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                            # Check if RRP is available

                            try {
                                $RRP = Get-HPEGLResourceRestrictionPolicy -Name $ResourceRestrictionPolicyName
                            }
                            catch {
                                $PSCmdlet.ThrowTerminatingError($_)
                            }

                            if ($RRP) {
                               
                                $ResourceRestrictionPolicyID = $RRP.resource_restriction_policy_id

                                # Check if RRP name already assigned to the role

                                try {
                                    $RRPAlreadyAssigned = (Get-HPEGLUserRole -Email $email -ServiceName $ServiceName | Where-Object role -eq $RoleName).resource_restriction_policy
                                }
                                catch {
                                    $PSCmdlet.ThrowTerminatingError($_)
                                }

                                # If RRP name not already assigned to the role
                                if ( $RRPAlreadyAssigned -ne $ResourceRestrictionPolicyName) {

                                    # Build payload
                                    $Payload = [PSCustomObject]@{ add = @( 
                                            @{ 
                                                role                          = @{  
                                                    slug           = $Slug
                                                    application_id = $ServiceID
                                                }
                                                resource_restriction_policies = @(
                                                    $ResourceRestrictionPolicyID
                                                )
                                            }
        
                                        )
                                    } | ConvertTo-Json -Depth 5
                            

                                    # Set user role with RRP      
                                    try {
                                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                                        if (-not $WhatIf) {

                                            "[{0}] Role '{1}' successfully assigned to user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $Email | Write-Verbose

                                            $objStatus.Status = "Complete"
                                            $objStatus.Details = "Role successfully assigned!"
                                            $objStatus.Service = $ServiceName

                                        }

                                    }
                                    catch {
                                        if (-not $WhatIf) {
                                            $objStatus.Status = "Failed"
                                            $objStatus.Details = "Role cannot be assigned to user!"
                                            $objStatus.Exception = $_.Exception.message 
                                            $objStatus.Service = $ServiceName
                                        }
                                    }

                                }
                                # If RRP name already assigned to the role
                                else {
                                    # Must return a message if RRP name is already assigned to the role
                                    "[{0}] Resource restriction policy name '{1}' is already assigned to this role!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                    if ($Whatif) {
                                        $ErrorMessage = "Resource restriction policy '{0}' is already assigned to this role!" -f $ResourceRestrictionPolicyName
                                        Write-warning $ErrorMessage
                                        return
                                    }
                                    else {
                                        $objStatus.Status = "Warning"
                                        $objStatus.Details = "Resource restriction policy name is already assigned to this role!"
                                        
                                    }
                    
                                }
                            }
                            else {
                                # Must return a message if RRP name is not found in the region
                                "[{0}] Resource restriction policy name '{1}' cannot be found in this region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName | Write-Verbose

                                if ($Whatif) {
                                    $ErrorMessage = "Resource restriction policy '{0}' cannot be found in this region!" -f $ResourceRestrictionPolicyName
                                    Write-warning $ErrorMessage
                                    return
                                }
                                else {
                                    $objStatus.Status = "Failed"
                                    $objStatus.Details = "Resource restriction policy name cannot be found in this region!"
                                    
                                }
                
                      
                            }
                        }
                    }
                }

                # If GreenLake service
                else {

                    $ServiceID = "00000000-0000-0000-0000-000000000000"

                    # Build payload

                    # No resource restriction policy exists for HPE GreenLake = "HPE GreenLake platform"

                    # Build payload
                    $Payload = [PSCustomObject]@{ add = @( 
                            @{ 
                                role                          = @{  
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                                resource_restriction_policies = $Null
                                
                            }

                        )
                    } | ConvertTo-Json -Depth 5

                    # Set user roles without RRP       
                    try { 
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null 
                            
                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' successfully assigned to user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Role successfully assigned!"
                            $objStatus.Service = $ServiceName

                        }
                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Role cannot be assigned to user!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }

                               
                }
            }
        }

        [void] $UserRoleAssignmentStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($UserRoleAssignmentStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more users failed the role assignment attempt!"
                
          
            }

            Return $UserRoleAssignmentStatus
        }


    }
}


Function Remove-HPEGLUserRole {
    <#
    .SYNOPSIS
    Remove user roles in an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet removes users' roles and permissions in an HPE GreenLake workspace. 
    Roles are groups of permissions that grant users access to the HPE GreenLake services.

    Roles are unassigned from a service in all regions. 

    .PARAMETER Email 
    Email address of the user for whom you want to remove roles and permissions (can be retrieved using Get-HPEGLUser).    

    .PARAMETER ArubaCentralRole 
    Name of the Aruba Central role to remove from the user's roles. 
    The predefined roles are as follows:
        * Aruba Central Administrator  
        * Aruba Central Guest Operator
        * Aruba Central Operator
        * Aruba Central view edit role
        * Aruba Central View Only
        * Netlnsight Campus Admin
        * Netlnsight Campus Viewonly

    .PARAMETER ComputeOpsManagementRole 
    Name of the Compute Ops Management role to remove from the user's roles. 
    The predefined roles are as follows:
        * Administrator
        * Observer
        * Operator

    .PARAMETER DataServicesRole 
    Name of the Data Services role to remove from the user's roles. 
    The predefined roles are as follows:
        * Administrator
        * Backup and Recovery Administrator
        * Backup and Recovery Operator
        * Data Ops Manager Administrator
        * Data Ops Manager Operator
        * Disaster Recovery Admin
        * Read only

    .PARAMETER HPEGreenLakeRole 
    Name of the HPE GreenLakeRole role to remove from the user's roles. 
    The predefined roles are as follows:
        * Workspace Administrator
        * Workspace Observer
        * Workspace Operator
        * Orders Administrator
        * Orders Observer
        * Orders Operator

    .PARAMETER RoleName 
    Role name of a service to be unassigned (can be retrieved using Get-HPEGLUserRole).   
        
    .PARAMETER ServiceName 
    Name of the service to which the role name will be unassigned (can be retrieved using Get-HPEGLUserRole).   

    .PARAMETER ResourceRestrictionPolicyName 
    Name of a resource restriction policy to be removed (can be retrieved with Get-HPEGLUserRole ).  

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLUserRole -Email richardfeynman@quantummechanics.lab -ComputeOpsManagementRole Observer 

    Remove the Observer role to richardfeynman@quantummechanics.lab for the "Compute Ops Management" service.

    .EXAMPLE
    Remove-HPEGLUserRole -Email richardfeynman@quantummechanics.lab -ServiceName "Aruba Central" -RoleName 'Aruba Central Administrator'

    Remove the Aruba Central Administrator role to richardfeynman@quantummechanics.lab for the "Aruba Central" service.
  
    .EXAMPLE
    Get-HPEGLUserRole -Email richardfeynman@quantummechanics.lab -ServiceName  "Compute Ops Management"  | Remove-HPEGLUserRole 
  
    Remove all roles to richardfeynman@quantummechanics.lab for the "Compute Ops Management" service.

    .EXAMPLE
    Remove-HPEGLUserRole -Email  richardfeynman@quantummechanics.lab -ComputeOpsManagementRole Administrator -ResourceRestrictionPolicyName RRP_COM-Location-Texas

    Remove the resource restriction policy named 'RRP_COM-Location-Texas' to the user Alexandre Liapounov for the "Compute Ops Management" service with the Administrator role. 
        
    .INPUTS
    System.Collections.ArrayList
        List of user role(s) from 'Get-HPEGLUserRole'.

    .OUTPUTS
    System.Collections.ArrayList
        A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - Email of the user 
        * Role - Name of the role to remove 
        * Service - Name of the service 
        * ResourceRestrictionPolicyName - Name of the resource restriction policy to remove
        * Status - Status of the role unassignment attempt (Failed for http error return; Complete if successful; Warning if no action is needed) 
        * Details - More information about the status 
        * Exception: Information about any exceptions generated during the operation.

    
   #>
    [CmdletBinding(DefaultParameterSetName = 'ComputeOpsManagement')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'ArubaCentral')]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'HPEGreenLake')]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'DataServices')]
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,
      
        [Parameter (Mandatory, ParameterSetName = 'ArubaCentral')]
        [ValidateSet ('Aruba Central Administrator', 'Aruba Central Guest Operator', 'Aruba Central Operator', 'Aruba Central view edit role', 'Aruba Central View Only', 'Netlnsight Campus Admin', 'Netlnsight Campus Viewonly')]
        [String]$ArubaCentralRole,

        [Parameter (Mandatory, ParameterSetName = 'HPEGreenLake')]
        [ValidateSet ('Workspace Administrator', 'Workspace Observer', 'Workspace Operator', 'Orders Administrator', 'Orders Observer', 'Orders Operator')]
        [String]$HPEGreenLakeRole,

        [Parameter (Mandatory, ParameterSetName = 'ComputeOpsManagement')]
        [ValidateSet ('Administrator', 'Observer', 'Operator')]
        [String]$ComputeOpsManagementRole,

        [Parameter (Mandatory, ParameterSetName = 'DataServices')]
        [ValidateSet ('Administrator', 'Backup and Recovery Administrator', 'Backup and Recovery Operator', 'Data Ops Manager Administrator', 'Data Ops Manager Operator', 'Disaster Recovery Admin', 'Read only')]
        [String]$DataServicesRole,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [Alias('Application_name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Other')]
        [Alias('Role')]
        [String]$RoleName,

        [Parameter (ParameterSetName = 'ArubaCentral')]
        [Parameter (ParameterSetName = 'HPEGreenLake')]
        [Parameter (ParameterSetName = 'ComputeOpsManagement')]
        [Parameter (ParameterSetName = 'DataServices')]
        [Parameter (ParameterSetName = 'Other')]
        [String]$ResourceRestrictionPolicyName,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $UserRoleUnassignmentStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose


        $Uri = $AuthzUsersRolesUri + $Email.ToLower() + "/roles"


        # Test if user present
        try {
            
            $User = (Get-HPEGLUser).contact | Where-Object email -eq $Email
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email                         = $Email
            Role                          = $Null
            Service                       = $Null
            ResourceRestrictionPolicyName = $Null
            Status                        = $Null
            Details                       = $Null
            Exception                     = $Null
                  
        }
        
        if (-not $User) {
            # Must return a message if user not found
            "[{0}] User '{1}' not found." -f $MyInvocation.InvocationName.ToString().ToUpper(), $Email | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "User '{0}' cannot be found in the HPE GreenLake workspace!" -f $Email
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "User cannot be found in the HPE GreenLake workspace!"
            }
    
            $objStatus.Service = $ServiceName
            
        }

        ############### If RoleName / ServiceName ###############
        elseif ($RoleName) {

            $objStatus.Role = $RoleName
            $objStatus.Service = $ServiceName


            try {
                $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
                
            }
            catch {    
                $PSCmdlet.ThrowTerminatingError($_)

            }
            # If ServiceName not found except if GreenLake service
            if (-not $Service -and $ServiceName -ne "HPE GreenLake platform") {
                # Must return a message if Service is not provisioned in the region
                "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Service '{0}' is not provisioned in any region!" -f $ServiceName
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Service is not provisioned in any region!"
                }
        
                $objStatus.Service = $ServiceName
    
            }
            else {
                
                # Role assigned?  
                try {
                   
                    $ExistingUserRoles = Get-HPEGLUserRole -Email $email

                    $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName

                    $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName

                    $Slug = $Rolefound.slug

                    "[{0}] Rolefound = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolefound | write-verbose

                 

                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }

                # Role found but not RRP modification = DELETE
                if ( $Rolefound -and -not $ResourceRestrictionPolicyName) {

                    "[{0}] Role '{1}' found for '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolename, $ServiceName | Write-Verbose
                    "[{0}] Slug = '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Slug | write-verbose


                    if ($ServiceName -eq "HPE GreenLake platform") {

                        $ServiceID = "00000000-0000-0000-0000-000000000000"

                    }
                    else {
                        $ServiceID = $Service.application_id
                    }

                    # Build payload
                    $Payload = [PSCustomObject]@{ delete = @( 
                            @{ 
                                slug           = $Slug
                                application_id = $ServiceID
                            }
                        )
                    } | ConvertTo-Json -Depth 5
                  

                    # Remove user role      
                    try {
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' successfully removed from user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Role, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Role successfully removed!"
                            $objStatus.Service = $ServiceName

                        }

                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Role cannot be removed from user!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }

                }

                # Role found with RRP parameter = MODIFICATION 
                elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                    $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                    # Check if RRP name assigned to the role
                    $RRPAssigned = $Rolefound.resource_restriction_policy
                    
                    # If RRP assigned to role, modification
                    if ($RRPAssigned -eq $ResourceRestrictionPolicyName) {
    
                        $RolesList = [System.Collections.ArrayList]::new()

                        foreach ($ExistingUserRole in $ExistingUserRoles) {
                 
                            $Slug = $ExistingUserRole.slug
                            $ServiceID = $ExistingUserRole.application_id
         
                            if ($ExistingUserRole.resource_restriction_policy) {

                                $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                                # If ExistingUserRole is the one we want to remove the exisiting RRP and set the default AllScopes RRP back
                                if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                        
                                    # Get the AllScopes default resource restriction policy ID of this role
                                    $ResourceRestrictionPolicyID = (Get-HPEGLResourceRestrictionPolicy -Name 'Allscopes' | Where-Object application_name -eq $ServiceName).resource_restriction_policy_id
              
                                }
                                    
                                $Role = [PSCustomObject]@{
                                    role                          = @{  
                                        slug           = $Slug
                                        application_id = $ServiceID
                                    }
                                    resource_restriction_policies = @(
                                        $ResourceRestrictionPolicyID
                                    )
                                }

                            }
                            else {                                
          
                                $Role = [PSCustomObject]@{
                                    role                          = @{  
                                        slug           = $Slug
                                        application_id = $ServiceID
                                    }
                                    resource_restriction_policies = @( )
                                }
                            }

                            $RolesList += $Role

                        }
        

                        # Build payload
                        $Payload = [PSCustomObject]@{ overwrite = @( 
                                $RolesList
                            )
                        } | ConvertTo-Json -Depth 5
        

                        # Set user role with RRP      
                        try {
                            Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                            if (-not $WhatIf) {

                                "[{0}] Role '{1}' with resource restriction policy '{2}' successfully removed for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                                $objStatus.Status = "Complete"
                                $objStatus.Details = "Resource restriction policy successfully removed!"
                                $objStatus.Service = $ServiceName

                            }

                        }
                        catch {
                            if (-not $WhatIf) {
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Resource restriction policy cannot be removed!"
                                $objStatus.Exception = $_.Exception.message 
                                $objStatus.Service = $ServiceName
                            }
                        }


                    }

                    # If RRP name not assigned to the role: ERROR
                    else {
                        # Must return a message if RRP name is not found
                        "[{0}] Resource restriction policy name '{1}' cannot be found for the role '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName, $Rolename | Write-Verbose

                        if ($WhatIf) {
                            $ErrorMessage = "Resource restriction policy '{0}' cannot be found for the role '{1}'!" -f $Name, $Rolename
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Resource restriction policy name cannot be found for this role!"
                        }
                        
                    }




                }

                # Role not found = ERROR
                elseif (-not $Rolefound) {
                    # Must return a message if Rolename is not found
                    "[{0}] Role name '{1}' is not assigned to user '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $Email | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Role name '{0}' is not assigned to user '{1}'!" -f $RoleName, $Email
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Role name is not assigned to the user!"
                    }
    
                    $objStatus.Service = $ServiceName
                }            
            }
            
        }

        ############## If Predefined roles (i.e. -ComputeOpsManagementRole, etc.) ##############
        else {

            try {
                $ExistingUserRoles = Get-HPEGLUserRole -Email $email
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }


            if ($MyInvocation.BoundParameters["ArubaCentralRole"] ) {
            
                $ServiceName = "Aruba Central"
                $Rolename = $ArubaCentralRole
            
            }
            elseif ($MyInvocation.BoundParameters["HPEGreenLakeRole"] ) {
            
                $ServiceName = "HPE GreenLake platform"
                $Rolename = $HPEGreenLakeRole
            
            }
            elseif ($MyInvocation.BoundParameters["ComputeOpsManagementRole"] ) {

                $ServiceName = "Compute Ops Management"
                $Rolename = $ComputeOpsManagementRole
            
            }
            elseif ($MyInvocation.BoundParameters["DataServicesRole"] ) {
            
                $ServiceName = "Data Services"
                $Rolename = $DataServicesRole

            }

            $ServiceNameUserRoles = $ExistingUserRoles | Where-Object application_name -eq $ServiceName
            $Rolefound = $ServiceNameUserRoles | Where-Object role -eq $RoleName
            $Slug = $Rolefound.slug

            $objStatus.Role = $Rolename
            $objStatus.Service = $ServiceName
            
            # Role found but not RRP modification = DELETE
            if ($Rolefound -and -not $ResourceRestrictionPolicyName) {
                            
                if (-not $MyInvocation.BoundParameters["HPEGreenLakeRole"]) {

                    try {
                        $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName | sort-object -Property application_id  -Unique
                    
                    }
                    catch {    
                        $PSCmdlet.ThrowTerminatingError($_)
    
                    }

                    if (-not $Service) {
                        # Must return a message if Service is not provisioned in the region
                        "[{0}] Service '{1}' not provisioned in a region!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose


                        if ($WhatIf) {
                            $ErrorMessage = "Service '{0}' not provisioned in any region!" -f $ServiceName
                            Write-warning $ErrorMessage
                            return
                        }
                        else {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Service not provisioned in a region!"
                        }

                        $objStatus.Service = $ServiceName
        
                    }
                    else {

                        $ServiceID = $Service.application_id

                        $Payload = [PSCustomObject]@{ delete = @( 
                                @{ 
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                            )
                        } | ConvertTo-Json -Depth 5
                      

                        # Remove user role      
                        try {
                            Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                            if (-not $WhatIf) {

                                "[{0}] Role '{1}' successfully removed from user '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Rolename, $Email | Write-Verbose

                                $objStatus.Status = "Complete"
                                $objStatus.Details = "Role successfully removed!"
                                $objStatus.Service = $ServiceName

                            }

                        }
                        catch {
                            if (-not $WhatIf) {
                                $objStatus.Status = "Failed"
                                $objStatus.Details = "Role cannot be removed!"
                                $objStatus.Exception = $_.Exception.message 
                                $objStatus.Service = $ServiceName
                            }
                        }
                    }
                }

                else {

                    $ServiceID = "00000000-0000-0000-0000-000000000000"

                    # Build payload
                    $Payload = [PSCustomObject]@{ delete = @( 
                            @{ 
                                slug           = $Slug
                                application_id = $ServiceID
                            }
                        )
                    } | ConvertTo-Json -Depth 5
              

                    # Remove user role     
    
                    try {
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' successfully removed from user: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Role successfully removed!"
                            $objStatus.Service = $ServiceName

                        }

                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Role cannot be removed!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }

                }

            }

            # Role found with RRP parameter = MODIFICATION 
            elseif ($Rolefound -and $ResourceRestrictionPolicyName) {

                $objStatus.ResourceRestrictionPolicyName = $ResourceRestrictionPolicyName

                # Check if RRP name assigned to the role
                $RRPAssigned = $Rolefound.resource_restriction_policy
                
                # If RRP assigned to role, modification
                if ($RRPAssigned -eq $ResourceRestrictionPolicyName) {

                    $RolesList = [System.Collections.ArrayList]::new()

                    foreach ($ExistingUserRole in $ExistingUserRoles) {
             
                        $Slug = $ExistingUserRole.slug
                        $ServiceID = $ExistingUserRole.application_id
     
                        if ($ExistingUserRole.resource_restriction_policy) {

                            $ResourceRestrictionPolicyID = $ExistingUserRole.resource_restriction_policy_id

                            # If ExistingUserRole is the one we want to remove the exisiting RRP and set the default AllScopes RRP back
                            if ($ExistingUserRole.application_name -eq $ServiceName -and $ExistingUserRole.role -eq $RoleName) {
                    
                                # Get the AllScopes default resource restriction policy ID of this role
                                $ResourceRestrictionPolicyID = (Get-HPEGLResourceRestrictionPolicy -Name 'Allscopes' | Where-Object application_name -eq $ServiceName).resource_restriction_policy_id
          
                            }
                                
                            $Role = [PSCustomObject]@{
                                role                          = @{  
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                                resource_restriction_policies = @(
                                    $ResourceRestrictionPolicyID
                                )
                            }

                        }
                        else {                                
      
                            $Role = [PSCustomObject]@{
                                role                          = @{  
                                    slug           = $Slug
                                    application_id = $ServiceID
                                }
                                resource_restriction_policies = @( )
                            }
                        }

                        $RolesList += $Role

                    }
    

                    # Build payload
                    $Payload = [PSCustomObject]@{ overwrite = @( 
                            $RolesList
                        )
                    } | ConvertTo-Json -Depth 5
    

                    # Set user role with RRP      
                    try {
                        Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf | Out-Null

                        if (-not $WhatIf) {

                            "[{0}] Role '{1}' with resource restriction policy '{2}' successfully removed for '{3}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName, $ResourceRestrictionPolicyName, $Email | Write-Verbose

                            $objStatus.Status = "Complete"
                            $objStatus.Details = "Resource restriction policy successfully removed!"
                            $objStatus.Service = $ServiceName

                        }

                    }
                    catch {
                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = "Resource restriction policy cannot be removed!"
                            $objStatus.Exception = $_.Exception.message 
                            $objStatus.Service = $ServiceName
                        }
                    }


                }

                # If RRP name not assigned to the role: ERROR
                else {
                    # Must return a message if RRP name is not found
                    "[{0}] Resource restriction policy name '{1}' cannot be found for the role '{2}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyName, $Rolename | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Resource restriction policy name '{0}' cannot be found for the role '{1}'!" -f $ResourceRestrictionPolicyName, $Rolename
                        Write-warning $ErrorMessage
                        return
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Resource restriction policy name cannot be found for this role!"
                    }
    

                }




            }

            # Role not found = ERROR
            elseif (-not $Rolefound) {
                # Must return a message if Rolename is not found
                "[{0}] Role name '{1}' is not assigned to this user!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $RoleName | Write-Verbose

                if ($WhatIf) {
                    $ErrorMessage = "Role name '{0}' is not assigned to this user!" -f $Rolename
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "Role name is not assigned to this user!"
                }

                $objStatus.Service = $ServiceName
              
            }
        }

        [void] $UserRoleUnassignmentStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($UserRoleUnassignmentStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                Write-Error "Attempt to remove one or more users from the role assignment has failed!"

          
            }

            Return $UserRoleUnassignmentStatus
        }


    }
}


Function Get-HPEGLResourceRestrictionPolicy {
    <#
    .SYNOPSIS
    View resource restriction policies in an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet returns the resource restriction policies in an HPE GreenLake workspace.  
    Resource restriction policies limit which resources can be accessed by creating customizable resource groupings.

    .PARAMETER Name 
    Name of the resource restriction policy.

    .PARAMETER ServiceName 
    Optional parameter to display resource restriction policies for a service name (can be retrieved using Get-HPEGLService -ShowProvisioned).
   
    .PARAMETER ShowFilter 
    Switch parameter to get the filters used by a resource restriction policy.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy 

    Return the resource restriction policies in an HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -Name RRP_COM-Location-Texas 

    Return the resource restriction policy information with the filter names in use for the 'RRP_COM-Location-Texas' resource restriction policy name.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -ServiceName 'Compute Ops Management'   

    Return all resource restriction policies for the Compute Ops Management service instances.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -Name RRP_with_3_COM_filters -ShowFilter
 
    Return all filters used by the 'RRP_with_3_COM_filters' resource restriction policy.
    
   #>

    [CmdletBinding(DefaultParameterSetName = 'Name')]
    Param( 
                    
        [Parameter (ParameterSetName = 'Name')]
        [String]$Name,
            
        [Parameter (ValueFromPipelineByPropertyName, ParameterSetName = 'ApplicationName')]
        [Alias('Application_name')]
        [String]$ServiceName,

        [Parameter (ParameterSetName = 'Name')]
        [Switch]$ShowFilter,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $FilterList = [System.Collections.ArrayList]::new()

        $Uri = $ResourceRestrictionsPolicyUri 
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
   
        
        if ($Null -ne $Collection.policies) {

            if ($Name -and $ShowFilter) {

                if ($Collection.policies | Where-Object name -eq $Name) {

                    $ResourceRestrictionPolicyID = ( $Collection.policies | Where-Object name -eq $Name).resource_restriction_policy_id
                    "[{0}] Resource Restriction Policy ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyID | Write-Verbose
                    
                    $Uri = $ResourceRestrictionPolicyUri + $ResourceRestrictionPolicyID
                    
                    "[{0}] URIAdd to retrieve the RRP '{1}': '{2}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Uri | Write-Verbose
                    
                    try {
                        
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }    

                    $Uri = $ResourceRestrictionsPolicyUsersUri + $ResourceRestrictionPolicyID + "/users?limit=2000"

                    "[{0}] URIAdd to retrieve the users using the RRP '{1}': '{2}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name, $Uri | Write-Verbose

                    try {

                        [array]$Users = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf

                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }    
                    
                    foreach ($_Filter in $collection.scope_resource_instances) {
                        
                        $Region = (Get-HPEGLService -Name $Collection.application_name ) | Where-Object application_instance_id -eq $_Filter.application_instance_id | ForEach-Object region
                        
                        $ReturnData = $Collection | Select-Object `
                        @{N = "name"; E = { $_Filter.name } }, `
                        @{N = "description"; E = { $_Filter.description } }, `
                        @{N = "slug"; E = { $_Filter.slug } }, `
                        @{N = "application_instance_id"; E = { $_Filter.application_instance_id } }, `
                        @{N = "region"; E = { $Region } }, `
                        @{N = "application_cid"; E = { $_Filter.application_cid } }, `
                        @{N = "type"; E = { $_Filter.type } }, `
                        @{N = "scope_type_name"; E = { $_Filter.scope_type_name } }, `
                        @{N = "resource_restriction_policy_name"; E = { $Name } }, `
                        @{N = "resource_restriction_policy_id"; E = { $_.resource_restriction_policy_id } }, `
                        @{N = "resource_restriction_policy_description"; E = { $_.description } }, `
                        @{N = "platform_cid"; E = { $_.platform_cid } }, `
                        @{N = "application_id"; E = { $_.application_id } }, `
                        @{N = "application_name"; E = { $_.application_name } }, `
                        @{N = "users"; E = { $Users.users } }, `
                        @{N = "created_at"; E = { $_.created_at } }, `
                        @{N = "updated_at"; E = { $_.updated_at } }
                        
                        $FilterList += $ReturnData 
                        
                    }
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $FilterList -ObjectName "Resource.Restriction.Policy.GetFilter"    
                    $ReturnData = $ReturnData | Sort-Object { $_.name }
                }
                else {
                    Return
                }


            }
            elseif ($Name -and -not $ShowFilter) {

                if ($Collection.policies | Where-Object name -eq $Name) {

                    $ResourceRestrictionPolicyID = ( $Collection.policies | Where-Object name -eq $Name).resource_restriction_policy_id
                    "[{0}] Resource Restriction Policy ID: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ResourceRestrictionPolicyID | Write-Verbose
                    
                    $Uri = $ResourceRestrictionPolicyUri + $ResourceRestrictionPolicyID
                    
                    "[{0}] URIAdd: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose
                    
                    try {
                        
                        [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
                        
                    }
                    catch {
                        $PSCmdlet.ThrowTerminatingError($_)
                    }    
                    
                    "[{0}] Number of filters: '{1}' " -f $MyInvocation.InvocationName.ToString().ToUpper(), $collection.scope_resource_instances.Length | write-Verbose
                    
                    $FilterCount = ($collection.scope_resource_instances).count
                    
                    if (-not $FilterCount) {
                        $FilterCount = 1
                    }
                    
                    # $ReturnData = $Collection  |  Select-Object `
                    # @{N = "resource_restriction_policy_name"; E = { $Name } }, `
                    # @{N = "resource_restriction_policy_id"; E = { $_.resource_restriction_policy_id } }, `
                    # @{N = "resource_restriction_policy_description"; E = { $_.description } }, `
                    # @{N = "platform_cid"; E = { $_.platform_cid } }, `
                    # @{N = "application_id"; E = { $_.application_id } }, `
                    # @{N = "application_name"; E = { $_.application_name } }, `
                    # @{N = "filter_number"; E = { $FilterCount } }, `
                    # @{N = "created_at"; E = { $_.created_at } }, `
                    # @{N = "updated_at"; E = { $_.updated_at } }
                    
                    
                    $ReturnData = Invoke-RepackageObjectWithType -RawObject $Collection -ObjectName "Resource.Restriction.Policy"    
                }
                else {
                    Return
                }

            }
            else {

                $CollectionList = $Collection.policies 

            
                if ($ServiceName) {

                    $CollectionList = $CollectionList | Where-Object application_name -eq $ServiceName
                }

                $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Resource.Restrictions.Policy"    

                $ReturnData = $ReturnData | Sort-Object { $_.name }


            }

            return $ReturnData 

        }
        else {

            return
            
        }
 
    }
}


Function New-HPEGLResourceRestrictionPolicy {
    <#
    .SYNOPSIS
    Creates a resource restriction policy in an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet creates a resource restriction policy for a service instance. 
    A resource restriction policy can limit users' ability to perform actions on a selected list of resources provided by a service instance.

    Note that the resource restriction policy requires filters, which need to be created and saved with the resource restriction policy option enabled in the service instance.
    For Compute Ops Management, use 'New-HPECOMFilter'.

    .PARAMETER Name 
    Specifies the name of the resource restriction policy.

    .PARAMETER ServiceName 
    Specifies the name of the service to which the resource restriction policy will be applied.

    .PARAMETER ServiceRegion 
    Specifies the service region to which the resource restriction policy will be applied.

    .PARAMETER FilterName 
    Specifies the name of the filter to assign to the resource restriction policy. This can be retrieved using 'Get-HPEGLServiceResourceRestrictionPolicyFilter' and created using 'New-HPECOMFilter'.

    .PARAMETER Description 
    Provides a description of the resource restriction policy.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of sending the request. This is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    New-HPEGLResourceRestrictionPolicy -Name COM-US-West -ServiceName "Compute Ops Management" -ServiceRegion us-west -FilterName "RRP_ESXi_Group" -Description "My description"
    
    Defines a resource restriction policy named "COM-US-West" for the "Compute Ops Management" service in the US-West region using the filter "RRP_ESXi_Group".

    .EXAMPLE
    Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName "Compute Ops Management" -ServiceRegion us-west | New-HPEGLResourceRestrictionPolicy -Name RRP_Group_1
    
    Defines a resource restriction policy named "RRP_Group_1" for the "Compute Ops Management" service in the US-West region using all available filters in this service instance.

    .INPUTS
    System.Collections.ArrayList
        List of resource restriction policy filters from 'Get-HPEGLServiceResourceRestrictionPolicyFilter'.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:
        * Name - Name of the resource restriction policy attempted to be created 
        * Service - Name of the service to which the resource restriction policy will be applied
        * Region - Name of the service region to which the resource restriction policy will be applied
        * Filtername - Name of the filter assigned to the resource restriction policy
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if successful) 
        * Details - More information about the status         
        * Exception - Information about any exceptions generated during the operation.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 
                
        [Parameter (ParameterSetName = 'Default')]
        [String]$Name,
            
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Alias('application_name')]
        [String]$ServiceName,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Alias('region')]
        [String]$ServiceRegion,

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
        [Alias('filter_name')]
        [String]$FilterName,

        [Parameter (ParameterSetName = 'Default')]
        [String]$Description,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetResourceRestrictionPolicyStatus = [System.Collections.ArrayList]::new()

        $FilterList = [System.Collections.ArrayList]::new()

        $objStatus = @{}
        $FilternamesList = [System.Collections.ArrayList]::new()


    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        

        try {
            $Service = Get-HPEGLService -ShowProvisioned -Name $ServiceName -Region $ServiceRegion
            
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        
        # Build object for the output
        $objStatus = [pscustomobject]@{

            Name       = $Name
            Service    = $ServiceName
            Region     = $ServiceRegion 
            Filtername = [System.Collections.ArrayList]::new()
            Status     = $Null
            Details    = $Null
            Exception  = $Null
                                  
        }


        if ( $ServiceName -eq "HPE GreenLake platform") {
            # Must return a message if Service is CCS 
            "[{0}] HPE GreenLake service '{1}' does not support RRP!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose

            
            if ($WhatIf) {
                $ErrorMessage = "HPE GreenLake service does not support resource restriction policy!" 
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "HPE GreenLake service does not support resource restriction policy!"
    
            }


        }
        elseif (-not $Service) {
            # Must return a message if Service is not provisioned in the region
            "[{0}] Service instance '{1}' cannot be found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $ServiceName | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Service instance '{0}' cannot be found!" -f $ServiceName
                Write-warning $ErrorMessage
                return
            }
            else {

                $objStatus.Status = "Failed"
                $objStatus.Details = "Service instance cannot be found!"
    
            }


        }
        else {

            $ServiceID = $Service.application_id
            $ApplicatrionCid = $Service.application_customer_id
            $ServiceInstanceId = $Service.application_instance_id

            $Uri = $SetResourceRestrictionPolicyUri + "/" + $ServiceID + "/resource_restriction"

            #  Get filters
            try {
                $Filterfound = Get-HPEGLServiceResourceRestrictionPolicyFilter -ServiceName $ServiceName -ServiceRegion $ServiceRegion -FilterName $FilterName
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
            

            if (-not $Filterfound) {
                # Must return a message if Service is not provisioned in the region
                "[{0}] Filter name '{1}' cannot be found in this service instance!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Filtername | Write-Verbose

                # Must return a message if resource not found

                if ($WhatIf) {
                    $ErrorMessage = "Filter '{0}' cannot be found in the '{1}' region of '{2}'!" -f $Filtername, $ServiceRegion, $ServiceName
                    Write-warning $ErrorMessage
                    continue # Continue in Process block stop processing the object in pipeline and DOES NOT go to End block 
                    
                }
                else {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Filter name cannot be found in this service instance!"
                }

    

    
            }
            else {

                "[{0}] Filter '{1}' found" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Filtername | Write-Verbose


                #  Get RRPs
                try {
                    $RRPfound = Get-HPEGLResourceRestrictionPolicy -Name $Name
                }
                catch {
                    $PSCmdlet.ThrowTerminatingError($_)
                }
                

                if ($RRPfound) {
                    # Must return a message if RRP is present
                    "[{0}] RRP name '{1}' is already present in the workspace!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    if ($WhatIf) {
                        $ErrorMessage = "Resource restriction policy '{0}' is already present in the HPE GreenLake workspace!" -f $Name
                        Write-warning $ErrorMessage
                        continue # Continue in Process block stop processing the object in pipeline and DOES NOT go to End block 
                        
                    }
                    else {
                        $objStatus.Status = "Failed"
                        $objStatus.Details = "Resource restriction policy name already present in the HPE GreenLake workspace!!"
                    }
                }
                else {

                    $Slug = $Filterfound.slug
                    $ScopeTypeName = "Server filter"
                    # $ScopeTypeName = $Filterfound.scope_type_name
                    $ScopeTypeSlug = "/compute/filter"
                    # $ScopeTypeSlug = $Filterfound.scope_type_slug
                    
                    # Build object               
                    $FilterList += [PSCustomObject]@{
                        name                    = $Filtername
                        slug                    = $Slug 
                        # description             = $Null
                        matcher                 = $Slug 
                        scope_type_name         = $ScopeTypeName
                        scope_type_slug         = $ScopeTypeSlug
                        type                    = $ScopeTypeSlug
                        application_cid         = $ApplicatrionCid
                        application_instance_id = $ServiceInstanceId
                    }
                    
                    
                    # Build payload
                    $payload = [PSCustomObject]@{
                        
                        name                     = $Name
                        description              = $Description
                        application_name         = $ServiceName
                        scope_resource_instances = $FilterList
                        
                    } | ConvertTo-Json -Depth 5
                    
                    $FilternamesList += $FilterName
                    
                }
            }
        }
    }

    end {

        $FilternamesList | write-verbose

        foreach ($Item in $FilternamesList) {

            $objStatus.filtername += $Item
        }
          

        # Set resource restriction policy

        try {
            Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $payload -WhatIfBoolean $WhatIf | out-Null

            if (-not $WhatIf) {

                $objStatus.Status = "Complete"
                $objStatus.Details = "Resource restriction policy successfully created!"

            }

        }
        catch {

            if (-not $WhatIf) {

                if ($objStatus.Status -ne "Failed") {
                
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Resource restriction policy cannot be created!"
                    $objStatus.Exception = $_.Exception.message 
                
                }            
            }

        }    
        
        [void] $SetResourceRestrictionPolicyStatus.add($objStatus)

        if (-not $WhatIf) {

            if ($SetResourceRestrictionPolicyStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more resource restriction policies failed the creation attempt!"
          
            }

            Return $SetResourceRestrictionPolicyStatus
        }


    }


}


Function Remove-HPEGLResourceRestrictionPolicy {
    <#
    .SYNOPSIS
    Removes a resource restriction policy from an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet removes a resource restriction policy from the currently connected HPE GreenLake workspace.
    
    When a resource restriction policy assigned to a user is deleted, the user's resource access will still be marked as "Limited access", and the user will have read-only access to all server resources.

    The cmdlet issues a message at runtime to warn the user of the irreversible impact of this action and prompts for confirmation before proceeding with the removal.

    .PARAMETER Name 
    Specifies the name of the resource restriction policy to delete.

    .PARAMETER Force
    Switch parameter that performs the deletion without prompting for confirmation.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of sending the request. This is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Remove-HPEGLResourceRestrictionPolicy -Name COM-RRP-US-West
    
    Removes the resource restriction policy named 'COM-RRP-US-West' after the user has confirmed the removal.

    .EXAMPLE
    Remove-HPEGLResourceRestrictionPolicy -Name COM-RRP-US-West -Force
    
    Removes the resource restriction policy named 'COM-RRP-US-West' without prompting for confirmation.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy -Name RRP_with_2_COM_filters | Remove-HPEGLResourceRestrictionPolicy 
    
    Retrieves the resource restriction policy named 'RRP_with_2_COM_filters' and removes it, pending user confirmation.

    .EXAMPLE
    "RRP_with_2_COM_filters", "RRP_Gen11_filters" | Remove-HPEGLResourceRestrictionPolicy -Force

    Removes the resource restriction policy named 'RRP_with_2_COM_filters' and 'RRP_Gen11_filters' without prompting for confirmation.

    .EXAMPLE
    Get-HPEGLResourceRestrictionPolicy | Remove-HPEGLResourceRestrictionPolicy
    
    Retrieves all resource restriction policies and removes them. A warning message appears and asks the user to confirm the action for each resource restriction policy found.

    .INPUTS
    System.Collections.ArrayList
        List of resource restriction policy filters from 'Get-HPEGLResourceRestrictionPolicy'.
    System.String, System.String[]
        A single string object or a list of string objects that represent the resource restriction policy's names.


    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Name - Name of the resource restriction policy object attempted to be deleted 
        * Status - Status of the deletion attempt (Failed for HTTP error return; Complete if successful; Warning if no action is needed) 
        * Details - More information about the status         
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
                
        [Parameter (Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]$Name,

        [Switch]$Force,
            
        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose      

        $Uri = $DeleteResourceRestrictionPolicyUri

        $ObjectStatusList = [System.Collections.ArrayList]::new()
        $RRPIdsList = [System.Collections.ArrayList]::new()
        $RRPNameIdsList = [System.Collections.ArrayList]::new()

    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose
        
        
        # Condition met when 'Get-HPEGLResourceRestrictionPolicy |  Remove-HPEGLResourceRestrictionPolicy' is used 
        if ($name -eq "AllScopes" -and $PSCmdlet.MyInvocation.ExpectingInput) {
            
            # Skipping All scopes from deletion as read only.
            return

        }
        # Condition met when 'Remove-HPEGLResourceRestrictionPolicy -Name Allscopes' is used
        elseif ($name -eq "AllScopes") {
            
            $ErrorMessage = "Resource restriction policy '{0}' does not support delete operation!" -f $Name
            Write-warning $ErrorMessage
            break

        }
        else {

            # Build object for the output
            $objStatus = [pscustomobject]@{

                Name      = $Name
                Status    = $Null
                Details   = $Null
                Exception = $Null
                            
            }
                
        }

        [void]$ObjectStatusList.add($objStatus)
    
    }
    end {
        
        try {
            $ResourceRestrictionPolicies = Get-HPEGLResourceRestrictionPolicy 
            
        }
        catch {    
            $PSCmdlet.ThrowTerminatingError($_)

        }

        "[{0}] List of policies to delete: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($ObjectStatusList.name | out-string) | Write-Verbose

        
        foreach ($Object in $ObjectStatusList) {

            $RRP = $ResourceRestrictionPolicies | Where-Object name -eq $Object.Name

            if (-not $RRP) {
                    
                # Must return a message if not found
                $Object.Status = "Failed"
                $Object.Details = "Resource restriction policy cannot be found in the HPE GreenLake workspace!"
                
                if ($WhatIf) {
                    $ErrorMessage = "Resource restriction policy '{0}' cannot be found in the HPE GreenLake workspace!" -f $Object.name
                    Write-warning $ErrorMessage
                    continue
                }
            } 
            else {

                $ID = $RRP.resource_restriction_policy_id
                

                # Building the list of RRP IDs object for payload
                [void]$RRPIdsList.Add($ID)

                
                # Building the list of RRP name and IDs object for tracking
                $_Obj = [pscustomobject]@{
                    Name = $Object.Name
                    ID   = $ID
                }

                [void]$RRPNameIdsList.Add($_Obj)
            }
        }

        If ($RRPNameIdsList) {

            if ($Force) {
                $decision = 0
            }
            else {
    
                if ($RRPNameIdsList.Count -gt 1) {
                    $title = "All data associated with the restriction policies will be deleted. Confirm that you would like to remove {0} policies: {1}" -f $RRPNameIdsList.count, ($RRPNameIdsList.name -join ", ")
                    $question = 'This action cannot be undone. Are you sure you want to proceed?'
                    $choices = '&Yes', '&No'
    
                    $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
                }
                else {
                    $name = $RRPNameIdsList.name
                    $title = "All data associated with the '{0}' restriction policy will be deleted. Confirm that you would like to remove '{0}'." -f $name
                    $question = 'This action cannot be undone. Are you sure you want to proceed?'
                    $choices = '&Yes', '&No'
    
                    $decision = $Host.UI.PromptForChoice($title, $question, $choices, 1)
                }
            }
    
            if ($decision -eq 0) {
                
                # Build payload
                $payload = [PSCustomObject]@{
    
                    ids = $RRPIdsList
                
                } | ConvertTo-Json -Depth 5
    
    
                # Remove resource restriction policy
    
                try {
                    Invoke-HPEGLWebRequest -Uri $Uri -method 'DELETE' -body $payload -WhatIfBoolean $WhatIf | out-Null
    
                    if (-not $WhatIf) {
    
                        foreach ($Object in $ObjectStatusList) {

                            $RRPName = $RRPNameIdsList | Where-Object name -eq $Object.name

                            If ($RRPName) {

                                $Object.Status = "Complete"
                                $Object.Details = "Resource restriction policy successfully deleted!"
                            }
                        }
                    }
        
                }
                catch {
    
                    if (-not $WhatIf) {

                        foreach ($Object in $ObjectStatusList) {

                            $RRPName = $RRPNameIdsList | Where-Object name -eq $Object.name

                            If ($RRPName) {
    
                                $Object.Status = "Failed"
                                $Object.Details = "Resource restriction policy cannot be deleted!"
                                $Object.Exception = $_.Exception.message 
                                
                            }
                        }
                    }
    
                }    
            }
            else {

                'Operation cancelled by user!' | Write-Verbose
    
                if (-not $Whatif) {
                    
                    foreach ($Object in $ObjectStatusList) {
                        
                        $RRPName = $RRPNameIdsList | Where-Object name -eq $Object.name
                        
                        If ($RRPName) {
                            
                            $Object.Status = "Failed"
                            $Object.Details = "Operation cancelled by the user!"
                            $Object.Exception = $_.Exception.message 
                            
                        }
                    }
                }
                else {
                    
                    $ErrorMessage = "Operation cancelled by the user!"
                    Write-warning $ErrorMessage

                }
            }
        }        

        if (-not $WhatIf) {

            if ($ObjectStatusList | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more resource restriction policies failed the deletion attempt!"
          
            }

            Return $ObjectStatusList
        }
    }
}


Function Get-HPEGLUserPreference {
    <#
    .SYNOPSIS
    Displays HPE GreenLake user preferences.

    .DESCRIPTION
    This Cmdlet returns the user profile preferences for HPE GreenLake, including settings such as language, session timeout, notification and multi-factor preferences.       

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Get-HPEGLUserPreference

    Return the user profile preferences for HPE GreenLake.
    
   #>
    [CmdletBinding()]
    Param( 

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
        
        $Uri = $UserPreferencesUri
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = [System.Collections.ArrayList]::new()

        try {
            [array]$UserPreferences = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

   
        if ($Null -ne $UserPreferences ) {

    
            $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserPreferences -ObjectName "User.Preference"    
    
            return $ReturnData  
        }
        else {
            
            return            
        }
 
    }
}


Function Set-HPEGLUserPreference {
    <#
    .SYNOPSIS
    Update HPE GreenLake user preferences.

    .DESCRIPTION
    Cmdlet can be used to update the HPE GreenLake user preferences such as session timeout and Language.  

    .PARAMETER Language 
    The Language directive can be used to set the language to use in the HPE GreenLake UI. 
    Supported languages: Chinese, English, French, German, Japanese, Korean, Portuguese, Russian, Spanish, ltalian

    .PARAMETER SessionTimeoutInMinutes 
    The SessionTimeoutInMinutes directive can be used to set the session timeout (in minutes). 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLUserPreference -Language French

    Sets the language of the HPE GreenLake user interface to French.

    .EXAMPLE
    Set-HPEGLUserPreference -SessionTimeout 120

    Set the session timeout of the HPE GreenLake user interface to 120 minutes.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Email - Email address of the user 
        * Status - Status of the modification attempt (Failed for http error return; Complete if the update of the user preferences is successful) 
        * Details - More information about the status         
        * Exception: Information about any exceptions generated during the operation.
    
   #>
    [CmdletBinding()]
    Param( 

        # Argument completer reqistered in library module 
        [ValidateScript({ 
                if ($HPESupportedLanguages[$_]   ) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid language name!"
                }
            })]
        [String]$Language,   
        
        [ValidateScript({
                if ($_ -ge 5 -and $_ -le 1440) {
                    $True
                }    
                else {
                    Throw "Input value must be at least 5 and cannot exceed 1440 minutes."
                }
            })]        
        [Int]$SessionTimeoutInMinutes,

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $UserPreferencesUri

        $SetUserPreferenceStatus = [System.Collections.ArrayList]::new()

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $UserPreferences = Get-HPEGLUserPreference 
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Email     = $HPEGreenLakeSession.username
            Status    = $Null
            Details   = $Null
            Exception = $Null
                  
        }

               
        if ($Language) {

            $LanguageSet = $HPESupportedLanguages[$language]
            
            $UserPreferences.language = $LanguageSet
        }

 
        if ($SessionTimeoutInMinutes) {
                
            $UserPreferences.idle_timeout = $SessionTimeoutInMinutes * 60
        }

        if (-Not $Language -and -Not $SessionTimeoutInMinutes) {

            
            if ($Whatif) {
                $ErrorMessage = "At least one parameter must be provided!" 
                Write-warning $ErrorMessage
                return
            }
            else {
                
                $objStatus.Status = "Failed"
                $objStatus.Details = "At least one parameter must be provided!"
            }
            
        }
        else {
                
            # User Preferences modification
            try {
            
                $Response = Invoke-HPEGLWebRequest -Method 'PUT' -Body ($UserPreferences | ConvertTo-Json -Depth 5) -Uri $Uri -whatifBoolean $WhatIf
                            
                if (-not $WhatIf) {
    
                    $Global:HPEGreenLakeSession.userSessionIdleTimeout = $SessionTimeoutInMinutes

                    $objStatus.Status = "Complete"
                    $objStatus.Details = ($Response | ForEach-Object message)
                }

            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = ($Response | ForEach-Object message)
                    $objStatus.Exception = $_.Exception.message 
                }
            }    
            
        }

        [void] $SetUserPreferenceStatus.add($objStatus)
            
    }

    end {

        if (-not $WhatIf) {

            if ($SetUserPreferenceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to update the user preferences!"
          
            }

            Return $SetUserPreferenceStatus
        }



    }
}


Function Get-HPEGLUserAccountDetails {
    <#
    .SYNOPSIS
    Retrieves details of HPE GreenLake user accounts.

    .DESCRIPTION
    This Cmdlet fetches and displays HPE GreenLake user account details. The returned information includes personal details, organization name, address, time zone, language preferences, and phone numbers.
    
    .PARAMETER Raw
    Switch to return all available properties of the HPE GreenLake user account details in their raw, unprocessed form. 

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP without actually sending the request. This is useful for understanding the native REST API calls utilized by GLP.

    .EXAMPLE
    Get-HPEGLUserAccountDetails

    Retrieves and displays the details of your HPE GreenLake user account.
    
    .EXAMPLE
    Get-HPEGLUserAccountDetails -Raw
    
    Retrieves and displays all available properties of your HPE GreenLake user account details in their raw form.
    
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

#>


    [CmdletBinding()]
    Param( 

        [switch]$Raw,
        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $HPEOnepassbaseURL + "/v2-get-user/" + $HPEGreenLakeSession.username
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # $ReturnData = @() #[System.Collections.ArrayList]::new()

        try {
            [array]$UserAccountDetails = Invoke-HPEGLWebRequest -Method POST -Uri $Uri -whatifBoolean $WhatIf 
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

   
        if ($Null -ne $UserAccountDetails ) {

            if ($raw) {
                $ReturnData = $UserAccountDetails
            }
            else {
                if ($UserAccountDetails.profile) {
                    $ReturnData = $UserAccountDetails.profile | Select-Object firstName, lastName, hpeCompanyName, streetAddress, hpeStreetAddress2, city, state, zipCode, hpeCountryCode, hpeTimezone, preferredLanguage, primaryPhone, mobilePhone
                    # $ReturnData = Invoke-RepackageObjectWithType -RawObject $UserAccountDetails -ObjectName "User.AccountDetails"    
                }
                else {
                    # Required to get any error returned by invoke-HPEGLwebrequest
                    $ReturnData = $UserAccountDetails
                }
            }
    
            return $ReturnData  
        }
        else {
            
            return            
        }
 
    }
}

Function Set-HPEGLUserAccountDetails {
    <#
    .SYNOPSIS
    Set HPE GreenLake user account details.

    .DESCRIPTION
    This Cmdlet is used to update the HPE GreenLake user account details, such as first name, last name, address, time zone, language information, etc. If you omit any parameter, the cmdlet retains the current settings for those fields and only updates the provided parameters.
      
    .PARAMETER Language 
    Specifies the language to use in the HPE GreenLake UI. Supported languages include: Chinese, English, French, German, Japanese, Korean, Portuguese, Russian, Spanish, and Italian.

    .PARAMETER Street
    Sets the primary street address for the user.

    .PARAMETER Street2
    Sets the secondary address line for the user.

    .PARAMETER City
    Sets the city where the user resides.

    .PARAMETER State
    Sets the state or province where the user resides.

    .PARAMETER PostalCode
    Sets the postal code for the user's address.

    .PARAMETER Timezone
    Sets the time zone for the user's location.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be made to GLP instead of actually sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLUserAccountDetails `
    -Firstname Henri `
    -Lastname Poincar `
    -Organizationname "Celestial" `
    -Street "Theory of dynamical systems street" `
    -Street2 "Cosmos building" `
    -City Heaven `
    -PostalCode 77777 `
    -Country France `
    -Timezone Europe/Paris `
    -Language English `
    -PrimaryPhone +33123456789 `
    -Mobilephone +33612345678

    Set all parameter details of the HPE GreenLake user account for the currently connected user.

    .EXAMPLE
    Set-HPEGLUserAccountDetails -Timezone Europe/Paris -Language French 

    Sets the time zone and language details of the HPE GreenLake user account for the currently connected user. 
    
    .EXAMPLE
    Set-HPEGLUserAccountDetails -Firstname Albert -Lastname Einstein
    
    Updates the first name and last name of the HPE GreenLake user account while preserving all other existing settings.

    .EXAMPLE
    Set-HPEGLUserAccountDetails -State "" -Street2 ""

    Removes the state and the secondary address line details from the HPE GreenLake user account while preserving all other existing settings.
    
    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    #>


    [CmdletBinding()]
    Param( 
        [String]$Firstname,
        [String]$Lastname,
        [String]$Organizationname,
        [String]$Street,
        [String]$Street2,        
        [String]$City,
        [String]$State,
        [String]$PostalCode,

        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country, 

        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeTimezone.enum -split "`n" -contains $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid timezone name!"
                }
            })]
        [String]$Timezone, 

        # Argument completer reqistered in library module 
        [ValidateScript({ 
                if ($HPESupportedLanguages[$_]   ) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid language name!"
                }
            })]
        [String]$Language,   

        [String]$PrimaryPhone,  
        [String]$Mobilephone,   
        [Switch]$WhatIf

    ) 

    Begin {
       
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $Uri = $HPEOnepassbaseURL + "/v2-update-user-okta/" + $HPEGreenLakeSession.username
        
        $SetUserAccountDetailsStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        try {
            $UserAccountDetails = Get-HPEGLUserAccountDetails -Raw 
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }



        # Build object for the output
        $objStatus = [pscustomobject]@{
        
            Email     = $HPEGreenLakeSession.username
            Status    = $Null
            Details   = $Null
            Exception = $Null
                
        }


        # Build payload

        $_Profile = @{ 
            email = $HPEGreenLakeSession.username
            login = $HPEGreenLakeSession.username
        }

        
        if ($Firstname) {
            $_Profile.firstName = $Firstname

        }

        if ($Lastname) {
            $_Profile.lastName = $Lastname

        }

        if ($PSBoundParameters.ContainsKey('Organizationname')) {
            $_Profile.hpeCompanyName = $Organizationname
            $_Profile.UserUpdatedGTSAttribute = "Y"

        }  

        if ($PSBoundParameters.ContainsKey('Street')) {
            $_Profile.streetAddress = $Street
            $_Profile.UserUpdatedGTSAttribute = "Y"

        }

        if ($PSBoundParameters.ContainsKey('Street2')) {
            $_Profile.hpeStreetAddress2 = $Street2
            $_Profile.UserUpdatedGTSAttribute = "Y"

        }

        if ($PSBoundParameters.ContainsKey('City')) {
            $_Profile.city = $City
            $_Profile.UserUpdatedGTSAttribute = "Y"
            
        }
        
        if ($PSBoundParameters.ContainsKey('State')) {
            $_Profile.state = $State
            $_Profile.UserUpdatedGTSAttribute = "Y"
            
        }
        
        if ($PSBoundParameters.ContainsKey('PostalCode')) {
            $_Profile.zipCode = $PostalCode
            $_Profile.UserUpdatedGTSAttribute = "Y"
            
        }
        
        if ($Country) {
            
            $CountryCode = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $Country | ForEach-Object const
        
            $_Profile.hpeCountryCode = $CountryCode
            $_Profile.countryCode = $CountryCode
            $_Profile.UserUpdatedGTSAttribute = "Y"

            if ($Language) {

                $LanguageSet = $HPESupportedLanguages[$language]
                $_Profile.locale = $LanguageSet + "_" + $CountryCode
            }
            else {
                $LanguageSet = $UserAccountDetails.profile.preferredLanguage
                $_Profile.locale = $LanguageSet + "_" + $CountryCode

            }

        
        }
        
        if ($Timezone) {
            $_Profile.hpeTimezone = $Timezone
            
        }
        
        if ($Language) {
            
            $LanguageSet = $HPESupportedLanguages[$language]
            $_Profile.preferredLanguage = $LanguageSet
            
            if ($CountryCode) {

                $_Profile.locale = $LanguageSet + "_" + $CountryCode
            }
            else {
                $CountryCode = $UserAccountDetails.profile.countryCode
                $_Profile.locale = $LanguageSet + "_" + $CountryCode

            }

        }

        if ($PSBoundParameters.ContainsKey('PrimaryPhone')) {
            $_Profile.primaryPhone = $PrimaryPhone

        }

        if ($PSBoundParameters.ContainsKey('Mobilephone')) {
            $_Profile.mobilePhone = $Mobilephone

        } 
        
        $payload = @{ 
            profile = $_Profile
            # sessionId = $HPEGreenLakesession.onepassSid  # Auto added by Invoke-HPEGLWebRequest
                    
        }

        $payload = ConvertTo-Json $payload -Depth 10 

             
        # User account details modification
        
        try {
            $Response = Invoke-HPEGLWebRequest -Method POST -Body $payload -Uri $Uri -whatifBoolean $WhatIf 
        
            if (-not $WhatIf) {
   
                $objStatus.Status = "Complete"
                $objStatus.Details = ($Response | ForEach-Object message)
            }
        
        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = ($Response | ForEach-Object message)
                $objStatus.Exception = $_.Exception.message 
            }
        }

        [void] $SetUserAccountDetailsStatus.add($objStatus)
   
    }

    end {

        if (-not $WhatIf) {

            if ($SetUserAccountDetailsStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to update the user preferences!"
          
            }

            Return $SetUserAccountDetailsStatus

        }
    }
}


Function Set-HPEGLUserAccountPassword {
    <#
    .SYNOPSIS
    Set HPE GreenLake user account password.

    .DESCRIPTION
    This Cmdlet can be used to set the HPE GreenLake user account password.       
    
    .PARAMETER currentpassword
    Your current user account password as a secure string.

    .PARAMETER newpassword
    Your new password to set as a secure string. It must meet the following requirements:
    - Contains at least one upper case letter
    - Contains at least one lower case letter
    - Contains at east one number (0-9)
    - Contains at least one symbol (eg. !@#$%^&)
    - Does not contain part of email
    - Does not contain first name
    - Does not contain last name
    - Does not contain common passwords
    - Does not match any of your last 24 passwords

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    $currentpassord = Read-Host -AsSecureString -Prompt "Enter your current password"
    $newpassord = Read-Host -AsSecureString -Prompt "Enter the new password to set"

    Set-HPEGLUserAccountPassword -CurrentPassword $currentpassord -NewPassword $newpassord

    Change the HPE GreenLake user account password to a new one for the currently connected user.

    .EXAMPLE
    $plainTextCurrentpassord = "np$$rPKHK39cU3e9T%SzR!!L"
    $secureCurrentPassword = ConvertTo-SecureString $plainTextCurrentpassord -AsPlainText -Force
    $plainTextNewpassword = "kLi7@zvzt4DyhUXUE8^32keY"
    $secureNewPassword = ConvertTo-SecureString $plainTextNewpassword -AsPlainText -Force

    Set-HPEGLUserAccountPassword -CurrentPassword $secureCurrentPassword -NewPassword $secureNewPassword

    Change the HPE GreenLake user account password to a new one for the currently connected user.

  
   #>
    [CmdletBinding()]
    Param( 
        [Parameter(Mandatory)]
        [SecureString]$CurrentPassword,
        [Parameter(Mandatory)]
        [SecureString]$NewPassword,
        [Switch]$WhatIf

    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $userid = (Get-HPEGLUserAccountDetails).id
        $Uri = $HPEOnepassbaseURL + "/v2-change-password-okta/" + $userid 
        
        $UserPasswordChangeStatus = [System.Collections.ArrayList]::new()
        
        $_OldPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($CurrentPassword))
        $_NewPassword = [Runtime.InteropServices.Marshal]::PtrToStringBSTR([Runtime.InteropServices.Marshal]::SecureStringToBSTR($NewPassword))

    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Build object for the output
        $objStatus = [pscustomobject]@{
        
            Email     = $HPEGreenLakeSession.username
            Status    = $Null
            Details   = $Null
            Exception = $Null
                
        }

        $upperCasePattern = '[A-Z]'
        $lowerCasePattern = '[a-z]'
        $numberPattern = '[0-9]'
        $symbolPattern = '[!@#$%^&*(),.?":{}|<>]'

        if ($_NewPassword -match $upperCasePattern -and `
                $_NewPassword -match $lowerCasePattern -and `
                $_NewPassword -match $numberPattern -and `
                $_NewPassword -match $symbolPattern) {
            
       
            $Payload = @{ 
                oldPassword = @{
                    value = $_oldPassword
                } 
                newPassword = @{
                    value = $_newPassword

                } 
            
            } | ConvertTo-Json -Depth 5


            "[{0}] Payload content: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Payload | Write-Verbose

            # User password modification
            
            try {
                [array]$Response = Invoke-HPEGLWebRequest -Method POST -Body $Payload -Uri $Uri -whatifBoolean $WhatIf 
            
                if (-not $WhatIf) {
    
                    $objStatus.Status = "Complete"
                    $objStatus.Details = ($Response | ForEach-Object message)
                }
            
            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = ($Response | ForEach-Object message)
                    $objStatus.Exception = $_.Exception.message 
                }
            }

            [void] $UserPasswordChangeStatus.add($objStatus)

        } 
        else {

            $errorMessage = "The new password does not meet the requirements, it should contain at least one upper case letter, at least one lower case letter, at least one number (0-9) and at least one symbol (eg. !@#$%^&)."
            
            throw $errorMessage
        }
   
    }
    end {

        if (-not $WhatIf) {

            if ($UserPasswordChangeStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to modify the user password!"
          
            }

            Return $UserPasswordChangeStatus
        }
    }
}

    
#EndRegion


#Region --- WORKSPACE ---


Function Get-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Retrieve workspace resource(s) from HPE GreenLake.

    .DESCRIPTION
    This Cmdlet returns a collection of workspace resources available in HPE GreenLake. The "current" column indicates the workspace you are currently connected to.
    
    .PARAMETER Name
    Specifies the name of a workspace to retrieve.

    .PARAMETER ShowCurrent
    Retrieves details of the workspace you are currently connected to.
    
    .PARAMETER ShowActivationKey
    Fetches the activation key of the workspace you are presently connected to.
    The activation key is necessary for connecting iLOs to Compute Ops Management.

    .PARAMETER WhatIf 
    Displays the raw REST API call that would be executed, without actually sending the request. Useful for understanding the native REST API interactions with GLP.

    .EXAMPLE
    Get-HPEGLWorkspace

    Retrieves all workspaces available on the HPE GreenLake platform.

    .EXAMPLE
    Get-HPEGLWorkspace -ShowCurrent

    Retrieves general information about the current HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLWorkspace -ShowActivationKey

    Retrieves the activation key for the current HPE GreenLake workspace, required for connecting iLOs to Compute Ops Management.
    #>

    
    [CmdletBinding(DefaultParameterSetName = "Default")]
    Param( 

        [Parameter (ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [Parameter (ParameterSetName = "Current")]
        [ValidateNotNullOrEmpty()]
        [Switch]$ShowCurrent,

        [Parameter (ParameterSetName = "ActivationKey")]
        [ValidateNotNullOrEmpty()]
        [Switch]$ShowActivationKey,

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command
    
        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = [System.Collections.ArrayList]::new()
        # $AllAccounts = [System.Collections.ArrayList]::new()

        $AllCollection = [System.Collections.ArrayList]::new()

        # GET WORKSPACES
        # Get 50 workspaces pagination
        $limit = 50

        $Uri = $WorkspacesListUri + "?offset=0&count_per_page=$limit"
      
        try {
            [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf 
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }

        if ($Collection.customers) {
            
            $AllCollection = $Collection
            
            $Numberofpages = [System.Math]::Ceiling(($Collection.pagination.total_count / $Collection.pagination.count_per_page))
            
            if ($Numberofpages -gt 1) {
                
                for ($i = 1; $i -lt $Numberofpages; $i++) {
                    
                    $Offset += $limit
                    
                    $Uri = $WorkspacesListUri + "?offset=$Offset&count_per_page=$limit"
                    
                    "[{0}] Request URI: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Uri | Write-Verbose
                    
                    try {
                        [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf 
                        
                        
                        $AllCollection += $Collection
                        
                    }
                    catch {    
                        $PSCmdlet.ThrowTerminatingError($_)
                        
                    }
                    
                }
                
            }
            
            $AllCollection = $AllCollection.customers
        }
            
        # GET CURRENT WORKSPACE
        
        $uri = $CurrentWorkspaceUri    
        # $Uri = $UserLoadAccountUri                                                    # gives nothing
        # $Uri = $WorkspacesUri + "/" + $HPEGreenLakeSession.workspaceId + "/contact"   # gives not enought info
        # $Uri = $WorkspacesUri + "/" + $HPEGreenLakeSession.workspaceId                # gives not enought info

        try {
            [Array]$Collection = Invoke-HPEGLWebRequest -Method GET -Uri $Uri -WhatIfBoolean $WhatIf 
            "[{0}] Content of current workspace: `n {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($Collection | Out-String) | Write-Verbose
            
            # Add platform_customer_id property
            $Collection | Add-Member -Type NoteProperty -Name "platform_customer_id" -Value $HPEGreenLakeSession.workspaceId

            # Add account_type (MSP or SANDALONE) from $HPEGLworkspaces generated by 'Connect-HPEGLWorkspace'
            $_AccountType = $HPEGLworkspaces | Where-Object platform_customer_id -eq $HPEGreenLakeSession.workspaceId | ForEach-Object account_type
            $Collection | Add-Member -Type NoteProperty -Name "account_type" -Value $_AccountType

            $AllCollection += $Collection
            
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
        
        
        # Add name property
        foreach ($_workspace in $AllCollection) {
            $_workspace | Add-Member -Type NoteProperty -Name "name" -Value $_workspace.company_name
        }


        "[{0}] Content of all workspaces: `n {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($AllCollection | Out-String) | Write-Verbose


        $CurrentWorkspace = $AllCollection | Where-Object platform_customer_id -eq $HPEGreenLakeSession.workspaceId


        if ($ShowActivationKey) {

            if ($HPEGreenLakeSession.workspaceId) {
                return $HPEGreenLakeSession.workspaceId
                
            }
            else {
        
                "[{0}] Error - No session found! Connect-HPEGL must be executed first!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                Write-Warning "Error - No session found! Connect-HPEGL must be executed first!"
                return
            }


        }
        elseif ($ShowCurrent) {      

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CurrentWorkspace -ObjectName "Workspace"    
            return $ReturnData  
                    
        }
        else {

            if ($Null -ne $AllCollection ) {
   
                if ($Name) {
    
                    $AllCollection = $AllCollection | Where-Object company_name -eq $Name
                }
        
                $ReturnData = Invoke-RepackageObjectWithType -RawObject $AllCollection -ObjectName "Workspace"    
    
                $ReturnData = $ReturnData | Sort-Object { $_.company_name }
        
                return $ReturnData  
            }
            else {
                
                return            
            }
        } 
    }
}


Function New-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Creates a workspace in HPE GreenLake.

    .DESCRIPTION
    This Cmdlet creates a workspace in HPE GreenLake.
            
    When you have an HPE account and log in to HPE GreenLake for the first time, you must create a workspace for your organization.

    .PARAMETER Name
    The name of the workspace. The name must be unique across all workspaces on the HPE GreenLake platform.

    .PARAMETER Type
    Specifies the workspace type to create. There are two types of workspace in HPE GreenLake:
        - Standard enterprise workspace: This is the standard workspace for teams wanting to use GreenLake services.
        - Managed service provider workspace: MSP workspaces are for service providers who manage their customers' services, devices, and subscriptions.

    .PARAMETER Street
    Specifies the postal street address of the workspace (optional).

    .PARAMETER Street2
    Specifies the secondary postal street address (Apt, suite, building, floor, etc.) of the workspace (optional).

    .PARAMETER Country
    Specifies the country of origin for the company.

    .PARAMETER City
    Specifies the city of the workspace (optional).

    .PARAMETER State
    Specifies the state of the workspace (optional).

    .PARAMETER PostalCode
    Specifies the postal code of the workspace (optional).

    .PARAMETER PhoneNumber
    Specifies the contact phone number of the workspace (optional).

    .PARAMETER Email
    Specifies the contact email address of the workspace (optional).

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    # This example demonstrates how to create a first workspace in an HPE GreenLake console.

    New-HPEGLWorkspace -Name "My_first_workspace_name" -Type "Managed Service Provider workspace" -Country "United States"
    Connect-HPEGL -Credential $credentials -Workspace "My_first_workspace_name"

    The first command creates a new 'Managed Service Provider' workspace named "My_first_workspace_name" in the United States. 
    If the cmdlet detects that this workspace is the first one created, it terminates the current HPE GreenLake session by logging out the user. 
    The next step is to reconnect using the `Connect-HPEGL` cmdlet with the credentials and the newly created workspace name.

    .EXAMPLE
    New-HPEGLWorkspace `
        -Name Velocity  `
        -Type 'Standard enterprise workspace' `
        -Email 'HenriPoincar@Velocity.com' `
        -Street "Theory of dynamical systems street" `
        -Street2 "Cosmos building" `
        -City Paris `
        -PostalCode 75000 `
        -Country France `
        -PhoneNumber +33612345678

    Creates a new HPE GreenLake workspace named "Velocity" using the standard enterprise workspace type and various details.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Workspace - Name of the workspace object attempted to be created 
        * Status - Status of the creation attempt (Failed for HTTP error return; Complete if the creation is successful; Warning if no action is needed) 
        * Details - More information about the status         
        * Exception: Information about any exceptions generated during the operation.
    #>
    
    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)]
        [String]$Name,

        [Parameter (Mandatory)]
        [ArgumentCompleter({
                param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
                $Items = @('Standard enterprise workspace', 'Managed Service Provider workspace')
                $filteredItems = $Items | Where-Object { $_ -like "$wordToComplete*" }
                return $filteredItems | ForEach-Object {
                    [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
                }
            })]
        [ValidateSet ('Standard enterprise workspace', 'Managed Service Provider workspace')]
        [String]$Type,

        
        [String]$Street,
        [String]$Street2,
        [String]$City,
        [String]$State,
        [String]$PostalCode,
        
        [Parameter (Mandatory)]
        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,

        [String]$PhoneNumber,

        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,       

        [Switch]$WhatIf
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
                
        $Uri = $NewWorkspaceUri
        
        $WorkspaceCreationStatus = [System.Collections.ArrayList]::new()
        
        
    }
    
    Process {
        
        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Check workspaces only supported if at least one workspace exists in HPE GreenLake (so if $HPEGreenLakeSession.workspaceId exists is a good if condition) 
        if ( $HPEGreenLakeSession.workspaceId) {
            
            try {
                $Workspace = Get-HPEGLWorkspace -name $Name
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
            
        }

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Workspace = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
          
        }

        if ($Workspace -and $HPEGreenLakeSession.workspaceId) {
            
            # Must return a message if Workspace found
            "[{0}] Workspace '{1}' found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

            if ($WhatIf) {
                $ErrorMessage = "Workspace '{0}' already exists!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Warning"
                $objStatus.Details = "This workspace already exists!"
            }

            
        }
        else {

            # $User = Get-HPEGLUser -Email $HPEGreenLakeSession.username

            $CountryCode = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $Country | ForEach-Object const

            if ($Type -eq "Managed Service Provider workspace") {
                $WorkspaceType = "MSP"
            }
            elseif ($Type -eq "Standard enterprise workspace") {
                $WorkspaceType = "STANDALONE"
                
            }

            # Create payload  

            $Payload = [PSCustomObject]@{
                workspace_type = $WorkspaceType
                company_name   = $Name
                created_by     = $HPEGreenLakeSession.username
                email          = $Email
                phone_number   = $PhoneNumber
                address        = @{
                    street_address   = $Street
                    street_address_2 = $Street2
                    city             = $City
                    state_or_region  = $State
                    zip              = $PostalCode
                    country_code     = $CountryCode
                }
            } | ConvertTo-Json -Depth 5


            # Create workspace

            try {
                $Response = Invoke-HPEGLWebRequest -Uri $Uri -method 'POST' -body $Payload -WhatIfBoolean $WhatIf 

                if (-not $WhatIf) {

                    "[{0}] Workspace '{1}' successfully created!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

                    # When the first workspace is created, it is necessary to run 'Connect-HPEGL -workspace <workspace_name>' to access the first new workspace.
                    if (-not $HPEGreenLakeSession.workspaceId) {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Workspace successfully created! Session disconnected, you must run `Connect-HPEGL -workspace <workspace_name>` to access the new workspace."
                        
                    }
                    else {
                        $objStatus.Status = "Complete"
                        $objStatus.Details = "Workspace successfully created!"
                    }

                }


            }
            catch {

                if (-not $WhatIf) {
                    $objStatus.Status = "Failed"
                    $objStatus.Details = "Workspace cannot be created!"
                    $objStatus.Exception = $_.Exception.message 

                }
            }
           
        }

        [void] $WorkspaceCreationStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($WorkspaceCreationStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures during the attempt to create the workspace!"
          
            }

            # Must disconnect if this is the first workspace beeing created
            if (-not $HPEGreenLakeSession.workspaceId) {
                Disconnect-HPEGL 
            }

            Return $WorkspaceCreationStatus
        }


    }
}


# This cmdlet is deprecated. Use Connect-HPEGLWorkspace instead.
<# 
Function Use-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Switch between HPE GreenLake workspaces.
    
    .DESCRIPTION
    When you have multiple HPE GreenLake workspaces, you can use this cmdlet to switch between them and manage them independently.
        
    .PARAMETER Name 
    Name of the HPE GreenLake workspace.

    .PARAMETER WhatIf
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Use-HPEGLWorkspace -Name "DreamCompany"

    Switch from the current workspace to the 'DreamCompany' HPE GreenLake workspace.

    .INPUTS
    None. You cannot pipe objects to this Cmdlet.

    .OUTPUTS
    System.Collections.ArrayList
        When an error occurs, a custom status object or array of objects containing the following PsCustomObject keys is displayed:  
        * Workspace - Name of the workspace object attempted to be set 
        * Status - Status of the modification attempt (Failed for http error return; Complete if the workspace switch is successful; Warning if no action is needed) 
        * Details - More information about the status         
        * Exception: Information about any exceptions generated during the operation.

    HPEGreenLakeSession
        When a valid connection is established with a new HPE GreenLake workspace, ${Global:HPEGreenLakeSession} connection tracker variable is displayed.  

    
   

    [CmdletBinding()]
    Param( 

        [Parameter (Mandatory)]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [Switch]$WhatIf
    ) 


    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $WorkspaceSwitchStatus = [System.Collections.ArrayList]::new()

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Check if the workspace exists
       
        try {
            $Workspace = Get-HPEGLWorkspace -Name $Name
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }


        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Workspace = $Name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                  
        }

        if (-not $Workspace) {
            # Must return a message if workspace not found
            "[{0}] Workspace '{1}' not found!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name | Write-Verbose

            if ($Whatif) {
                $ErrorMessage = "Workspace '{0}' cannot be found in HPE GreenLake!" -f $Name
                Write-warning $ErrorMessage
                return
            }
            else {
                $objStatus.Status = "Failed"
                $objStatus.Details = "Workspace cannot be found!"
                
            }
  
        }
        else {       

            # Check if the workspace is not the current one
            try {
                $CurrentWorkspace = Get-HPEGLWorkspace -ShowCurrent  
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
            }
        
            if ( $CurrentWorkspace.company_name -eq $Name  ) {
                # Must return a message if workspace is already in use
                "[{0}] You are already connected to the workspace '{1}'!" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Name 

                if ($Whatif) {
                    $ErrorMessage = "You are already connected to the '{0}' workspace!" -f $Name
                    Write-warning $ErrorMessage
                    return
                }
                else {
                    $objStatus.Status = "Warning"
                    $objStatus.Details = "You are already connected to this workspace!"
                    
                }


      
            }
            else {                

                $PlatformCustomerId = $Workspace.platform_customer_id

                $Url = $UserLoadAccountUri + $PlatformCustomerId
                $Method = "GET"

                $headers = @{} 
                $headers["Accept"] = "application/json"
                $headers["Authorization"] = "Bearer $($HPEGreenLakeSession.oauth2AccessToken)"

                $NewSession = $HPEGreenLakeSession.session


                if ($WhatIf) {

                    if ( -not $Body ) {
                        $Body = 'No Body'
                    }
                    write-warning "You have selected the What-IF option, so the call will not be made to HPE GreenLake console, `ninstead you will see a preview of the RestAPI call"
                    Write-host "The URI for this call will be " 
                    write-host  "$Url" -foregroundcolor green
                    Write-host "The Method of this call will be "
                    write-host -foregroundcolor green $Method
    
                    Write-host "The Header for this call will be :"
                    write-host -foregroundcolor green ($Headers | ConvertTo-JSON | Out-String)  

                }
                else {

                    try {
         
                        # Load CCS workspace account to get cookies session values for CCS API authentication 

                        "[{0}] Load CCS workspace account to get cookies session values for CCS API authentication" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        "[{0}] About to execute '{1}' request to: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Method, $url  | Write-Verbose

                        $response = Invoke-WebRequest -Method $Method -Uri $url -Headers $headers -WebSession $NewSession  | Out-Null
                        
                        "[{0}] Received status code response: '{1}' - Description: '{2}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response.StatusCode, $InvokeReturnData.StatusDescription | Write-verbose
                        "[{0}] Raw response: `n{1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $response | Write-verbose
           
                        "[{0}] CCS workspace account session - Cookies content:" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose
           
                        $cookies = $NewSession.Cookies.GetCookies($url)
                        foreach ($cookie in $cookies) { 
                            Write-Verbose "$($cookie.name) = $($cookie.value)"
                        }

               
                        "[{0}] CCS workspace session creation successful!" -f $MyInvocation.InvocationName.ToString().ToUpper() | Write-Verbose

                        $global:HPEGreenLakeSession.workspaceId = $PlatformCustomerId
                        $global:HPEGreenLakeSession.workspace = $Name 
                        $global:HPEGreenLakeSession.session = $NewSession

                        return $global:HPEGreenLakeSession
            
                    }
                    catch {         

                        if ($_.ErrorDetails.Message) {
                            $ErrorMsg = "Error: '{0}' - Error details: '{1}'" -f $_.Exception.Message, $_.ErrorDetails 
 
                        }
                        else {
                            $ErrorMsg = "Error: '{0}'" -f $_.Exception.Message | Write-Warning
 
                        }

            
                        "[{0}] CCS workspace session creation - Headers content: '{1}'" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($headers | Out-String) | Write-Verbose

                        if (-not $WhatIf) {
                            $objStatus.Status = "Failed"
                            $objStatus.Details = $ErrorMsg
                            $objStatus.Exception = $_.Exception.message 
                        }
            
                    }
                }
            }
        }

        [void] $WorkspaceSwitchStatus.add($objStatus)

    }

    end {

        if (-not $WhatIf) {

            if ($WorkspaceSwitchStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to use this workspace!"
          
            }

            Return $WorkspaceSwitchStatus
        }


    }
}
#>


Function Set-HPEGLWorkspace {
    <#
    .SYNOPSIS
    Updates the current workspace details.

    .DESCRIPTION
    Updates general information about the HPE GreenLake workspace to which you are currently connected. If you omit any parameter, the cmdlet retains the current settings for those fields and only updates the provided parameters.

    .PARAMETER NewName 
    Specifies the new name of the workspace. The new name must be unique across all workspaces on the HPE GreenLake platform.

    .PARAMETER Street
    Specifies the postal street address of the workspace.

    .PARAMETER Street2
    Specifies the secondary postal street address (Apt, suite, building, floor, etc.) of the workspace.

    .PARAMETER Country
    Specifies the country of origin for the company.

    .PARAMETER City
    Specifies the city of the workspace.

    .PARAMETER State
    Specifies the state of the workspace.

    .PARAMETER PostalCode
    Specifies the postal code of the workspace.

    .PARAMETER PhoneNumber
    Specifies the contact phone number of the workspace.

    .PARAMETER Email
    Specifies the contact email address of the workspace. 

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.

    .EXAMPLE
    Set-HPEGLWorkspace `
        -Street "Theory of Dynamical Systems Street" `
        -City Heaven `
        -PostalCode 77777 `
        -Country France `
        -PhoneNumber +33612345678

    Sets the street address, city, postal code, country, and phone number information of the currently connected HPE GreenLake workspace.

    .EXAMPLE
    Set-HPEGLWorkspace -State "" -Street2 ""

    Removes the state and the secondary address line details from the currently connected HPE GreenLake workspace while preserving all other existing settings.

    .INPUTS
    No pipeline input is supported.

    .OUTPUTS
    System.Collections.ArrayList
    A custom status object or array of objects containing the following PsCustomObject keys:  
        * Workspace - Name of the workspace object attempted to be updated.
        * Status - Status of the modification attempt (Failed for HTTP error return; Complete if the workspace update is successful).
        * Details - More information about the status.
        * Exception - Information about any exceptions generated during the operation.
    #>


    [CmdletBinding()]
    Param( 
        [ValidateNotNullOrEmpty()]
        [String]$NewName,

        [String]$Street,
        [String]$Street2,
        [String]$City,
        [String]$State,
        [String]$PostalCode,

        # Argument completer reqistered in Connect-HPEGL 
        [ValidateScript({ 
                if ($HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $_) {
                    $True
                }
                else {
                    Throw "'$_' is not a valid country name!"
                }
            })]
        [String]$Country,

        [String]$PhoneNumber,

        [validatescript({ if ($_ -as [Net.Mail.MailAddress]) { $true } else { Throw "The Parameter value is not an email address. Please correct the value and try again." } })]
        [String]$Email,    

        [Switch]$WhatIf
       
    ) 

    Begin {

        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose

        $SetWorkspaceStatus = [System.Collections.ArrayList]::new()
        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        # Check current workspace

        try {
            $WorkspaceDetails = Get-HPEGLWorkspace -ShowCurrent
           
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
            
        }

        $Uri = $CurrentWorkspaceUri

        # Build object for the output
        $objStatus = [pscustomobject]@{
  
            Workspace = $WorkspaceDetails.company_name
            Status    = $Null
            Details   = $Null
            Exception = $Null
                  
        }

        # Conditionally add properties
        if ($NewName) {
            $Name = $NewName
        }
        else {
            $Name = $WorkspaceDetails.company_name
        }
       
        if (-not $PSBoundParameters.ContainsKey('Street')) {
	    
            if ($WorkspaceDetails.address.street_address) {
                          
                $Street = $WorkspaceDetails.address.street_address
            }
            else {
                $Street = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('Street2')) {
	    
            if ($WorkspaceDetails.address.street_address_2) {
                          
                $Street2 = $WorkspaceDetails.address.street_address_2

            }
            else {
                $Street2 = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('State')) {
	    
            if ($WorkspaceDetails.address.state_or_region) {
                          
                $State = $WorkspaceDetails.address.state_or_region

            }
            else {
                $State = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('PostalCode')) {
	    
            if ($WorkspaceDetails.address.zip) {
                          
                $PostalCode = $WorkspaceDetails.address.zip

            }
            else {
                $PostalCode = $Null
            }
        }

        if (-not $PSBoundParameters.ContainsKey('City')) {
	    
            if ($WorkspaceDetails.address.city) {
                          
                $City = $WorkspaceDetails.address.city

            }
            else {
                $City = $Null
            }
        }
 
        if (-not $PSBoundParameters.ContainsKey('Country')) {
	    
            if ($WorkspaceDetails.address.country_code) {
                          
                $CountryCode = $WorkspaceDetails.address.country_code

            }

        }
        else {
            $CountryCode = $HPEGLSchemaMetadata.definitions.custom.properties.hpeCountryCode.oneOf | Where-Object title -eq $Country | ForEach-Object const
        }
        
        if (-not $PSBoundParameters.ContainsKey('PhoneNumber')) {
	    
            if ($WorkspaceDetails.phone_number) {
                          
                $PhoneNumber = $WorkspaceDetails.phone_number

            }
            else {
                $PhoneNumber = $Null
            }

        }

        if (-not $PSBoundParameters.ContainsKey('Email')) {
	    
            if ($WorkspaceDetails.email) {
                          
                $Email = $WorkspaceDetails.email

            }
            else {
                $Email = $Null
            }

        }

        $Payload = [PSCustomObject]@{
            company_name = $Name
            email        = $Email
            phone_number = $PhoneNumber
            address      = @{
                street_address   = $Street
                street_address_2 = $Street2
                city             = $City
                state_or_region  = $State
                zip              = $PostalCode
                country_code     = $CountryCode
            }
        } | ConvertTo-Json -Depth 5


        # Current workspace modification
        try {
        
            $Response = Invoke-HPEGLWebRequest -Method 'PUT' -Body $Payload -Uri $Uri -whatifBoolean $WhatIf
                         
            if (-not $WhatIf) {
                $objStatus.Status = "Complete"
                $objStatus.Details = ($Response | ForEach-Object message)
            }

        }
        catch {

            if (-not $WhatIf) {
                $objStatus.Status = "Failed"
                $objStatus.Details = ($Response | ForEach-Object message)
                $objStatus.Exception = $_.Exception.message 
            }
        }    

        [void] $SetWorkspaceStatus.add($objStatus)
        

    }

    end {

        if (-not $WhatIf) {

            if ($SetWorkspaceStatus | Where-Object { $_.Status -eq "Failed" }) {
  
                write-error "One or more failures to update the workspace details!"
          
            }

            Return $SetWorkspaceStatus
        }


    }
}

#EndRegion


#Region --- LOGS ---

Function Get-HPEGLAuditLog {
    <#
    .SYNOPSIS
    View changes and processes within an HPE GreenLake workspace.

    .DESCRIPTION
    This Cmdlet retrieves the last 50 audit logs from the HPE GreenLake platform by default or from a service instance. 
    The audit logs can be filered by category with or without limit. Additionally, you can use a search string to further narrow down the audit logs.

   .PARAMETER ServiceName 
    An optional parameter to filter audit logs for a specific service. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER ServiceRegion
    An optional parameter to filter audit logs for a specific region of a service. This value can be retrieved using 'Get-HPEGLService -ShowProvisioned'.

    .PARAMETER SearchString 
    An optional parameter to filter audit logs using a search string, such as an email address, IP address, etc.

    .PARAMETER Category 
    An optional parameter to filter audit logs by category. A predefined incomplete list of HPE GreenLake and Compute Ops Management categories is provided.

    .PARAMETER Limit 
    A parameter to specify the number of audit logs to return.

    .PARAMETER NoLimit
    A parameter to return all audit logs without any limit.

    .PARAMETER WhatIf 
    Shows the raw REST API call that would be made to GLP instead of sending the request. This option is useful for understanding the inner workings of the native REST API calls used by GLP.
  
    .EXAMPLE
    Get-HPEGLAuditLog 

    Retrieves the last fifty audit logs from the HPE GreenLake workspace.

    .EXAMPLE
    Get-HPEGLAuditLog -ServiceName 'Compute Ops Management' -ServiceRegion 'eu-central'

    Retrieves the last fifty audit logs for the 'Compute Ops Management' service in the 'eu-central' region.

    .EXAMPLE
    Get-HPEGLAuditLog -Category 'Subscription Management'

    Retrieves the last fifty audit logs for the 'Subscription Management' category.

    .EXAMPLE
    Get-HPEGLAuditLog -Category Authorization -Limit 5

    Retrieves the last five audit logs for the "Authorization" category.

    .EXAMPLE
    Get-HPEGLAuditLog -SearchString Leonhard.Euler@mathematician.com -Category 'Customer Management'

    Retrieves the last fifty audit logs for Leonhard Euler in the "Customer Management" category.

 
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param( 

        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Service')]
        [Alias("Name")]
        [String]$ServiceName,
 
        [Parameter (Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Service')]
        [Alias("Region")]
        [String]$ServiceRegion,

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (ParameterSetName = 'Service')]
        [String]$SearchString,

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (ParameterSetName = 'Service')]
        [validateSet(
            "API Gateway",
            "App Management",
            "Authorization",
            "Configuration",
            "Credential Management",
            "Customer Management",
            "Delete Device",
            "Delete Fingerprint",
            "Device Direct",
            "Device Management",
            "External Services",
            "Federated User Activity",
            "Firmware",
            "Firmware Registry",
            "Gateway Management",
            "General Settings",
            "Global Trade Export License Check",
            "Groups",
            "Inventory",
            "Lifecycle",
            "Licensing",
            "Location Management",
            "Management",
            "Network Device",
            "Notifications Service",
            "Order Processor",
            "Orders",
            "Organization",        
            "Others",
            "Power",
            "Rbac",
            "Reboot",
            "Report Management",
            "Reports",
            "SAML SSO",
            "Schedules",
            "Server Settings",
            "Settings",
            "Subscription",
            "Subscription Management",
            "System Setup",
            "User Activity",
            "User and Customer Account",
            "User Management",
            "User Personalisation"
        )]
        [String]$Category,
        
        [Parameter (ParameterSetName = 'Default')]
        [Parameter (ParameterSetName = 'Service')]
        [Int]$Limit,

        [Parameter (ParameterSetName = 'Default')]
        [Parameter (ParameterSetName = 'Service')]
        [switch]$NoLimit,
              
        [Switch]$WhatIf

    ) 
            

    Begin {
        
        $Caller = (Get-PSCallStack)[1].Command

        "[{0}] Called from: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), $Caller | Write-Verbose
    
        $Uri = $AuditLogsUri
        
        $Services = Get-HPEGLService -ShowProvisioned 

        if ($ServiceName) {

            try {
                $Service = $Services | Where-Object { $_.Name -eq $ServiceName -and $_.Region -eq $ServiceRegion }
                
                if (-not $Service) {
                    $ErrorMessage = "Service '{0}' in region '{1}' cannot be found in the HPE GreenLake workspace!" -f $ServiceName, $ServiceRegion
                    Write-warning $ErrorMessage  
                    break
                }

                $Slug = $Service.slug
                $application_customer_id = $Service.application_customer_id
                
            }
            catch {
                $PSCmdlet.ThrowTerminatingError($_)
                
            }
            

        }

      
        if ($category) {
            $Uri = $Uri + "&category=$Category"        
        }

        if ($SearchString) {
            $Uri = $Uri + "&_all=$SearchString&sort_by=audit_created_at&sort_dir=desc"
        }

        if ($ServiceName) {
            $Uri = $Uri + "&app_slug=$Slug&&application_customer_id=$application_customer_id"        
        }

        if ($Limit ) {
            $Uri = $Uri + "&limit=$Limit"
        }
        elseif ($NoLimit) {
            $Uri = $Uri
        }
        else {
            $Uri = $Uri + "&limit=50"
        }

        
    }

    Process {

        "[{0}] Bound PS Parameters: {1}" -f $MyInvocation.InvocationName.ToString().ToUpper(), ($PSBoundParameters | out-string) | Write-Verbose

        $ReturnData = @()
        
        try {
            [array]$Collection = Invoke-HPEGLWebRequest -Method Get -Uri $Uri -whatifBoolean $WhatIf
        }
        catch {
            $PSCmdlet.ThrowTerminatingError($_)
        }
   
   
        if ($Null -ne $Collection.audits) {

            $CollectionList = $Collection.audits 
          
            foreach ($Item in $CollectionList) {

                $_Region = ($Services | Where-Object application_customer_id -eq $Item.application_customer_id).region

                $_Name = ($Services | Where-Object application_customer_id -eq $Item.application_customer_id).name
          
                if (-not $_Name) {
                    $_Name = "HPE GreenLake"
                }
                
                $Item | Add-Member -MemberType NoteProperty -Name 'region' -Value $_Region
                $Item | Add-Member -MemberType NoteProperty -Name 'application_name' -Value $_Name 
            }
            

            $ReturnData = Invoke-RepackageObjectWithType -RawObject $CollectionList -ObjectName "Auditlog"    

            $ReturnData = $ReturnData | Sort-Object -Descending { $_.audit_created_at }

            return $ReturnData 
        }
        else {

            return
            
        }
 
    }
}


#EndRegion
#EndRegion



#---------------------------------------------------------
#Region Set $HPEGLLibraryVersion Global variable

# $versionMajorMinorBuild = "{0}.{1}.{2}" -f $ModuleVersion.Major, $ModuleVersion.Minor, $ModuleVersion.Build

$LibraryVersion = New-Object -TypeName PSObject -Property @{
    LibraryVersion = $ModuleVersion
    
}

$LibraryVersion = Invoke-RepackageObjectWithType -RawObject $LibraryVersion -ObjectName "Library.Version"     

New-Variable -Name HPEGLLibraryVersion -Scope Global -Value $LibraryVersion -ErrorAction SilentlyContinue



# ------------------------------------------------------------------------------------------------------------------------------------------------


#EndRegion



# SIG # Begin signature block
# MIIsFgYJKoZIhvcNAQcCoIIsBzCCLAMCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCC14w57if7gMyU1
# aDyOAZZ6twBo11bK5jgEj4eqfPezRKCCEXYwggVvMIIEV6ADAgECAhBI/JO0YFWU
# jTanyYqJ1pQWMA0GCSqGSIb3DQEBDAUAMHsxCzAJBgNVBAYTAkdCMRswGQYDVQQI
# DBJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAOBgNVBAcMB1NhbGZvcmQxGjAYBgNVBAoM
# EUNvbW9kbyBDQSBMaW1pdGVkMSEwHwYDVQQDDBhBQUEgQ2VydGlmaWNhdGUgU2Vy
# dmljZXMwHhcNMjEwNTI1MDAwMDAwWhcNMjgxMjMxMjM1OTU5WjBWMQswCQYDVQQG
# EwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMS0wKwYDVQQDEyRTZWN0aWdv
# IFB1YmxpYyBDb2RlIFNpZ25pbmcgUm9vdCBSNDYwggIiMA0GCSqGSIb3DQEBAQUA
# A4ICDwAwggIKAoICAQCN55QSIgQkdC7/FiMCkoq2rjaFrEfUI5ErPtx94jGgUW+s
# hJHjUoq14pbe0IdjJImK/+8Skzt9u7aKvb0Ffyeba2XTpQxpsbxJOZrxbW6q5KCD
# J9qaDStQ6Utbs7hkNqR+Sj2pcaths3OzPAsM79szV+W+NDfjlxtd/R8SPYIDdub7
# P2bSlDFp+m2zNKzBenjcklDyZMeqLQSrw2rq4C+np9xu1+j/2iGrQL+57g2extme
# me/G3h+pDHazJyCh1rr9gOcB0u/rgimVcI3/uxXP/tEPNqIuTzKQdEZrRzUTdwUz
# T2MuuC3hv2WnBGsY2HH6zAjybYmZELGt2z4s5KoYsMYHAXVn3m3pY2MeNn9pib6q
# RT5uWl+PoVvLnTCGMOgDs0DGDQ84zWeoU4j6uDBl+m/H5x2xg3RpPqzEaDux5mcz
# mrYI4IAFSEDu9oJkRqj1c7AGlfJsZZ+/VVscnFcax3hGfHCqlBuCF6yH6bbJDoEc
# QNYWFyn8XJwYK+pF9e+91WdPKF4F7pBMeufG9ND8+s0+MkYTIDaKBOq3qgdGnA2T
# OglmmVhcKaO5DKYwODzQRjY1fJy67sPV+Qp2+n4FG0DKkjXp1XrRtX8ArqmQqsV/
# AZwQsRb8zG4Y3G9i/qZQp7h7uJ0VP/4gDHXIIloTlRmQAOka1cKG8eOO7F/05QID
# AQABo4IBEjCCAQ4wHwYDVR0jBBgwFoAUoBEKIz6W8Qfs4q8p74Klf9AwpLQwHQYD
# VR0OBBYEFDLrkpr/NZZILyhAQnAgNpFcF4XmMA4GA1UdDwEB/wQEAwIBhjAPBgNV
# HRMBAf8EBTADAQH/MBMGA1UdJQQMMAoGCCsGAQUFBwMDMBsGA1UdIAQUMBIwBgYE
# VR0gADAIBgZngQwBBAEwQwYDVR0fBDwwOjA4oDagNIYyaHR0cDovL2NybC5jb21v
# ZG9jYS5jb20vQUFBQ2VydGlmaWNhdGVTZXJ2aWNlcy5jcmwwNAYIKwYBBQUHAQEE
# KDAmMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5jb21vZG9jYS5jb20wDQYJKoZI
# hvcNAQEMBQADggEBABK/oe+LdJqYRLhpRrWrJAoMpIpnuDqBv0WKfVIHqI0fTiGF
# OaNrXi0ghr8QuK55O1PNtPvYRL4G2VxjZ9RAFodEhnIq1jIV9RKDwvnhXRFAZ/ZC
# J3LFI+ICOBpMIOLbAffNRk8monxmwFE2tokCVMf8WPtsAO7+mKYulaEMUykfb9gZ
# pk+e96wJ6l2CxouvgKe9gUhShDHaMuwV5KZMPWw5c9QLhTkg4IUaaOGnSDip0TYl
# d8GNGRbFiExmfS9jzpjoad+sPKhdnckcW67Y8y90z7h+9teDnRGWYpquRRPaf9xH
# +9/DUp/mBlXpnYzyOmJRvOwkDynUWICE5EV7WtgwggXhMIIESaADAgECAhEA83w3
# gf2o8H0GHWXSUybisjANBgkqhkiG9w0BAQwFADBUMQswCQYDVQQGEwJHQjEYMBYG
# A1UEChMPU2VjdGlnbyBMaW1pdGVkMSswKQYDVQQDEyJTZWN0aWdvIFB1YmxpYyBD
# b2RlIFNpZ25pbmcgQ0EgUjM2MB4XDTIyMDYwNzAwMDAwMFoXDTI1MDYwNjIzNTk1
# OVowdzELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVRleGFzMSswKQYDVQQKDCJIZXds
# ZXR0IFBhY2thcmQgRW50ZXJwcmlzZSBDb21wYW55MSswKQYDVQQDDCJIZXdsZXR0
# IFBhY2thcmQgRW50ZXJwcmlzZSBDb21wYW55MIIBojANBgkqhkiG9w0BAQEFAAOC
# AY8AMIIBigKCAYEA3nXTSeo4pVdKrf7RlSd2tDEbwbNsAuOo9sKzn6H1kVFshc5b
# ALe9NHmnAsdDFhmcriSrlCPsKekOpmBzUY+hjMTv7eF99bR1rA5tvQQvEdkGkzyN
# 2ZpFc2h7WiImjuGapcXXu8YpSm9seDgSbKnLtS/WAer5K/x30t4BBXm4j7nScY6E
# 0V3ZwkueiVNq0uiUjmGXxqzDgPQmP4H9Gt5mfrQdmpFMccfv9KC4TbbT0m0WHZte
# ebUIBJCWyJQHNJZES9oytn10QoSeBxclInXGzG7q6PIkyXSds7RsBm25gmBRvrm8
# Uf33JnfBEyyd6AH0nfSUVylOYlrLexniH5Kdrq96spk9Wj+7pq5fSXcjULZSunMN
# 6gIrQG+d7NvxuaUkjwDx+3k/A0daJc4hiHcOJa4kjK2SmQ3e27Z4FsiTUWk88C+t
# 1yya6Q/KmT8DcTfHOBpyF0mDEPJYsU5X/jquFRNrG6fzDuKkse3MEbc641HDap/n
# Ldwm7gztHt/IFc4JAgMBAAGjggGJMIIBhTAfBgNVHSMEGDAWgBQPKssghyi47G9I
# ritUpimqF6TNDDAdBgNVHQ4EFgQU9ol95gfMeTfyaXeTTny+MR/YG/UwDgYDVR0P
# AQH/BAQDAgeAMAwGA1UdEwEB/wQCMAAwEwYDVR0lBAwwCgYIKwYBBQUHAwMwSgYD
# VR0gBEMwQTA1BgwrBgEEAbIxAQIBAwIwJTAjBggrBgEFBQcCARYXaHR0cHM6Ly9z
# ZWN0aWdvLmNvbS9DUFMwCAYGZ4EMAQQBMEkGA1UdHwRCMEAwPqA8oDqGOGh0dHA6
# Ly9jcmwuc2VjdGlnby5jb20vU2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nQ0FSMzYu
# Y3JsMHkGCCsGAQUFBwEBBG0wazBEBggrBgEFBQcwAoY4aHR0cDovL2NydC5zZWN0
# aWdvLmNvbS9TZWN0aWdvUHVibGljQ29kZVNpZ25pbmdDQVIzNi5jcnQwIwYIKwYB
# BQUHMAGGF2h0dHA6Ly9vY3NwLnNlY3RpZ28uY29tMA0GCSqGSIb3DQEBDAUAA4IB
# gQAdJNlWSujYBAZ1mdIy0Q66db+4YWP+FbaUiQWNqbfi30s7Ctg70/2t0n1QDDkg
# hWHFM2kcdy1PGh4fOMeRSfIhsTre54YcsNe5wELSJQbvN8lfPYXMThb3n4/BXxoD
# 1zx5rmcwGPXVF5oIZJub5FzMNVpECjy8C42skTFXv4eB/yEHKI/BWsjvnkldkNEG
# 3v8Y/23gGHruFy2qVW50xyH8zsjd+gIStVojyhPJ0jgtZvXgxwVJYwBGJwgYOO+q
# pRnuUp4Bse+KlA8Ttm+Q4Nx8qOJYBE44Qi8BUXwoEDs26pFIyNuszBFuzeyL4Wkx
# y7srdCWYCIyLbD5b7WFbhd2ieK2Mg+WtZJNB3t8ZpdLLkH4vPmZGIo4FkeAST1I1
# XtKp5PqLhzPEZbsY9JL8i6XvedCL8cHe1zVX3eM9EPL/jxw9kLcFrFN+DQ1wIHCc
# gEH7/RYXc9abuGcC2XpP4YbzSMWbff8X/Pgw8HA8aSRhctF+bz7dI+/REmlDJtdP
# T6wwggYaMIIEAqADAgECAhBiHW0MUgGeO5B5FSCJIRwKMA0GCSqGSIb3DQEBDAUA
# MFYxCzAJBgNVBAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxLTArBgNV
# BAMTJFNlY3RpZ28gUHVibGljIENvZGUgU2lnbmluZyBSb290IFI0NjAeFw0yMTAz
# MjIwMDAwMDBaFw0zNjAzMjEyMzU5NTlaMFQxCzAJBgNVBAYTAkdCMRgwFgYDVQQK
# Ew9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMTIlNlY3RpZ28gUHVibGljIENvZGUg
# U2lnbmluZyBDQSBSMzYwggGiMA0GCSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCb
# K51T+jU/jmAGQ2rAz/V/9shTUxjIztNsfvxYB5UXeWUzCxEeAEZGbEN4QMgCsJLZ
# UKhWThj/yPqy0iSZhXkZ6Pg2A2NVDgFigOMYzB2OKhdqfWGVoYW3haT29PSTahYk
# wmMv0b/83nbeECbiMXhSOtbam+/36F09fy1tsB8je/RV0mIk8XL/tfCK6cPuYHE2
# 15wzrK0h1SWHTxPbPuYkRdkP05ZwmRmTnAO5/arnY83jeNzhP06ShdnRqtZlV59+
# 8yv+KIhE5ILMqgOZYAENHNX9SJDm+qxp4VqpB3MV/h53yl41aHU5pledi9lCBbH9
# JeIkNFICiVHNkRmq4TpxtwfvjsUedyz8rNyfQJy/aOs5b4s+ac7IH60B+Ja7TVM+
# EKv1WuTGwcLmoU3FpOFMbmPj8pz44MPZ1f9+YEQIQty/NQd/2yGgW+ufflcZ/ZE9
# o1M7a5Jnqf2i2/uMSWymR8r2oQBMdlyh2n5HirY4jKnFH/9gRvd+QOfdRrJZb1sC
# AwEAAaOCAWQwggFgMB8GA1UdIwQYMBaAFDLrkpr/NZZILyhAQnAgNpFcF4XmMB0G
# A1UdDgQWBBQPKssghyi47G9IritUpimqF6TNDDAOBgNVHQ8BAf8EBAMCAYYwEgYD
# VR0TAQH/BAgwBgEB/wIBADATBgNVHSUEDDAKBggrBgEFBQcDAzAbBgNVHSAEFDAS
# MAYGBFUdIAAwCAYGZ4EMAQQBMEsGA1UdHwREMEIwQKA+oDyGOmh0dHA6Ly9jcmwu
# c2VjdGlnby5jb20vU2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nUm9vdFI0Ni5jcmww
# ewYIKwYBBQUHAQEEbzBtMEYGCCsGAQUFBzAChjpodHRwOi8vY3J0LnNlY3RpZ28u
# Y29tL1NlY3RpZ29QdWJsaWNDb2RlU2lnbmluZ1Jvb3RSNDYucDdjMCMGCCsGAQUF
# BzABhhdodHRwOi8vb2NzcC5zZWN0aWdvLmNvbTANBgkqhkiG9w0BAQwFAAOCAgEA
# Bv+C4XdjNm57oRUgmxP/BP6YdURhw1aVcdGRP4Wh60BAscjW4HL9hcpkOTz5jUug
# 2oeunbYAowbFC2AKK+cMcXIBD0ZdOaWTsyNyBBsMLHqafvIhrCymlaS98+QpoBCy
# KppP0OcxYEdU0hpsaqBBIZOtBajjcw5+w/KeFvPYfLF/ldYpmlG+vd0xqlqd099i
# ChnyIMvY5HexjO2AmtsbpVn0OhNcWbWDRF/3sBp6fWXhz7DcML4iTAWS+MVXeNLj
# 1lJziVKEoroGs9Mlizg0bUMbOalOhOfCipnx8CaLZeVme5yELg09Jlo8BMe80jO3
# 7PU8ejfkP9/uPak7VLwELKxAMcJszkyeiaerlphwoKx1uHRzNyE6bxuSKcutisqm
# KL5OTunAvtONEoteSiabkPVSZ2z76mKnzAfZxCl/3dq3dUNw4rg3sTCggkHSRqTq
# lLMS7gjrhTqBmzu1L90Y1KWN/Y5JKdGvspbOrTfOXyXvmPL6E52z1NZJ6ctuMFBQ
# ZH3pwWvqURR8AgQdULUvrxjUYbHHj95Ejza63zdrEcxWLDX6xWls/GDnVNueKjWU
# H3fTv1Y8Wdho698YADR7TNx8X8z2Bev6SivBBOHY+uqiirZtg0y9ShQoPzmCcn63
# Syatatvx157YK9hlcPmVoa1oDE5/L9Uo2bC5a4CH2Rwxghn2MIIZ8gIBATBpMFQx
# CzAJBgNVBAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMT
# IlNlY3RpZ28gUHVibGljIENvZGUgU2lnbmluZyBDQSBSMzYCEQDzfDeB/ajwfQYd
# ZdJTJuKyMA0GCWCGSAFlAwQCAQUAoHwwEAYKKwYBBAGCNwIBDDECMAAwGQYJKoZI
# hvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEOMAwGCisGAQQBgjcC
# ARUwLwYJKoZIhvcNAQkEMSIEINNr/FKCJ+bcPbq8wFLRcWM89EzG3oT6PPKnlXq9
# aeLuMA0GCSqGSIb3DQEBAQUABIIBgEmVhS8bStZPMXgezEskas1eywScHxZONTzp
# BDshoIQhpZWYnQw+5B8otTgjNJpaWK9ffpjwLGhEGGoE+fztThijRWQ45yoCyCbK
# SyxSpvulrRFzjTPwbmm7PJC+rIwtPWWUUbGsao5FYdDxWjZyFJluBGbaDXdFMMaK
# Du83ukSpI7DtemRKZpY+4H79+rVqHVMVh3bv853007ndGZ2ARUEC9sA/zomWCpNo
# bZZyQg/Fdc6eWieoeMud2kJojR3497C8mUOqFihd877rt1KmSP0LK7A1fNI8ccQv
# BmjNLGHpou91meyokE2/ouzh7Y6QIu1VctVEBRFx4RYd0sAWvJAQcAs9fHksfz3b
# flz915yRTktEgAQtf2GKMWHC4J++TwJgx1rLOlSPV903VwiwNL4H46HIISjKlWoN
# waLZ/GK2YXHiHSkR1FJBc8bq0xUfDhPScIkbWG4iKf75hrzI7u3/cfnWnWt5KY7V
# NYTCUlH+Wrivo47tSsX2T/6XYHOPY6GCF2AwghdcBgorBgEEAYI3AwMBMYIXTDCC
# F0gGCSqGSIb3DQEHAqCCFzkwghc1AgEDMQ8wDQYJYIZIAWUDBAICBQAwgYcGCyqG
# SIb3DQEJEAEEoHgEdjB0AgEBBglghkgBhv1sBwEwQTANBglghkgBZQMEAgIFAAQw
# uiISIj7dy/nV0OVboGRs2sZmi7Yz9pWMdHVb9pj6PYvd7p6thGOUGpME7n6gRR0h
# AhB3wcWio2hVG7+4ie6YvZxfGA8yMDIzMTIwODE4MTEwOVqgghMJMIIGwjCCBKqg
# AwIBAgIQBUSv85SdCDmmv9s/X+VhFjANBgkqhkiG9w0BAQsFADBjMQswCQYDVQQG
# EwJVUzEXMBUGA1UEChMORGlnaUNlcnQsIEluYy4xOzA5BgNVBAMTMkRpZ2lDZXJ0
# IFRydXN0ZWQgRzQgUlNBNDA5NiBTSEEyNTYgVGltZVN0YW1waW5nIENBMB4XDTIz
# MDcxNDAwMDAwMFoXDTM0MTAxMzIzNTk1OVowSDELMAkGA1UEBhMCVVMxFzAVBgNV
# BAoTDkRpZ2lDZXJ0LCBJbmMuMSAwHgYDVQQDExdEaWdpQ2VydCBUaW1lc3RhbXAg
# MjAyMzCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKNTRYcdg45brD5U
# syPgz5/X5dLnXaEOCdwvSKOXejsqnGfcYhVYwamTEafNqrJq3RApih5iY2nTWJw1
# cb86l+uUUI8cIOrHmjsvlmbjaedp/lvD1isgHMGXlLSlUIHyz8sHpjBoyoNC2vx/
# CSSUpIIa2mq62DvKXd4ZGIX7ReoNYWyd/nFexAaaPPDFLnkPG2ZS48jWPl/aQ9OE
# 9dDH9kgtXkV1lnX+3RChG4PBuOZSlbVH13gpOWvgeFmX40QrStWVzu8IF+qCZE3/
# I+PKhu60pCFkcOvV5aDaY7Mu6QXuqvYk9R28mxyyt1/f8O52fTGZZUdVnUokL6wr
# l76f5P17cz4y7lI0+9S769SgLDSb495uZBkHNwGRDxy1Uc2qTGaDiGhiu7xBG3gZ
# beTZD+BYQfvYsSzhUa+0rRUGFOpiCBPTaR58ZE2dD9/O0V6MqqtQFcmzyrzXxDto
# RKOlO0L9c33u3Qr/eTQQfqZcClhMAD6FaXXHg2TWdc2PEnZWpST618RrIbroHzSY
# LzrqawGw9/sqhux7UjipmAmhcbJsca8+uG+W1eEQE/5hRwqM/vC2x9XH3mwk8L9C
# gsqgcT2ckpMEtGlwJw1Pt7U20clfCKRwo+wK8REuZODLIivK8SgTIUlRfgZm0zu+
# +uuRONhRB8qUt+JQofM604qDy0B7AgMBAAGjggGLMIIBhzAOBgNVHQ8BAf8EBAMC
# B4AwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCDAgBgNVHSAE
# GTAXMAgGBmeBDAEEAjALBglghkgBhv1sBwEwHwYDVR0jBBgwFoAUuhbZbU2FL3Mp
# dpovdYxqII+eyG8wHQYDVR0OBBYEFKW27xPn783QZKHVVqllMaPe1eNJMFoGA1Ud
# HwRTMFEwT6BNoEuGSWh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydFRy
# dXN0ZWRHNFJTQTQwOTZTSEEyNTZUaW1lU3RhbXBpbmdDQS5jcmwwgZAGCCsGAQUF
# BwEBBIGDMIGAMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5jb20w
# WAYIKwYBBQUHMAKGTGh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2Vy
# dFRydXN0ZWRHNFJTQTQwOTZTSEEyNTZUaW1lU3RhbXBpbmdDQS5jcnQwDQYJKoZI
# hvcNAQELBQADggIBAIEa1t6gqbWYF7xwjU+KPGic2CX/yyzkzepdIpLsjCICqbjP
# gKjZ5+PF7SaCinEvGN1Ott5s1+FgnCvt7T1IjrhrunxdvcJhN2hJd6PrkKoS1yeF
# 844ektrCQDifXcigLiV4JZ0qBXqEKZi2V3mP2yZWK7Dzp703DNiYdk9WuVLCtp04
# qYHnbUFcjGnRuSvExnvPnPp44pMadqJpddNQ5EQSviANnqlE0PjlSXcIWiHFtM+Y
# lRpUurm8wWkZus8W8oM3NG6wQSbd3lqXTzON1I13fXVFoaVYJmoDRd7ZULVQjK9W
# vUzF4UbFKNOt50MAcN7MmJ4ZiQPq1JE3701S88lgIcRWR+3aEUuMMsOI5ljitts+
# +V+wQtaP4xeR0arAVeOGv6wnLEHQmjNKqDbUuXKWfpd5OEhfysLcPTLfddY2Z1qJ
# +Panx+VPNTwAvb6cKmx5AdzaROY63jg7B145WPR8czFVoIARyxQMfq68/qTreWWq
# aNYiyjvrmoI1VygWy2nyMpqy0tg6uLFGhmu6F/3Ed2wVbK6rr3M66ElGt9V/zLY4
# wNjsHPW2obhDLN9OTH0eaHDAdwrUAuBcYLso/zjlUlrWrBciI0707NMX+1Br/wd3
# H3GXREHJuEbTbDJ8WC9nR2XlG3O2mflrLAZG70Ee8PBf4NvZrZCARK+AEEGKMIIG
# rjCCBJagAwIBAgIQBzY3tyRUfNhHrP0oZipeWzANBgkqhkiG9w0BAQsFADBiMQsw
# CQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cu
# ZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQw
# HhcNMjIwMzIzMDAwMDAwWhcNMzcwMzIyMjM1OTU5WjBjMQswCQYDVQQGEwJVUzEX
# MBUGA1UEChMORGlnaUNlcnQsIEluYy4xOzA5BgNVBAMTMkRpZ2lDZXJ0IFRydXN0
# ZWQgRzQgUlNBNDA5NiBTSEEyNTYgVGltZVN0YW1waW5nIENBMIICIjANBgkqhkiG
# 9w0BAQEFAAOCAg8AMIICCgKCAgEAxoY1BkmzwT1ySVFVxyUDxPKRN6mXUaHW0oPR
# nkyibaCwzIP5WvYRoUQVQl+kiPNo+n3znIkLf50fng8zH1ATCyZzlm34V6gCff1D
# tITaEfFzsbPuK4CEiiIY3+vaPcQXf6sZKz5C3GeO6lE98NZW1OcoLevTsbV15x8G
# ZY2UKdPZ7Gnf2ZCHRgB720RBidx8ald68Dd5n12sy+iEZLRS8nZH92GDGd1ftFQL
# IWhuNyG7QKxfst5Kfc71ORJn7w6lY2zkpsUdzTYNXNXmG6jBZHRAp8ByxbpOH7G1
# WE15/tePc5OsLDnipUjW8LAxE6lXKZYnLvWHpo9OdhVVJnCYJn+gGkcgQ+NDY4B7
# dW4nJZCYOjgRs/b2nuY7W+yB3iIU2YIqx5K/oN7jPqJz+ucfWmyU8lKVEStYdEAo
# q3NDzt9KoRxrOMUp88qqlnNCaJ+2RrOdOqPVA+C/8KI8ykLcGEh/FDTP0kyr75s9
# /g64ZCr6dSgkQe1CvwWcZklSUPRR8zZJTYsg0ixXNXkrqPNFYLwjjVj33GHek/45
# wPmyMKVM1+mYSlg+0wOI/rOP015LdhJRk8mMDDtbiiKowSYI+RQQEgN9XyO7ZONj
# 4KbhPvbCdLI/Hgl27KtdRnXiYKNYCQEoAA6EVO7O6V3IXjASvUaetdN2udIOa5kM
# 0jO0zbECAwEAAaOCAV0wggFZMBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYE
# FLoW2W1NhS9zKXaaL3WMaiCPnshvMB8GA1UdIwQYMBaAFOzX44LScV1kTN8uZz/n
# upiuHA9PMA4GA1UdDwEB/wQEAwIBhjATBgNVHSUEDDAKBggrBgEFBQcDCDB3Bggr
# BgEFBQcBAQRrMGkwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNv
# bTBBBggrBgEFBQcwAoY1aHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lD
# ZXJ0VHJ1c3RlZFJvb3RHNC5jcnQwQwYDVR0fBDwwOjA4oDagNIYyaHR0cDovL2Ny
# bDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0VHJ1c3RlZFJvb3RHNC5jcmwwIAYDVR0g
# BBkwFzAIBgZngQwBBAIwCwYJYIZIAYb9bAcBMA0GCSqGSIb3DQEBCwUAA4ICAQB9
# WY7Ak7ZvmKlEIgF+ZtbYIULhsBguEE0TzzBTzr8Y+8dQXeJLKftwig2qKWn8acHP
# HQfpPmDI2AvlXFvXbYf6hCAlNDFnzbYSlm/EUExiHQwIgqgWvalWzxVzjQEiJc6V
# aT9Hd/tydBTX/6tPiix6q4XNQ1/tYLaqT5Fmniye4Iqs5f2MvGQmh2ySvZ180HAK
# fO+ovHVPulr3qRCyXen/KFSJ8NWKcXZl2szwcqMj+sAngkSumScbqyQeJsG33irr
# 9p6xeZmBo1aGqwpFyd/EjaDnmPv7pp1yr8THwcFqcdnGE4AJxLafzYeHJLtPo0m5
# d2aR8XKc6UsCUqc3fpNTrDsdCEkPlM05et3/JWOZJyw9P2un8WbDQc1PtkCbISFA
# 0LcTJM3cHXg65J6t5TRxktcma+Q4c6umAU+9Pzt4rUyt+8SVe+0KXzM5h0F4ejjp
# nOHdI/0dKNPH+ejxmF/7K9h+8kaddSweJywm228Vex4Ziza4k9Tm8heZWcpw8De/
# mADfIBZPJ/tgZxahZrrdVcA6KYawmKAr7ZVBtzrVFZgxtGIJDwq9gdkT/r+k0fNX
# 2bwE+oLeMt8EifAAzV3C+dAjfwAL5HYCJtnwZXZCpimHCUcr5n8apIUP/JiW9lVU
# Kx+A+sDyDivl1vupL0QVSucTDh3bNzgaoSv27dZ8/DCCBY0wggR1oAMCAQICEA6b
# GI750C3n79tQ4ghAGFowDQYJKoZIhvcNAQEMBQAwZTELMAkGA1UEBhMCVVMxFTAT
# BgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTEk
# MCIGA1UEAxMbRGlnaUNlcnQgQXNzdXJlZCBJRCBSb290IENBMB4XDTIyMDgwMTAw
# MDAwMFoXDTMxMTEwOTIzNTk1OVowYjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERp
# Z2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTEhMB8GA1UEAxMY
# RGlnaUNlcnQgVHJ1c3RlZCBSb290IEc0MIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
# MIICCgKCAgEAv+aQc2jeu+RdSjwwIjBpM+zCpyUuySE98orYWcLhKac9WKt2ms2u
# exuEDcQwH/MbpDgW61bGl20dq7J58soR0uRf1gU8Ug9SH8aeFaV+vp+pVxZZVXKv
# aJNwwrK6dZlqczKU0RBEEC7fgvMHhOZ0O21x4i0MG+4g1ckgHWMpLc7sXk7Ik/gh
# YZs06wXGXuxbGrzryc/NrDRAX7F6Zu53yEioZldXn1RYjgwrt0+nMNlW7sp7XeOt
# yU9e5TXnMcvak17cjo+A2raRmECQecN4x7axxLVqGDgDEI3Y1DekLgV9iPWCPhCR
# cKtVgkEy19sEcypukQF8IUzUvK4bA3VdeGbZOjFEmjNAvwjXWkmkwuapoGfdpCe8
# oU85tRFYF/ckXEaPZPfBaYh2mHY9WV1CdoeJl2l6SPDgohIbZpp0yt5LHucOY67m
# 1O+SkjqePdwA5EUlibaaRBkrfsCUtNJhbesz2cXfSwQAzH0clcOP9yGyshG3u3/y
# 1YxwLEFgqrFjGESVGnZifvaAsPvoZKYz0YkH4b235kOkGLimdwHhD5QMIR2yVCkl
# iWzlDlJRR3S+Jqy2QXXeeqxfjT/JvNNBERJb5RBQ6zHFynIWIgnffEx1P2PsIV/E
# IFFrb7GrhotPwtZFX50g/KEexcCPorF+CiaZ9eRpL5gdLfXZqbId5RsCAwEAAaOC
# ATowggE2MA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFOzX44LScV1kTN8uZz/n
# upiuHA9PMB8GA1UdIwQYMBaAFEXroq/0ksuCMS1Ri6enIZ3zbcgPMA4GA1UdDwEB
# /wQEAwIBhjB5BggrBgEFBQcBAQRtMGswJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3Nw
# LmRpZ2ljZXJ0LmNvbTBDBggrBgEFBQcwAoY3aHR0cDovL2NhY2VydHMuZGlnaWNl
# cnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNydDBFBgNVHR8EPjA8MDqg
# OKA2hjRodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRBc3N1cmVkSURS
# b290Q0EuY3JsMBEGA1UdIAQKMAgwBgYEVR0gADANBgkqhkiG9w0BAQwFAAOCAQEA
# cKC/Q1xV5zhfoKN0Gz22Ftf3v1cHvZqsoYcs7IVeqRq7IviHGmlUIu2kiHdtvRoU
# 9BNKei8ttzjv9P+Aufih9/Jy3iS8UgPITtAq3votVs/59PesMHqai7Je1M/RQ0Sb
# QyHrlnKhSLSZy51PpwYDE3cnRNTnf+hZqPC/Lwum6fI0POz3A8eHqNJMQBk1Rmpp
# VLC4oVaO7KTVPeix3P0c2PR3WlxUjG/voVA9/HYJaISfb8rbII01YBwCA8sgsKxY
# oA5AY8WYIsGyWfVVa88nq2x2zm8jLfR+cWojayL/ErhULSd+2DrZ8LaHlv1b0Vys
# GMNNn3O3AamfV6peKOK5lDGCA4YwggOCAgEBMHcwYzELMAkGA1UEBhMCVVMxFzAV
# BgNVBAoTDkRpZ2lDZXJ0LCBJbmMuMTswOQYDVQQDEzJEaWdpQ2VydCBUcnVzdGVk
# IEc0IFJTQTQwOTYgU0hBMjU2IFRpbWVTdGFtcGluZyBDQQIQBUSv85SdCDmmv9s/
# X+VhFjANBglghkgBZQMEAgIFAKCB4TAaBgkqhkiG9w0BCQMxDQYLKoZIhvcNAQkQ
# AQQwHAYJKoZIhvcNAQkFMQ8XDTIzMTIwODE4MTEwOVowKwYLKoZIhvcNAQkQAgwx
# HDAaMBgwFgQUZvArMsLCyQ+CXc6qisnGTxmcz0AwNwYLKoZIhvcNAQkQAi8xKDAm
# MCQwIgQg0vbkbe10IszR1EBXaEE2b4KK2lWarjMWr00amtQMeCgwPwYJKoZIhvcN
# AQkEMTIEMAISIgtESaNMr7cxjRp/LMURfDt/t+yugDGOK7+imj+VSLEd53f5muDZ
# PhXmksBGPTANBgkqhkiG9w0BAQEFAASCAgBYX91B0qMUkJ4ZhfGTOzb7nIvjdBcQ
# Pn4pBPGzUgN/GPvMD6ie8rRwG88R+WDobGSh+IMBaCxYXCFWs+Oh5FCl8JqmeyGX
# t3GBZBwkhIM4qRTStTvvb4+E2tqb+rRlaIUS2PG7Hp9kwNrBbik1yKOv7fAmKVU3
# O7fr6sK8tri2gcct5MU56VdGPm7RXKtOx/ItgmaCzXykN2NYNI7dM0dKfPKplHV3
# wY/IK6G3V9F8sU1ahriTRMwD1aVoO/8mkn+jDrKkEn62TmDgtZ3f5+vnfdVpdULL
# sv1gshGPLxa/yPahsns9362gR1+MM2R5Wi9WRf+Lj1b9vMeRGxPFSjTnL9kZVZhJ
# PXi6Tx5h6kJODAMGeh3+VJ+dLdUjyPAIn6upexwedwqLSmMn6spLBogCc61fTUZO
# q8YZEQFIotRWS2UOvmQJEzvxnuM0ivLMycxNdx7kGvZK5oo7foGkIMNPKXJjIj+Q
# ifCBz89cXVPKquKmiwGlsKjN/G+AdKFanvouamqx/VIoIwBFbtayvk4u5J1V19Yx
# ZpLFHjSyxYc5ORzw0+JanLQpQ+49ia5RXV5s5am2hmAwj8W+jyOEa/33wiTkWXyv
# it7o5suUQt0uiq9o83ptOAQIP/DEPbFWtG7wNU7wp5hJnT6TrpfdxdF/21mIlbTW
# XJWLrsco2qqZEg==
# SIG # End signature block